<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sjc的搬砖小屋</title>
  
  
  <link href="https://icbtbo.github.io/atom.xml" rel="self"/>
  
  <link href="https://icbtbo.github.io/"/>
  <updated>2022-06-13T14:32:05.166Z</updated>
  <id>https://icbtbo.github.io/</id>
  
  <author>
    <name>icbtbo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty的对象池技术：Recycler</title>
    <link href="https://icbtbo.github.io/2022/06/13/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/"/>
    <id>https://icbtbo.github.io/2022/06/13/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/</id>
    <published>2022-06-13T13:08:25.000Z</published>
    <updated>2022-06-13T14:32:05.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Recycler-示例代码"><a href="#Recycler-示例代码" class="headerlink" title="Recycler 示例代码"></a>Recycler 示例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;User&gt; userRecycler = <span class="keyword">new</span> Recycler&lt;User&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> User <span class="title">newObject</span><span class="params">(Handle&lt;User&gt; handle)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在对象实例中存储handle以便使用实例进行回收操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(handle);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Recycler.Handle&lt;User&gt; handle;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Recycler.Handle&lt;User&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.handle = handle;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            handle.recycle(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User user1 = userRecycler.get(); <span class="comment">// 1、从对象池获取 User 对象</span></span><br><span class="line"></span><br><span class="line">        user1.setName(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 2、设置 User 对象的属性</span></span><br><span class="line"></span><br><span class="line">        user1.recycle(); <span class="comment">// 3、回收对象到对象池</span></span><br><span class="line"></span><br><span class="line">        User user2 = userRecycler.get(); <span class="comment">// 4、从对象池获取对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(user2.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台的输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码示例中定义了对象池实例 userRecycler，其中实现了 <code>newObject()</code> 方法，如果对象池没有可用的对象，会调用该方法新建对象。此外需要创建 Recycler.Handle 对象与 User 对象进行绑定，这样我们就可以通过<code>userRecycler.get()</code> 从对象池中获取 User 对象，如果对象不再使用，通过调用 User 类实现的<code>recycle()</code>方法即可完成回收对象到对象池。</p><h1 id="Recycler-设计思想"><a href="#Recycler-设计思想" class="headerlink" title="Recycler 设计思想"></a>Recycler 设计思想</h1><p>对象池与内存池的都是为了提高 Netty 的并发处理能力，我们知道 Java 中频繁地创建和销毁对象的开销是很大的，所以很多人会将一些通用对象缓存起来，当需要某个对象时，优先从对象池中获取对象实例。通过重用对象，不仅避免频繁地创建和销毁所带来的性能损耗，而且对 JVM GC 是友好的，这就是对象池的作用。</p><p>在Recycler中一共有四个核心组件：<strong>Stack</strong>、<strong>WeakOrderQueue</strong>、<strong>Link</strong>、<strong>DefaultHandle</strong>，接下来我们逐一进行介绍。</p><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206132124361.png" alt="image-20220613212414282" style="zoom:80%;" /><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack 是整个对象池的顶层数据结构，描述了整个对象池的构造，用于存储当前本线程回收的对象。在多线程的场景下，Netty 为了避免锁竞争问题，每个线程都会持有各自的对象池，内部通过 FastThreadLocal 来实现每个线程的私有化(关于 FastThreadLocal 的内容可参考这篇博文——–待撰写 ————–                )。</p><p>先看下 Stack 的数据结构，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Recycler&lt;T&gt; parent; <span class="comment">// 所属的 Recycler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;Thread&gt; threadRef; <span class="comment">// 所属线程的弱引用</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger availableSharedCapacity; <span class="comment">// 异线程回收对象时，其他线程能保存的被回收对象的最大个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxDelayedQueues; <span class="comment">// WeakOrderQueue最大个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity; <span class="comment">// 对象池的最大大小，默认最大为 4k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ratioMask; <span class="comment">// 控制对象的回收比率，默认只回收 1/8 的对象 (默认值为7)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DefaultHandle&lt;?&gt;[] elements; <span class="comment">// 存储缓存数据的数组（Default中存着缓存的对象）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 缓存的 DefaultHandle 对象个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> handleRecycleCount = -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// WeakOrderQueue 链表的三个重要节点</span></span><br><span class="line">    <span class="keyword">private</span> WeakOrderQueue cursor, prev;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WeakOrderQueue head;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应上面 Recycler 的内部结构图，Stack 包括用于存储缓存数据的 DefaultHandle 数组，以及维护了 WeakOrderQueue 链表中的三个重要节点。</p><p>除此之外，Stack 其他的重要属性在源码中已经全部以注释的形式标出，大部分已经都非常清楚，其中 availableSharedCapacity 是比较难理解的，每个 Stack 会维护一个 WeakOrderQueue 的链表，每个 WeakOrderQueue 节点会保存非当前线程的其他线程所回收的对象，例如图中 ThreadA 表示当前线程，WeakOrderQueue 的链表存储着 ThreadB、ThreadC 等其他线程回收的对象。availableSharedCapacity 的初始化方式为 new AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY))，默认大小为 16K，其他线程在回收对象时，最多可以回收 ThreadA 创建的对象个数不能超过 availableSharedCapacity。</p><p>还有一个疑问就是既然 Stack 是每个线程私有的，为什么 availableSharedCapacity 还需要用 AtomicInteger 呢？因为 ThreadB、ThreadC 等多个线程可能都会创建 ThreadA 的 WeakOrderQueue，存在同时操作 availableSharedCapacity 的情况。</p><h2 id="WeakOrderQueue"><a href="#WeakOrderQueue" class="headerlink" title="WeakOrderQueue"></a>WeakOrderQueue</h2><p>WeakOrderQueue 用于存储其他线程回收到的当前线程所分配的对象，并且在合适的时机，Stack 会从这些 WeakOrderQueue 中收割对象。例如，当ThreadB 回收到 ThreadA 所分配的对象时，就会将该对象放到 ThreadA 的 WeakOrderQueue 当中。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>每个 WeakOrderQueue 中都包含一个 Link 链表，回收的对象都会被存在 Link 链表中的节点上，每个 Link 节点默认存储 16 个对象，当一个 Link 节点存储满了会创建新的 Link 节点放入链表尾部。</p><h2 id="DefaultHandle"><a href="#DefaultHandle" class="headerlink" title="DefaultHandle"></a>DefaultHandle</h2><p>DefaultHandle 实例中保存了实际回收的对象，Stack 和 WeakOrderQueue 都使用 DefaultHandle 存储回收的对象。在 Stack 中包含一个 elements 数组，该数组保存的是 DefaultHandle 实例。WeakOrderQueue 中每个 Link 节点所存储的 16 个对象也是使用 DefaultHandle 表示的。</p><h1 id="Recycler-获取对象原理"><a href="#Recycler-获取对象原理" class="headerlink" title="Recycler 获取对象原理"></a>Recycler 获取对象原理</h1><p>从代码示例中可以看出，从对象池中获取对象的入口是在 Recycler#get() 方法，直接定位到源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get(); <span class="comment">// 获取当前线程缓存的 Stack</span></span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop(); <span class="comment">// 从 Stack 中弹出一个 DefaultHandle 对象</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle); <span class="comment">// 创建的对象并保存到 DefaultHandle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Recycler#get() 方法的逻辑非常清晰，首先通过 FastThreadLocal 获取当前线程的唯一栈缓存 Stack，然后尝试从栈顶弹出 DefaultHandle 对象实例，若栈中存在实例则直接返回，否则会调用 newObject 生成一个新的对象，完成 handle 与用户对象和 Stack 的绑定。</p><p>那么 Stack 是如何从 elements 数组中弹出 DefaultHandle 对象实例的呢？只是从 elements 数组中取出一个实例吗？我们一起跟进下 stack.pop() 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 elements 数组为空，就尝试从其他线程回收的对象中转移一些到 elements 数组当中</span></span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size]; <span class="comment">// 将实例从栈顶弹出</span></span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled multiple times&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Stack 的 elements 数组中有可用的对象实例，直接将对象实例弹出；如果 elements 数组中没有可用的对象实例，会调用 scavenge 方法，scavenge 的作用是从其他线程回收的对象实例中转移一些到 elements 数组当中，也就是说，它会想办法从 WeakOrderQueue 链表中迁移部分对象实例。</p><p>每个 Stack 会有一个 WeakOrderQueue 链表，每个 WeakOrderQueue 节点都存储着相应异线程回收的对象，那么以什么样的策略从 WeakOrderQueue 链表中迁移对象实例呢？继续跟进 scavenge 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从 WeakOrderQueue 中转移对象实例到 Stack 中</span></span><br><span class="line">    <span class="keyword">if</span> (scavengeSome()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果迁移失败，就会重置 cursor 指针到 head 节点</span></span><br><span class="line">    prev = <span class="keyword">null</span>;</span><br><span class="line">    cursor = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = <span class="keyword">this</span>.cursor; <span class="comment">// cursor 指针指向当前 WeakorderQueueu 链表的读取位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 cursor 指针为 null, 则是第一次从 WeakorderQueueu 链表中获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = <span class="keyword">this</span>.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 不断循环从 WeakOrderQueue 链表中找到一个可用的对象实例</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试迁移 WeakOrderQueue 中部分对象实例到 Stack 中,若成功直接退出循环并返回</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已退出的线程还有数据，则将这些数据全都转移到 stack 的 elements 数组中</span></span><br><span class="line">            <span class="keyword">if</span> (cursor.hasFinalData()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将已退出的线程从 WeakOrderQueue 链表中移除</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 cursor 指针指向下一个 WeakOrderQueue</span></span><br><span class="line">        cursor = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scavenge 的源码中首先会从 cursor 指针指向的 WeakOrderQueue 节点回收部分对象到 Stack 的 elements 数组中，如果没有回收到数据就会将 cursor 指针移到下一个 WeakOrderQueue，重复执行以上过程直至回到到对象实例为止。具体的流程可以结合下图来理解。</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206132200685.png" alt="image-20220613220058574" style="zoom:80%;" /><p>此外，每次移动 cursor 时，都会检查 WeakOrderQueue 对应的线程是否已经退出了，如果线程已经退出，那么线程中的对象实例都会被回收，然后将 WeakOrderQueue 节点从链表中移除。</p><p>那每次 Stack 从 WeakOrderQueue 链表会回收多少数据呢？我们依然结合上图讲解，每个 WeakOrderQueue 中都包含一个 Link 链表，Netty 每次会回收其中的一个 Link 节点所存储的对象（不一定有16个）。从图中可以看出，Link 内部会包含一个读指针 readIndex，每个 Link 节点默认存储 16 个对象，读指针到链表尾部就是可以用于回收的对象实例，每次回收对象时，readIndex 都会从上一次记录的位置开始回收。</p><p>在回收对象实例之前，Netty 会计算出可回收对象的数量（transfer 方法中），加上 Stack 中已有的对象数量后，如果超过 Stack 的当前容量且小于 Stack 的最大容量，会对 Stack 进行扩容。为了防止回收对象太多导致 Stack 的容量激增，在每次回收时 Netty 会调用 dropHandle 方法控制回收频率，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dropHandle</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!handle.hasBeenRecycled) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((++handleRecycleCount &amp; ratioMask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Drop the object.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handle.hasBeenRecycled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dropHandle 方法中主要靠 hasBeenRecycled 和 handleRecycleCount 两个变量控制回收的频率，会从每 8 个未被收回的对象中选取一个进行回收，其他的都被丢弃掉。</p><p>到此为止，从 Recycler 中获取对象的主流程已经讲完了，简单总结为两点：</p><ul><li>当 Stack 中 elements 有数据时，直接从栈顶弹出。</li><li>当 Stack 中 elements 没有数据时，尝试从 WeakOrderQueue 中回收一个 Link 包含的对象实例到 Stack 中，然后从栈顶弹出。</li></ul><h1 id="Recycler-回收对象原理"><a href="#Recycler-回收对象原理" class="headerlink" title="Recycler 回收对象原理"></a>Recycler 回收对象原理</h1><p> 同样从上文代码示例中定位到对象回收的源码入口为 DefaultHandle#recycle()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;object does not belong to handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;?&gt; stack = <span class="keyword">this</span>.stack;</span><br><span class="line">    <span class="keyword">if</span> (lastRecycledId != recycleId || stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack#push</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class="line">      <span class="comment">// 同线程时</span></span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异线程时</span></span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回收对象时，会向 Stack 中 push 对象，push 会分为同线程回收和异线程回收两种情况，分别对应 pushNow 和 pushLater 两个方法，我们逐一进行分析。</p><h2 id="同线程对象回收"><a href="#同线程对象回收" class="headerlink" title="同线程对象回收"></a>同线程对象回收</h2><p>如果是当前线程回收自己分配的对象时，会调用 Stack#pushNow 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) &#123; <span class="comment">// 防止被多次回收</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 超出最大容量 2. 控制回收速率</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同线程回收对象的逻辑非常简单，就是直接向 Stack 的 elements 数组中添加数据，对象会被存放在栈顶指针指向的位置。如果超过了 Stack 的最大容量，那么对象会被直接丢弃，同样这里使用了 dropHandle 方法控制对象的回收速率，每 8 个对象会有一个被回收到 Stack 中。</p><h2 id="异线程对象回收"><a href="#异线程对象回收" class="headerlink" title="异线程对象回收"></a>异线程对象回收</h2><p>异线程回收对象时，会调用 pushLater 方法。我们合理得猜测，异线程并不会将对象添加到 Stack 中，而是会与 WeakOrderQueue 直接打交道，下面是 Stack#pushLater 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get(); <span class="comment">// 当前线程帮助其他线程回收的对象对应的 WeakOrderQueue</span></span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>); <span class="comment">// 取出对象绑定的 Stack 对应的 WeakOrderQueue</span></span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最多帮助 2*CPU 核数的线程回收线程</span></span><br><span class="line">        <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY); <span class="comment">// WeakOrderQueue.DUMMY 表示当前线程无法再帮助该 Stack 回收对象</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建 WeakOrderQueue</span></span><br><span class="line">        <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">        <span class="comment">// drop object</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(item); <span class="comment">// 添加对象到 WeakOrderQueue 的 Link 链表中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pushLater 的实现过程可以总结为两个步骤：<strong>获取 WeakOrderQueue</strong>，<strong>添加对象到 WeakOrderQueue 中</strong>。</p><ul><li>首先看下如何获取 WeakOrderQueue 对象。通过 FastThreadLocal 取出当前对象的 DELAYED_RECYCLED 缓存，DELAYED_RECYCLED 存放着当前线程帮助其他线程回收的对象对应的 Stack 以及 WeakOrderQueue 之间的映射关系。例如，假如 item 是 ThreadA 分配的对象，当前线程是 ThreadB，此时 ThreadB 帮助 ThreadA 回收 item，那么 DELAYED_RECYCLED 放入的 key 是 StackA。</li><li>然后从 delayedRecycled 中取出 StackA 对应的 WeakOrderQueue，如果 WeakOrderQueue 不存在，那么为 StackA 新创建一个 WeakOrderQueue，并将其加入 DELAYED_RECYCLED 缓存。WeakOrderQueue.allocate() 会检查帮助 StackA 回收的对象总数是否超过 2K 个，如果没有超过 2K，会将 StackA 的 head 指针指向新创建的 WeakOrderQueue，否则不再为 StackA 回收对象。</li></ul><p>当然 ThreadB 不会只帮助 ThreadA 回收对象，它可以帮助其他多个线程回收，所以 DELAYED_RECYCLED 使用的 Map 结构，为了防止 DELAYED_RECYCLED 内存膨胀，Netty 也采取了保护措施，从 delayedRecycled.size() &gt;= maxDelayedQueues 可以看出，每个线程最多帮助 2 倍 CPU 核数的线程回收线程，如果超过了该阈值，假设当前对象绑定的为 StackX，那么将在 Map 中为 StackX 放入一种特殊的 WeakOrderQueue.DUMMY，表示当前线程无法帮助 StackX 回收对象。</p><p>接下来我们继续分析对象是如何被添加到 WeakOrderQueue 的，直接跟进 queue.add(item) 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    handle.lastRecycledId = id;</span><br><span class="line">    Link tail = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">int</span> writeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表尾部的 Link 已经写满，那么再新建一个 Link 追加到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 检查是否超过对应 Stack 可以存放的其他线程帮助回收的最大对象数</span></span><br><span class="line">        <span class="keyword">if</span> (!head.reserveSpace(LINK_CAPACITY)) &#123;</span><br><span class="line">            <span class="comment">// Drop it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.tail = tail = tail.next = <span class="keyword">new</span> Link();</span><br><span class="line">        writeIndex = tail.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.elements[writeIndex] = handle; <span class="comment">// 添加对象到 Link 尾部</span></span><br><span class="line">    handle.stack = <span class="keyword">null</span>; <span class="comment">// handle 的 stack 属性赋值为 null</span></span><br><span class="line">    tail.lazySet(writeIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在向 WeakOrderQueue 写入对象之前，会先判断 Link 链表的 tail 节点是否还有空间存放对象。如果还有空间，直接向 tail Link 尾部写入数据，否则直接丢弃对象。如果 tail Link 已经没有空间，会新建一个 Link 之后再存放对象，但在新建 Link 之前会检查异线程帮助回收的对象总数是否超过了 Stack 设置的阈值，如果超过了阈值，那么对象也会被丢弃掉。</p><p>对象被添加到 Link 之后，handle 的 stack 属性被赋值为 null，而在取出对象的时候，handle 的 stack 属性又再次被赋值回来，为什么这么做呢，岂不是很麻烦？如果不这么做的话，若是 Stack 不再使用，期望被 GC 回收，但JVM发现 handle 中还持有 Stack 的引用，那么Stack就无法被 GC 回收，从而造成内存泄漏。</p><p>到此为止，Recycler 如何回收对象的实现原理就全部分析完了，在多线程的场景下，Netty 考虑的还是非常细致的，Recycler 回收对象时向 WeakOrderQueue 中存放对象，而从 Recycler中 获取对象时，WeakOrderQueue 中的对象会作为 Stack 的储备，而且有效地解决了跨线程回收的问题，是一个挺新颖别致的设计。</p><h1 id="Recycler-在-Netty-中的应用"><a href="#Recycler-在-Netty-中的应用" class="headerlink" title="Recycler 在 Netty 中的应用"></a>Recycler 在 Netty 中的应用</h1><p>其中比较常用的有 PooledHeapByteBuf 和 PooledDirectByteBuf，分别对应的堆内存和堆外内存的池化实现。例如我们在使用 PooledDirectByteBuf 的时候，并不是每次都去创建新的对象实例，而是从对象池中获取预先分配好的对象实例，不再使用 PooledDirectByteBuf 时，被回收归还到对象池中。</p><p>此外，内存池的 MemoryRegionCache 也有使用到对象池，MemoryRegionCache 中保存着一个队列，队列中每个 Entry 节点用于保存内存块，Entry 节点在 Netty 中就是以对象池的形式进行分配和释放。</p>]]></content>
    
    
    <summary type="html">介绍Netty的对象池技术--Recycler，详细介绍Recycler如何获取以及回收对象。</summary>
    
    
    
    <category term="Netty学习" scheme="https://icbtbo.github.io/categories/Netty%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Netty" scheme="https://icbtbo.github.io/tags/Netty/"/>
    
    <category term="对象池" scheme="https://icbtbo.github.io/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现:独立功能的实现</title>
    <link href="https://icbtbo.github.io/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://icbtbo.github.io/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-01-05T12:59:07.000Z</published>
    <updated>2022-03-24T07:20:31.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过<code>MULTI</code>，<code>EXEC</code>，<code>WATCH</code>等命令实现事务功能。</p><p>事务是将<strong>多个命令打包</strong>，然后<strong>原子地按顺序地执行</strong>的机制，执行期间服务器<strong>不会中断事务</strong>执行其他客户端的命令请求。下面展示了一次完整事务的执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET <span class="string">&quot;name&quot;</span> <span class="string">&quot;The Design and Implementation of Redis&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET <span class="string">&quot;name&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;The Design and Implementation of Redis&quot;</span></span><br></pre></td></tr></table></figure><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>可以看出，事务主要有3个阶段：事务开始、命令入队、事务执行。</p><p><strong>事务开始</strong></p><p>MULTI命令表示事务的开始，将客户端从非事务状态切换为事务状态，在flags属性中<strong>打开<code>REDIS_MULTI</code>标识</strong>。</p><p><strong>命令入队</strong></p><p>当客户端处于事务状态时，命令不会被立即执行（除了EXEC、DISCARD、WATCH、MULTI），而是加入事务队列。</p><p><strong>事务队列</strong></p><p>客户端的事务状态保存在mstate里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisCLient</span>&#123;</span></span><br><span class="line">    <span class="comment">//事务状态</span></span><br><span class="line">    multiState mstate;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>事务状态包括<strong>事务队列</strong>和<strong>入队命令计数器</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    <span class="comment">//数组，事务队列</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="comment">//入队命令计数器</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>事务队列的实例结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>先入队的命令先放入数组，后入队的后放入。</p><p><strong>执行事务</strong></p><p>当收到客户端的EXEC命令时，将立即执行，然后服务器遍历客户端的事务队列，保存命令，执行命令，返回结果给客户端，最后移除事务标识。</p><h3 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h3><p>WATCH命令是一个<strong>乐观锁</strong>，可以在EXEC前<strong>监视任意数量的键</strong>，如果在EXEC执行时，发现这些被监视的键被修改过，服务器将拒绝执行事务。</p><p><strong>使用WATCH命令监视数据库键</strong></p><p>每个Redis数据库都保存着watched_keys字典，键是某个被WATCHED命令<strong>监视的键</strong>，值是一个链表，记录所有<strong>监视该键的客户端</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//正在被WATCHED命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb；</span><br></pre></td></tr></table></figure><p><strong>监控机制的触发&amp;事务安全</strong></p><p>在执行数据库修改命令时，都会调用<code>multi.c/touchWatchKey</code>函数对watched_keys字典进行检查，查看是否有客户端正在监视的刚被命令修改过的键，如果有，将watched_keys该键对应的值，也就是监听的客户端都打开<code>REDIS_DIRTY_CAS</code>标识，表示事务的<strong>安全性已经被破坏</strong>。此时，服务器拒绝执行该客户端的事务。</p><h3 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h3><p>Redis的事务有原子性、一致性和隔离性，当Redis运行在特定的持久化模式下时，才具有持久性。</p><p><strong>原子性</strong></p><p>Redis事务队列中的命令，要么全部都执行，要么一个都不执行，因此，具有原子性。Redis进行事务命令入队时，如果命令入队出错，会被拒绝执行。但是命令的语法错误（执行错误），不会导致整个命令不被执行，也就是说Redis不支持事务的回滚机制。</p><p>下面例子表示发生<strong>入队错误</strong>（一致性时将提到入队错误和执行错误）时，事务中的所有命令都不会被执行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET msg &quot;he1lo&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;get&#x27; command</span><br><span class="line">redis&gt; GET msg</span><br><span class="line">QUEUED </span><br><span class="line">redis&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>发生执行错误，不影响其他命令的执行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot; # msg键是一个字符串</span><br><span class="line">OK</span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SADD fruit &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; RPUSH msg &quot;good bye&quot; &quot;bye bye&quot; #错误地对字符串键msg执行列表键的命令</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; SADD alphabet &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC </span><br><span class="line">1) (integer) 3</span><br><span class="line">2)(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3)(integer) 3</span><br></pre></td></tr></table></figure><p>不支持事务回滚是考虑到了复杂性，与其<strong>简单高效的理念不符</strong>，并且Redis的设计者认为，Redis事务的执行时错误通常都是<strong>编程错误</strong>产生的，在开发环境中会有，但生产环境不应该出现，因此，没有设计回滚机制。</p><p><strong>一致性</strong></p><p>一致性表示在事务的执行前后，成功与否，数据库<strong>都是一致的</strong>，也就是数据符合数据库本身定义和要求，<strong>没有非法或无效错误数据</strong>。</p><p>Redis通过简单的错误检测来保证一致性。</p><ol><li>入队错误</li></ol><p>在2.6.5之后的版本，如果一个事务在入队时出现了命令不存在，Redis则拒绝执行这个事务。</p><ol start="2"><li>执行错误</li></ol><p>对于命令执行期间发现的错误，<strong>不会影响其他命令</strong>的执行。服务器会识别出错的命令，并进行相应处理，这些命令不会对数据库做修改，不影响一致性。</p><ol start="3"><li>服务器停机</li></ol><p>如果Redis在执行事务过程中停机，数据也是一致的。如果没有开启持久化，重启后数据库是空白的。开启持久化后，重启后会还原到一致状态。</p><p><strong>隔离性</strong></p><p>事务的隔离性是指，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响。</p><p>Redis是单线程的，并且服务器保证在执行事务期间<strong>不会对事务进行中断</strong>，因此Redis的事务总是以串行的方式运行，是具有隔离性的。</p><p><strong>持久性</strong></p><p>持久性的意思是，事务执行的结果被<strong>永久性地保存</strong>，执行事务的结果不会丢失。</p><p>因为Redis没有单独为事务队列提供持久化功能，所以<strong>取决于持久化模式</strong>，只有AOF方式持久化并且appendsync的值为always，而且没有打开<code>no-appendfsync-on-rewrite</code>时，才具有持久性。因为其他方式并不能保证事务的执行结果被第一时间保存到硬盘里。</p><blockquote><p>注：<code>no-appendfsync-on-rewrite</code>打开后，在执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>时会暂停对AOF文件的同步。</p></blockquote><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求。可通过两个参数配置：</p><ul><li><code>slowlog-log-slower-than</code>：执行时间超过多少微秒的命令会被记录到日志上。</li><li><code>slowlog-max-len</code>：指定服务器最多保存多少条慢查询日志，超过时会删除最久的那条日志。</li></ul><p>可以使用<code>CONSIG SET slowlog-log-slower-than &lt;microsecond&gt;</code>直接<strong>修改配置</strong>，使用<code>SLOWLOG GET</code>来<strong>查询慢查询日志</strong>。</p><p><strong>慢查询记录的保存</strong></p><p>相关慢查询日志的属性记录在redisServer中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID，初始为0，每产生一条就加1</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span> *slow1og;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="number">1</span>ong slowlog_1og_slower_than;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-max-len选项的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slowlog是一个链表，有几个节点就表示有几条慢查询日志，节点是一个slowlogEntry实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slow1ogEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="number">1</span>ong id;</span><br><span class="line">    <span class="comment">//命令执行时的时间，格式为UNIX时间戥</span></span><br><span class="line">    <span class="keyword">time_t</span> time;</span><br><span class="line">    <span class="comment">//执行命令消耗的时间，以微秒为单位</span></span><br><span class="line">    <span class="number">1</span>ong <span class="keyword">long</span> duration;</span><br><span class="line">    <span class="comment">//命令与命令参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">&#125; slowlogEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新添加的日志会被放到slowlog链表的表头。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>执行MONITOR命令，客户端就成为了监视器，<strong>实时接收并打印服务器处理的命令</strong>。当其他客户端发送请求时，服务器除了执行，还会将相关信息发送给所有监视器。</p><p><strong>成为监视器</strong></p><p>redisServer中有monitors链表，记录所有成为监视器的客户端。如果某个客户端发送MONITOR命令，就会打开它的<code>REDIS_MONITOR</code>标志，并将其插入到该链表的<strong>尾部</strong>。</p><p><strong>向监视器发送命令信息</strong></p><p>服务器处理命令前都会调用<code>replicationFeedMonitors</code>函数，将相关信息发送给各个监视器。主要是封装要发送给监视器的信息、遍历监视器、发送信息这三步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的重点是Redis的事务，其他的作以了解。</p>]]></content>
    
    
    <summary type="html">本文主要介绍了Redis一些重要功能的实现，包括事务、慢查询日志和监视器。</summary>
    
    
    
    <category term="《Redis设计与实现》阅读笔记" scheme="https://icbtbo.github.io/categories/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://icbtbo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现:多机数据库的实现</title>
    <link href="https://icbtbo.github.io/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://icbtbo.github.io/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-01-05T01:35:35.000Z</published>
    <updated>2022-04-07T13:53:43.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在Redis中，可通过SLAVEOF命令或配置文件中设置slaveof选项，让一个服务器去复制另一个服务器，被复制的为主服务器，对其复制的称为从服务器。</p><h3 id="旧版本复制功能的实现"><a href="#旧版本复制功能的实现" class="headerlink" title="旧版本复制功能的实现"></a>旧版本复制功能的实现</h3><p>Redis在2.8以前使用旧版本复制，在从服务器断线重连时会遇上低效的情况。</p><p>Redis的复制功能分为<strong>同步</strong>和<strong>命令传播</strong>俩操作：</p><ul><li>同步用于把从服务器的数据库状态<strong>更新至主服务器的数据库状态</strong>。</li><li>命令传播是在主服务器的<strong>数据库状态被修改</strong>导致主从数据库状态不一致时，让主从回到一致的过程。</li></ul><p><strong>同步</strong></p><p>从服务器对主服务器的同步（下文以主从代替），需要向主服务器发送SYNC命令，具体步骤：</p><ol><li>从向主发送SYNC命令。</li><li>主接收并<strong>执行BGSAVE</strong>，后台生成RDB文件，并用一个<strong>缓冲区记录</strong>现在开始执行的所有写命令。</li><li>BGSAVE执行完毕时，主将RDB文件发给从，从接收并载入，更新数据库状态。</li><li>主将其记录在<strong>缓冲区的所有写命令</strong>发给从，从执行写命令。</li></ol><p>下图展示了同步的过程：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941116.jpg" alt="img"></p><p><strong>命令传播</strong></p><p>当主发生写操作时，主从同步需要通过命令传播，具体步骤：</p><ol><li>主将写命令发送给从。</li><li>从接收并执行相同的写命令。</li></ol><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>旧版复制的缺陷主要体现在断线重连上：</p><p>主因为网络原因中断复制，但从通过自动重连连上主，并继续复制主。此时，从发送SYNC命令，希望将<strong>断线期间</strong>由于对主的写操作造成的主从数据库不一致状态同步回一致状态，但SYNC每次都会<strong>重新生成RDB文件</strong>，将<strong>所有的</strong>数据库状态都写到RDB，这就造成了资源的<strong>大量浪费</strong>。</p><p>SYNC命令对性能的损耗比较高主要表现在：</p><ol><li>主执行BGSAVE生成RDB文件会消耗<strong>CPU、内存和磁盘I/O资源</strong>。</li><li>主需要发送RDB，消耗<strong>网络资源</strong>。</li><li>从接收并载入RDB，载入期间是<strong>阻塞的无法处理命令</strong>。</li></ol><p>因此，必须是真正有必要时才调用SYNC命令。</p><h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><p>Redis从2.8开始使用PSYNC代替SYNC命令来执行同步操作。</p><p>PSYNC有完整重同步和部分重同步的两种模式：</p><ul><li><p>完整重同步用于初次复制的情况，与SYNC命令一样。</p></li><li><p>部分重同步用于处理断线重连后的情况，重连后，主服务器将<strong>断线期间执行的写命令</strong>发送给从服务器，从只需接收并执行这些命令。</p><p>部分重同步的执行过程：</p><ul><li>从向主发送PSYNC命令，请求同步数据。</li><li>主判断后，确认需要执行部分重同步时，返回给从**+COUNTINUE**。</li><li>主将断线期间的写命令发送给从。</li></ul><p>下图展示了部分重同步的过程：</p></li></ul><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941165.jpg" alt="img"></p><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p>部分重同步基于三个部分实现：</p><ul><li>主从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器运行ID</li></ul><p><strong>复制偏移量</strong></p><p>主从都会维护一个复制偏移量，记录<strong>存储数据的字节数</strong>，当主服务器向从服务器传播N个字节数据时，主的复制偏移量会加N，从接收到之后也会加N。通过偏移量<strong>判断数据库状态是否一致</strong>。但有一个问题，就是从服务器重连后，需要执行部分还是完整重同步，这时候就需要复制积压缓冲区来帮忙判断。</p><p><strong>复制积压缓冲区</strong></p><p>复制积压缓冲区由主服务器维护，是固定长度的<strong>先进先出队列</strong>，默认1M。当入队元素大于队列长度时，最先入队的元素会被弹出。主服务器在命令传播时，不仅将写命令发给从，还会将<strong>写命令入队至积压缓冲区</strong>。</p><p>下图展示了传播的命令发给从并写入缓冲区的过程：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941262.jpg" alt="img"></p><p>复制积压缓冲区会保存最近写的命令，并为队列中的<strong>每个字节记录复制偏移量</strong>。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941357.jpg" alt="img"></p><p>当从服务器重连后，发送PSYNC并将自己的复制偏移量也发送给主服务器，主服务器拿着复制偏移量去复制积压缓冲区找，如果<strong>存在</strong>则进行部分重同步并给从服务器<strong>发送+CONTINUE</strong>回复，否则进行完整重同步。</p><p>复制积压缓冲区大小应该根据实际场景的两个因素进行调整：</p><ul><li>断线重连平均时间</li><li>主服务器平均每秒产生写命令的数据量</li></ul><p>一般得将这两个指标相乘后再乘以2，作为复制积压缓冲区的大小，应对大多数断线情况。</p><p><strong>服务器运行ID</strong></p><p>服务器运行ID决定断线后执行哪种同步方式，主从都有运行ID，是自动生成的40个随机十六进制字符。主从第一次复制时，从服务器会保存主服务器的ID，断线后也会向主服务器发送这个ID，如果<strong>不同则进行完整重同步</strong>（之前的主服务器由于某些原因连接断开，重新选举的情况）；相同则部分重同步。</p><h3 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h3><p>PSYNC命令调用方法有两种：</p><ul><li>从服务器第一次复制时，会发送<code>PSYNC ? -1</code>命令，请求完整重同步。</li><li>已经复制过的情况，向主服务器发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>命令，一个是主服务器运行ID，一个是积压缓冲区的偏移量。</li></ul><p>主服务器接收后有3种返回值：</p><ul><li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>：表示执行<strong>完整重同步</strong>，从服务器会将这两个变量保存。</li><li><code>+CONTINUE</code>：执行<strong>部分重同步</strong>，从服务器等待缺失数据的发送。</li><li><code>-ERR</code>：主服务器版本低于2.8，执行<strong>完整重同步</strong>操作。</li></ul><p>下图展示了PSYNC的执行流程： </p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941507.jpg" alt="img"></p><h3 id="一次完整的主从复制过程"><a href="#一次完整的主从复制过程" class="headerlink" title="一次完整的主从复制过程"></a>一次完整的主从复制过程</h3><p>一次完整的复制过程可以分为设置主服务器的地址和端口、建立套接字连接、发送PING命令、身份验证、发送端口信息、同步、命令传播。</p><ul><li><p><strong>设置主服务器的地址和端口</strong></p><p>当客户端向服务器发送SLAVEOF命令时，从服务器会将主服务器的ip和端口都保存后发送OK。这是一个<strong>异步命令</strong>，所以复制工作在回复OK后再执行。</p></li><li><p><strong>建立套接字连接</strong></p><p>从服务器此时创建连接主服务器的套接字，如果套接字能成功连接，从服务器会给它关联一个处理复制工作的<strong>文件事件处理器</strong>（负责接收RDB，传播的命令等）。主从成功连接后，主服务器会创建从服务器的客户端状态。</p></li><li><p><strong>发送PING命令</strong></p><p>从服务器在套接字连接后做的第一个工作就是发送PING命令，检查套接字<strong>读写状态是否正常</strong>；主服务器<strong>能否正常处理命令请求</strong>。而主服务器会根据网络状态、能够处理给出对应回复。一旦回复超时或返回错误，从服务器就会断开并重连主服务器。</p></li><li><p><strong>身份验证</strong></p><p>检查从服务器是否设置masterauth，如果设置则进行身份验证。</p></li><li><p><strong>发送端口信息</strong></p><p>身份验证后，从服务器向主服务器发送自己监听的端口号，主服务器保存这个端口号。</p></li><li><p><strong>同步</strong></p><p>从服务器发送PSYNC命令，主从互相成为对方的客户端，都能够执行命令并回复，执行同步操作，看是完整重同步还是部分重同步。</p></li><li><p><strong>命令传播</strong></p><p>完成同步后，进入该阶段，主服务器将写命令发送给从服务器，从服务器接收并执行。</p></li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认<strong>1秒一次</strong>发送<code>REPLCONF ACK &lt;replication_offset&gt;</code>命令给主服务器，replication_offset是复制偏移量。这么做有3个作用：</p><ul><li>检测主从网络状态</li><li>辅助实现min-slave选项</li><li>检测命令丢失</li></ul><p><strong>检测主从网络状态</strong></p><p>下面分别说这三个作用。检测网络连接很好理解，如果主服务器超过一秒没收到从服务器的<code>REPLCONF ACK</code>则表示连接有问题。</p><p><strong>辅助实现min-slave选项</strong></p><p>Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>可<strong>防止主服务器在不安全的情况下执行写命令</strong>。如果设置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3 </span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示从服务器数量少于3或3个从服务器延迟大于等于10s时，主服务器拒绝写命令。</p><p><strong>检测命令丢失</strong></p><p>通过发送的偏移量，主服务器会判断命令是否有丢失，如果丢失，就从积压缓冲区里找到并<strong>补发</strong>。</p><blockquote><p>注：Redis2.8之前版本并<strong>不会注意</strong>到丢失数据，所以保持主从数据一致性最好使用以上版本。</p></blockquote><h2 id="Sentinel机制"><a href="#Sentinel机制" class="headerlink" title="Sentinel机制"></a>Sentinel机制</h2><p>Sentinel（哨兵）是Redis的<strong>高可用性</strong>的解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及属下的所有从服务器。当主服务器下线时，自动将下线的某个主服务器属下的某个从服务器<strong>升级</strong>为新的主服务器。从而实现<strong>故障转移</strong>，当原来的主服务器重新上线时，会被降级为从服务器。</p><p>下面展示了哨兵监视主从的状态：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051117188.jpg" alt="img"></p><p>下面主要讲解Sentinel系统对主服务器执行故障转移的整个过程。</p><h3 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h3><p>启动Sentinel有两种方式：</p><ul><li><code>redis-sentinel /path/to/your/sentinel.conf</code></li><li><code>redis-server /path/to/your/sentinel.conf --sentinel</code></li></ul><p>俩命令效果相同，启动时需要执行以下步骤：</p><ol><li>初始化服务器。</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码。</li><li>初始化Sentinel状态。</li><li>根据配置文件，初始化Sentinel的监视主服务器列表。</li><li>创建连向主服务器的网络连接。</li></ol><p>接下来对这些步骤进行详细说明。</p><p><strong>初始化服务器</strong></p><p>Sentinel实际上是一个特殊的Redis服务器，所以很多地方和Redis服务器的初始化有些类似。只不过少了RDB或AOF文件的载入等操作。</p><p><strong>使用Sentinel专用代码</strong></p><p>将加载的常量，命令表（决定了Sentinel可以执行哪些命令）等替换为Sentinel专用的。</p><p><strong>初始化Sentinel状态</strong></p><p>初始化一个<code>sentinel.c/sentinelState</code>结构，记录Sentinel的状态，保存了服务器中所有与Sentinel相关的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span>&#123;</span></span><br><span class="line">    <span class="comment">//当前纪元，选举计数器，用于实现故障转移</span></span><br><span class="line">    uint64_ t current_ epoch;</span><br><span class="line">    <span class="comment">//（重点）保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line">    <span class="comment">//字典的键是主服务器的名字，值是一个指向sentine1RedisInstance结构的指针</span></span><br><span class="line">    dict masters;</span><br><span class="line">    <span class="comment">//是否进入了TILT模式</span></span><br><span class="line">    <span class="keyword">int</span> tilt;</span><br><span class="line">    <span class="comment">//目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="keyword">int</span> running_ scripts;</span><br><span class="line">    <span class="comment">//进入TILT模式的时间</span></span><br><span class="line">    mstime_ <span class="keyword">_t</span> tilt_ start_ time;</span><br><span class="line">    <span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    mstime_ t previous_ time ;</span><br><span class="line">    <span class="comment">//一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_ <span class="built_in">queue</span>;</span><br><span class="line">&#125;sentinel;</span><br></pre></td></tr></table></figure><p><strong>初始化master属性</strong></p><p>masters字典的值是一个指向sentine1RedisInstance结构的指针，而一个sentine1RedisInstance实例包括主服务器、从服务器或另一个Sentinel。实例结构如下，了解一下，故障转移的可以先不关注：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="comment">//标识值，记录了实例的类型，以及该实例的当前状态.</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//实例的名字.</span></span><br><span class="line">    <span class="comment">//主服务器的名字由用户在配置文件中设置</span></span><br><span class="line">    <span class="comment">//从服务器以及Sentinel 的名字由Sentinel 自动设置</span></span><br><span class="line">    <span class="comment">//格式为ip:port</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">//实例的运行ID .</span></span><br><span class="line">    <span class="keyword">char</span> *runid;</span><br><span class="line">    <span class="comment">//配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> config_epoch;</span><br><span class="line">    <span class="comment">//实例的地址</span></span><br><span class="line">    sentinelAddr *addr;</span><br><span class="line">    <span class="comment">// SENTINEL down-after-milliseconds 选项设定的值</span></span><br><span class="line">    <span class="comment">//实例无响应多少毫秒之后才会被判断为主观下线</span></span><br><span class="line">    <span class="keyword">mstime_t</span> down_after_period;</span><br><span class="line">    <span class="comment">//判断这个实例为客观下线所需的支持投票数量</span></span><br><span class="line">    <span class="keyword">int</span> quorum;</span><br><span class="line">    <span class="comment">//在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="keyword">int</span> paral1el_syncs;</span><br><span class="line">    <span class="comment">//刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_timeout;</span><br><span class="line">  <span class="comment">// 当该实例为主服务器时，该属性记录其从服务器</span></span><br><span class="line">  dict slaves;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>创建连向主服务器的网络连接</strong></p><p>Sentinel会为监视的主服务器创建两个异步网络连接：</p><ul><li><strong>命令连接</strong>：专用于向主服务器发送命令，接收命令回复。</li><li><strong>订阅连接</strong>：专用于订阅主服务器<code>__sentinel__:hello</code>频道。（由于Redis的发布订阅消息不会保存，客户端断线就会丢失，为了不丢失，必须使用专门的频道连接）</li></ul><h3 id="获取主从服务器信息"><a href="#获取主从服务器信息" class="headerlink" title="获取主从服务器信息"></a>获取主从服务器信息</h3><p>Sentinel默认<strong>10秒一次</strong>通过命令连接向被监视的主服务器发送<strong>INFO</strong>命令，获取主服务器信息。</p><p>主要获取主服务器本身信息（如服务器运行ID），下属从服务器信息（如ip，port，offset）。对主服务器实例和从服务器实例的相应属性进行更新，如果没有某个从服务器的信息就会创建一个实例结构，放到主服务器实例的slaves字典中，键为ip+端口，值为sentinelRedisInstance。</p><p>除了创建新实例，还会创建连接到从服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>。在创建命令连接后，Sentinel默认<strong>10秒一次</strong>通过命令连接向从服务器并发送<strong>INFO</strong>命令，获取从服务器信息（运行ID，角色，ip和端口，优先级等）。之后根据这些信息对从服务器的实例结构进行更新。</p><h3 id="向主服务器和从服务器发送消息"><a href="#向主服务器和从服务器发送消息" class="headerlink" title="向主服务器和从服务器发送消息"></a>向主服务器和从服务器发送消息</h3><p>sentinel默认以两秒一次，通过命令连接向服务器的<code>__sentinel__:hello</code>频道发送消息，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure><p>参数包含sentinel本身<code>（s_...）</code>和主服务器<code>（m_...）</code>的运行ID，ip，端口号，配置纪元等参数。</p><h3 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h3><p>Sentinel与一个主服务器或从服务器建立订阅连接后，会发送<code>SUBSCRIBE _sentinel_:hello</code>命令。</p><p>也就是Sentinel通过命令连接发送信息到频道，又通过订阅连接接收频道中的信息。一个Sentinel发的信息也会被其他Sentinel接收，根据信息记录的Sentinel运行id和接收信息的Sentinel<strong>运行id是否相同</strong>，来决定<strong>是否处理</strong>这条消息。通过这种透明的沟通机制，Sentinel可以对各自监听的服务器信息进行更新。</p><p><strong>更新sentinels字典</strong></p><p>根据接收而来的消息，Sentinel会更新实例结构中sentinels字典保存的所有Sentinel实例的信息。键为Sentinel的ip+端口，值为某个Sentinel的实例。消息接收者会检查发送消息的Sentinel（源sentinel）结构是否在sentinels字典，若存在则更新，没有则创建实例，和自己相同的sentinel不会被放入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span>&#123;</span></span><br><span class="line">    dict *sentinels;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种发布订阅的方式，Sentinel不需要各自发信息告诉对方，而是监视同一个主服务器的多个Sentinel自动发现对方。</p><p><strong>创建连向其他Sentinel的命令连接</strong></p><p>sentinel也会为对方互相创建命令连接，最终监视同一主服务器的多个sentinel会形成一个<strong>网络</strong>。但他们互相之间<strong>不会创建订阅连接</strong>，因为他们通过主或从服务器发来的频道来发现未知的sentinel。</p><p>下图展示了多个sentinel通过命令连接形成网络：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051117254.jpg" alt="img"></p><h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>Sentinel默认每秒与创建命令连接的实例（主服务器，从服务器，其他sentinel）发送PING命令，通过回复判断是否在线。如果实例返回除了<code>+PONG</code>，<code>-LOADING</code>，<code>-MASTERRDOWN</code>之外的回复或未及时回复，就认为是<strong>无效回复</strong>。</p><p>根据配置文件的<code>down-after-milliseconds</code>指定的<strong>主观下线所需时长内</strong>是否一直无效回复，来判断实例是否已经主观下线。下线了就将实例的的flags标识属性打开<code>SRI_S_DOWN</code>标识。由于每个Sentinel中的主观下线时间配置都可以不同，所有有可能<strong>某个Sentinel判断主观下线时，另一个Sentinel认为在线状态</strong>。</p><h3 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h3><p>当Sentinel判断主服务器为主观下线时，还会向其他Sentinel询问，得到足量数量的已下线判断后，就会判定服务器为客观下线，并执行故障转移。</p><p><strong>发送sentinel is-master-down-by-addr命令</strong></p><p>Sentinel使用：<code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current. epoch&gt; &lt;runid&gt;</code>命令询问其他Sentinel是否同意主服务器下线。这些参数分别是Sentinel的ip，端口，配置纪元和运行id。</p><p><strong>接收sentinel is-master-down-by-addr命令</strong></p><p>其他哨兵节点接收并返回三个参数的Multi Bulk回复：</p><ol><li><down_state>：是对主服务器的检查结果，1表示已下线；0表示未下线。</li><li><leader_runid>：如果是*，表示该命令用于检测服务器状态；如果是Sentinel的运行id用于选举领头Sentinel。</li><li><leader_epoch>：选举计数器，用于选举领头sentinel。</li></ol><p><strong>接收sentinel is-master-down-by-addr命令的回复</strong></p><p>统计其他Sentinel同意主服务器已下线数量，当数量超过配置值（quorum参数）时，sentinel会将主服务器实例的flags属性的<code>SRI_O_DOWN</code>属性打开，表示已进入客观下线状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="comment">//判断这个实例为客观下线所需的支持投票数量</span></span><br><span class="line">    <span class="keyword">int</span> quorum;</span><br><span class="line">    ...</span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure><h3 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h3><p>当主服务器被判断为客观下线时，sentinel会协商选举领头sentinel，并由领头sentinel对下线主服务器执行故障转移操作。</p><p>当<code>SENTINEL is-master-down-by-addr</code>命令已经确认主服务器客观下线时，Sentinel还会<strong>再发送</strong>带有选举性质的该命令，并且带上自己的运行ID。如果接收命令的Sentinel还没设置局部领头时，就会将这个运行ID作为自己的<strong>Multi Bulk回复参数</strong>。根据回复参数来判断多少sentinel将自己设置为局部领头。可能根据网络延迟，有的Sentinel命令比其他Sentinel都先到达，并且胜出（必须有<strong>半数以上</strong>的票），那么就由它负责故障转移。</p><p>若一次选举没有产生领头Sentinel，一段时间后再次选举，直到选出为止。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>故障转移包括3步：</p><ol><li>在已下线的主服务器属下从服务器里选出一个将其转为主服务器。</li><li>让其他从服务器都复制新主服务器。</li><li>当原来的主服务器再次上线时，让他成为新主服务器的从服务器。</li></ol><p><strong>选出新主服务器</strong></p><p>如何选新的主服务器？Sentinel会将所有从服务器放入列表，<strong>一项一项</strong>过滤：</p><ul><li>删除处于下线或断线状态的从服务器。</li><li>删除最近5秒没有回复过领头<code>sentinel INFO</code>命令的从服务器。</li><li>删除与已下线主服务器段开时间超过<code>down-after-milliseconds*10</code>毫秒的从服务器。</li></ul><p>然后根据<strong>优先级排序</strong>，相同则选<strong>偏移量最大</strong>的，再相同则选运行ID最小的。</p><p>选出来之后，对这个从服务器发送<code>SLAVEOF no one</code>命令，然后以<strong>每秒一次</strong>的频率向它发送<code>INFO</code>命令，观察返回的role属性如果变成master，就表示顺利升级为主服务器了。</p><p><strong>修改从服务器的复制目标</strong></p><p>向所有其他从服务器发送<code>SLAVEOF</code>命令，让他们都去复制新的主服务器。</p><p><strong>将旧的主服务器变为从服务器</strong></p><p>当原来的主服务器上线时，Sentinel就会向它发送<code>SLAVEOF</code>命令，让他成为新主服务器的从服务器。</p><h2 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h2><p>集群是Redis提供的<strong>分布式数据库</strong>方案，通过<strong>分片</strong>来进行数据共享并提供复制和故障转移的功能。主要对集群的节点，槽指派，命令执行，重新分片，转向，故障转移，消息进行介绍。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>集群由多个节点组成，通过<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>可以将节点连接起来。这个命令主要是将目标节点加入到当前Redis所在的集群中。下面从启动节点，集群相关数据结构，命令实现来介绍节点内容。</p><p><strong>启动节点</strong></p><p>Redis服务器在启动时会根据<code>cluster-enable</code>配置是否为yes来决定是否开启集群模式。</p><p>集群中的节点除了使用redisServer，redisClient之外，还用<code>cluster.h/clusterNode</code>结构、<code>cluster.h/clusterLink</code>结构、<code>cluster.h/clusterState</code>结构来保存集群数据。</p><p><strong>集群数据结构</strong></p><p>集群的每个节点都会用clusterNode来保存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; .</span><br><span class="line">    <span class="comment">//节点的名字，由40个十六进制字符组成</span></span><br><span class="line">    <span class="keyword">char</span> name [REDIS_CLUSTER_NAMELEN] ; </span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="comment">//使用各种不同的标识值记录节点的角色(比如主节点或者从节点),</span></span><br><span class="line">    <span class="comment">//以及节点目前所处的状态(比如在线或者下线)。</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">    <span class="comment">//节点的IP地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN] ;</span><br><span class="line">    <span class="comment">//节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>link属性保存了连接节点所需的有关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">//连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime ;</span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息( message )。</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    <span class="comment">//输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf ;</span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> <span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个节点都保存一个集群状态，记录在当前节点下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line">    <span class="comment">//集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">//集群当前的状态:是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量（下一节谈）</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//集群节点名单(包括myself节点)</span></span><br><span class="line">    <span class="comment">//键为节点名字，值为节点对应的clusterNode结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">    ...</span><br><span class="line">&#125; clusterState;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>CLUSTER MEET命令的实现</strong></p><p>通过向节点A发送<code>CLUSTER MEET</code>命令，让目标节点B加入集群，进行<strong>握手</strong>，执行过程如下：</p><ol><li>客户端发送该命令给节点A，节点A会创建一个节点B的clusterNode结构，添加到clusterState.nodes中。</li><li>解析IP地址和端口号，向节点B发送MEET消息（最后一节会讲消息）。</li><li>同理，节点B收到后，会为A创建clusterNode结构并添加到nodes。</li><li>节点B向A发送PONG消息。</li><li>节点A收到后向B发送一条PING消息。</li><li>节点B收到后直到A成功感知到B，握手完成。</li></ol><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504000.jpg" alt="img"></p><p>之后，节点A将节点B的信息通过<strong>Gossip协议</strong>（最后一节消息中将提到）传播给集群中的其他节点。</p><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis通过分片方式保存键值对，集群的整个数据库被分为<strong>16384</strong>个槽（slot），数据库的每个键都属于某一个槽，每个节点可处理0~16384个槽。当集群中的<strong>每个槽都归某个节点</strong>管理，集群处于上线状态；但凡有一个没人管，集群处于下线状态。</p><p>发送<code>CLUSTER ADDSLOTS &lt;slot&gt; [slot...]</code>命令，可以将槽委派给某个节点负责。下面介绍槽的实现。</p><p><strong>记录节点的槽指派信息</strong></p><p>clusterNode有slots和numslot属性记录了节点负责处理的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//二进制位数组，长度为16384/8=2048字节，</span></span><br><span class="line">    <span class="comment">//每个索引8位，根据0和1判断该槽是否被该节点负责</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slot[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//负责处理的槽数量</span></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如该节点负责0~7的槽，存储结构如下：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504094.png" alt="img"></p><p>通过这种设计，检查某节点<strong>是否负责处理某个槽</strong>或者<strong>让节点负责某个槽</strong>的操作的时间复杂度都为**O(1)**。</p><p><strong>传播节点的槽指派信息</strong></p><p>节点除了将自己负责的槽记录在<code>clusterNode.slots</code>中，还会将这个数组通过<strong>消息发送</strong>给其他节点，让他们都知道自己负责什么槽。其他节点接收消息后，会对<code>clusterStaste.nodes</code>字典中对应的<code>clusterNode.slots</code>数据进行更新。</p><p><strong>记录集群所有槽的指派信息</strong></p><p>clusterState会维护集群中每个节点管理槽的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果slot[i]指向空，说明该槽<strong>没有被节点管理</strong>；如果指向具体某个clusterNode，说明该槽由这个节点管理。</p><p>总结一下，<code>clusterState.slots</code>数组记录<strong>集群中所有槽的信息</strong>；<code>clusterNode.slots</code>数组记录当前节点<strong>负责槽的信息</strong>。前者方便知道某个槽指派给谁，后者方便知道某个槽是否指派给自己，或者发送自己槽的指派信息。（因为被指派后，还需要向其他节点发送消息告知）。</p><p><strong>CLUSTER ADDSLOTS命令的实现</strong></p><p>这个命令的执行其实就是把上面讲的几小节知识给串起来。主要是用来指派槽给节点负责的，接收该命令后，首先会遍历所有传入的槽（命令入参）检查其是否都是未指派的，如果<strong>有一个被指派了就报错</strong>。如果都未指派，将这些槽委派给当前节点，更新<code>clusterState.slots</code>数组指向当前节点的clusterNode；然后将<code>clusterNode.slots</code>数组中对应的索引<strong>二进制位设置为1</strong>。最后，<strong>发送消息</strong>告诉集群中其他节点，自己负责这些槽。</p><h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h3><p>当客户端对节点发送与数据库键有关的命令时，接收命令的节点会计算属于哪个槽，检查这个槽是否指派给自己（根据key的<strong>CRC-16校验和16383做与操作</strong>来确定槽号i，再根据clusterState.slots[i]是否指向当前节点的clusterNode判断是否自己负责的）。</p><p>如果不是指派给自己的，就（找负责该槽的节点的ip和端口，指引客户端转向它）向客户端<strong>返回MOVED错误</strong>，引导客户端指向正确的节点并再次发送命令。</p><blockquote><p>注：通过<code>CLUSTER KEYSLOT &lt;key&gt;</code>可查看某个key对应的槽号。</p></blockquote><p><strong>MOVED错误</strong></p><p>MOVED错误格式为：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p><p>在集群模式下，会被隐藏，客户端会进行自动转向并重发命令。节点的转向其实就是<strong>换对应套接字</strong>来发送命令。下面演示了对7000端口的节点操作键命令并被引导转向到真正存储该键的服务器（7001端口）的过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1: 7000&gt; SET msg &quot;hello&quot;</span><br><span class="line">-&gt; Redirected to slot [6257] located at 127.0.0.1: 7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; GET msg</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure><p><strong>节点数据库的实现</strong></p><p>节点对数据的存储和单机Redis的实现是一样的，只不过节点只能使用0号库。还需要维护一个<code>slots_to_keys</code>跳跃表关联槽号和键。<strong>分值是槽号，成员就是键</strong>。当节点往数据库添加新键时，节点就会在<code>slots_to_keys</code>中进行<strong>关联</strong>，反之则删除关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    ...</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片通过集群管理软件redis-trib执行，步骤如下：</p><ol><li>redis-trib对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让<strong>目标节点准备</strong>好，要导入键值对了。</li><li>redis-trib对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让<strong>源节点准备好</strong>，要转移键值对了。</li><li>redis-trib 向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令， 获得最多count个属于槽slot的键值对的键名( key name )，这实际上就是个<strong>批量分片</strong>的意思。</li><li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_ port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点。</li><li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点。</li><li>redis-trib向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_ id&gt;</code>命令，将槽slot指派给目标节点这个信息，通过<strong>消息发送至整个集群</strong>，让所有节点感知。</li></ol><p>整体迁移的流程图：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504126.jpg" alt="img"></p><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>当客户端向源节点发送与数据库键相关的命令，并且该键恰好属于<strong>被迁移的槽</strong>时，源节点会先查自己有没有，有就返回；<strong>没有则返回ASK错误</strong>，指引客户端向正在导入该槽的目标节点发送命令。这个命令和MOVED类似，不会直接打印错误。比如端口7000是源节点，”love”键的槽（16198槽）正在被迁移到7001就会这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1: 7000&gt; GET &quot;love&quot;</span><br><span class="line">-&gt; Redirected to slot [16198] located at 127.0.0.1: 7001</span><br><span class="line">&quot;you get the key &#x27;love&#x27;&quot;</span><br><span class="line">127.0.0.1: 7001&gt;</span><br></pre></td></tr></table></figure><p><strong>CLUSTER SETSLOT IMPORTING的实现</strong></p><p>clusterState.importing_slots_from数组记录当前节点正在从其他节点导入的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode *importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下指向空，当执行<code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>时，会将目标节点（当前节点）<code>clusterState.importing_slots_from[i]</code>设置为source_id所代表节点的clusterNode。</p><p><strong>CLUSTER SETSLOT MIGRATING的实现</strong></p><p>clusterState结构的migrating_slot_to数组记录了当前节点正在迁移至其他节点的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode *migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下指向空，当执行<code>CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code>时，会将源节点<code>clusterState.migrating_slots_to[i]</code>设置为target_id所代表节点的clusterNode。</p><p><strong>ASK错误</strong></p><p>如果节点收到一个关于键key的命令请求，并且键key所属的槽正好指派给了该节点，那么该节点会尝试在自己的数据库里查找键key，找到则返回，如果没找到则检查<code>clusterState.migrating_slots_to[i]</code>，是否正在迁移，如果<strong>正在迁移</strong>，就向客户端返回ASK错误，引导其去<strong>导入槽的节点查询</strong>。</p><p>客户端接收到ASK错误后，根据IP和端口，转向目标节点，然后先向目标节点发送<strong>ASKING</strong>命令，再重新发送要执行的命令。</p><p><strong>ASKING命令</strong></p><p>这个命令的唯一作用就是打开发送该命令客户端的<code>REDIS_ASKING</code>标识。有了这个标识后，节点会<strong>为正在导入的键执行命令</strong>。这个标识是<strong>一次性</strong>的，如果再对刚才的key执行相关操作，该节点会返回MOVED错误（因为重分片未结束，它不是负责该槽的节点）。下面表示相关判断过程：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504212.jpg" alt="img"></p><p><strong>ASK错误与MOVED错误的区别</strong></p><p>这两个错误都会导致客户端转向：</p><ul><li>MOVED错误代表槽的负责权<strong>已经从一个节点到了另一个节点</strong>。</li><li>ASK错误只是两个节点再迁移槽过程中使用的<strong>临时措施</strong>。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点（相当于备份，<strong>不处理读请求</strong>），并在被复制节点下线时，代替下线主节点继续处理命令请求。</p><p>接下来介绍节点的复制方法，检测节点是否下线方法及对下线节点故障转移方法。</p><p><strong>设置从节点</strong></p><p>向节点发送命令<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为指定节点的从节点并对主节点开始复制。主要过程是：</p><ol><li>接收命令节点在<code>clusterState.node</code>字典中找到node_id对应节点的clusterNode，然后将<code>clusterState.myself.slaveof</code>指向这个节点。</li><li>修改<code>clusterState.myself.flags</code>属性，关闭<code>REDIS_NODE_MASTER</code>标识，<strong>打开<code>REDIS_NODE_SLAVE</code>标识</strong>，标识该节点成为从节点。</li><li>调用复制代码，对主节点复制。</li></ol><p>当节点成为从节点并开始复制时，这个信息会通过消息发送给集群中其他节点。</p><p><strong>故障检测</strong></p><p>集群中每个节点都会定期向其他节点发送PING消息，如果没有在规定时间返回PONG消息，就会被标记位<strong>疑似下线</strong>。集群中各个节点会互相发送消息来交换各个节点的状态，当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态，A会将B的<strong>下线报告添加</strong>到<code>clusterNode.fail_reports</code>链表中。</p><p>链表中每个元素都由clusterNodeFailReport组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span>&#123;</span></span><br><span class="line">    <span class="comment">//报告目标节点已经下线的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">//最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="comment">//程序使用这个时间戳来检查下线报告是否过期</span></span><br><span class="line">    <span class="comment">// (与当前时间相差太久的下线报告会被删除)</span></span><br><span class="line">    <span class="keyword">mstime_t</span> time;</span><br><span class="line">&#125; <span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure><p>在一个集群中，<strong>半数以上</strong>负责处理槽的主节点将某个主节点报告为疑似下线后，这个主节点将被<strong>标记为已下线</strong>。并向集群广播一条关于该主节点FAIL的消息，所有收到消息的节点都会将其标记为已下线。</p><p><strong>故障转移</strong></p><p>当一个从发现主节点下线后，开始故障转移。具体步骤：</p><ol><li>下线的主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li><li>新的主节点会撤销对已下线主节点的槽指派，并将这些槽指派给自己。</li><li>新的主节点向集群广播一条PONG消息，让其他节点立即知道新的主节点。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><p><strong>选举新的主节点</strong></p><p>集群选举新主节点的具体过程：</p><ol><li>通过集群的配置纪元确定是哪一次选举，它是一个<strong>自增计数器</strong>，初始值为0。</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被加一。</li><li>集群里每个负责处理槽的主节点都有<strong>一次投票的机会</strong>，第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群<strong>广播</strong>一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到这条消息并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权(它正在负责处理槽)，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，并根据自己<strong>收到消息的条数</strong>来统计自己获得多少主节点的支持。</li><li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于<strong>N/2+1</strong> 支持票时，这个从节点就会当选为新的主节点。</li><li>配置纪元确定每个具有投票权的主节点只能投一次，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>如果在一个配置纪元里没有从节点得到足够的票，那么集群进入一个新的配置纪元，并<strong>再次进行选举</strong>，直到选出新的主节点为止。</li></ol><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>集群中节点主要通过发送消息来传递信息，主要有5种：</p><ul><li>MEET消息：发送者接收到客户端的<em>CLUSTER MEET</em>消息时，发送者向接收者发送MEET消息，<strong>请求加入</strong>发送者所在集群。</li><li>PING消息：集群每个节点每隔一秒从已知节点<strong>随机选出5个</strong>节点，然后对<strong>最长时间没发</strong>PING消息的节点进行发送。除此之外，如果最后一次收到某节点的PONG消息的时间，<strong>超过</strong>配置的<code>cluster-node-timeout</code>选项的<strong>一半</strong>时，也会发送PING消息。</li><li>PONG消息：应答MEET或PING消息。还可以通过PONG，告诉其他节点，刷新该节点的相关信息。</li><li>FAIL消息：当某个主节点判断另一个主节点<strong>已经进入FAIL状态</strong>时，当前主节点会向集群<strong>广播</strong>一条关于已下线节点的FAIL消息。</li><li>PUBLISH消息：当节点接收到PUBLISH命令时，执行这个命令，并向集群<strong>广播</strong>一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul><p>一条消息由消息头和消息正文组成。</p><p><strong>消息头</strong></p><p>记录信息发送者的一些信息。比如发送者的当前纪元，发送者名字，发送者的槽指派信息等。接收者可根据发送者的信息来更新发送者的状态。消息头是一个<code>cluster.h/clusterMsg</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//消息的长度(包括这个消息头的长度和消息正文的长度)</span></span><br><span class="line">    uint32_ t totlen;</span><br><span class="line">    <span class="comment">//消息的类型</span></span><br><span class="line">    uint16_ t type;</span><br><span class="line">    <span class="comment">//消息正文包含的节点信息数量</span></span><br><span class="line">    <span class="comment">//只在发送MEET. PING、PONG这三种Gossip协议消息时使用</span></span><br><span class="line">    uint16_ t count;</span><br><span class="line">    <span class="comment">//发送者所处的配置纪元</span></span><br><span class="line">    uint64_ t currentEpoch;</span><br><span class="line">    <span class="comment">//如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span></span><br><span class="line">    <span class="comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元.</span></span><br><span class="line">    uint64_ t configEpoch;</span><br><span class="line">    <span class="comment">//发送者的名字(ID)</span></span><br><span class="line">    <span class="keyword">char</span> sender [REDIS_ CLUSTER_ NAMELEN] ;</span><br><span class="line">    <span class="comment">//发送者目前的槽指派信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots [REDIS_ CLUSTER_ SLOTS/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span></span><br><span class="line">    <span class="comment">//如果发送者是一个主节点，那么这里记录的是REDIS_ NODE_NULL_NAME</span></span><br><span class="line">    <span class="comment">// (一个40字节长，值全为0的字节数组)</span></span><br><span class="line">    <span class="keyword">char</span> slaveof [REDIS_ CLUSTER_ NAMELEN] ;</span><br><span class="line">    <span class="comment">//发送者的端口号</span></span><br><span class="line">    uint16_ t port;</span><br><span class="line">    <span class="comment">//发送者的标识值</span></span><br><span class="line">    uint16_ t flags;</span><br><span class="line">    <span class="comment">//发送者所处集群的状态</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state;</span><br><span class="line">    <span class="comment">//消息的正文(或者说，内容)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure><p>其中消息正文是一个<code>cluster.h/clusterMsgData</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span>&#123;</span></span><br><span class="line">    <span class="comment">// MEET、 PING、PONG消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="comment">//每条MEET、PING、pONG消息都包含两个</span></span><br><span class="line">        <span class="comment">//clusterMsgDataGossip结构</span></span><br><span class="line">        clusterMsgDataGossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FAIL消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    clusterMsgDatafail about;</span><br><span class="line">    &#125;fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PUBLISH消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        clusterMsgDataPublish msg;</span><br><span class="line">    &#125;publish;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他消息的正文...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>MEET、PING、PONG消息的实现</strong></p><p>集群中的各个节点通过<strong>Gossip协议</strong>来交换各自关于不同节点的状态信息，Gossip协议由MEET、PING、PONG这三种消息实现，他们的的正文就是上面的ping结构体。</p><p>因为共用消息正文，所以需要消息头的type属性来区分。每次发送这类消息时，发送者都从已知节点中<strong>随机选择两个节点</strong>保存到clusterMsgDataGossip，因此正文包含两个clusterMsgDataGossip结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">struct</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> nodename [REDIS_CLUSTER_NAMELEN]; .</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后一次向该节点发送PING消息的时间戳</span></span></span></span><br><span class="line"><span class="function"><span class="params">    uint32_ t ping_sent;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后一次从该节点接收PONG消息的时间戳</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> pong_received;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的IP地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的墙口号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint16_t</span> port;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的标识值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint16_t</span> flags;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;clusterMsgDataGossip;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br></pre></td></tr></table></figure><p>消息接收者会根据clusterMsgDataGossip包含的节点，看是否为第一次接触，如果是的话，需要进行一次握手，记录节点信息；如果已经存在于已知节点中，则对相关节点信息更新。</p><p><strong>FAIL消息的实现</strong></p><p>在集群节点较多的情况下，单纯使用Gossip会带来一些<strong>延迟</strong>，FAIL消息需要所有节点立刻知道某个主节点下线了，从而尽快判断<strong>是否需要标记为下线或故障转移</strong>。消息正文是一个<code>cluster.h/clusterMsgDatafail</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录下线节点的名字</span></span><br><span class="line">    <span class="keyword">char</span> nodename[REDIS_CLUSTER_NAMELEN]</span><br><span class="line">&#125;clusterMsgDataFail;</span><br></pre></td></tr></table></figure><p>因为名字都是集群内唯一的，所以可以这么保存。</p><p><strong>PUBLISH消息的实现</strong></p><p>当集群的某个节点发送<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>时，会引发集群中所有节点都向channel发送消息。消息正文是一个<code>cluster.h/clusterMsgDataPublish</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint32_ t channel_len;</span><br><span class="line">    uint32_ t message_len;</span><br><span class="line">    <span class="comment">//定义为8字节只是为了对齐其他消息结构</span></span><br><span class="line">    <span class="comment">//实际的长度由保存的内容决定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bulk_data[<span class="number">8</span>] ;</span><br><span class="line">&#125; clusterMsgDataPublish;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bulk_data保存消息的channel和message参数。具体是根据对应参数长度识别的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>复制章节主要讲述主从复制功能，通过复制偏移量判断<strong>是否数据不一致</strong>，然后根据复制积压缓冲区和运行id判断执行<strong>完全重同步还是部分重同步</strong>，从而解决断线重连后的系统资源损耗问题。命令传播的心跳检测<strong>1秒一次</strong>，由从服务器发送，保障网络通常，防止主服务器在不安全的情况下执行写命令。</p><p>哨兵章节主要讲述哨兵的数据结构，命令实现，选举，故障转移等操作。Redis的哨兵集群模式是高可用的解决方案，默认每<strong>10秒一次</strong>向主从服务器发送<strong>INFO</strong>命令更新信息，主服务器下线或故障转移时会<strong>1秒一次</strong>。Sentinel每秒一次与创建命令连接的实例发送PING命令，根据配置的时间内未得到回复就标记为<strong>主观下线</strong>。然后询问其他Sentinel，得到足量下线判断后会标记为客观下线。发现客观下线的哨兵就会发起选举哨兵领头，根据规则（Raft算法），<strong>一半以上</strong>支持则成功担任并负责故障转移工作。根据配置规则向过滤不在线的从服务器，然后按优先级，偏移量，运行id排序选择主服务器并让从服务器都复制它。</p><p>集群章节主要讲述Redis的cluster集群模式下的集群数据结构，实现原理，选举，故障转移等操作。这种集群模式提供了<strong>分布式的数据存储</strong>。每个节点都维护了集群状态，各个节点状态信息还有槽指派信息。集群将<strong>数据分区</strong>，按槽存储，key的<strong>CRC-16</strong>的校验码决定了存放于哪个槽，每个主节点都指派不同的槽。当对某个节点执行key的相关命令时，会先判断<strong>是否归这个槽负责</strong>，如果不是则产生MOVED错误引导客户端指向正确的节点。如果<strong>归这个槽负责并且key在重分片</strong>，就会产生ASK错误，引导客户端指向目标节点。发送ASKING后，才能执行相关读写命令。这种集群模式，<strong>主节点负责读写，从节点复制</strong>，作为一个备份。</p><p>当从节点发现主节点下线，就进行故障转移，通过配置纪元选举出主节点，将原先槽指派给它，并且<strong>广播一条PONG</strong>消息，让其他节点知道。节点之间传递信息依赖消息，有MEET、PING、PONG、FAIL、PUBLISH消息。</p>]]></content>
    
    
    <summary type="html">本文主要介绍Redis的复制机制、哨兵（sentinel）机制以及cluster集群</summary>
    
    
    
    <category term="《Redis设计与实现》阅读笔记" scheme="https://icbtbo.github.io/categories/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://icbtbo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现:单机数据库的实现</title>
    <link href="https://icbtbo.github.io/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://icbtbo.github.io/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-01-04T06:38:05.000Z</published>
    <updated>2022-03-23T12:55:59.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>redis3.0 标有注解的源码：<a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p></blockquote><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>从Redis服务端的实现角度介绍，包括db存储，切换，键的存储及过期相关处理。</p><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis把所有库信息都保存在<code>redis.h/redisServer</code>结构的db数组中，数组类型是<code>redis.h/redisDB</code>，dbnum决定着应该创建多少数据库中的db，clients维护着所有连接Redis的客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//客户端状态链表</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器数据库实例如图所示：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042148700.jpg" alt="img"></p><p>当切换库时，其实就是redisClient.db对redisServer.db数组的目标数据库指针的移动。下面展示了从0号库切为1号库的过程。通过<strong>指针的切换</strong>，实现对库的共享：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149516.jpg" alt="img"></p><h3 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h3><p>redis将所有key进行统一管理，按照所属的库划分，放在redisDb的字典中（按照上面画的数据结构，redis每一个库都对应一个redisDb）。redisDb结构的dict字典保存了该数据库中的所有键值对，也称为<strong>键空间</strong>。键空间的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键空间的键就是数据库的键，每个键都是一个字符串对象，键空间的值就是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象（上一章主要是对值的存储结构介绍）。</p><p>下图展示了键空间的存储：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149396.jpg" alt="img"></p><p>当执行一些插入指令时，就是对dict中key的新增；同理，删除键后，dict中的键值对对象都会被删除。</p><p><strong>读写键空间时的维护操作(9.3.6详讲)</strong></p><p>对键的读写时，服务器会做相应的善后操作，比如更新缓存的命中率，更新LRU（最后一次使用）时间，对已过期的键先进行删除操作，修改时对客户端watch的键进行dirty标记，更新dirty键计数器的值，当开启通知功能后，键修改时需要按配置发送相应通知。</p><h3 id="键过期时间相关操作"><a href="#键过期时间相关操作" class="headerlink" title="键过期时间相关操作"></a>键过期时间相关操作</h3><p>通过<code>EXPIRE</code>或<code>PEXPIRE</code>，客户端可以以<strong>秒或毫秒</strong>为精度设置过期时间（Time To Live，TTL）。通过<code>EXPIREAT</code>或<code>PEXPIREAT</code>，客户端可以设置<strong>时间戳</strong>作为过期时间。</p><p>使用<code>TTL</code>或<code>PTTL</code>也可查看某个键的剩余生存时间，还有多久过期：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 498</span><br></pre></td></tr></table></figure><p>Redis是如何保存过期时间的，又是如何删除过期键的将在下面论述。</p><p><strong>设置过期时间</strong></p><p>Redis提供了4个命令设置过期时间：</p><ul><li>EXPIRE<key> <ttl>：将key的生存时间设为ttl秒。</li><li>PEXPIRE<key> <ttl>：将key的生存时间设为ttl毫秒。</li><li>EXPIREAT<key> <timestamp>：将key的过期时间设置为timestamp秒数时间戳。</li><li>PEXPIREAT<key> <timestamp>：将key的过期时间设置为timestamp毫秒数时间戳。</li></ul><p>其实几个命令底层都是经过换算后，用<strong>PEXPIREAT</strong>实现的。</p><p>实现转换关系图：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149255.jpeg" alt="img"></p><p><strong>存储过期时间</strong></p><p>redisDb中有一个expires的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个<strong>long long</strong>类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的Unix时间戳）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>图中键空间和过期的键其实复用了一个键对象，这里方便展示就拆开来，假设我们给键alphabet和book都设置了过期时间：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149780.jpg" alt="img"></p><p><strong>移除过期时间</strong></p><p>PERSIST命令可以<strong>移除一个键的过期时间</strong>，在过期字段中查找给定键，并<strong>解除</strong>键和值在过期字典中的关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 498</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><p><strong>计算并返回剩余生存时间</strong></p><p>TTL以秒为单位返回剩余时间，PTTL以毫秒返回键的剩余时间。二者的计算都是通过计算键的过期时间与当前时间之差来实现的。</p><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>如果一个键过期了，那么在什么时候被删除？列举几个常见淘汰策略：</p><ol><li>定时删除：设置键的过期时间时，创建定时器，过期时，以定时器立刻执行键的删除。</li><li>惰性删除：不着急删除过期键，每次获取时都会进行过期校验。</li><li>定期删除：隔一段时间，程序就对数据库检查，删除过期键。</li></ol><p><strong>定时删除</strong></p><p>定时删除策略<strong>对内存友好</strong>，但<strong>对CPU不友好</strong>。过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。Redis定时器需要创建时间事件，时间事件底层由无序链表实现，查找复杂度为O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p><p><strong>惰性删除</strong></p><p>惰性删除<strong>对CPU友好</strong>，但<strong>对内存不友好</strong>。不需要把时间浪费在非相关键的删除上。当键非常多时，会导致内存泄漏，因为只有用到时才会判断，删除。</p><p><strong>定期删除</strong></p><p>定期删除是一种折衷的方式，隔一段时间执行一次，并<strong>限制</strong>删除操作<strong>执行的时长和频率</strong>减少对CPU的占用；定期删除还能<strong>减少庞大的过期键对内存的占用</strong>。如何确定时长和频率是难点，过长或过少，会退变为定时删除和惰性删除。</p><p><strong>Redis的过期键删除策略</strong></p><p>Redis使用了<strong>惰性删除和定期删除</strong>两种策略配合，服务器可以合理地在使用CPU时间和避免内存浪费之间权衡。</p><ul><li><p>惰性删除策略的实现</p><p>该策略由<code>db.c/expireIfNeeded</code>函数实现，如同指令过滤器，在执行读写键指令时都会调用该函数检查键是否过期，如果过期则删除。</p></li><li><p>定期删除策略的实现</p><p>该策略由<code>redis.c/activeExpireCycle</code>函数实现，当服务器周期性调用<code>redis.c/serverCron</code>函数时，<code>activeExpireCycle</code>函数就会被调用，规定时间内，多次遍历服务器的各个数据库，从expires字典中随机检查一部分键的过期时间，并删除过期键。<code>activeExpireCycle</code>函数的主要工作可以拆分为：</p><ol><li>每次运行，都从一定数量的数据库中取出一定数量的<strong>随机键</strong>检查并删除过期键。</li><li>全局遍历记录检查进度，有<strong>记忆</strong>功能，全局变量存储的是几号库。</li><li>当所有数据库都被检查一遍后，<strong>重置</strong>全局变量，进行新一轮检查。</li></ol></li></ul><h3 id="RDB、AOF和复制功能对过期键的处理"><a href="#RDB、AOF和复制功能对过期键的处理" class="headerlink" title="RDB、AOF和复制功能对过期键的处理"></a>RDB、AOF和复制功能对过期键的处理</h3><p><strong>载入RDB文件</strong>：</p><ul><li>若服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键不会对主服务器载入RDB文件产生影响</li><li>若以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，主从服务器在进行数据同步时，从服务器的数据库会被清空，所以过期键不会对从服务器载入RDB文件产生影响</li></ul><p><strong>写入AOF文件</strong>：</p><ul><li>若某个键已过期但未被删除，那么AOF文件不会因这个过期键产生任何影响</li><li>若某个键已过期并被删除后，程序会向AOF文件追加一条DEL命令</li></ul><p><strong>重写AOF文件</strong>：</p><ul><li>与生成RDB文件类似，在重写AOF文件过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中</li></ul><p><strong>复制</strong>：</p><ul><li>主服务器删除一个过期键后，会向所有从服务器发送一个DEL命令，告知从服务器删除该过期键</li><li>从服务器在执行客户端发送的读命令时，即使遇到过期键也不会做什么，而时像处理未过期键一样处理该键，将其值返回。只有在收到主服务器发过来的DEL命令后，从服务器才会删除该过期键。</li></ul><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>Redis发布订阅功能可以让客户端获取数据库中键的变化及命令的执行情况。关注某个键执行了什么命令的通知称为键空间通知。关注某个命令被什么键执行的通知称为事件通知。</p><p>主要就是围绕通知功能，简单看下发送通知及其实现。</p><p><strong>发送通知</strong></p><p>该功能由<code>notify.c/notifyKeyspaceEvent</code>函数实现：</p><p>通过几个入参：要发送的通知类型，事件名称，产生事件的键，产生事件的数据库号。来构造事件通知内容和接收频道名，Redis许多指令的执行函数都会调用这个函数，传递该命令引发的事件相关信息。</p><p><strong>发送通知的实现</strong></p><ol><li>通过服务器配置的值判断，如果给定通知类型不是服务器允许的就直接返回。</li><li>如果是服务器允许发送的，检测是否允许发送键空间通知，允许则构建发送事件并通知。</li><li>检测是否允许发送键事件通知，如果允许则构建并发送通知。</li></ol><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>由于Redis是内存数据库，数据状态都存储于内存，如果不想办法将存储在内存中的数据库状态保存到磁盘里，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p><p>为解决这个问题，Redis提供了持久化的功能，可将内存中的数据库保存到磁盘，防止意外丢失。RDS持久化（默认持久化策略）就是将某一时间点上的状态保存到一个RDB文件里。RDB文件是经过<strong>压缩的二进制文件</strong>，可通过该文件还原成数据库状态。</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个命令可用于生成RDB文件（SAVE和BGSAVE）。他们之间的区别是：SAVE会<strong>阻塞</strong>Redis服务器进程，直到RDB文件创建完毕为止，阻塞期间，服务器不能处理任何命令请求。而BGSAVE会<strong>fork出一个子进程</strong>，由子进程负责创建RDB文件，<strong>父进程继续处理命令请求</strong>。当子进程完成之后，向父进程<strong>发送信号</strong>。</p><p>创建就是执行SAVE/BGSAVE底层调用rdbSave函数的过程，载入就是服务启动时读取RDB文件底层调用rdbLoad函数的过程。</p><p><strong>适用场景</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><p><strong>缺陷</strong></p><ul><li>在一定间隔时间做一次备份，所以如果redis挂了，就会<strong>丢失最后一次快照后的所有修改</strong>。</li><li>fork的时候，当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul><p><strong>BGSAVE执行时的服务器状态</strong></p><p>BGSAVE命令执行期间，对SAVE，BGSAVE，BGREWRITEAOF（AOF持久化命令）三个命令的处理方式如下：</p><ul><li>由于SAVE，BGSAVE底层都是调用rdbSave来持久化文件的，而且父子进程同时执行两个rdbSave调用会<strong>产生竞态条件</strong>，所以这两个指令会被服务器拒绝。</li><li>BGREWRITEAOF会被延迟到BGSAVE执行结束后执行。</li></ul><blockquote><p>如果BGREWRITEAOF正在执行，服务器会拒绝BGSAVE命令。由于BGREWRITEAOF和BGSAVE都会产生子进程且有大量的磁盘写入，出于性能考虑不会同时执行。</p></blockquote><p>简单来说，就是BGSAVE执行期间，<strong>拒绝SAVE，BGSAVE</strong>；<strong>延迟执行BGREWRITEAOF</strong>。BGREWRITEAOF执行期间，<strong>拒绝BGSAVE</strong>。</p><p><strong>RDB与AOF共存的载入情况</strong></p><p>RDB文件的载入是在服务器启动时执行，Redis并没有专门提供载入RDB文件的命令。由于AOF文件的更新频率更高，因此开启AOF持久化功能后，启动时<strong>优先加载AOF</strong>还原数据，只有在AOF处于关闭状态，才使用RDB文件恢复数据。</p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>服务器允许用户通过配置文件设置隔一定时间自动执行BGSAVE。可通过save选项设多个保存条件，默认的配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>只要满足任意条件，900s内对数据库进行1次修改或300s内…BGSAVE就会被执行。</p><p>那么，服务器是如何根据save选项来自动执行BGSAVE的？<br>从实现角度考虑，我们需要<strong>记录配置</strong>、<strong>评判依据</strong>和<strong>依据更新驱动</strong>。记录配置由saveparams实现；评判依据是dirty计数器和lastsave属性；依据更新驱动就是serverCron对评判依据的动态更新。<br>save配置都会在redisServer的saveparam数组中体现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>dirty计数器和lastsave属性</strong></p><p>这两个属性由redisServer持有：</p><ul><li>dirty计数器记录距离上次成功执行SAVE或BGSAVE后数据库被修改了几次。</li><li>lastsave是一个UNIX时间戳，记录上次成功执行SAVE或BGSAVE的时间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行保存的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>检查条件是否满足</strong></p><p>Redis的周期性操作函数serverCron每隔100毫秒会执行一次，其中一项工作就是检查save选项设置的保存条件是否满足要求，满足则执行BGSAVE。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150112.jpeg" alt="img"></p><p>REDIS：长度5字节，保存”REDIS”5个字符（为书写方便，其实是5个单独字符），通过这个判断该文件是否为RDB文件。</p><p>db_version：长度4字节，是字符串表示的整数记录RDB的版本号。</p><p>database：包含0个或多个数据库及各数据库中键值对数据。表示那些数据库是有数据的。</p><p>EOF：常量长度1字节，标志RDB文件正文的结束。读取时遇到该值，表示键值对的载入已经结束了。</p><p>check_sum：是一个8字节的无符号整数，保存一个同过前几位变量计算出来的校验和。每次加载都会进行计算校验，通过这个来判断文件是否损坏。</p><p><strong>database部分</strong></p><p>每个非空数据库在RDB文件中都可表示为SELECTDB，db_number，key_value_pairs三部分</p><ul><li>selectdb：1字节，标志位，标志着下一位存储的是数据库号码。</li><li>db_number：是一个数据库号码。</li><li>key_value_pairs：保存了数据库中所有键值对数据，如果有过期时间，则过期时间也会保存。</li></ul><p><strong>key_value_pairs部分</strong></p><p>不带过期时间的键值对在RDB文件由TYPE，key，value组成，带过期时间则含有EXPIRETIME_MS，ms：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150519.png" alt="img"></p><p>EXPIRETIME_MS：标志位，长度为1字节，告知程序下一个读入的是以毫秒为单位的过期时间。<br>ms：是8字节长的带符号整数，记录UNIX时间戳，即过期时间。<br>type：记录value的类型，长度1字节，这个常量其实就是Redis对象类型和底层编码的组装：</p><ul><li>REDIS RDBTYPE_STRING</li><li>REDIS_ RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_HASH_ZIPLIST</li></ul><p>服务器会根据TYPE来决定如何读入和解释value的数据。</p><p>key就不用做过多解释~</p><p><strong>value的编码</strong></p><p>根据TYPE的不同，value的存储结构也大不相同。这里不详细展开，只需要知道，对于字符串对象，如果大于20字节，就会用LZF算法压缩。除字符串对象和整数集合，其他存储方式的开头都是节点数量，告诉程序应读入多少节点/键值对。（详细内容可查阅10.3.3节）</p><h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><p>Redis自带RDB文件检查工具redis-check-dump。可以帮助在系统故障后分析快照文件，也就是RDB文件。</p><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。服务器启动时，可通过载入和执行AOF文件中保存的命令来还原服务器关闭前的数据库状态。</p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化可分为命令追加，文件写入，文件同步三个步骤。</p><p><strong>命令追加</strong></p><p>开启AOF持久化后，服务器执行完一个写命令后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的<code>aof_buf</code>缓冲区末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>AOF文件的写入与同步</strong></p><p>Redis服务器进程就是一个<strong>事件循环</strong>，负责接收客户端命令请求及命令回复，时间事件负责执行像<code>serverCron</code>函数这样需要定时运行的函数。服务器每结束一个事件循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否有必要<strong>将aof缓冲区中的内容写入和保存至AOF文件</strong>里。</p><p>这个判断的依据就是根据配置文件的appendfsync值决定：</p><ul><li>always：将aof_buf缓冲区的所有内容<strong>写入并同步</strong>到AOF文件。</li><li>everysec：将aof_buf缓冲区中的所有内容写入到AOF文件，如果此时与上次同步AOF文件的时间<strong>超过一秒</strong>，就再次对AOF文件进行同步，并由一个线程专门负责。</li><li>no：将aof_buf缓冲区中的所有内容写入到AOF文件，但并<strong>不对AOF文件进行同步</strong>，何时同步<strong>由操作系统决定</strong>。</li></ul><p>为什么有写入和同步的区分？写入≠同步</p><p>为提高写效率，操作系统一般将写入数据<strong>暂时保存在内存缓冲区</strong>，等缓冲区<strong>填满或超过</strong>指定时间后才会真正地将<strong>数据同步到磁盘里</strong>。操作系统提供了fsync和fdatasync两个同步函数，可<strong>强制操作系统同步数据</strong>，保证数据安全性。</p><p>也就是说，每一次的事件循环，aof_buf中的指令<strong>都会被写入操作系统的缓冲区</strong>，根据appendfsync配置，当操作系统缓冲区满足一定条件后，才被<strong>真实地写入</strong>磁盘内。</p><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>步骤如下：</p><ol><li>创建一个没有网络连接的伪客户端。（由于Redis命令只能在客户端上下文中执行，并且AOF文件在本地而不是网络）。</li><li>解析AOF文件并取出一条写命令。</li><li>使用伪客户端执行被读出的写命令</li><li>持续执行2和3，直到所有写命令都已经执行完毕</li></ol><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150967.jpg" alt="img"></p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为AOF持久化会将所有的写命令都记录，所以会有冗余情况，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong>瘦身的机制</strong>确保AOF里存的都是必不可少的精华。</p><p>Redis提供AOF文件重写功能，让服务器创建一个新的AOF文件，替代现有的AOF文件，减少冗余命令。</p><p><strong>AOF文件重写的实现</strong></p><p>在新的AOF文件的重写过程中，不会读取旧AOF文件，而是通过<strong>读取数据库状态</strong>来实现的。首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录的多条命令。</p><blockquote><p>注：在重写时会先检查键所包含的元素数量，因为多元素的键在命令转换时可能会导致客户端输入缓冲区溢出。该限制由配置中对应的一个常量控制，默认超过64个就用多条指令记录。</p></blockquote><p><strong>AOF后台重写过程</strong></p><p>AOF重写的过程中会有大量的写入操作，为了避免Redis服务器长时间的阻塞，重写工作将被放到<strong>子进程中进行</strong>。这样的好处是：</p><ul><li>父进程仍然可继续处理请求。</li><li>子进程有自己的数据副本，而非子线程，可以避免一些线程安全性问题的出现。</li></ul><p>子进程在执行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致<strong>当前数据库状态与重写后的AOF文件保存的状态不一致</strong>。为解决这个问题，设置了<strong>AOF重写缓冲区</strong>。</p><p>当重写子进程创建后，Redis服务器执行完写命令就会将其写入AOF缓冲区和AOF重写缓冲区，子进程执行重写期间，服务器进程要执行3个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到AOF缓冲区。</li><li>将执行后的写命令追加到AOF重写缓冲区。</li></ol><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150308.jpg" alt="img"></p><p>当子进程完成重写后，会向父进程<strong>发送一个信号</strong>，父进程接收并调用信号处理函数，将重写缓冲区的所有内容写到新AOF文件中，原子地覆盖现有的AOF文件。因此整个AOF文件重写的过程中，只有<strong>信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是一个<strong>事件驱动程序</strong>，主要有两种：</p><ul><li>文件事件：Redis服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端通信会产生相应文件事件，服务器通过监听这些事件来完成一系列网络通信操作。</li><li>时间事件：Redis服务器有一些需要在给定时间内执行的操作，而时间事件就是对这类定时操作的抽象。</li></ul><p>简单来说，文件事件就是<strong>套接字操作相关的事件</strong>；时间事件就是<strong>定时操作相关事件</strong>。</p><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发的网络事件处理器，就是文件事件处理器。大致是使用I/O多路复用程序<strong>同时监听多个套接字</strong>，根据套接字目前执行的任务为套接字<strong>关联不同的事件处理器</strong>；当被监听的套接字准备好<strong>应答，读取，写入，关闭</strong>等操作时。与之对应的文件事件就会产生，文件事件处理器就开始发挥作用了，调用事先关联好的事件处理器来处理事件。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150098.jpg" alt="img"></p><p>利用多路复用，虽然以单线程的方式运行，但文件事件处理器实现了高性能的网络通信模型，又能很好的与Redis服务器中其他模块对接，保持了设计的<strong>简单性</strong>。</p><p><strong>文件事件处理器的组成</strong></p><p>由套接字，I/O多路复用程序，文件事件分派器，事件处理器组成。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O多路复用程序总是将所有产生事件的<strong>套接字放入到一个队列</strong>中，以有序，同步，<strong>一次一个套接字</strong>向文件事件分派器传送的姿态来运行。只有当上一个套接字产生事件被事件处理器执行完了，才会继续传送下一个套接字。</p><p>下图展示了多路复用程序使用队列传输套接字：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150230.png" alt="img"></p><p><strong>I/O多路复用的实现</strong></p><p>Redis为所有多路复用的函数库进行包装，每个多路复用函数库在其中都对应一个单独文件：<code>ae_select.c</code>,<code>ae_epoll.c</code>,<code>ae_kqueue.c</code>。为每个多路复用函数都实现了相同的API，所以多路复用程序的底层实现是可以互换的。Redis在多路复用程序源码中用宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的I/O多路复用函数库。</p><p>有关多路复用的知识可以参考：<a href="https://zhuanlan.zhihu.com/p/127170201">https://zhuanlan.zhihu.com/p/127170201</a></p><p><strong>事件的类型</strong></p><p>多路复用程序可监听的套接字事件可分为<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件。</p><ul><li>当套接字变得<strong>可读</strong>时（客户端对套接字执行write，close，accept后），套接字产生AE_READABLE事件。</li><li>当套接字变得<strong>可写</strong>时（客户端对套接字执行read操作后），套接字产生AE_WRITABLE事件。</li></ul><p>I/O多路复用程序允许服务器同时监听者两个事件，如果某个套接字同时产生了两种事件，文件事件分派其会优先处理AE_READABLE，再处理AE_WRITABLE</p><p><strong>文件事件的处理器</strong></p><p>根据客户端的需要，事件处理器分为连接应答处理器，命令请求处理器，命令回复处理器，复制处理器。这里只介绍前三者。</p><ol><li><p>连接应答处理器</p><p><code>networking.c/acceptTcpHandler</code>函数是Redis的连接应答处理器，用于连接服务器监听套接字的客户端进行应答。</p><p>Redis服务器初始化时，程序就将连接应答处理器和服务器监听套接字的<strong>AE_READABLE事件关联</strong>，当客户端调用<code>sys/socket.h/connect</code>函数时连接服务器监听套接字时，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p>简单来说就是客户端<strong>连接被监听的套接字</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>连接应答处理器就会执行</strong>。</p></li><li><p>命令请求处理器</p><p><code>networking.c/readQueryFromClient</code>函数是Redis命令请求处理器，主要负责从套接字中读入客户端发送的命令请求内容。</p><p>当客户端成功连接到服务器后，服务器会将<strong>AE_READABLE事件</strong>和命令请求处理器关联。当客户端向服务器发送命令请求时，套接字产生AE_READABLE事件，引发命令请求处理器执行，执行相应套接字的读入操作。</p><p>简单来说就是客户端<strong>发送命令请求</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>命令请求处理器就会执行</strong>。</p></li><li><p>命令回复处理器</p><p><code>networking.c/sendReplyToClient</code>函数是Redis的命令回复处理器，负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p><p>当需要回复命令结果时，服务器会将客户端套接字的<strong>AE_WRITEBLE事件</strong>和命令回复处理器关联，当客户端准备好接收回复时就会产生AE_WRITABLE事件，引发命令回复处理器执行。执行结束，服务器会解除命令回复处理器与客户端的套接字AE_WRITABLE事件之间的关联。</p><p>简单来说就是服务器<strong>发送命令回复</strong>时，套接字<strong>产生并触发写事件</strong>，<strong>命令回复处理器就会执行</strong>。</p></li></ol><p><strong>总结</strong></p><p>一次完整的基于文件事件的服务器与客户端交互，相关处理器的处理过程：</p><ol><li>客户端发起连接，产生读事件，触发连接应答处理器执行。创建套接字，客户端状态并将该套接字的读事件与命令请求处理器关联。</li><li>客户端发送命令，产生读事件，触发命令请求处理器。读取执行命令，得到回复并将该套接字的写事件与命令回复处理器关联。</li><li>客户端读取命令回复，产生写事件，触发命令回复处理器。将回复写入套接字，解除写事件与命令回复处理器的关联。</li></ol><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件可分为<strong>定时事件</strong>和<strong>周期性事件</strong>：</p><ul><li>定时事件:只在指定时间到达时执行一次。如xx时间后执行一次。</li><li>周期性事件:每隔一段时间执行一次。如每隔xx秒执行一次。</li></ul><blockquote><p>注：Redis一般只用周期性事件。</p></blockquote><p><strong>时间事件的组成</strong></p><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一ID (标识号)。 ID号按<strong>从小到大</strong>的顺序递增，新事件的ID号比旧事件大。</li><li>when：毫秒精度的UNIX时间戳，时间事件的到达(arrive)时间。</li><li>timeProc：时间事件处理器函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>事件处理器返回<code>ae.h/AE_NOMORE</code>, 为定时事件：该事件在达到一次之后被删除，之后不再到达。</li><li>事件处理器返回非<code>AE_NOMORE</code>的整数值，为周期性时间。当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，找到已到达的时间事件，调用相应的事件处理器。新的事件总是插入到链表的表头。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150489.jpg" alt="img"></p><p>因为事件ID只能增大，所以新插入的id总是最大的。</p><h4 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h4><p>很多情况下，Redis需要定期进行资源检查，状态同步等操作，就需要定期操作，而定期操作都是由serverCron函数负责的，也是时间事件的应用实例。默认每隔100ms执行，具体工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。以及清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>下面简单从几个方面出发，介绍serverCron的本职工作。</p><p><strong>更新服务器时间缓存</strong></p><p>Redis不少功能依赖于系统当前时间，每次获取系统时间都会进行系统调用，为减少系统调用次数，服务器使用了unixtime和mstime作为当前时间的缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">//保存了毫秒级的系统当前UNIC时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于serverCron默认100毫秒更新一次unixtime和mstime，导致其精度不高，只使用于精度要求不高的场景：</p><ul><li>服务器打印日志，更新服务器的LRU时钟，决定执行持久化，计算上限时间等。</li><li>设置过期时间，添加慢查询日志需要高高进度，服务器还是会进行系统调用。</li></ul><p><strong>更新LRU时钟</strong></p><p>每个Redis对象也会有lru属性，记录上一次被命令访问的时间。如果要计算一个键的空转时长，就要通过lrulock记录的时间减去对象的lru属性记录时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">//用于计算键的空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lrulock:<span class="number">22</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//对象最后一个被命令访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>更新服务器每秒执行命令数</strong></p><p>抽样计算函数以100毫秒一次，估算最近一秒钟的处理请求数。每次都会根据4个变量（上次抽样时间、当前时间、上次抽样已执行命令数、当前已执行命令数）来计算调用之间平均每毫秒处理几个命令，乘以1000就是1秒内处理命令的估计值。这个估计值会被放入redisServer的ops_sec_samples数组中。当我们需要知道秒内的指令数时，就会计算这个数组的平均数，因此结果是一个估算值。</p><p><strong>更新服务器内存峰值记录</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stat_peak_memory记录内存峰值，每次serverCron函数执行就会判断是否需要刷新内存峰值，如果当前使用的多就刷新。</p><p><strong>管理客户端资源</strong></p><p>serverCron每次执行都会调用clientsCron函数对客户端进行检查：如果已经超时则关闭；如果输入缓冲区大小超过一定长度则重新创建默认大小的输入缓冲区。</p><p><strong>管理数据库资源</strong></p><p>serverCron每次执行都会调用databaseCron函数，会对服务器的一部分数据库检查，删除过期键；对字典收缩。</p><p><strong>执行被延迟的BGREWRITEAOF</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//AOF延迟标志位，如果为1，则有AOF操作被延迟</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_shceduled;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由<code>aof_rewrite_shceduled</code>标志位决定，如果处于BGSAVE命令执行期间，BGREWRITEAOF会被延迟到BGSAVE执行后执行。</p><p><strong>检查持久化操作的运行状态</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行BGSAVE命令的子进程，没有为-1</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;</span><br><span class="line">    <span class="comment">//执行BGREWRITEAOF命令的子进程，没有为-1</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rdb_child_pid</code>和<code>aof_child_pid</code>只要<strong>一个不为-1</strong>，则检查子进程是否有信号发来。如果有信号到达则进行后续操作，比如新<strong>RDB文件的替换，重写的AOF文件替换</strong>等。</p><p>如果<code>rdb_child_pid</code>和<code>aof_child_pid</code><strong>都为-1</strong>，则进行检查：</p><ul><li>是否有BGREWRITEAOF被延迟，有的话就进行BGREWRITEAOF操作。</li><li>自动保存条件是否满足，满足且未执行其他持久化操作则执行BGSAVE。</li><li>AOF重写条件是否满足，满足且未执行其他持久化操作则开始一次新的BGREWRITEAOF操作。</li></ul><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150971.jpg" alt="img"></p><h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>当服务器同时存在时间事件和文件事件，调度时该如何选择，花费多久？</p><p>事件的调度由<code>ae.c/aeProcessEvents</code>函数负责。对于每一次事件循环，主要过程是：</p><ol><li>拿到最近的时间事件并计算还有多少毫秒。</li><li>创建时间任务结构；阻塞等待文件事件产生，最大阻塞时间<strong>由最近时间事件到达毫秒数决定</strong>。</li><li>先处理已产生的<strong>文件事件</strong>再处理到达的<strong>时间事件</strong>。</li></ol><p>执行原则/设计利弊：</p><ol><li>aeApiPoll函数（redis封装的多路复用函数）的最大阻塞时间由到达时间<strong>最接近当前时间的时间事件</strong>决定，这个方法既可以避免服务器对时间事件进行频繁的轮询(忙等待)，也可以确保aeApiPoll函数<strong>不会阻塞过长时间</strong>。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。</li><li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器,还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性</li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>本文第一章提到过Redis服务器的状态结构clients属性是<strong>链表</strong>，记录了所有与服务器相连的客户端结构，对客户端执行批量操作或查找操作，都可以通过clients链表完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clents</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端的属性主要分为通用和特定的，这里主要介绍通用的。简单来说有套接字描述符，标志，输入缓冲区，命令与参数，输出缓冲区，时间等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//标志</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="comment">//单个命令拆分的数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//argv数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    <span class="comment">//固定大小输出缓冲区，默认16K</span></span><br><span class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    <span class="comment">//buf已使用字节数</span></span><br><span class="line">    <span class="keyword">int</span> bufpos;</span><br><span class="line">    <span class="comment">//大小可变输出缓冲区</span></span><br><span class="line">    <span class="built_in">list</span> *reply</span><br><span class="line">    <span class="comment">//创建客户端的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="comment">//与服务器互动的最后时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="comment">//软性限制时间</span></span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    ...</span><br><span class="line">&#125;redis client;</span><br></pre></td></tr></table></figure><p><strong>套接字描述符fd</strong></p><p>根据客户端类型不同：</p><ul><li>fd为-1表示伪客户端。</li><li>fd为大于-1的整数时表示普通客户端。</li></ul><p>伪客户端就是用于处理的命令请求来源于AOF或Lua脚本，不需要套接字连接，也就不需要套接字记录符。普通客户端就是所有来源于网络需要套接字连接的客户端。</p><p><strong>标志flags</strong></p><p>标志flags记录了客户端的角色。有主从标志，Lua伪客户端标志，执行MONITOR标志…标志可以以二进制来拼接：flags:<flag1>|<flag2>|<flag3>…</p><p><strong>输入缓冲区querybuf</strong></p><p>输入缓冲区存储客户端输入的指令，大小根据输入内容动态缩小扩大，最大不可超过1G，否则导致服务器关闭该客户端。</p><p><strong>命令与参数(argv，argc）</strong></p><p>在将客户端输入的命令保存到querybuf后，服务器将对命令进行解析，并将得到的命令参数以及命令参数的个数存放到数组argv和整数argc中，其数据结构是这样的：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150757.jpg" alt="img"></p><blockquote><p>当客户端输入命令后，服务器根据argv[0]的值在命令表中查找（命令不区分大小写）对应命令的函数并给cmd赋值，cmd就是对应的命令函数相关的操作信息。</p><p>命令表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令的redisCommand结构，这个结构保存了命令的实现函数、命令的标志、命令需要的参数个数以及总执行次数和总消耗时长等统计信息。</p></blockquote><p><strong>输出缓冲区（buf，bufpos，reply）</strong></p><p>输出缓冲区有两个，一个大小固定，一个大小可变。大小固定的存储长度小的回复，比如OK，错误返回等。大小可变缓冲区保存长度较大的回复，比如长列表，大集合。</p><p>大小可变缓冲区由reply链表实现，利用链表结构存储若干和字符串对象，使得长度不会受到限制。</p><p>其数据结构如下：</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150003.png" alt="image-20220104200809219" style="zoom:30%;" /><p><strong>时间（ctime，lastinteraction，obuf_soft_limit_reached_time）</strong></p><ul><li>ctime属性记录了创建客户端的事件</li><li>lastinteraction属性记录了客户端与服务器最后一次进行互动的事件</li><li>obuf_soft_limit_reached_time记录了输出缓冲区第一次到达软性限制的时间</li></ul><blockquote><p>服务器使用两种模式来限制客户端输出缓冲区的大小:</p><ul><li>硬性限制( hard limit):如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制(softlimit):软性限制比硬性限制小，服务器会根据输出缓冲区大小介于软硬性限制之间的时间决定是否关闭客户端 。</li></ul></blockquote><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><p>由于客户端有不同类型，所以创建和关闭的方式也不相同。</p><p><strong>创建普通客户端</strong></p><p>客户端连接时调用connect函数，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将该新的客户端状态添加到client链表末尾。</p><p><strong>关闭普通客户端</strong></p><p>普通客户端可因其中一个原因关闭：</p><ul><li>客户端进程退出或者被杀死</li><li>客户端向服务器发送了带有不符合协议格式的命令请求</li><li>客户端成为了CLIENT KILL命令的目标</li><li>用户为服务器设置了timeout配置选项且当客户端的空转时间超过timeout时。不过timeout选项有一些例外情况：若客户端是主服务器，从服务器，正在被BLPOP等命令阻塞，或正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小(默认为1GB)</li><li>输出缓冲区的大小超过了硬性限制所设置的大小</li><li>输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制的时间超过指定时间。</li></ul><p><strong>Lua脚本的伪客户端</strong></p><p>服务器初始化时创建，随服务器结束关闭。</p><p><strong>AOF文件的伪客户端</strong></p><p>载入AOF文件时创建，载入结束关闭。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>简而言之，这章就是在解释客户端<strong>输入Redis指令到返回结果的执行过程</strong>。</p><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>首先是Redis服务器初始化操作，服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ol><li>初始化服务器状态。</li><li>载入服务器配置。</li><li>初始化服务器数据结构。</li><li>还原数据库状态。</li><li>执行事件循环。</li></ol><p><strong>初始化服务器状态结构</strong></p><p>主要是对redisServer结构体的初始化，包括设置服务器运行ID，运行频率，设置配置文件路径，设置持久化条件，命令表创建等。</p><p><strong>载入配置选项</strong></p><p>根据用户设定的配置，对redisServer相关变量的值进行修改，比如端口号，数据库数量，RDB的压缩是否开启等等。其他属性还是沿用默认值。</p><p><strong>初始化服务器数据结构</strong></p><p>对除了命令表外的数据结构（包括客户端链表，db数组，订阅信息，Lua脚本执行环境，慢查询日志相关属性等等）进行初始化。</p><blockquote><p>服务器必须先载入用户配置，才能对其他数据结构进行准确初始化。否则，若是先初始化再根据用户配置设定相关值，那么若是用户配置的值和默认值不同，且该配置和数据结构有关，那么服务器就要重新调整和修改已创建的数据结构。这样就会比较麻烦。</p></blockquote><p><strong>还原数据库状态</strong></p><p>载入RDB或AOF文件的数据恢复过程。</p><p><strong>执行事件循环</strong></p><p>至此，服务器可接收客户端请求并发送信息。</p><h3 id="命令执行过程"><a href="#命令执行过程" class="headerlink" title="命令执行过程"></a>命令执行过程</h3><p>以<code>SET key value</code>为例，命令的执行过程是：</p><ol><li>客户端发送命令。</li><li>服务器接收并处理请求，对数据库操作，回复OK。</li><li>服务器将命令回复OK返回给给客户端。</li><li>客户端接收命令并打印结果。</li></ol><p>下面将按照步骤拆解为发送，读取查找，执行预备操作，调用实现函数，执行后续工作，回复，打印操作讲解。</p><p><strong>发送</strong></p><p>客户端接收命令请求时，会将命令根据协议转为固定格式再发送给服务器。</p><p><strong>读取</strong></p><p>当套接字因客户端的写入变得可读时，服务器会先读取协议格式内容并保存到输入缓冲区。命令分析，提取参数及个数，存入argv和argc属性。最后调用命令执行器。</p><p><strong>命令执行器-查找命令的实现</strong></p><p>命令表是一个<strong>字典</strong>，键是命令名字，值是redisCommand结构。几个重要属性如下：</p><ul><li>name：命令名称。</li><li>proc：指向命令实现函数。</li><li>arity：命令参数个数，包括命令名称。</li><li>sflags：命令属性。</li></ul><p>查找命令表的过程就是找到redisCommand，把指针指向它：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150982.jpg" alt="img"></p><p><strong>命令执行器-执行预备操作</strong></p><p>在命令真正执行前需要有预备操作保证命令可以被正确，顺利地执行。这个环节相当于一层过滤，比如检查命令是否正确，参数是否正确，身份验证是否通过，内存是否够用等等。保证配置生效，准确执行。</p><p><strong>命令执行器-调用命令的实现函数</strong></p><p>执行过程就是调用之前找到并指向的执行函数。通过client-&gt;cmd-&gt;proc(client);调用。然后将回复保存在客户端状态的输出缓冲区中，关联该套接字的命令回复处理器。</p><p><strong>命令执行器-执行后续工作</strong></p><p>有一些善后工作还将继续，比如慢查询日志记录，执行时长记录，AOF持久化，主服务器将命令传给从服务器。当这些都处理完后，服务器就继续从文件事件处理器中取出并执行下一个命令请求。</p><p><strong>将命令回复发送给客户端</strong></p><p>当客户端套接字变为可写状态，服务器执行命令回复处理器，将输出缓冲区的回复发送给客户端。</p><p><strong>客户端接收并打印命令回复</strong></p><p>将回复转为人类可读的格式，打印给用户看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库章节主要介绍键值对的宏观存储是怎么实现的和过期策略。通过RedisServer进行组织，用<strong>字典存键值对</strong>，具体数据结构<strong>按照对象的编码存储</strong>。客户端与服务器主要通过<strong>共享指针</strong>的方式来共享库对象。键的过期时间是按照单独的键过期字典存储的，设置过期时间的命令<strong>都会转换为PEXPIREAT</strong>来实现。Redis使用<strong>惰性删除</strong>和<strong>定期删除</strong>作为移除策略。每次对键的读取都会判断是否过期，定期抽查并删除过期键。</p><p>RDB持久化章节主要介绍持久化机制和发生时机，BGSAVE指令对其他指令的<strong>排斥性</strong>，RDB文件结构。RDB文件载入时，主服务器会<strong>检查键是否过期</strong>。RDB的实现分为SAVE和BGSAVE，<strong>SAVE会阻塞</strong>，BGSAVE是通过fork子进程来写RDB文件的方式，来记录Redis的数据库快照。BGSAVE随着serverCron函数的执行，每次都会判断是否有必要执行。</p><p>AOF持久化章节主要介绍持久化机制，时机，重写过程。AOF文件<strong>载入时不会判断键是否过期</strong>，只是执行文件中的命令。AOF开启后，执行一个写命令就会被<strong>追加到aof_buf</strong>中。AOF持久化过程是根据其同步策略配置，一次事件循环，一定会将aof_buf中的命令写到操作系统缓冲区，在根据配置考虑是否需要<strong>强制写入磁盘</strong>。AOF重写是对文件的瘦身计划，为了解决子进程执行AOF文件重写前后数据库状态不一致的问题，AOF重写缓冲区会<strong>记录在这期间对数据库的变更</strong>，子进程结束后<strong>发信号</strong>，主进程接收后会<strong>进入阻塞阶段</strong>，同步重写缓冲区至新的AOF文件。</p><p>事件章节主要介绍文件事件和时间事件。文件时间是<strong>对套接字操作</strong>的事件，时间事件是<strong>对定时操作</strong>相关的事件。文件事件利用I/O多路复用程序<strong>监听多个套接字</strong>，根据相应的<strong>可读/可写事件</strong>来触发并移交给文件事件分派器，分派器会给具体的<strong>事件处理器处理</strong>。然后介绍了时间事件的组成，serverCron的职能，主要负责对资源的检查，更新，判断操作。对于两种事件同时出现情况的处理机制，利用<strong>等待时间事件的空隙</strong>作为文件事件的最大阻塞时间，然后先处理随机的文件事件，再处理时间事件。不浪费CPU资源，提高效率。</p><p>客户端章节主要介绍<strong>redisClient的属性</strong>，包括套接字描述符，输入缓冲区，时间等。然后介绍普通客户端的创建和关闭原因，是通过对应的事件处理器进行的。其他的伪客户端主要是AOF伪客户端按卸磨杀驴的套路，在载入时创建，载入结束后关闭。</p><p>服务器章节主要描述了Redi<strong>s一条指令的执行过</strong>程，从初始化到具体的过程细化，发送命令，读取命令，查找命令字典，执行预备操作，调用实现函数，善后工作，发送回复，客户端打印。</p>]]></content>
    
    
    <summary type="html">本文主要对redis单机数据库实现中涉及到的一些技术进行介绍，包括数据库的实现、数据持久化、事件的概念以及客户端和服务端的实现</summary>
    
    
    
    <category term="《Redis设计与实现》阅读笔记" scheme="https://icbtbo.github.io/categories/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://icbtbo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现:数据结构与对象</title>
    <link href="https://icbtbo.github.io/2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://icbtbo.github.io/2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-12-18T09:16:04.000Z</published>
    <updated>2022-03-23T11:35:49.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>redis3.0 标有注解的源码：<a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p></blockquote><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>Redis中，涉及可以被修改的字符串值时，都用<strong>简单动态字符串</strong>（simple dynamic string，SDS）来实现。比如包含字符串值的键值对在底层的实现。C字符串（C语言中传统字符串，以空字符串结尾的字符数组）则用于<strong>无须对字符串进行修改</strong>的地方，比如日志打印。</p><p>SDS还被用作缓冲区，比如AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。</p><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//buf已使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//buf未使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf遵循C字符串以空字符串结尾的惯例，保存空字符串的1字节空间不计算在SDS的len属性里面，并为空字符分配<strong>额外1字节</strong>空间，对用户来说是透明的。</p><p>SDS结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182029378.jpg" alt="img"></p><p>图中展示了SDS的数据结构，5字节未使用空间，已使用5字节，buf存储了字符串值，最后一个字节保存了空字符<code>&#39;\0&#39;</code>。这里要注意的是，free和len的计算不涉及空字符。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><ol><li>SDS有<strong>常数级的时间复杂度</strong>获取字符串长度。<br>由于C字符串不会记录自身长度，因此只能遍历，直到遇到结尾的空字符为止,时间复杂度为O(N)。而SDS对于字符串长度的记录都是在其API中执行的，所以时间复杂度为**O(1)**。</li><li>SDS<strong>杜绝缓冲区溢出。</strong><br>由于C字符串未记录自身长度，容易导致缓冲区溢出。在执行字符串拼接时，如果没有足够的空间，并且相邻内存地址被其他字符串占用时，字符串的<strong>数据将溢出</strong>，且容易<strong>意外修改相邻的字符串内容</strong>。相比而言，SDS会将这种情况扼杀在摇篮之中，SDS API先判断<strong>空间是否满足</strong>，如果不满足则将空间<strong>扩展至执行修改所需的大小</strong>。</li><li>SDS拥有的<strong>内存分配策略</strong>可以减少修改字符串造成的内存重分配次数，详见1.3。</li><li>SDS API都是<strong>二进制安全</strong>的。<br>C字符串的字符<strong>必须符合某种编码</strong>，并且中间<strong>不能</strong>有空字符，否则读取时会被误以为是字符串结尾。种种局限使得C字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保Redis对不同使用场景的支持，SDS API都是二进制安全的，也就是所有SDS API都会以<strong>二进制的方式</strong>存取buf中的数据，数据的写入和读出都是一个样的。由于SDS读取时并不是依靠空字符来判断结束的，而是<strong>len属性</strong>，所以是二进制安全的。</li><li><strong>兼容部分C字符串函数</strong>。<br> SDS虽然都是二进制安全的，但也<strong>遵循以空字符结尾</strong>的习惯。SDS API总会在buf数组分配空间时多分配一个字节用于容纳空字符，这是为了保存文本的SDS<strong>重用一部分</strong>&lt;string.h&gt;库函数，避免代码重复。</li></ol><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>由于C字符并<strong>不记录</strong>自身长度，并且需要一个字符空间保存空字符串，因此每次增长或缩短字符串时，就要对其进行一次<strong>内存重分配</strong>操作。增长字符串时要看空间是否够用，否则会有<strong>缓冲区溢出</strong>；缩短字符串要释放不用的空间，否则会有<strong>内存泄漏</strong>。</p><p>Redis经常被用于速度要求严苛，数据被频繁修改的场合，每次修改字符串都要重新分配内存，就会占用很多时间。为避免这个问题，redis采用了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略。</p><p><strong>空间预分配</strong></p><p>空间预分配用于优化SDS字符串<strong>增长操作</strong>。在扩展SDS空间前，SDS API会先检查未使用空间够不够，如果不够，则进行空间预分配。此时，程序<strong>不仅会为SDS分配修改所必须要的空间，还为其分配额外未使用的空间</strong>。 </p><ul><li>修改后的SDS&lt;1MB，程序分配和len属性<strong>同样大小</strong>的未使用空间，此时SDS的len与free大小相等。比如修改后实际存储字符串的空间变为13字节，那么len=13，free=13，buf数组整体的长度=13+13+1（额外1字节保存空字符）。</li><li>修改后SDS&gt;=1MB。程序会分配<strong>1MB</strong>的未使用空间。比如修改后实际存储字符串的空间变为2MB，那么len=2M，free=1MB，buf数组整体的长度=2MB+1MB+1byte。</li></ul><p>通过空间的预分配，将<strong>连续增长N次字符串需要的内存分配次数从一定需要N次变为最多N次</strong>。因而可以减少连续执行字符串增长操作所需的内存重分配的次数。</p><p><strong>惰性空间释放</strong></p><p>惰性空间的释放用于优化SDS字符串<strong>缩短操作</strong>。当SDS API需要缩短保存的字符串时，程序并不立即回收这部分内存，而是使用free属性将字节的数量记录，等待使用。与此同时，SDS提供了相关API，在有需要时，<strong>真正释放</strong>未使用空间，不需要担心惰性空间造成的内存浪费。</p><h3 id="SDS总结"><a href="#SDS总结" class="headerlink" title="SDS总结"></a>SDS总结</h3><p>C字符串与SDS的区别简单来说：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182030627.png" alt="image-20211218194706398" style="zoom:75%;" /><p>SDS相关操作及时间复杂度：</p> <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182030423.png" alt="image-20211218203032217" style="zoom:75%;" /><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>当一个列表键包含了数量比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>节点由前驱后继组成，多个节点组成的链表为双端链表。</p><p>使用<code>adlist.h/list</code>来持有，操作链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>整个链表串起来后，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182105328.png" alt="image-20211218210534199"></p><p>Redis的链表特性可以总结如下：</p><p><strong>双端</strong>：链表节点带有prev和next指针，获取前置和后置节点的复杂度都是O(1)。<br><strong>无环</strong>：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。 带表头指针和表尾指针 带链表长度计数器 。<br><strong>头尾指针</strong>：将程序获取头尾节点的复杂度降为O(1)。<br><strong>长度计数器</strong>：将程序获取表长的复杂度降为O(1)。<br><strong>多态</strong>：链表节点使用void*指针来保存节点值，并且可以通过list结构的<code>dup、free、match</code>为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p><h3 id="链表时间复杂度"><a href="#链表时间复杂度" class="headerlink" title="链表时间复杂度"></a>链表时间复杂度</h3><p>链表相关操作及时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182106389.png" alt="image-20211218210638244" style="zoom:75%;" /> <h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典又称<strong>符号表</strong>，<strong>关联数组</strong>或<strong>映射</strong>，用于保存键值对的抽象数据结构。当一个哈希键包含的键值对比较多时，或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个哈希表节点</strong>，每个哈希表节点保存了字典中的<strong>一个键值对</strong>。</p><p><strong>哈希表</strong></p><p>使用<code>dict.h/dictht</code>结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><p>数组中的每个元素都是指向<code>dict.h/dictht</code>的结构，dictEntry就是一个键值对。</p><p><strong>哈希表节点</strong></p><p>哈希表节点使用dictEntry实现，每个dictEntry都存储着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>键值对的值可以是一个指针，或一个<code>uint64_t</code>整数，或一个<code>int64_t</code>整数。next是<strong>指向另一个哈希节点的指针</strong>，可将多个<strong>哈希值相同的键值对连接在一起</strong>，以此来解决冲突。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182112502.png" alt="image-20211218211218390"></p><p>如图，表示的是两个哈希值相同的节点，通过指针连接在一起。</p><p><strong>字典</strong></p><p>Redis中的字典由<code>dict.h/dict</code>实现，由这个数据结构将字典组织在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type和privdata属性是<strong>针对不同类型</strong>的键值对，为丰富键值对的使用场景而设置的。</p><ul><li>type属性是一个指向dictType的结构指针，每个dictType结构保存了一簇用于<strong>操作特定类型键值对的函数</strong>，Redis为用途不同的字典设置不同类型特定函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li><li>ht属性是包含<strong>两个项</strong>的数组，每项都是一个哈希表，ht[0]平时使用，而ht[1]仅在rehash时使用。</li><li>rehashidx记录了rehash的进度，初始为-1。</li></ul><p>下图展示了一个普通状态下（没有进行rehash）的字典：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182135997.png" alt="image-20211218212233398"></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>Redis计算哈希值方法： <code>hash=dict-&gt;type-&gt;hashFunction(key);</code><br>计算索引值的方法：<code>index=hash &amp; dict-&gt;ht[x].sizemask;</code> </p><p>当字典被用作数据库的底层实现或哈希键的底层实现时，Redis使用<strong>MurmurHash2算法</strong>来计算键的哈希值。优点在于即使输入的键是有规律的，算法仍然能给出<strong>很好的随机分布性</strong>，并且计算<strong>速度飞快</strong>。</p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上的键被分配到哈希表的<strong>同个索引</strong>，那么就发生了冲突。Redis使用链地址法来解决冲突，被分配到相同索引的多个节点<strong>使用链表连接</strong>。为了提高速度，每次都是将新节点添加到链表的<strong>表头</strong>位置。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>为了让哈希表的负载因子维持在一个<strong>合理的范围内</strong>，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行响应的扩容或缩容。扩容和缩容通过执行rehash来完成，Redis中<strong>重新散列的步骤</strong>如下：</p><ol><li>为字典ht[1]哈希表<strong>分配空间</strong>，大小取决于要执行的操作与ht[0]<strong>当前键值对的数量</strong>。</li><li>将保存在ht[0]中的所有键值对存放到ht[1]指定的位置</li><li>当ht[0]的所有键值对都迁移完毕后，<strong>释放ht[0]**，并</strong>指向ht[1]**，并在ht[1]上创建一个空的哈希表，为下次rehash准备。</li></ol><p><strong>扩容与缩容场景</strong></p><p>扩容操作场景：</p><ul><li>服务器目前没有在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子&gt;=1</strong>。</li><li>服务器正在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子&gt;=5</strong>。</li></ul><p>负载因子=哈希表已存储节点数/哈希表大小， 即 <code>load_factor=ht[0].used/ht[0].size</code> </p><blockquote><p>为什么根据**<code>BGSAVE</code><strong>命令或</strong><code>BGREWRITEAOF</code><strong>命令来判断是否扩展？<br>因为执行这些命令时，Redis需要创建当前服务器进程的</strong>子进程<strong>，大多数操作系统采用</strong>写时复制技术**来优化子进程使用效率，此时提高负载因子，可以尽量避免在子进程存在期间对哈希表扩展，避免不必要的内存写入操作，节约内存。</p></blockquote><p>缩容操作场景：</p><p><strong>负载因子&lt;0.1</strong>时，<strong>自动</strong>对哈希表执行收缩操作。</p><h3 id="渐进式rehash的过程"><a href="#渐进式rehash的过程" class="headerlink" title="渐进式rehash的过程"></a>渐进式rehash的过程</h3><p>rehash时会将ht[0]中所有的键值对rehash到ht[1]，如果键值对很多并且一次性操作的话，容易导致服务器在<strong>一段时间内停止服务</strong>。为避免这种情况，Redis采用渐进式rehash，将ht[0]中的键值对分多次，<strong>慢慢地rehash</strong>到ht[1]之中。</p><p>步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有两个哈希表。</li><li>在字典中维持一个<strong>索引计数器变量rehashidx</strong>，将其设置为0，表示rehash正式开始。</li><li>在rehash进行期间，每次对字典进行<strong>添加，删除，查找或更新</strong>操作时，程序除了执行指定的操作外，还会将ht[0]哈希表在rehashidx索引上的所有键值对**rehash到ht[1]**，当rehash工作完成后，将rehashidx++。</li><li>某个时刻，ht[0]中的所有键值对都被rehash至ht[1]，此时设置rehashidx=-1时，表示rehash操作已经完成。</li></ol><p>这种方式的rehash的好处在于采用了分而治之的方式，将rehash键值对所需的<strong>计算工作均摊到对字典的每个操作中</strong>，从而避免集中式rehash带来庞大计算量。</p><p>在rehash的期间，字典<strong>同时使用</strong>ht[0]，ht[1]两个哈希表。对哈希表的操作会在两个表上进行，比如查找键时，<strong>先在ht[0]里面查找</strong>，如果为空，就<strong>继续到ht[1]里查找</strong>。在此期间，新增的键值对<strong>都会被添加到ht[1]**中，ht[0]**不承担任何添加</strong>操作，保证ht[0]中的键值对只能是<strong>越来越少</strong>。</p><h3 id="字典时间复杂度"><a href="#字典时间复杂度" class="headerlink" title="字典时间复杂度"></a>字典时间复杂度</h3><p>字典相关操作及时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182114711.png" alt="image-20211218211457606" style="zoom:75%;" /> <h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是一种<strong>有序</strong>的数据结构，通过在每个节点<strong>维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。</p><p>如果一个有序集合中包含的元素数量比较多，又或者有序集合中元素的成员是较长的字符串，Redis就会使用跳跃表来作为有序集合键的底层实现。Redis只有在两个地方用到了跳跃表，一个是实现<strong>有序集合键</strong>，另一个是在<strong>集群节点中</strong>作为内部数据结构。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个数据结构定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    structz zskiplistNode *header,* tail;</span><br><span class="line">    <span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳跃表由zskiplist组织，通过多个跳跃表节点zskiplistNode组成一个跳跃表。值得注意的是，记录level时，表头节点的层高不会记录在内。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201044622.png" alt="image"></p><p><strong>跳跃表节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> strct zskiplistNode&#123;</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistlevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ol><li><p>层–level</p><p>跳跃表的每个节点都会包含多个层，每次创建一个新跳跃表节点时，都会根据<strong>幂次定律</strong>，随机生成一个1~32之间的数作为层的大小。每个层都会包含前进指针和跨度。</p><p>前进指针（forword）用于访问下一个节点。跨度表示<strong>两个节点之间的距离</strong>，指向NULL的所有前进指针的<strong>跨度为0</strong>。跨度用于计算排位，访问某一结点的经过的<strong>跨度之和</strong>就是当前节点的排位。</p><p>注：幂次定律也是80-20法则。最重要的只占一小部分，越大的数出现的概率越小。Redis中对level的随机获取实现是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>后退指针–backward</p><p>用于从表尾向表头方向访问节点，<strong>前进指针可以一次跳过多个节点</strong>，后退指针<strong>只能后退至前一个</strong>节点，因为每个节点只有一个后退指针。</p></li><li><p>分值–score</p><p>分值是一个<strong>double类型的浮点数</strong>，跳跃表中节点都按照分值排序。</p></li><li><p>成员对象–obj</p><p>是一个指针，指向字符串<strong>SDS对象</strong>。一个跳跃表中，<strong>对象必须是唯一的，但分值可以相同</strong>。相同时按对象字典序来排序。</p></li></ol><blockquote><p><strong>思考</strong></p><p>我看代码的时候就有个疑问，书上也没有给出清晰的解释，通过看帖子和自己的理解总结了一下。Redis的level个数为什么要<strong>用幂次定律生成（随机生成节点的层数）</strong>？</p><p>通过幂次定律能保证越高level的结点数量越少 。保证索引等级越高，<strong>参与索引建立的元素越少</strong>，如果每层都有很多level，那么这个索引建立的就没有意义了。那么，为什么不用最均衡的方式，按照节点分数的排序情况均匀建立索引？考虑到下一个插入的元素<strong>具有随机性</strong>，这样设计<strong>不容易出现最坏的情况</strong>。如果每次都以均匀固定的方式建索引，<strong>维护的成本很高</strong>，跳跃表的优点就是维持结构平衡的成本低，完全依靠随机。跳跃表相比二叉树有一个优势就在于<strong>不需要主动rebalance</strong>去维护平衡。</p></blockquote><h3 id="跳跃表的操作"><a href="#跳跃表的操作" class="headerlink" title="跳跃表的操作"></a>跳跃表的操作</h3><p><strong>插入</strong></p><p>初始跳跃表如下图：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201044473.jpg" alt="img" style="zoom:67%;" /><p>插入11.0，随机层数为2。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201045619.jpg" alt="img" style="zoom:67%;" /><p>观察可知，插入操作仅新增节点和指针变化，不需要对整体的平衡进行额外维护操作。</p><p><strong>查找</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201045390.jpg" alt="img" style="zoom:67%;" /><p>跳跃表查找10的过程如上图，由于数字标注的是<strong>查找顺序</strong>，所以不标注跨度以免引起歧义。此时跳跃表查找10，会先从header节点（O1）的最高层（L3）寻找，发现要查找的数小于23.5则返回，继续从下一个有后继的层开始寻找，当发现要查找的数小于11.0时，则从O1的下一层找，此时到O2的L1，发现要查找的数大于7.0，则从L1找，直到查找到相邻节点为止。</p><p><strong>删除</strong></p><p>节点的删除操作比较简单，查找到要删除的节点后，再处理好前后节点的前驱后继就可以啦~</p><p>拓展阅读：<a href="https://zhuanlan.zhihu.com/p/109946103">https://zhuanlan.zhihu.com/p/109946103</a></p><h3 id="跳跃表的时间复杂度"><a href="#跳跃表的时间复杂度" class="headerlink" title="跳跃表的时间复杂度"></a>跳跃表的时间复杂度</h3><p>跳跃表相关操作及时间复杂度：</p> <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201045658.png" alt="image-20211220102700170" style="zoom:75%;" /><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>当一个集合只包含整数元素，并且元素不多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合是Redis中用于保存整数值的集合<strong>抽象数据结构</strong>，可以保证集合<strong>有序不重复</strong>。每个<code>intset.h/intset</code>结构来表示一个整数集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>length属性记录了整数集合包含的元素数量，contents是整数集合的底层实现。contents存储元素的真实类型<strong>取决于encoding</strong>，比如<code>encoding==INT_ENC_INT16</code>时，contents数组中每个向都是int16_t类型的整数。可以为<code>int16_t</code>,<code>int32_t</code>或<code>int64_t</code>。</p><p>下图展示了整数集合的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201102377.png" alt="image-20211220110233149"></p><p><strong>升级</strong></p><p>当我们要将一个新元素添加至集合时，并且新元素的类型<strong>比现有集合类型都长</strong>时，整数集合就要升级。</p><p>步骤：</p><ol><li>根据新元素类型，<strong>扩展</strong>数组空间，并为新元素分配空间。</li><li>将底层数组现有所有元素<strong>都转为新元素相同类型</strong>，并将类型转换后的元素放到正确位置。</li><li>将新元素<strong>添加</strong>到底层数组。</li></ol><p>由于每次向整数集合添加新元素都<strong>可能会引起升级</strong>，而每次升级都需要对底层数组中已有元素进行类型转换，所以添加的**时间复杂度为O(N)**。</p><p><strong>升级的好处</strong></p><p>有两个好处，可以提升整数集合的<strong>灵活性</strong>，也能尽可能地<strong>节约内存</strong>。<br>C语言是静态类型语言，一般数组中的元素类型都相同，使用升级可以<strong>不用担心类型兼容</strong>问题，提升灵活性。元素统一以最大类型存储，而不是都用<code>int64_t</code>，可节约内存。</p><p><strong>降级</strong></p><p>整数集合<strong>不支持降低</strong>，一旦升级就不能降级。</p><h3 id="整数集合的时间复杂度"><a href="#整数集合的时间复杂度" class="headerlink" title="整数集合的时间复杂度"></a>整数集合的时间复杂度</h3><p>整数集合相关操作及时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201106980.png" alt="image-20211220110628831" style="zoom:75%;" /> <h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表是<strong>列表键、哈希键和有序集合键</strong>底层实现之一。当一个列表键只包含少量列表项，且每个列表项要么是小整数，要么是长度比较短的字符串，Redis就使用压缩列表来做列表键的底层实现。哈希键和有序集合键也类似。</p><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>为节约内存而开发的，由一系列<strong>特殊编码</strong>的<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构。</p><p>下图为压缩列表的数据结构:</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201119209.png" alt="image-20211220111940022"></p><p>结构比较简单，属性如下：</p><ul><li>zlbytes：记录整个压缩列表占用<strong>内存字节数</strong>，进行内存重分配或计算zlend时使用。</li><li>zltail：记录压缩列表尾节点<strong>距离压缩列表起始地址</strong>多少字节。</li><li>zllen：节点数量。小于65535时，表示<strong>节点数量</strong>；等于时，需要<strong>遍历</strong>才能计算得出。</li><li>entryx：列表节点。</li><li>zlend：特殊值0xFF用于<strong>标记压缩列表的末端</strong>。</li></ul><h3 id="压缩列表节点的组成"><a href="#压缩列表节点的组成" class="headerlink" title="压缩列表节点的组成"></a>压缩列表节点的组成</h3><p>每个压缩列表节点可以是一个<strong>字节数组</strong>，也可以是一个<strong>整数</strong>。由<code>previous_entry_length，encoding，content</code>组成。</p><p><strong>previous_entry_length</strong></p><p>单位是字节，记录压缩列表<strong>前一个节点的长度</strong>。该属性长度为<strong>1字节或5字节</strong>，前<strong>两位</strong>表示该属性长度为1字节还是5字节。</p><ul><li>前一个节点的长度&lt;254字节时，该属性只有<strong>1字节</strong>，且前一节点的长度就保存在这一个字节。如0x05，表示前一个字节长度为5字节。</li><li>前一个节点的长度&gt;=254字节时，该属性有<strong>5字节</strong>，且该属性的第一字节会被设置成0xFE，表示这是一个5字节的长度，后4字节表示前一个节点的长度。如0xFE00002766，表示前一个字节长度为0x00002766，换算为10进制就是我们熟悉的数字。</li></ul><p><strong>encoding</strong></p><p>encoding记录了节点的content属性所保存<strong>数据类型</strong>和<strong>长度</strong>。<strong>高两位</strong>表示存储的是字节数组还是整数。</p><p><strong>content</strong></p><p>存储节点的值。</p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>当<strong>多个连续</strong>的长度<strong>介于250字节到253字节</strong>之间的节点，插入新的头节点（长度大于等于254字节），后面节点的previous_entry_length就要新增4字节的空间（1字节变成5字节），需要进行<strong>内存重分配</strong>，由于前一个节点的变更，每个节点的previous_entry_length属性<strong>也需要记录之前的长度而发生相应的变更</strong>，所以会出现连锁更新。除了新增节点，删除节点也可能会遇到这种情况。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行<strong>N次空间重分配操作</strong>，每次<strong>重分配的的最坏时间复杂度</strong>为 <img src="https://www.zhihu.com/equation?tex=O(N)" alt="[公式]"> ，所以连锁更新的<strong>最坏时间复杂度为</strong> <img src="https://www.zhihu.com/equation?tex=O(N%5E2)" alt="[公式]"> </p><p>虽然代价很高，但是出现的<strong>几率比较低</strong>，而且只要更新节点的数量不多，就不会对性能产生影响。因此ziplistPush命令的<strong>平均复杂度为</strong> <img src="https://www.zhihu.com/equation?tex=O(N)" alt="[公式]"> 。</p><h3 id="压缩列表的时间复杂度"><a href="#压缩列表的时间复杂度" class="headerlink" title="压缩列表的时间复杂度"></a>压缩列表的时间复杂度</h3><p>压缩列表相关操作及时间复杂度：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201129046.png" alt="image-20211220112937849"> </p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis<strong>没有直接使用</strong>前文的数据结构来实现键值对数据库，而是基于这些数据结构构建了一个对象系统，通过对象组织数据结构，包括<strong>字符串对象，列表对象，哈希对象，集合对象</strong>和<strong>有序集合对象这</strong>5种对象。</p><p>使用对象的一个好处是可以针对不同的使用场景，为对象<strong>设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率。</p><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p>Redis使用对象来表示数据库的键和值。每个对象都是一个redisObject结构，是一个按照位段存储的结构，节约内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type :<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>其中，type是类型常量，记录对象的类型：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%5Bb%5D+%7B%7Cc%7Cc%7C%7D++%5Chline+%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F&+%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E5%AD%97%5C%5C++%5Chline+REDIS%5C_String++&+%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1+%5C%5C++%5Chline+REDIS%5C_List&+%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1+%5C%5C++%5Chline+REDIS%5C_HASH++&%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1+%5C%5C+++%5Chline+REDIS%5C_SET++&+%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1+%5C%5C+++%5Chline+REDIS%5C_ZSET++&+%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1+%5C%5C++%5Chline+%5Cend%7Barray%7D%5C%5C" alt="[公式]"> </p><p>encoding记录对象使用的编码，即对象底层使用的具体数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936332.jpg" alt="img"></p><p>使用object encoding命令可以查看键的值对象的编码，每个对象都至少使用两种不同编码常量：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936516.jpg" alt="img"></p><blockquote><p>注：Redis中的列表对象在版本3.2之前，列表底层的编码是ziplist和linkedlist实现的，但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</p></blockquote><p>Redis对象采用<strong>encoding属性来设置编码</strong>，从而<strong>决定底层数据结构</strong>，而不是为特定类型的对象关联一种固定编码。这种方式极大地提高了灵活性和效率。</p><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象可以是<strong>int，raw</strong>或<strong>embstr</strong>。 </p><ul><li>如果字符串对象保存的是<strong>整数值</strong>，且这个数值<strong>可用long</strong>表示，底层就会以**<code>REDIS_ENCODING_INT</code>**编码来实现。</li><li> 如果字符串对象是一个字符串值，且这个字符串长度**&gt;32字节<strong>，字符串将使用一个SDS保存，底层编码为</strong><code>REDIS_ENCODING_RAW</code>**。 </li><li>如果字符串对象保存的是字符串，且这个字符串长度**&lt;=32字节<strong>，底层编码就是</strong><code>REDIS_ENCODING_EMBSTR</code>**，使用embstr编码的方式保存字符串。</li></ul><p>下图为raw编码的字符串对象：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936272.jpg" alt="img"></p><p><strong>embstr编码</strong></p><p>专门用于保存短字符串的一种优化编码方式，与raw的效果相同，都使用redisObject和sdshdr结构来表示字符串对象，但是raw会调用两次内存分配函数<strong>分别创建</strong>redisObject和sdshdr结构。embstr编码则通过调用<strong>一次内存分配</strong>函数来分配一块连续空间，空间依次包括redisObject和sdshdr俩结构。</p><p>使用embstr编码保存短字符串的<strong>优点</strong>：</p><ul><li>内存分配次数由两次降为<strong>1次</strong>。</li><li>释放embstr字符串对象只需调用<strong>1次</strong>内存释放函数。</li><li>embstr字符串放在一块连续的内存中，能更好地<strong>利用缓存</strong>带来的优势.</li></ul><p>注：<strong>浮点数</strong>的存储，在Redis底层也会以<strong>字符串的形式</strong>保存。在有需要时，程序会将字符串对象中的字符串值<strong>转为浮点数值</strong>执行运算操作，然后再将结果<strong>转为字符串值</strong>保存。</p><p><strong>编码的转换</strong></p><p><code>int-&gt;raw</code>：对int编码的字符串对象执行后，保存的不再是整数值，而是字符串值时，就会转换成raw编码的字符串。比如整数追加字符串。</p><p><code>embstr-&gt;raw</code>：Redis没有为embstr编写修改程序，所以是<strong>只读的</strong>，当embstr编码的字符串修改后，就变成raw编码的字符串对象。</p><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码是ziplist或linkedlist。</p><p>当列表可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都**&lt;64字节**</li><li>列表对象保存的元素数量**&lt;512个**</li></ul><p>否则使用linkedlist编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用ziplist编码，执行<code>RPUSH elements &quot;a&quot; &quot;b&quot; 1</code>，后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936647.jpg" alt="img"></p><p>使用linkedlist编码，执行<code>RPUSH elements &quot;a&quot; &quot;b&quot; 1</code>，后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936381.jpg" alt="img"></p><blockquote><p>注：SDS对象都<strong>以StringObject代替</strong>。</p></blockquote><blockquote><p><strong>注：Redis中的列表对象在版本3.2之前，列表底层的编码是ziplist和linkedlist实现的，但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</strong></p><p>quicklist的介绍可参考：<a href="https://juejin.cn/post/6844904023418486791">https://juejin.cn/post/6844904023418486791</a></p></blockquote><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或hashtable。</p><ul><li>ziplist的数据结构：每当有新的键值对插入哈希对象时，Redis会先将保存键的压缩列表节点推入表尾，再将保存值的压缩列表节点推入表尾。</li><li>hashtable的数据结构：字典的每个键都是一个字符串对象，保存键；字典的每个值都是字符串对象，保存值</li></ul><p>当哈希对象可以同时满足下两个条件时，使用<strong>ziplist编码</strong>：</p><ul><li>哈希对象保存的所有键值对的值和键<strong>都&lt;64字节</strong></li><li>哈希对象保存的键值对数量**&lt;512个**</li></ul><p>否则使用hashtable编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用<strong>ziplist</strong>编码，执行<code>HSET student name &quot;madongmei&quot; age 25 career &quot;pick up trash&quot;</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936878.jpg" alt="img"></p><p>使用<strong>hashtable</strong>编码，执行<code>HSET student name &quot;madongmei&quot; age 25 career &quot;pick up trash&quot;</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936135.jpg" alt="img"></p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset或hashtable。</p><p>如果以hashtable编码作为<strong>集合对象</strong>底层实现，那么字典的每个键都是一个<strong>字符串对象</strong>，值都是<strong>null</strong>。</p><p>当集合对象同时满足以下两个条件时，使用intset编码：</p><ul><li>集合对象保存的所有元素<strong>都是整数值</strong></li><li>集合对象保存的元素数量**&lt;=512个**</li></ul><p>否则使用hashtable编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用<strong>intset</strong>编码，执行<code>SADDnumbers 1 3 5</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937548.jpg" alt="img"></p><p>使用<strong>hashtable</strong>编码，执行<code>SADDnumbers 1 3 5</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937885.jpg" alt="img"></p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是ziplist或skiplist。</p><p>使用<strong>ziplist</strong>编码时，每个元素使用<strong>两个紧挨在一起的压缩列表节点</strong>来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937195.jpg" alt="img"></p><p>如果是<strong>skiplist</strong>编码，使用zset结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>dict字典为有序集合创建了一个从<strong>成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：键保存元素，值保存分值。通过字典以<strong>O(1)查找给定成员的分值</strong>。有序集合元素的成员都是<strong>字符串对象</strong>，分值都是<strong>double类型浮点数</strong>。zset的跳跃表和字典通过指针来<strong>共享相同元素</strong>的成员和分值，<strong>不会浪费</strong>额外内存。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937088.jpg" alt="img">当有序集</p><blockquote><p>上图中存在错误，应该是zsl指向跳表结构而不是由ptr指向</p></blockquote><p>合对象同时满足以下两条件时，对象使用ziplist编码：</p><ul><li>有序集合保存的元素数量**&lt;128个**</li><li>有序集合保存的所有元素成员的长度<strong>都&lt;64字节</strong></li></ul><p>否则使用skiplist编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><blockquote><p><strong>思考</strong></p><p>为什么有序集合需要<strong>同时使用跳跃表和字典</strong>来实现？</p><p>如果只使用字典存储，由于是无序的，所以每次在<strong>范围查询时</strong>，需要排序，<strong>时间复杂度为 <img src="https://www.zhihu.com/equation?tex=O(NlogN)" alt="[公式]"> 和额外 <img src="https://www.zhihu.com/equation?tex=O(N)" alt="[公式]"> 的内存空间</strong>，因为要创建一个数组存储排序后的元素。 如果只用跳跃表实现，根据成员<strong>查找分值时</strong>，<strong>复杂度将为 <img src="https://www.zhihu.com/equation?tex=O(logN)" alt="[公式]"></strong> 。综上，为了让有序集合的分值查找和范围查找都尽可能快地执行，Redis选择字典和跳跃表两种数据结构结合的方式。</p></blockquote><h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis中用于操作键的命令可分为两种类型。一种是可对<strong>任何类型执行</strong>的，如del，expire，rename等。另一种命令只能对<strong>特定类型的键执行</strong>，如set，get，hdel，hset，rpush等。如果对特定类型使用其他类型的命令，那么就会报错。</p><p><strong>类型检查的实现</strong></p><p>为了确保只有制定类型的键可以执行某些特定命令，在执行前，Redis会先通过输入键的值对象的<strong>type属性</strong>检查输入键的类型是否正确。</p><p><strong>多态命令的实现</strong></p><p>Redis除了根据值对象判断键是否能够执行特定命令外，还会根据<strong>值对象的编码方式</strong>，选择正确的命令实现代码来执行。比如基于编码的多态，列表对象的编码可能是ziplist或linkedlist，所以需要<strong>多态命令执行</strong>对应编码的API。基于类型的多态是<strong>一个命令可以同时处理多种不同类型的键</strong>。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>由于C语言没有内存回收机制，Redis在对象系统中构建了<strong>引用计数器技术</strong>实现内存回收机制。每个对象的引用计数器信息由redisObject的refcount来记录。当对象的引用计数值<strong>为0</strong>时，所占用的内存<strong>会被释放</strong>。</p><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>引用计数器还有共享对象的作用。如果两个不同键的值都一样（必须是整数值的字符串对象），则将数据库键的值指针<strong>指向一个现有的值对象</strong>，然后将被共享对象的引用计数加一。如果不是整数值的对象，则需要耗费大量的时间<strong>验证共享对象和目标对象是否相同</strong>，复杂度较高，消耗CPU时间，所以Redis<strong>不会共享包含字符串的对象</strong>。</p><p>Redis在初始化服务时，会创建很多字符串对象，包含0~9999的整数（和Integer的常量池有点像），当需要时，就能直接复用。</p><p>下图展示了键共享整数100的字符串对象：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937381.jpg" alt="img"></p><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>redisObject还包含了lru属性，记录对象最后一次被命令程序访问的时间。<code>object idletime</code>命令可打印键的空转时长，就是<strong>当前时间减去lru时间</strong>计算得到的。</p><blockquote><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/140726424">https://zhuanlan.zhihu.com/p/140726424</a></p></blockquote>]]></content>
    
    
    <summary type="html">本文主要介绍Redis的数据结构与对象部分。Redis以5大对象来满足键的数据结构：字符串对对象，列表对象，哈希对象，集合对象，有序集合对象。这些对象的底层实现依赖特定的编码类型，而某种编码类型又对应1种或多种数据结构。本文将分别介绍简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表这6种基本数据结构在Redis中的实现。</summary>
    
    
    
    <category term="《Redis设计与实现》阅读笔记" scheme="https://icbtbo.github.io/categories/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="redis" scheme="https://icbtbo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>kafka进阶篇：可靠性探究、应用、监控和高级应用</title>
    <link href="https://icbtbo.github.io/2021/11/25/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <id>https://icbtbo.github.io/2021/11/25/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</id>
    <published>2021-11-25T01:59:17.000Z</published>
    <updated>2022-03-23T07:29:37.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可靠性探究"><a href="#可靠性探究" class="headerlink" title="可靠性探究"></a>可靠性探究</h1><h2 id="副本剖析"><a href="#副本剖析" class="headerlink" title="副本剖析"></a>副本剖析</h2><h3 id="失效副本"><a href="#失效副本" class="headerlink" title="失效副本"></a>失效副本</h3><ul><li><p>同步失效或功能失效的副本成为失效副本，失效副本对应的分区成为同步失效分区（under-replicated）</p><ul><li><p>同步失效：根据broker参数 <code>replica.lag.time.max.ms</code> 作为标准，当ISR中的follower副本滞后leader副本的时间超过此时间则判定同步失败</p><blockquote><p>滞后时间 = now - lastCaughtUpTimeMs</p><p>当follower副本将leader副本LEO(LogEndOffset)之前的日志全部同步时，则认为该follower副本己经追赶上leader副本，此时更新该副本的lastCaughtUpTimeMs标识 </p></blockquote></li><li><p>功能失效：副本处于非存活状态，例如副本所在的broker节点被关闭</p></li></ul></li><li><p>如果通过工具增加了副本因子，那么新增加的副本在赶上leader副本之前也都是处于失效状态的。</p></li></ul><h3 id="ISR的伸缩"><a href="#ISR的伸缩" class="headerlink" title="ISR的伸缩"></a>ISR的伸缩</h3><p>Kafka 在启动时会开启定时任务，周期型的检测每个分区是否需要缩减其ISR集合</p><ul><li>ISR的缩减：当ISR中的follower副本滞后leader副本的时间超过<code>replica.lag.time.max.ms</code>则将该副本移出ISR集合</li><li>ISR的扩充：当follower副本的LEO不小于leader副本的HW即判定可进入ISR集合</li></ul><h3 id="LEO与HW"><a href="#LEO与HW" class="headerlink" title="LEO与HW"></a>LEO与HW</h3><p>多副本消息追加过程</p><ul><li>生产者客户端发送消息至leader副本</li><li>消息追加到leader副本的本地日志，并更新日志偏移量</li><li>follower副本向leader副本请求同步数据</li><li>leader副本所在的服务器读取本地日志，并更新对应拉取的follower副本信息</li><li>leader副本所在服务器将拉取结果返回follower副本</li><li>follower副本收到结果，将消息追加到本地日志，并更新日志的偏移量信息</li></ul><p>LEO和HW更新过程</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211125102555.png" alt="image-20211125102555685" style="zoom:80%;" /><ul><li>follower向leader拉取消息时，带有自己的LEO信息（fetch_offset），leader更新HW（取HW和LEO中的最小值），返回follower相应消息，并带有自身的HW</li><li>follower收到新消息后，更新LEO和HW</li></ul><p><strong>在一个分区中，leader会记录所有副本的LEO，而follower只会记录自身LEO</strong></p><h3 id="Leader-Epoch的介入"><a href="#Leader-Epoch的介入" class="headerlink" title="Leader Epoch的介入"></a>Leader Epoch的介入</h3><p>解决在需要截断数据的场景下，LEO/HW不一致导致数据丢失的问题，详细内容可查阅8.1.4节。</p><h3 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="headerlink" title="为什么不支持读写分离"></a>为什么不支持读写分离</h3><ul><li>主写从读的问题：数据一致性问题、延时问题</li><li>kafka通过分区副本机制来解决负载均衡问题</li></ul><h2 id="日志同步机制"><a href="#日志同步机制" class="headerlink" title="日志同步机制"></a>日志同步机制</h2><ul><li>日志同步机制的基本原则<ul><li>如果告知客户端已经成功提交了某条消息，那么即使leader宕机，也要保证新选举出来的leader中能够包含这条消息</li></ul></li><li>kafka通过维护ISR集合，保证leader切换后的数据完整性</li></ul><h1 id="Kafka应用"><a href="#Kafka应用" class="headerlink" title="Kafka应用"></a>Kafka应用</h1><ol><li><p>命令行工具</p><ul><li>kafka-configs.sh：配置管理</li><li>kafka-server-start.sh：启动kafka服务</li><li>kafka-server-stop.sh：关闭kafka服务</li><li>kafka-topics.sh：管理主题</li><li>kafka-preferred-replica-election.sh：优先副本选举</li><li>kafka-reassign-partitions.sh：分区重分配</li><li>kafka-consumer-groups.sh：消费组管理、重置消费位移</li><li>kafka-console-consumer.sh：命令行消费消息</li><li>kafka-console-producer.sh：命令行生产消息</li><li>kafka-consumer-perf-test.sh：测试消费性能</li><li>kafka-dump-log.sh：查看日志内容</li><li>kafka-delete-records.sh：删除消息</li></ul></li><li><p>Kafka Connect</p><ul><li><p>基本概念</p><ul><li>Kafka Connect是一个用于将数据流输入和输出Kafka的框架，可以简单快捷地将数据从Kafka导入或导出</li><li>Source和Sink：Source负责导入数据到Kafka，Sink负责从Kafka导出数据，统称为Connector</li><li>Task和Worker：<ul><li>Connector把一项工作分割成许多Task，然后分发到各个Worker进程去执行</li><li>Task不保存自己的状态信息，而是交给特定kafka topic保存，Connector和Task都是逻辑工作单位，必须安排在进程（Worker）中执行</li></ul></li></ul></li><li><p>独立模式</p><ul><li>通过connect-standalone.sh启动，所有操作都是在一个进程中完成</li><li>需要制定两个配置文件：<ul><li>Worker进程运行相关配置：connect-standalone.properties</li><li>Source或Sink配置：connect-file-source.properties、connect-file-sink.properties</li></ul></li></ul></li><li><p>REST API</p><ul><li>/（GET）：查看Kafka集群版本信息</li><li>/connectors （GET/POST）：查看Connector列表、创建Connector</li><li>/connectors/{name}（GET）：查看指定Connector</li><li>/connectors/{name}/config（GET/PUT）：查看/修改指定Connector配置</li><li>/connectors/{name}/status（GET）：查看指定Connector配置<br>……</li></ul></li><li><p>分布式模式</p><ul><li>运行脚本启动：connect-distributed.sh</li><li>修改Worker配置文件：connect-distributed.properties</li><li>修改Source或Sink配置：同独立模式</li></ul><blockquote><p>以分布式模式启动的连接器并不支持在启动时通过加载连接器配置文件来创建一个连接器，只能通过访问RESTAPI来创建连接器。</p></blockquote></li></ul></li><li><p>Kafka Mirror Maker</p><ul><li>用于在两个集群之间同步数据的工具，原理是从源集群消费消息，然后生产到目标集群</li><li>修改配置文件：consumer.properties，producer.properties</li><li>启动脚本：kafka-mirror-maker.sh</li></ul></li><li><p>Kafka Streams</p><ul><li><p>Kafka Streams是一个用于处理和分析数据的客户端库，它先把存储在Kafka中的数据进行处理和分析，然后将数据结果写到Kafka或发送到外部系统</p></li><li><p>解决问题：</p><ul><li>毫秒级延迟的逐个事件处理</li><li>有状态的处理，包括分布式连接和聚合</li><li>方便的DSL</li><li>使用类似DataFlow的模型对无序数据进行窗口化</li><li>具有快速故障切换的分布式处理和容错能力</li><li>无停机滚动部署</li></ul></li><li><p>使用时需要引入依赖：org.apache.kafka/kafka-streams</p></li></ul></li></ol><h1 id="Kafka监控"><a href="#Kafka监控" class="headerlink" title="Kafka监控"></a>Kafka监控</h1><ol><li>监控数据的来源<ul><li>Kafka自身提供的监控指标（包括broker和主题的指标）都可以通过JMX来获取，需要设置JMX_PORT设置端口并开启JMX功能<br>开启JMX后会在zk的 /brokers/ids/<brokerId> 节点中有jmx_port值</li><li>客户端指标数据可通过ProducerMetrics和ConsumerMetrics获取</li></ul></li><li>消费滞后<ul><li>Kafka中留存的消息与Consumer的消息之间的差值就是消息滞后量（Lag），对每个分区而言，Lag = HW - ConsumerOffset<br>如果分区中有未完成的事务，且isolation.level = “read_committed”，Lag = LSO - ConsumerOffset</li><li>计算Lag<ul><li>通过FindCoordinatorRequest查找消费组对应的GroupCoordinator</li><li>通过AdminClient获取DescribeGroupsRequest，获取当前消费组元数据信息</li><li>通过OffsetFetchRequest请求获取消费位移ConsumerOffset</li><li>通过KafkaConsumer.endOffsets()方法获取HW（LSO）值</li><li>HW与ConsumerOffset相减得到分区Lag</li></ul></li></ul></li><li>监控指标说明<ul><li>通过jconsole查看所有MBean</li></ul></li></ol><h1 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h1><ol><li>过期时间<ul><li>给消息添加timeStamp和超时时间，并在消费时使用拦截器，判断是否超时后进行消费</li></ul></li><li>延时队列<ul><li>到期才能消费</li><li>实现方式<ul><li>1.依然采用给消息添加timeStamp和延时时间，消费者拉取一批消息后，如果有未达到延时时间的消息，就重新写入主题</li><li>2.延时消息先投递到一个指定的主题，并使用自定义服务拉取、判断，满足条件后再投递到消费者真实消费的主题</li></ul></li></ul></li><li>其他功能：<ul><li>死信队列、消息路由、消息轨迹、消息审计等均可以自行设计生产消费结构来实现</li></ul></li><li>消息代理<ul><li>Kafka REST Proxy可以为Kafka集群提供一些列的REST API接口，通过这些接口可以实现发送消息、消费消息、查看集群状态和管理类操作等功能</li></ul></li></ol>]]></content>
    
    
    <summary type="html">从副本的角度分析Kafka中的数据一致性、数据可靠性；</summary>
    
    
    
    <category term="中间件" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="《Kafka核心设计与实践原理》阅读笔记" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E3%80%8AKafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="消息中间件" scheme="https://icbtbo.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://icbtbo.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka进阶篇：深入客户端</title>
    <link href="https://icbtbo.github.io/2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://icbtbo.github.io/2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2021-11-24T08:14:17.000Z</published>
    <updated>2022-03-23T06:24:33.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h1><p>消费者客户端可配置<code>partition.assignment.strategy</code>来设置消费者与topic之间的partition分配策略，默认<code>org.apache.kafka.clients.consumer.RangeAssignor</code>，可配置多个策略，逗号分隔。</p><ul><li><p>RangeAssignor：</p><ul><li><p>按照consumer总数和partition总数进行整除获得一个跨度，将partition按跨度进行平均分配，保证尽可能的均匀分配给所有consumer。分配时将consumerGroup内的consumer按名称字典排序，依次分配partition范围。</p><blockquote><p>这里的consumer指的是消费组内订阅了分区所属主题的消费者</p></blockquote></li><li><p>如果不够平均分配，那么字典序靠前的消费者会被多分配一个分区。</p></li></ul></li><li><p>RoundRobinAssignor：</p><ul><li>将group内所有consumer和被订阅的所有topic的partition按字典序排序，通过轮询方式，逐个分配partition</li><li>如果同一个group内的consumer订阅信息是不相同的，可能导致partition分配不均匀。</li></ul></li><li><p>StickyAssignor：</p><ul><li>主要目的：partition分配尽可能均匀，分配partition尽可能与上次保持相同</li><li>比上述两个策略更加优异</li></ul></li><li><p>自定义分配策略</p><ul><li>实现PartitionAssignor接口</li><li>具体内容查阅7.1.4节</li></ul></li></ul><h1 id="消费者协调器和组协调器"><a href="#消费者协调器和组协调器" class="headerlink" title="消费者协调器和组协调器"></a>消费者协调器和组协调器</h1><p>如果消费者客户端中配置了两个分配策略，那么以哪个为准呢?如果有多个消费者，彼此所配置的分配策略并不完全相同，那么以哪个为准?多个消费者之间的分区分配是需要协同的，那么这个协同的过程又是怎样的呢?这一切都是交由<strong>消费者协调器</strong>( ConsumerCoordinator )和<strong>组协调器</strong>(GroupCoordinator)来完成的，它们之间使用一套组协调协议进行交互。</p><h2 id="旧版客户端问题"><a href="#旧版客户端问题" class="headerlink" title="旧版客户端问题"></a>旧版客户端问题</h2><ul><li>旧版消费者客户端使用zk的监听器(Watcher)来实现分区分配。consumer和broker状态发生变化时，相应的节点也会变化，客户端就能够监听到状态。</li><li>依赖zk有两个严重问题：<ul><li>羊群效应：当监听的节点发生变化，大量Watcher通知发送到客户端，导致其他操作延迟，甚至发生死锁</li><li>脑裂问题：再均衡操作时，每个consumer与zk进行通信来监听变化情况，由于zk本身特性，可能导致同一时刻各个consumer获取的状态不一致，从而导致异常</li></ul></li></ul><h2 id="新版客户端再均衡的原理"><a href="#新版客户端再均衡的原理" class="headerlink" title="新版客户端再均衡的原理"></a>新版客户端再均衡的原理</h2><p>新版客户端将全部消费组分成多个子集，每个子集在服务端对应一个GroupCoordinator对其进行管理，而消费者客户端中使用ConsumerCoordinator组件与GroupCoordinator交互。</p><p><strong>触发再均衡操作的情形</strong>有：</p><ul><li>新的consumer加入group</li><li>consumer宕机（长时间没有发送心跳）</li><li>consumer主动退出group（unsubscrible()）</li><li>group对应的GroupCoorinator节点发生了变更</li><li>group内订阅的任一topic或主题的partition数量发生变化</li></ul><p>接下来以一个例子介绍<strong>再均衡</strong>的详细过程，当有<strong>消费者加入消费组</strong>时，消费者、消费组及组协调器之间会经历以下几个 阶段：</p><ul><li><p>第一阶段（FIND_COORDINATOR）</p><ul><li><p>consumer需要确定所属group对应的GroupCoordinator所在的broker，并创建与该broker通信的连接</p></li><li><p>如果已经保存了GroupCoordinator节点信息且连接正常，则进入第二阶段。否则，需要向集群中某个节点（leastLoadedNode）发送FindCoordinatorRequest来查找对应的GroupCoordinator</p><blockquote><p>具体查找 GroupCoordinator的方式是先根据消费组groupid的哈希值计算_consumer_offsets 中的分区编号，然后寻找该分区leader副本所在的broker节点</p></blockquote></li></ul></li><li><p>第二阶段（JOIN_GROUP）</p><ul><li><p>consumer会向GroupCoordinator发送JoinGroupRequest以加入消费组。</p><ul><li>JoinGroupRequest中包含该消费者设置的分配策略。</li><li>若该消费者是第一次加入该消费组，GroupCoordinator受到该请求后会为该消费者生成一个唯一标识<code>member_id</code></li></ul><blockquote><p>如果是原有consumer重新加入group，发送前还要执行一些准备工作：</p><ul><li><p><code>enable.auto.commit</code>为true时，需要向GroupCoordinator提交位移</p></li><li><p>执行再均衡监听器（ConsumerRebalanceListener）的<code>onPartitionsRevoked()</code>方法</p></li><li><p>暂时禁止心跳检测运作</p></li></ul></blockquote></li><li><p>选举消费组的leader</p><ul><li><p>GroupCoordinator需要为消费组内的consumer选举出一个leader。如果消费组内还没有leader，则第一个加入的consumer即为leader。如果原leader退出消费组，则重新选举leader（近乎随机）</p><blockquote><p>在GroupCoordinator中消费者的信息是以HashMap的形式存储的，其中key为消费者的member id，而value是消费者相关的元数据信息。 leaderld表示leader消费者的member id，它的取值为HashMap中的第一个键值对的 key。</p></blockquote></li></ul></li><li><p>选举分区分配策略</p><ul><li>每个consumer都可以设置自己的分区分配策略，而消费组需要从中选出一个来进行整体分区分配。</li><li>这个分区分配策略的选举是由消费组内的消费者投票来决定的。具体选举过程如下：<ul><li>收集各个消费者支持的所有分配策略，组成候选集</li><li>组内的消费者从候选集中找出第一个自身支持的策略，并投上一票（不需要再次与组协调器交互，该步骤在组协调器内部完成）</li><li>计算候选集中个分配策略的票数，票数最高的策略即为当前消费组的分配策略</li></ul></li></ul></li><li><p>在此之后， Kafka 服务端就要发送 JoinGroupResponse 响应给各个消费者，发送给普通消费者和leader消费者的响应中都包含最终选出的分配策略，响应内容并不完全相同。</p><ul><li>发送给普通消费者的 JoinGroupResponse 中的members内容为空，而只有leader消费者的 JoinGroupResponse 中的 members 包含有效数据。 members 为数组类型，其中包含各个成员的订阅信息 。</li></ul></li></ul></li><li><p>第三阶段（SYNC_GROUP）</p><ul><li>leader消费者根据第二阶段中选举出来的策略来实施具体的分区分配，然后通过GroupCoordinator将方案同步给各个consumer。</li><li>各个consumer会向GroupCoordinator发送SyncGroupRequest来同步分配方案。GroupCoordinator在收到该请求后会先进行合法性校验，然后将收到的分配方案发给各个消费者。</li></ul></li><li><p>第四阶段（HEARTBEAT）</p><ul><li>进入此阶段，consumer即处于正常工作状态</li><li>正式消费前，consumer还需要确定拉取消息的起始位置：通过OffsetFetchRequest请求获取消费位移</li><li>consumer通过向GroupCoordinator发送心跳来维持与消费组的从属关系，及对partition的所有权关系。<ul><li>如果一个消费者发生崩溃，并停止读取消息，那么 GroupCoordinator 会等待一小段时间，确认这个消费者死亡之后才会触发再均衡。这个一小段时间由 <code>session.timeout.ms</code> 参数控制</li><li>除了被动退出消费组，还可以使用 LeaveGroupRequest 请求主动退出消费组，比如客户端调用了unsubscrible()方法取消对某些主题的订阅</li></ul></li></ul></li></ul><h1 id="consumer-offsets剖析"><a href="#consumer-offsets剖析" class="headerlink" title="_consumer_offsets剖析"></a>_consumer_offsets剖析</h1><ul><li>一般情况下，集群中第一次有consumer消费消息时，会自动创建主题_consumer_offsets</li><li>它的副本因子还受<code>offsets.topic.replication.factor</code>约束。分区数通过<code>offsets.topic.num.partitions</code>设置（默认50）。</li><li>客户端提交消费位移是使用OffsetCommitRequest实现的</li><li>删除topic时，会将consumer提交的此topic的offset一并删除</li></ul><blockquote><p>OffsetCommitRequest的消息格式和消费位移对应的内容格式可查阅7.3节</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="消息传输保障"><a href="#消息传输保障" class="headerlink" title="消息传输保障"></a>消息传输保障</h2><ul><li>一般消息中间件的消息传输保障有3个层级<ul><li>at most once：至多一次。消息可能丢失，但不会重复</li><li>at least once：至少一次。消息不会丢失，但可能重复</li><li>exactly once：恰好一次。每条消息肯定且仅传输一次</li></ul></li><li>kafka提供的消息传输保障为at least once</li><li>从0.11.0.0版本开始引入幂等和事务特性来实现EOS（exactly once semantics）</li></ul><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>所谓的幕等，简单地说就是对接口的多次调用所产生的结果和调用一次是一致的。生产者在进行重试的时候有可能会重复写入消息，而使用 Kafka 的幕等性功能之后就可以避免这种情况。</p><ul><li><p>生产者客户端通过设置<code>enable.idempotence</code>=true（默认false）开启幂等性功能</p></li><li><p>开启幂等时，客户端会对用户显式设定的一些参数进行校验</p><ul><li>retries：必须大于0（默认Integer.MAX_VALUE）</li><li>acks：必须为-1（all，默认为1）</li><li>max.in.flight.requests.per.connection：不能大于5（默认5）</li></ul></li><li><p>对于每个PID（producer id），消息发送到的每一个partition都有对应的序列号，从0开始，每发送一条就+1，。broker在内存中为每一对 &lt;PID, partition&gt; 维护一个序列号，收到消息时，对比其序列号(SN_new)和内存中的序列号(SN_old)。</p><blockquote><p>生产者客户端和broker端都为每一对&lt;PID, partition&gt;维护一个序列号，生产者客户端每发送一条消息就将该序列号加一，而broker每接受一条消息就加一。</p><p>每个新的生产者实例在初始化的时候都会被分配一个PID，这个PID对用户而言是完全透明的。</p></blockquote><ul><li>如果SN_new&lt;SN_old+1，说明消息重复写入则丢弃此消息。</li><li>如果SN_new&gt;SN_old+1，可能有消息丢失，对应producer会抛出异常。</li><li>只有SN_new刚好比SN_old大1时，才接受此消息。</li></ul></li><li><p>引入序列号来实现幕等也只是针对每一对&lt;PID，分区&gt;而言的，也就是说Kafka的幂等只能保证<strong>单个生产者会话（session）中单分区的幂等</strong>.</p></li></ul><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>幂等性并不能跨多个分区运作，而事务可以弥补这个缺陷。事务可以保证对多个分区写入操作的原子性。Kafka引入事务协调器（TransactionCoordinator）负责处理事务。</p><p>每一个生产者都会被指派一个特定的 TransactionCoordinator，所有的事务逻辑包括分派 PID 等都是由 TransactionCoordinator 来负责实施的。TransactionCoordinator 会将事务状态持久化到内部主题_transaction_state 中。</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><ul><li>为了实现事务，生产端需要开启幂等，并且将<code>trasactional.id</code>参数设置为非空</li><li>transactionId与PID一一对应，但是transactionId是由用户显式设置，而PID是kafka内部分配。如果使用同一个transactionId开启两个producer，则前一个producer会报错并不再工作。</li><li>KafkaProducer提供了5个事务相关方法：<ul><li><code>initTransactions()</code>：初始化事务（前提是配置了transactionId）</li><li><code>beginTransaction()</code>：开启事务</li><li><code>sendOffsetsToTransaction()</code>：在事务内的位移提交</li><li><code>commitTransaction()</code>：提交事务</li><li><code>abortTransaction()</code>：中止事务</li></ul></li></ul><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><ul><li><p>需要配置enable.auto.commit=false</p></li><li><p>通过配置isolation.level设置事务消息的隔离级别</p><ul><li>read_uncommitted（默认）：可消费到未提交的事务</li><li>read_committed：消费端应用看不到尚未提交的事务内的消息（会缓存在KafkaConsumer内部直到事务提交或中止）</li></ul></li><li><p>KafkaConsumer通过控制消息（ControlBatch）判断事务的提交和中止</p></li></ul><h3 id="事务实现过程"><a href="#事务实现过程" class="headerlink" title="事务实现过程"></a>事务实现过程</h3><p>下面以最复杂的 consume-transform-produce 的流程为例来分析 Kafka 事务的实现原理。</p><blockquote><p><strong>consume-transform-produce 模式</strong></p><p>在这种模式下消费和生产并存: 应用程序从某个主题中消费消息，然后经过一系列转换后写入另一个主题，消费者可能在提交消费位移的过程中出现问题而导致重复消费，也有可能生产者重复生产消息。</p><p>该模式具体代码可查阅7.4.3节。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124213612.png" alt="image-20211124213612752" style="zoom:80%;" /><ul><li><p>1.查找TransactionCoordinator</p><ul><li>与查找组协调器类似，根据 transactionalld 的哈希值计算主题_transaction_state中的分区编号，再查找相应的broker节点</li></ul></li><li><p>2.获取PID</p><ul><li><p>凡是开启了幂等性功能的生产者都必须执行这个操作，而不论是否开启事务</p></li><li><p>通过向TransactionCoordinator发送InitProducerldRequest请求来实现（若未开启事务，则可发往任意broker）</p></li><li><p>当TransactionCoordinator第一次收到该请求时，会把请求中的transactionalId和对应的PID以消息的形式保存到主题_transaction_state中，从而持久化transactionalId和PID的关系。</p><blockquote><p>每个新的生产者实例在初始化的时候都会被分配一个 PID，这个PID对用户而言是完全透明的</p></blockquote></li></ul></li><li><p>3.开启事务</p><ul><li>通过 KafkaProducer的<code>beginTransaction()</code>方法可以开启一个事务</li><li>调用该方法后，生产者本地会标记己经开启了一个新的事务 ，只有在生产者发送第一条消息之后 TransactionCoordinator 才会认为该事务己经开启 </li></ul></li><li><p>4.Consume-Transform-Produce：事务的处理过程</p><ul><li><p>当生产者给一个<strong>新的</strong>分区( TopicPartition) 发送数据前， 它需要先向 TransactionCoordinator 发送 AddPartitionsToTxnRequest请求。这个请求会让 TransactionCoordinator 将&lt;transactionld, TopicPartition&gt;的对应关系存储在主题<code>_transaction_state</code>中。</p></li><li><p>生产者通过 ProduceRequest 请求发送消息(ProducerBatch)到用户自定义主题中</p></li><li><p>消费者通过 KafkaProducer 的sendOffsetsToTransaction()方法在一个事务里提交位移</p><ul><li>该方法会向 TransactionCoordinator 节点发送 AddOffsetsToTxnRequest 请求，收到该请求后，协调器会根据groupId推导出<code>_consumer_offsets</code>中的分区，然后将该分区保存在主题<code>_transaction_state</code>中。（对应图中步骤4.3）</li><li>在处理完 AddOffsetsToTxnRequest 之后，生产者还会发送 TxnOffsetCommitRequest 请求给 GroupCoordinator，从而将本次事务中包含的消费位移信息 offsets 存储到主题<code>_consumer_offsets</code>中。（对应图中步骤4.4）</li></ul></li></ul></li><li><p>5.提交或中止事务</p><ul><li><p>一旦数据被写入成功，我们就可以调用 KafkaProducer 的 <code>commitTransaction()</code>方法或 <code>abortTransaction()</code>方法来结束当前的事务。调用这两种方法后，生产者都会向TransactionCoordinator发送 EndTxnRequest 请求，受到该请求后TransactionCoordinator会执行如下操作：</p><ul><li><p>将 PREPARE COMMIT 或 PREPARE_ABORT 消息写入主题<code>_transaction_state</code></p></li><li><p>通过 WriteTxnMarkersRequest请求将 COMMIT 或 ABORT 信息写入用户所使用的普通主题和<code>_consumer_offsets</code></p><blockquote><p>当分区的leader节点收到这个请求之后，会在相应的分区中写入控制消息( ControlBatch)。控制消息用来标识事务的终结，它和普通的消息一样存储在日志文件中</p></blockquote></li><li><p>将COMPLETE CO孔仙lfIT或COMPLETE ABORT信息写入内部主题<code>_transaction_state</code></p><blockquote><p>表明当前事务已经结束，此时可以删除主题<code>_transaction_state</code> 中所有关于该事务的消息。由于主题<code>_transaction_state</code> 采用的日志清理策略为日志压缩，所以这里的删除只需将相应的消息设置为墓碑消息即可</p></blockquote></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">本章从客户端的角度入手，同时涉及客户端和服务端的内容，以便深入地挖掘Kafka的实现原理，从底层的概念去构建Kafka的知识体系。</summary>
    
    
    
    <category term="中间件" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="《Kafka核心设计与实践原理》阅读笔记" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E3%80%8AKafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="消息中间件" scheme="https://icbtbo.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://icbtbo.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka进阶篇：深入服务端</title>
    <link href="https://icbtbo.github.io/2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://icbtbo.github.io/2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2021-11-24T01:55:41.000Z</published>
    <updated>2022-03-23T03:13:01.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h1><ul><li>Kafka自定义了一组基于TCP的二进制协议，用于实现各种消息相关操作</li><li>协议基本结构<ul><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124110514.png" alt="img" style="zoom: 50%;" /></li><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124110530.png" alt="img" style="zoom:50%;" /></li><li>不同的api（PRODUCE、FETCH等），RequestBody和ResponseBody结构也不同，其详细描述可查阅6.1节</li></ul></li></ul><h1 id="时间轮（TimingWheel）"><a href="#时间轮（TimingWheel）" class="headerlink" title="时间轮（TimingWheel）"></a>时间轮（TimingWheel）</h1><p>Kafka基于时间轮概念自定义实现了一个用于延时功能的定时器（SystemTitmer）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124111337.png" alt="image-20211124111337413" style="zoom:80%;" /><ul><li>时间轮是一个存储定时任务的环形队列 ，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表( TimerTaskList)。TimerTaskList 是一个环形的双向链表，链表中的每一项表示的都是定时任务项( TimerTaskEntry)，其中封装了真正的定时任务 (TimerTask) 。</li><li>时间轮由多个时间格组成，每个时间格代表基本时间跨度（titkMs），时间轮时间格个数（wheelSIze）是固定的。</li><li>currentTime将时间轮划分为到期部分和未到期部分，当前指向的表示刚好到期，需要处理此时间格内的TimerTaskList中的任务</li></ul><p>wheelSize的扩充有限制，当定时时间较大时，不能直接扩充wheelsize，这不仅会占用很大的内存空间，也会拉低效率。针对不同定时需要，Kafka引入层级时间轮的概念。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124111650.png" alt="image-20211124111650888" style="zoom:80%;" /><ul><li><p>当任务的到期时间超过了当前时间轮的时间范围，会尝试添加到上层时间轮。当延时任务所在的时间轮不能精准实现到期时间时，也会重新提交到层级时间轮，进行降级。</p><blockquote><p><strong>降级示例</strong>：在到期时间为[400ms,800ms)区间内的多个任务(比如 446ms、455ms 和 473ms 的定时任务)都会被放入第三层时间轮的时间格1，时间格1对应的 TimerTaskList 的超时时间为 400ms。 随着时间的流逝，当此 TimerTaskList 到期之时，原本定时为 450ms 的任务还剩下 50ms 的时间，还不能执行这个任务的到期操作。这里就有一个时间轮降级的操作，会将这个剩余时间为 50ms 的定时任务重新提交到层级时间 轮中，此时第一层时间轮的总体时间跨度不够，而第二层足够，所以该任务被放到第二层时间轮到期时间为[40ms,60ms)的时间格中。 再经历40ms之后，此时这个任务又被“察觉”，不过 还剩余 lOms，还是不能立即执行到期操作。所以还要再有一次时间轮的降级，此任务被添加到 第一层时间轮到期时间为[1Oms,11ms)的时间格中，之后再经历 lOms后，此任务真正到期，最终执行相应的到期操作。</p><p><strong>可以类比成时钟来理解。</strong></p></blockquote></li><li><p>Kafka中的定时器只持有第一层时间轮引用，每一层时间轮中有一个引用指向更高一层。</p></li><li><p>Kafka 中的定时器借了JDK中的DelayQueue来协助推进时间轮，具体做法如下：</p><ul><li>每个使用到的TimerTaskList都加入DelayQueue，DelayQueue会根据TimerTaskList对应的超时时间expiration来排序</li><li>Kafka有一个线程ExpiredOperationReaper（过期任务收割机）来获取DelayQueue中到期的任务列表</li><li>获取 DelayQueue中超时的任务列表 TimerTaskList 之后，既可以根据TimerTaskList的expiration来推进时间轮的时间，也可以就获取的TimerTaskList执行相应的操作，对里面的TimerTaskEntry该执行过期操作的就执行过期操作，该降级时间轮的就降级时间轮 。</li></ul></li></ul><blockquote><p> delayqueue的<a href="https://www.cnblogs.com/tong-yuan/p/DelayQueue.html">原理</a></p><p>kafka的时间轮<a href="https://blog.csdn.net/chunlongyu/article/details/52971748">源码解析</a>和<a href="https://zhuanlan.zhihu.com/p/121483218">图解</a></p></blockquote><p><strong>Kafka 中的定时器真可谓“知人善用” ， 用 TimjngWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，两者相辅相成</strong> 。</p><h1 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h1><p>延时操作（延时生产、延时拉取等）需要延时返回响应的结果</p><ul><li>首先它必须有一个超时时间(delayMs)，如果在这个超时时间内没有完成既定的任务，那么就需要强制完成以返回响应结果给客户端 </li><li>其次，延时操作不同于定时操作，定时操作是指在特定时间之后执 行的操作，而延时操作可以在所设定的超时时间之前完成，所以延时操作能够支持外部事件的触发</li></ul><p>Kafka中的延时操作创建后会被加入延时操作管理器（DelayedOperationPurgatory）做专门处理，每个延时操作管理器配别一个定时器（由时间轮实现）。延时操作除了满足时间条件执行，还支持外部事件触发，由一个监听池来监听每个分区的外部事件。</p><h1 id="控制器（KafkaController）"><a href="#控制器（KafkaController）" class="headerlink" title="控制器（KafkaController）"></a>控制器（KafkaController）</h1><p>Kafka集群中有一个broker会被选举为控制器，负责管理整个集群中所有分区和副本的状态。其职责有：</p><ul><li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本</li><li>当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息</li><li>当使用 kafka-topics.sh 脚本为某个topic增加分区数量时，同样还是由控制器负责分区的重新分配</li></ul><h2 id="控制器的选举及异常恢复"><a href="#控制器的选举及异常恢复" class="headerlink" title="控制器的选举及异常恢复"></a>控制器的选举及异常恢复</h2><p><strong>控制器选举</strong></p><ul><li><p>broker启动时尝试读取zk的/controller节点的brokerid，如果不为-1，则放弃竞选。如果不存在/controller节点或节点数据异常，broker会尝试创建此节点，多个broker只有创建成功的会成为控制器。</p></li><li><p>broker内存会保存当前控制器brokerid：activeControllerId</p></li><li><p>Kafka通过zk的controller_epoch来保证控制器的唯一性，其用于记录控制器发生变更的次数</p><blockquote><p>每个和控制器交互的请求都会携带 controller epoch 这个宇段，如果请求的 controller_epoch 值小于内存中的 controller_epoch 值， 则认为这个请求是向己经过期的控制器所发送的请求，那么这个请求会被认定为无效的请求。 如果请求的 controller epoch 值大于内存中的 controller_epoch 值，那么说明 己经有 新的控制器当选了 </p></blockquote></li></ul><p><strong>异常恢复</strong></p><ul><li>当/controller节点的数据发生变化时，每个broker都会更新自身内存中保存的activeControllerld。如果broker在数据变更前是控制器，在数据变更后自身的brokerid值和新的activeControllerld值不一致，那么就需要“退位” ，关闭相应的资源，如关闭状态机、注销监听器。</li><li>当控制器由于异常下线或其他原因 导致/controller节点被删除时，每个 broker都会进行选举，如果 broker在节点被删除前 是控制器，那么在选举前还需要有 一个“退位”的动作。</li></ul><h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><p>使用kafka-server-stop.sh脚本来优雅地关闭kafka，而不是使用jps加kill -9来关闭</p><ul><li>该脚本会给kafka进程发送一个终止信号（TERM），kafka进程捕获该信号后会执行一个关闭钩子中的内容，其中除了关闭一些必要的资源，还会执行控制关闭（ControlledShutdown）的动作</li><li>broker使用ControlledShutdown的方式关闭时<ul><li>可以让消息完全同步到磁盘上，使服务下次上线时不需要进行日志的恢复操作</li><li>在关闭服务前会对其上的leader副本进行迁移，这样可以减少分区的不可用时间</li></ul></li></ul><h2 id="分区leader的选举"><a href="#分区leader的选举" class="headerlink" title="分区leader的选举"></a>分区leader的选举</h2><p>分区leader副本的选举由控制器负责具体实施。其有四种不同的选举策略，这些策略应用于不同的场景。</p><ul><li><p>OfflinePartitionLeaderElectionStrategy：</p><ul><li><p>当创建分区或原leader副本下线采用，控制器使用该策略选举新的leader：</p><ul><li><p><code>unclean.leader.election.enable</code> 为false时：按照AR集合顺序查找第一个存活的副本，且该副本在ISR集合中。</p></li><li><p><code>unclean.leader.election.enable</code> 为true时：按照AR集合顺序查找第一个存活的副本。</p></li></ul></li><li><p>注意AR顺序在分配时就被指定，只要不发生重分配就保持不变。而分区的ISR集合中副本的顺序可能会改变 </p></li></ul></li><li><p>ReassignPartitionLeaderElectionStrategy：</p><ul><li>当分区重分配时采用，从重分配的AR中找到第一个存活的 replica，且满足在ISR中</li></ul></li><li><p>PrefferredReplicaPartitionLeaderElectionStrategy：</p><ul><li>优先副本选举时采用，直接将优先副本设置为leader</li></ul></li><li><p>ControlledShutdownPartitionLeaderElectionStrategy：</p><ul><li>当某节点被优雅关闭时采用，AR中找到第一个存活replica，且在ISR中，还要确保不在关闭的节点上</li></ul></li></ul><h1 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h1><ul><li><p><code>broker.id</code></p><ul><li>broker启动前必须设定的参数，作为broker的唯一id。</li><li>broker启动时会在zk的/brokers/ids下创建节点，broker的健康状态检查就依赖此节点，broker下线时此节点会自动删除</li><li>在 config/server.properties 或 meta.properties 中配置</li><li>可通过 <code>broker.id.generation.enable</code>(默认true) 和 <code>reserved.broker.max.id</code>(默认1000) 来配合自动生成新的brokerId。自动生成的brokerId会大于maxid的配置。</li></ul></li><li><p><code>bootstrap.servers</code></p><ul><li><p>这个参数用来配置发现kafka集群元数据信息的服务地址（可以不是broker）</p></li><li><p>客户端连接kafka集群的过程</p><p>​    <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124160610.png" alt="image-20211124160610693" style="zoom:80%;" /></p><ul><li>客户端与bootstrap.servers指定的server连接，发送MetadataRequest请求获取集群的元数据信息</li><li>server收到请求后，返回MetadataResponse，其中包含集群元数据信息</li><li>客户端通过解析元数据信息，与集群各个节点建立连接</li></ul></li></ul></li><li><p>其他服务端参数列表<br>引：<a href="https://www.cnblogs.com/wangjing666/p/10234445.html">kafka brokers配置参数详解</a></p></li></ul>]]></content>
    
    
    <summary type="html">本章涉及 协议设计、时间轮、延迟操作、控制器及参数解密</summary>
    
    
    
    <category term="中间件" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="《Kafka核心设计与实践原理》阅读笔记" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E3%80%8AKafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="消息中间件" scheme="https://icbtbo.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://icbtbo.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka进阶篇：日志存储</title>
    <link href="https://icbtbo.github.io/2021/11/22/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/"/>
    <id>https://icbtbo.github.io/2021/11/22/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/</id>
    <published>2021-11-22T12:47:22.000Z</published>
    <updated>2022-03-22T13:01:25.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件目录布局"><a href="#文件目录布局" class="headerlink" title="文件目录布局"></a>文件目录布局</h1><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211122210338.png" alt="image-20211122210338721" style="zoom:80%;" /><p>上图所示的是kafka在某一时刻的文件目录布局，每一个根目录都会包含最基本的 4 个检查点文件(xxx-checkpoint)和 meta.prop创ies 文件。当broker配置了多个根目录时，会挑选分区数最少的根目录来创建主题。</p><p>主题、分区、副本、Log和LogSegment之间的关系如下图所示：</p><img src="https://img-blog.csdnimg.cn/20190801152646942.png" alt="img" style="zoom: 75%;" /><ul><li>一个分区副本对应一个日志(Log)，一个日志会分配成多个日志分段(LogSegment)，Log在物理上以文件夹形式存储，而LogSegment对应磁盘上的一个日志文件和两个索引文件及可能的其他文件。</li><li>向Log追加消息时是顺序写入的，只有最后一个LogSegment才能执行写入，称为<strong>activeSegment</strong>，满足一定条件时，需要创建新的activeSegment。</li><li>每个日志及索引的文件名根据基准偏移量(BaseOffset)命名，表示当前LogSegment中第一条消息的offset。</li></ul><h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><h2 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h2><ul><li>Kafka 会将多条消息一起进行压缩，生产者发送的压缩数据在 broker 中也是保持压缩状态进行存储的 ，消费者从服务端获取的也是压缩的消息，消费者在处理消息之前才会解压消息。</li><li>压缩方式通过compression.type来配置：producer、gzip、snappy、lz4、uncmpressed。</li><li>消息压缩时，整个消息集压缩为内层消息，整体作为外层消息的value。外层消息的offset保存了内层消息最后一条记录的offset，而内层消息在压缩时会从0开始分配一个offset，内层消息的offset会在服务端进行转换。</li></ul><h2 id="v2版本日志格式"><a href="#v2版本日志格式" class="headerlink" title="v2版本日志格式"></a>v2版本日志格式</h2><blockquote><p>旧版本的消息格式（日志格式）不在这里展示，有需要可查阅5.2节的内容</p></blockquote><img src="https://img-blog.csdnimg.cn/2019080115325191.png" alt="img" style="zoom: 67%;" /><p>该版本引入了变长整型(Varints)和ZigZag编码来保存数值。如果消息本身没有 key，那么 key length 字段为-1，旧版本的消息用int类型来编码，需要4个字节，而如果使用Varints加ZigZag来编码则只需要1个字节。</p><p><strong>Varints</strong>：</p><ul><li>使用一个或多个字节来序列化整数的一种方法。数值越小，其占用的字节数就越少。</li><li>每个字节都有一个位于最高位的 msb 位( most significant bit)，除最后一个字节的msb为0外，其余msb位都设置为1。除 msb 位外，剩余的 7 位用于存储数据本身，即一个字节可以表示$2^7=128$ 个值。</li><li>Varints中采用的是小端字节序，即最小的字节放在前面。</li><li>举例：<ul><li>数字1用varints来表示-&gt; 0000 0001；</li><li>数字300用varints来表示-&gt;1010 1100 0000 0010；</li></ul></li></ul><p><strong>ZigZag编码</strong>：</p><ul><li>若使用 int64等有符号整数类型表示一个负数，那么哪怕是-1，其编码后的长度始终为4个字节。为了使编码更加高效， Varints 使用了 ZigZag 的编码方式。</li><li>ZigZag编码以一种锯齿形( zig-zags)的方式来回穿梭正负整数， 将带符号整数映射为无符号整数，这样可以使绝对值较小的负数仍然享有较小的Varints编码值。</li><li>比如-1编码为1, 1编码为 2, -2编码为3，2编码为4，-3编码为5，以此类推。</li><li>将原值转换为ZigZag编码的公式为 ( n &lt;&lt; 1 ) ^ ( n &gt;&gt; 31 )  该公式是对sint32类型的原值而言的。</li></ul><h1 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h1><p>Kafka 中的索引文件以**稀疏索引( sparse index)**的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项 。</p><p><em>每当写入一定量(由 broker 端参数 <code>log.index.interval.bytes</code> 指定，默认值为 4096，即 4KB)的消息时，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项</em>。（通过增大或减小 <code>log.index.interval.bytes</code> 的值，可以增加或缩小索引项的密度）</p><p>偏移量索引文件中的偏移量是单调递增的，查询指定偏移量时，使用二分查找法来快速定位偏移量的位置，如果指定的偏移量不在索引文件中，则会返回小于指定偏移量的最大偏移量。查询指定时间戳时，也根据二分查找法来查找不大于该时间戳的最大偏移量，至于要找到对应的物理文件位置还需要根据偏移量索引文件来进行再次定位。</p><p><strong>日志分段文件进行切分的条件</strong>：</p><ul><li>当前日志分段文件的大小超过了 broker 端参数 <code>log.segment.bytes</code> 配置的值</li><li>当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于 <code>log.roll .ms</code> 或 <code>log.roll.hours</code> 参数配置的值。（若都配置了，则ms的优先级高）</li><li>偏移量索引文件或时间戳索引文件的大小达到 broker端参数 <code>log.index.size.max.bytes</code> 配置的值</li><li>追加的消息的偏移量与当前日志分段的偏移量之间的差值大于Integer.MAX_VALUE, 即要追加的消息的偏移量不能转变为相对偏移量</li></ul><blockquote><p><strong>日志分段的大小</strong>：Kafka 在创建索引文件的时候会为其预分配 <code>log.index.size.max.bytes</code> 大小的空间，注意这一点与日志分段文件不同，只有当索引文件进行切分的时候，Kafka 才会把该索引文件裁剪到实际的数据大小 。也就是说与当前活跃的日志分段对应的索引文件的大小固定为<code>log.index.size.max.bytes</code>，而其余日志分段对应的索引文件的大小为实际的占用空间。</p></blockquote><h2 id="偏移量索引（-index）"><a href="#偏移量索引（-index）" class="headerlink" title="偏移量索引（.index）"></a>偏移量索引（.index）</h2><p>偏移量索引文件用来建立消息偏移量(offset)到物理地址之间的映射关系，方便快速定位消息所在的物理文件位置</p><p>每个索引占8个字节，分为两个部分：</p><ul><li>relativeOffset：相对偏移量，表示消息相对于baseOffset的偏移量，当前索引文件的文件名即为baseOffset值</li><li>position：消息在日志分段文件中的物理地址</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211122215526.png" alt="image-20211122215526937" style="zoom:70%;" /><h2 id="时间戳索引（-timeindex）"><a href="#时间戳索引（-timeindex）" class="headerlink" title="时间戳索引（.timeindex）"></a>时间戳索引（.timeindex）</h2><p>时间戳索引文件则根据指定的时间戳( timestamp)来查找对应的偏移量 信息。</p><p>每个索引占12个字节，分为两个部分：</p><ul><li>timestamp：当前日志分段最大的时间戳</li><li>relativeOffset：时间戳对应的消息的相对偏移量</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211122215609.png" alt="image-20211122215609268" style="zoom:70%;" /><h1 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h1><p>Kafka 将消息存储在磁盘中，为了控制磁盘占用空间的不断增加就需要对消息做一定的清理操作。</p><ul><li><p>可以通过broker端参数<code>log.cleanup.policy</code>设置日志清理策略（默认delete）</p></li><li><p>有两种清理策略：</p><ul><li><p>日志删除：按照一定保留策略直接删除不符合条件的日志分段</p><ul><li>设置<code>log.cleanup.policy</code>为delete</li></ul></li><li><p>日志压缩：针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本</p><ul><li>设置<code>log.cleanup.policy</code>为compact，并且将<code>log.leaner.enable</code>设置为true（默认true）</li></ul></li><li><p>可同时使用日志删除和日志压缩两种策略</p></li></ul></li></ul><h2 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a><strong>日志删除</strong></h2><ul><li><p>Kafka的日志管理器中有一个专门的日志删除任务来周期性地检测和删除不符合<strong>保留条件</strong>的日志分段文件，周期通过 broker 端参数 <code>log.retention.check.interval.ms</code>来配置（默认300000，5分钟）</p></li><li><p>日志分段保留策略有3种：</p><ul><li><p>基于时间的保留策略：</p><ul><li><p>通过<code>log.retention.hours</code>、<code>log.retention.minutes</code>和<code>log.retention.ms</code>来配置超时清理阈值</p><blockquote><p>优先级ms&gt;minutes&gt;hours（默认log.retention.hours=168，7天） </p></blockquote></li></ul></li><li><p>基于日志大小的保留策略：</p><ul><li>通过<code>log.retention.bytes</code>配置Log日志总大小阈值（默认-1，无穷大）</li><li>通过<code>log.segment.bytes</code>配置日志分段文件大小阈值（默认1G）</li></ul></li><li><p>基于日志起始偏移量的保留策略：</p><ul><li>某日志分段的<strong>下一个日志分段</strong>的起始偏移量baseOffset是否小于等于logStartOffset，若是则可以删除此日志分段</li><li>logStartOffset 的值可以通过DeleteRecordsRequest请求（比如使用KafkaAdminClient的deleteRecords()方法、使用kafka-delete-records.sh脚本〉、日志的清理和截断等操作进行修改</li></ul></li></ul></li><li><p>删除日志分段时，首先会从Log对象中所维护日志分段的跳表中移出待删除分段，以保证没有线程对其进行读取，然后将对应文件加上.deleted后缀，最后由名为delete-file的延迟任务来删除文件</p><ul><li> Kafka 的每个日志对象中使用了 ConcurrentSkipListMap 来保存各个日志分段，每个日志分段的 baseOffset 作为 key</li><li>删除任务延迟时间通过<code>file.delete.delay.ms</code>配置（默认60000，1分钟）</li></ul></li></ul><h2 id="日志压缩（Log-Compaction）"><a href="#日志压缩（Log-Compaction）" class="headerlink" title="日志压缩（Log Compaction）"></a><strong>日志压缩</strong>（Log Compaction）</h2><ul><li><p>Log Compaction对于有相同key的不同value值，只保留最后一个版本。</p></li><li><p>每个日志目录下都有一个名为“cleaner-offset-checkpoint”的<strong>清理检查点文件</strong>，用来记录每个主题的每个分区中己清理的偏移量。通过清理检查点文件可以将 Log 分成两个部分。通过检查点cleaner checkpoint来划分出 一个己经清理过的clean部分和一个还未清理过的dirty部分。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123103357.png" alt="image-20211123103357404" style="zoom:80%;" /></li><li><p>注意Log Compaction是针对key的，所以在使用时应注意每个消息的key值不为null。每个broker会启动<code>log.cleaner.thread</code>（默认1）个日志清理线程负责执行清理任务， 这些线程会选择<strong>“污浊率”</strong>最高的日志文件进行清理。</p><blockquote><p>污浊率：dirtyRatio = dirtyBytes / ( cleanBytes + dirtyBytes ) </p></blockquote></li><li><p>为了防止日志不必要的频繁清理操作，使用参数<code>log.cleaner.min.cleanable.ratio</code>（默认0.5）来限定可进行清理操作的最小污浊率。 Kafka 中用于保存消费者消费位移的主题<strong>＿consumer_offsets使用的就是Log Compaction策略</strong></p></li><li><p>每个日志清理线程会使用一个名为<strong>“SkimpyOffsetMap”</strong>的对象来构建key与offset的映射关系的哈希表（dirty部分）。日志清理需要遍历两次日志文件，第一次遍历把每个 key 的哈希值和最后出现的offset都保存在 SkimpyOffsetMap 中，第二次遍历会检查每个消息是否符合保留条件，符合就保留下来，否则就会被清理.</p></li><li><p>墓碑消息（tombstone）：</p><ul><li>如果一条消息的key不为null，但是其value为null，那么此消息就是墓碑消息。</li><li>日志清理线程发现墓碑消息时会先进行常规的清理，并保留墓碑消息一段时间。墓碑消息的保留条件是所在的日志分段的最近修改时间 lastModifiedTime大于deleteHorizonMs。deleteHorizonMs为clean部分中最后一个日志分段的最近修改时间减去保留阈值deleteRetionMs（通过 broker 端参数<code>log.cleaner.delete.retention.ms</code>配置，默认86400000，即24小时）</li></ul></li><li><p>Log Compaction执行过后的日志分段的大小会比原先的日志分段的要小，为了防止出现太多的小文件，Kafka 在实际清理过程中并不对单个的日志分段进行单独清理，而是将日志文件 中 offset 从 0 至 firstUncleanableOffset 的所有日志分段进行分组，每个日志分段只属于一组 。</p><ul><li><strong>分组策略</strong>为: 按照日志分段的顺序遍历 ，每组中日志分段的占用空间大小之和不超过 segmentSize(可以通过 broker端参数 <code>log.segment.bytes</code> 设置，默认值为 1GB)，且对应的索引文件占用大小之和不超过 maxindexSize (可以通过 broker端参数 <code>log.index.interval.bytes</code>设置，默认值为 I0MB)。同一个组的多个日志分段清理过后，只会生成一个新的日志分段。</li><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123103848.png" alt="image-20211123103847982" style="zoom:80%;" /></li></ul></li></ul><h1 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h1><h2 id="页缓存（pagecache）"><a href="#页缓存（pagecache）" class="headerlink" title="页缓存（pagecache）"></a>页缓存（pagecache）</h2><ul><li><p>页缓存是操作系统实现的一种主要的磁盘缓存，用来减少对磁盘I/O的操作。具体就是把磁盘中的数据缓存到内存中，把对磁盘的访问变成对内存的访问。</p><ul><li>读取：操作系统会先查看数据所在的页（page）是否在页缓存中，如果存在则直接返回，不存在则向磁盘发起读取请求并将读取的数据存入页缓存，之后再将数据返回。</li><li>写入：查看数据所在的页（page）是否在页缓存中，存在则直接修改页缓存，不存在则在页缓存中添加相应的页再写入。被修改过的页变成了脏页，操作系统会在合适的时间把脏页数据写入磁盘以保持数据一致性。</li></ul></li><li><p>Kafka大量使用了页缓存，这是实现高吞吐的重要因素之一。Kafka提供了同步刷盘及间断性强制刷盘的功能，但并不推荐使用。</p></li></ul><h2 id="磁盘I-O流程"><a href="#磁盘I-O流程" class="headerlink" title="磁盘I/O流程"></a>磁盘I/O流程</h2><p>从编程角度而言，一般I/O场景有以下4种，他们的数据流为：</p><ul><li>用户调用标准C库进行I/O操作：用户程序buffer-&gt;C库标准IObuffer-&gt;文件系统页缓存-&gt;通过具体文件系统到磁盘</li><li>用户调用文件I/O：用户程序buffer-&gt;文件系统页缓存-&gt;通过具体文件系统到磁盘</li><li>用户打开文件时使用O_DIRECT，绕过页缓存直接写磁盘</li><li>用户使用类似dd工具，使用direct参数，绕过系统cache与文件系统直接写磁盘</li></ul><p>最长链路数据流图示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123105825.png" alt="image-20211123105825407" style="zoom:80%;" /><p>IO请求处理：通用块层根据 1/0 请求构造一个或多个 bio 结构并提交给调度层；调度器将 bio 结构进行排序和合并组织成队列且确保读写操作尽可能理想: 将一个或多个进程的读操作合并到一起读，将一个或多个进程的写操作合并到一起写，尽可能变随机为顺序 (因为随机读写比顺序读写要慢)，读必须优先满足，而写也不能等太久</p><blockquote><p>针对不同应用场景，I/O调度策略也会影响I/O读写性能，目前Linux提供4中调度策略：NOOP、CFQ（默认）、DEADLINE、ANTICIPATORY。各调度算法的详细描述可查阅5.5.2节，这里不再赘述。</p><p>此外，若想了解linux内核的磁盘io可参考<a href="https://zhuanlan.zhihu.com/p/96391501">该篇博文</a></p></blockquote><h2 id="零拷贝（Zero-Copy）"><a href="#零拷贝（Zero-Copy）" class="headerlink" title="零拷贝（Zero-Copy）"></a>零拷贝（Zero-Copy）</h2><ul><li><p>零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。 对 Linux 操作系统而言，零拷贝技术依赖于底层的sendfile()方法实现。对应于Java 语言，FileChannal.transferTo()的底层实现就是sendfile()。</p></li><li><p>零拷贝和非零拷贝对比</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123110541.png" alt="image-20211123110541773" style="zoom: 40%;" /></li></ul>]]></content>
    
    
    <summary type="html">介绍了Kafka日志存储相关的一些知识点，例如消息的具体存储格式、消息的检索以及消息的清理规则。</summary>
    
    
    
    <category term="中间件" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="《Kafka核心设计与实践原理》阅读笔记" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E3%80%8AKafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="消息中间件" scheme="https://icbtbo.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://icbtbo.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka基础篇：体系架构，生产者，消费者</title>
    <link href="https://icbtbo.github.io/2021/11/16/kafka/kafka%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>https://icbtbo.github.io/2021/11/16/kafka/kafka%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2021-11-16T13:54:18.000Z</published>
    <updated>2022-03-23T02:57:08.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211116220047.png" alt="img" style="zoom: 50%;" /><ul><li>Producer：生产者</li><li>Consumber：消费者</li><li>Broker：服务代理节点（kafka实例）</li></ul><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><ul><li>主题（Topic）：kafka消息以topic为单位进行归类，逻辑概念</li><li>分区（Partition）：<ul><li>Topic-Partition为一对多</li><li>分区在存储层面可看做是一个可追加的日志文件</li><li>消息在追加到分区时会分配一个特定的偏移量（offset）作为在此分区的唯一标示</li><li>kafka通过offset保证消息在分区内的顺序性，但只保证分区有序而不保证主题有序</li><li>Kafka 中的分区可以分布在不同的服务器 (broker)上，也 就是说，一个主题可以横跨多个 broker</li><li>每条消息发送到broker前，会根据分区规则分配到具体的哪个分区</li><li><img src="https://img-blog.csdnimg.cn/20190723125133884.png" alt="img" style="zoom:30%;" /></li></ul></li></ul><h2 id="容灾设计"><a href="#容灾设计" class="headerlink" title="容灾设计"></a>容灾设计</h2><h3 id="多副本机制（Replica）"><a href="#多副本机制（Replica）" class="headerlink" title="多副本机制（Replica）"></a>多副本机制（Replica）</h3><img src="https://img-blog.csdnimg.cn/20190723125246996.png" alt="img" style="zoom:50%;" /><ul><li>一个分区会在多个副本中保存相同的消息</li><li>副本之间是一主多从关系（一个leader副本，若干follower副本，副本数量可通过参数设置）</li><li>leader副本负责读写操作，follower副本只负责同步消息（主动拉取）</li><li>leader副本故障时，从follower副本重新选举新leader</li></ul><h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><ul><li>分区中所有副本统称为 AR（Assigned Replicas）</li><li>所有与leader副本保持<strong>一定程度的同步</strong>的副本（包括leader）组成 ISR（In-Sync Replicas）</li><li>同步滞后过多的副本组成 OSR（Out-of-Sync Replicas）</li></ul><blockquote><p>“<strong>一定程度的同步</strong>”是指可忍受的滞后范围，这个范围可以通过参数<code>replica.lag.time.max.ms</code>进行配置 </p></blockquote><ul><li>ISR的伸缩：<ul><li>从ISR中移出副本<ul><li>Kafka 的副本管理器会启动一个副本过期检测的定时任务，而这个定时任务会定时检查当前时间与副本的 lastCaughtUpTimeMs 差值是否大于参数 <code>replica.lag.time.max.ms</code> 指定的值，若是则从ISR中移出该副本</li><li>当 follower 副本将 leader 副本 LEO (LogEndOffset) 之前的日志全部同步时，则认为该 follower 副本己经追赶上 leader 副本，此时更新该副本的 lastCaughtUpTimeMs 标识为当前时间</li></ul></li><li>将副本移入ISR<ul><li>随着 follower 副本不断与 leader 副本进行消息同步， follower 副本的 LEO 也会逐渐后移 ， 并最终追赶上 leader 副本，此时该 follower 副本就有资格进入 ISR 集合</li><li>追赶上 leader 副本的 判定准则是此副本的 LEO 是否不小于 leader副本的 HW，<strong>注意这里并不是和 leader副本的 LEO 相比</strong></li></ul></li></ul></li></ul><h3 id="特殊偏移量"><a href="#特殊偏移量" class="headerlink" title="特殊偏移量"></a>特殊偏移量</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211116221144.png" alt="img" style="zoom: 60%;" /><ul><li><p>LEO（Log End Offset）：标识当前分区下一条代写入消息的offset</p></li><li><p>HW（High Watermark）：高水位，标识了一个特定的offset，消费者只能拉渠道这个offset之前的消息（不含HW）</p><ul><li>所有副本都同步了的消息才能被消费，HW的位置取决于所有follower中同步最慢的分区的offset</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211116221206.png" alt="img" style="zoom:50%;" /></li></ul><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h2><h3 id="消息发送步骤"><a href="#消息发送步骤" class="headerlink" title="消息发送步骤"></a>消息发送步骤</h3><ul><li><p>配置生产者客户端参数及创建相应的生产者实例</p><ul><li>Properties</li><li>KafkaProducer</li></ul></li><li><p>构建待发送的消息：ProducerRecord</p></li><li><p>发送消息：send( )，flush( )</p></li><li><p>关闭生产者实例：close( )</p></li></ul><h3 id="必要参数配置"><a href="#必要参数配置" class="headerlink" title="必要参数配置"></a>必要参数配置</h3><ul><li><p><code>bootstrap.servers</code>：设置kafka集群地址，并非需要所有broker地址，因为生产者会从给定的broker中获取其他broker信息</p></li><li><p><code>key.serializer</code>、<code>value.serializer</code>：转换字节数组到所需对象的序列化器，填写全限类名</p></li></ul><h3 id="发送模式"><a href="#发送模式" class="headerlink" title="发送模式"></a>发送模式</h3><ul><li>发后即忘（fire-and-forget）：只管往kafka发送而不关心消息是否正确到达，不对发送结果进行判断处理；</li><li>同步（sync）：KafkaProducer.send()返回的是一个Future对象，使用Future.get()来阻塞获取任务发送的结果，来对发送结果进行相应的处理；</li><li>异步（async）：向send()返回的Future对象注册一个Callback回调函数，Kafka在返回响应时调用该函数来实现异步的发送确认逻辑。</li></ul><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ul><li><p>实现<code>ProducerInterceptor</code>接口，在消息发送的不同阶段调用</p><ul><li><code>configure()</code>：完成生产者配置时</li><li><code>onSend()</code>：调用send()后，消息序列化和计算分区之前</li><li><code>onAcknowledgement()</code>：消息被应答之前或消息发送失败时</li><li><code>close()</code>：关闭拦截器时执行一些资源的清理工作</li></ul></li><li><p>通过 <code>interceptor.classes</code> 配置指定</p></li></ul><h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><ul><li>实现<code>Serializer</code>接口，此接口有三个方法<ul><li><code>configure()</code>：用来配置当前类</li><li><code>serialize()</code>：用来执行序列化操作</li><li><code>close()</code>：用来关闭当前的序列化器</li></ul></li></ul><blockquote><p>生产者使用的序列化器和消费者使用的反序列化器是需要一一对应的</p></blockquote><h3 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h3><ul><li>在消息发送到kafka前，需要先计算出分区号，这要依赖分区器，默认使用DefaultPartitioner<ul><li>默认分区器采用MurmurHash2算法，会对key进行哈希，最终根据得到的哈希值来计算分区号， 拥有相同 key 的消息会被写入同一个分区 。 如果key为null，那么消息将会以轮询的方式发往主 题内的各个可用分区</li></ul></li><li>自定义分区器：<ul><li>实现<code>Partitioner</code>接口，此接口有两个方法<ul><li>partition()：用来计算分区号</li><li>close()：用来在关闭分区器的时候回收一些资源</li></ul></li><li>通过<code>partitioner.class</code>配置指定</li></ul></li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><img src="https://img-blog.csdnimg.cn/20190723125338632.png" alt="img" style="zoom: 40%;" /><ul><li>主线程KafkaProducer创建消息，通过可能的拦截器、序列化器和分区器之后缓存到消息累加器（RecordAccumulatro）</li><li>消息在RecordAccumulator被包装成ProducerBatch(一个批次的消息，即一个至多个消息)，以便Sender线程可以批量发送。生产者发送消息的速度超过发送到服务器的速度时，会导致生产者的空间不足，<code>send()</code>方法会被阻塞或抛异常<ul><li>RecordAccumulatro缓存的大小通过<code>buffer.memory</code>配置，阻塞时间通过<code>max.block.ms</code>配置</li></ul></li><li>Kafka生产者客户端中，通过ByteBuffer实现消息内存的创建和释放，而RecordAccumulator内部有一个BufferPool用来实现ByteBuffer的复用<ul><li>BufferPool只针对<strong>特定大小</strong>的ByteBuffer进行管理，而其他大小的ByteBuffer不会缓存进BufferPool中，这个特定的大小由 <code>batch.size</code> 参数来指定(默认16384B， 即16KB)</li></ul></li><li>Sender从RecordAccumulator中获取缓存的消息后，将ProducerBatch按Node分组，转换成&lt;Node, List<ProducerBatch>&gt;的形式，Node代表broker节点。也就是说sender只向具体broker节点发送消息，而不关注属于哪个分区，这里是应用逻辑层面到网络层面的转换。<ul><li>在转换成&lt;Node, List<ProducerBatch>&gt;的形式之后， Sender 还会进一步将消息封装成&lt;Node, Request&gt;的形式，这样就可以将 Request 请求发往各个 Node了</li></ul></li><li>Sender将请求发往Kafka前，还会保存到InFlightRequests中，其主要作用是缓存已经发出去但还没收到响应的请求，也是以Node分组。<ul><li>每个连接最大缓存未响应的请求数通过<code>max.in.flight.requests.per.connection</code>配置(默认5)</li></ul></li></ul><blockquote><p>若请求返回异常，则可进行重试，重试次数可自行指定</p></blockquote><h3 id="元数据的更新"><a href="#元数据的更新" class="headerlink" title="元数据的更新"></a>元数据的更新</h3><ul><li>元数据是指 Kafka 集群的元数据，这些元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的 leader 副本分配在哪个节点上， follower副本分配在哪些节点上，哪些副本在 AR、 ISR 等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。</li><li>当客户端中没有需要使用的元数据信息或超过metadata.max.age.ms没有更新元数据时，就会引起元数据更新操作。</li><li>当需要更新元数据时，会先挑选出 leastLoadedNode, 然后 向这个Node发送 MetadataRequest请求来获取具体的元数据信息。这个更新操作是由 Sender 线程发起的， 在创建完 MetadataRequest之后同样会存入 InFlightRequests，之后的步骤就和发送消息时类似。 </li><li>InFlightRequests可以获得leastLoadedNode，即所有Node中负载最小的那一个。选择 leastLoadedNode 发送请求可以使它能够尽快发出，避免因网络拥塞等异常而影响整体的进度。leastLoadedNode一般用于元数据请求、消费者组播协议等交互。</li></ul><h2 id="重要的生产者参数"><a href="#重要的生产者参数" class="headerlink" title="重要的生产者参数"></a>重要的生产者参数</h2><ul><li><p><code>acks</code>：用来指定分区中有多少个副本收到这条消息，才认为生产者写入成功并对请求进行响应（默认”1”）</p><ul><li>“1”：leader写入即成功、“0”：不需要等待服务端响应、”-1”/“all”：ISR所有副本都写入才收到响应</li></ul></li><li><p><code>max.request.size</code>：限制生产者客户端能发送的消息的最大值（默认1048576，即1m）</p></li><li><p><code>retries、retry.backoff.ms</code>：生产者重试次数（默认0）和两次重试之间的间隔（默认100）</p></li><li><p><code>compression.type</code>：消息压缩方式，可配置为”gzip”、”snappy”、”lz4”（默认”none”）</p></li><li><p><code>connections.max.idle.ms</code>：多久后关闭闲置的连接（默认540000，9分钟）</p></li><li><p><code>linger.ms</code>：生产者发送ProducerBatch之前等待更多消息（ProducerRecord）加入的时间（默认为0）</p></li><li><p><code>receive.buffer.bytes</code>：Socket接收消息缓冲区的大小（默认32768，32k）</p></li><li><p><code>send.buffer.bytes</code>：Socket发送消息缓冲区的大小（默认131072，128k）</p></li><li><p><code>request.timeout.ms</code>：Producer等待请求响应的最长时间（默认30000ms），这个值需要比broker参数<code>replica.lag.time.max.ms</code>大(该参数配置ISR中的follower和leader副本间可容忍的滞后范围)</p></li></ul><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费者与消费组"><a href="#消费者与消费组" class="headerlink" title="消费者与消费组"></a>消费者与消费组</h2><ul><li>每个分区只能被一个消费组的一个消费者消费<ul><li>当一个消费组内的消费者数大于分区数时，会有消费者分配不到分区而无法消费任何消息</li></ul></li><li>消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个钱程，也可以是一个进程。</li></ul><h2 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h2><h3 id="消费步骤"><a href="#消费步骤" class="headerlink" title="消费步骤"></a>消费步骤</h3><ul><li>配置消费者客户端参数及创建KafkaConsumer实例</li><li>订阅主题</li><li>拉取消息并消费</li><li>提交消费位移</li><li>关闭实例</li></ul><h3 id="必要的参数配置"><a href="#必要的参数配置" class="headerlink" title="必要的参数配置"></a>必要的参数配置</h3><ul><li><code>bootstrap.servers</code>：集群broker地址清单</li><li><code>group.id</code>：消费组名称</li><li><code>key.deserializer</code>、<code>value.deserializer</code>：反序列化器</li></ul><h3 id="订阅主题和分区"><a href="#订阅主题和分区" class="headerlink" title="订阅主题和分区"></a>订阅主题和分区</h3><ul><li><code>subscribe()</code>：订阅主题，既可以以集合的形式订阅多个主题，也可以以正则表达式的形式订阅特定模式的主题</li><li><code>assign()</code>：订阅指定主题的指定分区<ul><li>如果我们事先并不知道主题中有多少个分区怎，则可通过<code>partitionFor()</code>方法先获取指定主题的元数据信息（包括分区信息）</li></ul></li><li><code>unsubscribe()</code>：取消订阅<ul><li>如果将 <code>subscribe(Collection)</code>或 <code>assign(Collection)</code>中的集合参数设置为空集合 ，那么作用等同于<code>unsubscribe()</code>方法 </li></ul></li></ul><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><ul><li><code>poll()</code>：返回的是所订阅的主题(分区)上的一组消息，可设定timeout参数来控制阻塞时间（返回的是还没有被消费过的消息集）</li><li><code>pause()</code>、<code>resume()</code>：暂停和恢复某分区的消费</li><li><code>seek()</code>：按指定分区的指定offset消费</li><li><code>beginingOffsets()</code>，<code>endOffsetes()</code>，<code>offstesForTimes()</code>：分别获取指定分区开头的位置、指定分区末尾的位置或时间戳大于等于待查询时间的第一条消息对应的位置和时间戳 </li><li><code>seekToBeginning</code>、<code>seekToEnd()</code>：从指定分区的开头、末尾开始消费</li></ul><h3 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h3><p>每次调用<code>poll()</code>方法时，返回的是还没有被消费过的消息集，要做到这一点，就需要记录上一次消费时的消费位移。在旧消费者客户端中，消费位移是存储在 ZooKeeper中的。而在新消费者客户端中，消费位移存储在 Kafka 内部的主题 consumer offsets 中 。 </p><ul><li>提交的offset为 lastConsumedOffset + 1<ul><li>lastConsumedOffset：上一次poll拉取到的分区的最后一条消息的offset</li></ul></li><li>自动提交<ul><li>Kafka 中默认的消费位移的提交方式是自动提交，由消费者客户端参数<code>enable.auto.commit</code>配置，默认值为 true</li><li>该自动提交是定期提交，定期的周期时间由客户端参数<code>auto.commit.interval.ms</code>配置，默认值为5秒。（此参数生效的前提是 <code>enable.auto.commit</code> 参数为 true）</li><li>自动提交位移的方式非常简便，但会导致重复消费和消息丢失的问题</li></ul></li><li>手动提交<ul><li>开启手动提交功能的前提是消费者客户端参数<code>enable.auto.commit</code>配置为 false</li><li>同步提交：<code>commitSync()</code>，会阻塞消费者线程直至位移提交完成</li><li>异步提交：<code>commitAsync()</code>，不会阻塞消费者线程，可能在提交结果未返回之前就开始了新一轮的拉取操作</li></ul></li></ul><h3 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h3><p>再均衡是指分区的所属权从一个消费者转移到另一消费者的行为，它为消费组具备高可用性和伸缩性提供保障，使我们可以既方便又安全地删除消费组内的消费者或往消费组内添加消费者。</p><ul><li><p>在再均衡发生期间，消费组内的消费者是无法读取消息的</p></li><li><p>当 一个分区被重新分配给另一个消费者时， 消费者当前的状态也会丢失。（当一个消费者A还没提交消费位移就发生了再均衡时，该分区分配的另一个消费者B会重新消费该分区已被A消费的消息）</p></li><li><p>在<code>subcribe()</code>时，可以注册一个实现<code>ConsumerRebalanceListener</code>接口的监听器，该接口有两个方法</p><ul><li><p><code>onPartionsRevoked()</code>：该方法会在再均衡开始之前和消费者停止读取消息之后被调用</p></li><li><p><code>onPartitionsAssigned()</code>：该方法会在重新分配分区之后和消费者开始读取消费之前被调用</p></li></ul></li></ul><h3 id="自定义拦截器-1"><a href="#自定义拦截器-1" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ul><li>实现ConsumerInterceptor接口，该接口有以下方法<ul><li><code>configure()</code>：完成消费者配置时</li><li><code>onConsume()</code>：在poll()方法返回之前调用</li><li><code>onCommit()</code>：在提交完消费位移之后调用</li><li><code>close()</code>：关闭拦截器时执行一些资源的清理工作</li></ul></li></ul><h3 id="自定义反序列化器"><a href="#自定义反序列化器" class="headerlink" title="自定义反序列化器"></a>自定义反序列化器</h3><p>实现<code>Deserializer</code>接口，此接口有三个方法</p><ul><li><code>configure()</code>：用来配置当前类</li><li><code>deserialize()</code>：用来执行反序列化操作</li><li><code>close()</code>：用来关闭当前的反序列化器</li></ul><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><ul><li><p>KafkaProducer是线程安全的，但KafkaConsumer是非线程安全的。KafkaConsumer 中定义了一个<code>acquire()</code>方法可检测当前是否只有一个线程在操作，否则抛出异常.</p></li><li><p>推荐使用单线程消费，而消息处理用多线程，如下图所示.</p><img src="https://img-blog.csdnimg.cn/20190723125353939.png" alt="img" style="zoom:50%;" /></li><li><p>消费者的更多多线程实现可查阅《深入理解kafka：核心设计和实践原理》3.2.10节内容</p></li></ul><h2 id="重要的消费者参数"><a href="#重要的消费者参数" class="headerlink" title="重要的消费者参数"></a>重要的消费者参数</h2><ul><li><code>fetch.min.bytes</code>：一次请求能拉取的最小数据量（默认1b）</li><li><code>fetch.max.bytes</code>：一次请求能拉取的最大数据量（默认52428800b，50m）</li><li><code>fetch.max.wait.ms</code>：与min.bytes有关，指定kafka拉取时的等待时间（默认500ms）</li><li><code>max.partition.fetch.bytes</code>：从每个分区里返回Consumer的最大数据量（默认1048576b，1m）</li><li><code>max.poll.records</code>：一次请求拉取的最大消息数（默认500）</li><li><code>connections.max.idle.ms</code>：多久后关闭闲置连接，默认（540000，9分钟）</li><li><code>receive.buffer.bytes</code>：Socket接收消息缓冲区的大小（默认65536，64k）</li><li><code>send.buffer.bytes</code>：Socket发送消息缓冲区的大小（默认131072，128k）</li><li><code>request.timeout.ms</code>：Consumer等待请求响应的最长时间（默认30000ms）</li><li><code>metadata.max.age.ms</code>：元数据过期时间（默认30000，5分钟）</li><li><code>reconnect.backoff.ms</code>：尝试重新连接指定主机前的等待时间（默认50ms）</li><li><code>retry.backoff.ms</code>：尝试重新发送失败请求到指定主题分区的等待时间（默认100ms）</li><li><code>isolation.level</code>：消费者的事务隔离级别（具体查看进阶篇：事务）</li></ul><h1 id="主题与分区"><a href="#主题与分区" class="headerlink" title="主题与分区"></a>主题与分区</h1><h2 id="主题的管理"><a href="#主题的管理" class="headerlink" title="主题的管理"></a>主题的管理</h2><ul><li><p>创建</p><ul><li>自动创建：broker设置<code>auto.create.topics.enable</code>=true时，生产者发送消息时会自动创建分区数为<code>num.partitions</code>(默认1)，副本因子为<code>default.replication.facto</code>r(默认1)的主题</li><li>通过kafka-topics.sh创建：<code>create</code>指令<ul><li><code>kafka-topics.sh  --zookeeper &lt;zkpath&gt; --create --topic &lt;topic&gt; --partitions &lt;N&gt; --replication-factor &lt;N&gt;</code></li><li>手动分配副本：<code>--replica-assignment</code><ul><li><code>--replica-assignment 2:0:1,1:2:0,0:1:2 partion1 AR：2,0,1 partion2 AR：1:2:0 partion3 AR：0:1:2</code></li><li>设定参数：<code>--config &lt;key=value&gt;</code></li></ul></li></ul></li></ul></li><li><p>分区副本的分配</p><ul><li>使用kafka-topics.sh创建主题内部分配逻辑按机架信息划分两种策略：<ul><li>未指定机架信息分配策略：<code>assignReplicasToBrokersRackUnaware()</code>方法</li><li>指定机架分配策略：<code>assignReplicasToBrokersRackAware()</code>方法</li></ul></li></ul></li></ul><blockquote><p>当创建一个主题时，不管用什么方式，实质上是在zk的/broker/topics节点下创建与该主题对应的子节点并写入分区副本分配方案，并且在/config/topics节点下创建与该主题相关的子节点并写入主题配置信息</p></blockquote><ul><li><p>查看：kafka-topics.sh脚本的 <code>list</code>、<code>describe</code>指令</p></li><li><p>修改：kafka-topics.sh脚本的 <code>alter</code>指令</p></li><li><p>配置管理：kafka-configs.sh脚本</p></li><li><p>删除：kafka-topics.sh脚本的 <code>delete</code>指令</p></li></ul><h2 id="初识KafkaAdminClient"><a href="#初识KafkaAdminClient" class="headerlink" title="初识KafkaAdminClient"></a>初识KafkaAdminClient</h2><ul><li><strong>KafkaAdminClient</strong>：一般情况下 ，我们都习惯使用 kafka-topics.sh脚本来管理主题，但有些时候我们希望将主题管理类的功能集成到公司内部的系统中， 打造集管理、监控、运维、告警为一体的生态平台， 那么就需要以程序调用 API 的方式去实现，KafkaAdminClient提供了这些API。具体的API不在本文中列出，有需要可以自行查阅相关文档。</li><li><strong>主题合法性验证</strong>：普通用户在通过KafkaAdminClient 管理主题时，有可能由于误操作或其他原因而创建了不符合运维规范的主题（比如命名不规范，副本因子数太低等），这些会影响后期的系统运维 。我们可以在broker端设置<code>create.topic.policy.class.name</code>来指定一个类验证主题创建时的合法性，这个类需要实现ClreateTopicPolicy接口。</li></ul><h2 id="分区的管理"><a href="#分区的管理" class="headerlink" title="分区的管理"></a>分区的管理</h2><ul><li><p>优先副本（preferred replica/preferred leader）</p><ul><li><p>优先副本即 AR 集合中的第一个副本，kafka保证了优先副本的均衡分布。<strong>优先副本选举就是对分区leader副本进行选举的时候，尽可能让优先副本成为leader副本，从而保证负载均衡</strong></p><blockquote><p><a href="https://juejin.cn/post/7000552764119973902">优先副本的作用可看这篇博文</a></p></blockquote></li><li><p>kafka-perferred-replica-election.sh可进行优先副本选举操作</p></li></ul></li><li><p>分区重分配</p><ul><li><p>何时需要进行：</p><ul><li><p>需要将某节点上的分区副本迁移至其他节点时(例如宕机迁移失效副本或有计划下线节点迁移副本时）</p><blockquote><p>注意，下线前最好先关闭或重启此broker，保证不是leader节点，减少了节点间流量复制</p></blockquote></li><li><p>需要向新增节点分配原有主题分区副本时</p><blockquote><p>集群中新增节点时，只有新创建的主题分区才有可能分配到新节点上，因此需要把老主体的分区分配到新节点上，否则会造成新节点和原来的节点之间的负载不均衡</p></blockquote></li></ul></li><li><p>如何进行：可使用kafka-reassign-partitions.sh脚本</p></li></ul></li><li><p>复制限流</p><ul><li>数据复制会占用额外的资源，如果重分配的量太大必然会严重影响整体的性能。可以通过对副本间的复制流量加以限制来保证重分配期间整体服务不会受太大的影响，可分别限制follower副本复制速度和leader副本传输速度</li><li>通过kafka-config.sh或 kafka-reassign-partitions.sh配置<ul><li>broker级别：follower/leader.replication.throttled.rate=N</li><li>topic级别：follower/leader.replication.throttled.replicas=N</li></ul></li><li>分区重分配过程中的临时限流策略（在进行相应配置后）<ul><li>原AR会应用leader限流配置</li><li>分区移动的目的地会应用follower限流配置</li><li>重分配所需的数据复制完成后，临时限流策略会被移除</li></ul></li></ul></li><li><p>修改副本因子</p><ul><li>通过kafka-reassign-partitions.sh配置</li></ul></li><li><p>如何选择合适的分区数</p><ul><li>性能测试工具<ul><li>生产者性能测试：kafka-producer-perf-test.sh脚本</li><li>消费者性能测试：kafka-consumer-perf-test.sh脚本</li></ul></li><li>分区数和吞吐量的关系<ul><li>在一定限度内，吞吐量随分区数增加而上升，但由于磁盘、文件系统、I/O调度策略等影响，到一定程度时吞吐量会存在瓶颈或有所下降</li></ul></li><li>考量因素<ul><li>分区数会占用文件描述符，而一个进程所能支配的文件描述符是有限的，这也是通常所说的文件句柄的开销</li><li>如果分区数过多，当集群中某个broker宕机，就会有大量分区需要进行leader角色切换，这个过程会耗费一定的时间，并且在此期间这些分区不可用。分区数越多，kafka的正常启动和关闭耗时也会越长，同时也会增加日志清理的耗时</li><li>建议将分区数设定为broker的倍数</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">介绍了kafka的体系架构、生产者与消费者的原理和使用方式。</summary>
    
    
    
    <category term="中间件" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="《Kafka核心设计与实践原理》阅读笔记" scheme="https://icbtbo.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E3%80%8AKafka%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%8E%9F%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="消息中间件" scheme="https://icbtbo.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://icbtbo.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>synchronized与锁</title>
    <link href="https://icbtbo.github.io/2021/09/11/synchronized%E4%B8%8E%E9%94%81/"/>
    <id>https://icbtbo.github.io/2021/09/11/synchronized%E4%B8%8E%E9%94%81/</id>
    <published>2021-09-11T11:01:57.000Z</published>
    <updated>2021-09-11T13:06:08.597Z</updated>
    
    <content type="html"><![CDATA[<p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。</p><p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。</p><p><strong>注意</strong>：不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的，在<a href="https://www.jianshu.com/p/9932047a89be">这篇博文</a>中提及。</p><blockquote><p>首先需要明确的一点是：<strong>Java多线程的锁都是基于对象的</strong>，Java中的每一个对象都可以作为一个锁。</p><p>还有一点需要注意的是，我们常听到的<strong>类锁</strong>其实也是对象锁。</p><p>Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。</p></blockquote><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>前面我们提到，Java的锁都是基于对象的。首先我们来看看一个对象的“锁”的信息是存放在什么地方的。</p><p>每个Java对象都有对象头。如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。对象头的内容如下表：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果是数组）</td></tr></tbody></table><p>我们主要来看看Mark Word的格式：</p><table><thead><tr><th>锁状态</th><th>29 bit 或 61 bit</th><th>1 bit 是否是偏向锁？</th><th>2 bit 锁标志位</th></tr></thead><tbody><tr><td>无锁</td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID、epoch</td><td>1</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>此时这一位不用于标识偏向锁</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>此时这一位不用于标识偏向锁</td><td>10</td></tr><tr><td>GC标记</td><td></td><td>此时这一位不用于标识偏向锁</td><td>11</td></tr></tbody></table><p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><blockquote><p>大白话就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为false，代表存在其他线程竞争资源，那么就会走后面的流程。</p></blockquote><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><p>一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。</p><p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：</p><ul><li>成功，表示之前的线程不存在了，或时还存在但当前执行位置已经不在同步块中， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li><li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li></ul><blockquote><p>CAS: Compare and Swap</p><p>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p></blockquote><p>图中涉及到了lock record指针指向当前堆栈中的最近一个lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。</p><h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol><p>所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseBiasedLocking=<span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><p>下面这个经典的图总结了偏向锁的获得和撤销：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210911190753.png" alt="img" style="zoom:67%;" /><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。</p><h4 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h4><p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p><p>然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><blockquote><p>自旋：不断尝试去获取锁，一般用循环来实现。</p></blockquote><p>自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p><p>但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p><p><strong>轻量级锁的释放：</strong></p><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><p>一张图说明加锁和释放锁的过程：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210911190825.png" alt="img" style="zoom:67%;" /><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><p>前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Contention List：所有请求锁的线程将被首先放置到该竞争队列</span><br><span class="line">Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</span><br><span class="line">Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</span><br><span class="line">OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</span><br><span class="line">Owner：获得锁的线程称为Owner</span><br><span class="line">!Owner：释放锁的线程</span><br></pre></td></tr></table></figure><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到Contention List的队列的队首，然后调用<code>park</code>函数挂起当前线程。</p><p>当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。</p><p>如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p><h3 id="总结锁的升级流程（重要）"><a href="#总结锁的升级流程（重要）" class="headerlink" title="总结锁的升级流程（重要）"></a>总结锁的升级流程（重要）</h3><p>每一个线程在准备访问同步块时：</p><p>第一步，在当前线程的栈帧中创建用于存储锁记录的空间，我们称为<code>Displaced Mark Word</code>，并把锁的<code>MarkWord</code>复制到这块空间中。</p><p>第二步，检查<code>MarkWord</code>里面是不是放的自己的ThreadId ,如果是，表示当前线程获取了 “偏向锁” 。</p><p>第三步，如果<code>MarkWord</code>中不是自己的<code>ThreadId</code>，则当前线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停（在安全点暂停），在暂停线程后，会通过遍历当前jvm的所有线程的方式，检查持有偏向锁的线程状态是否存活：</p><ul><li><p>如果之前线程还存活，且其正在执行同步代码块中的代码，则将锁升级为轻量级锁，唤醒暂停的线程，从安全点继续执行代码。然后继续第四步的流程。</p></li><li><p>如果之前持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：</p><ul><li><p>不允许重偏向，则<strong>撤销偏向锁，将<code>MarkWord</code>设为无锁状态，然后再升级为轻量级锁</strong>。最后唤醒暂停的线程，从安全点继续执行代码（若之前线程还存活），继续第四步的流程。</p></li><li><p>允许重偏向，<strong>将<code>MarkWord</code>设置为匿名偏向锁状态，然后当前线程通过CAS将偏向锁重新指向自己</strong>。最后唤醒暂停的线程，从安全点继续执行代码（若之前线程还存活）。</p><blockquote><p><a href="https://jacobchang.cn/lock-of-synchronized.html">重偏向资料</a></p></blockquote></li></ul></li></ul><p>第四步，当前线程尝试通过CAS修改<code>MarkWord</code>来获取轻量级锁</p><ul><li>若成功，则当前线程获取到了轻量级锁，结束流程。</li><li>若失败，则尝试自旋获取锁。若自旋过程中获得了锁，则结束流程，否则继续下一步。</li></ul><p>第五步，（此时当前线程自旋失败）修改锁标志位，将轻量级锁升级为重量级锁，然后阻塞当前线程，等待之前线程执行完成并唤醒自己（之前线程执行完后，会唤醒所有阻塞的线程）。</p><p>第六步，线程被唤醒后重新和其他被唤醒的线程争夺访问同步块。</p><p>更详细的锁升级流程图如下所示（其中）：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210911182145.jpg" alt="preview"></p><h3 id="各种锁的优缺点对比"><a href="#各种锁的优缺点对比" class="headerlink" title="各种锁的优缺点对比"></a>各种锁的优缺点对比</h3><p>下表来自《Java并发编程的艺术》：</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无锁状态&lt;/li&gt;
&lt;li&gt;偏向锁</summary>
      
    
    
    
    <category term="java" scheme="https://icbtbo.github.io/categories/java/"/>
    
    <category term="java并发" scheme="https://icbtbo.github.io/categories/java/java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="java" scheme="https://icbtbo.github.io/tags/java/"/>
    
    <category term="锁" scheme="https://icbtbo.github.io/tags/%E9%94%81/"/>
    
    <category term="synchronized" scheme="https://icbtbo.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>os：IO子系统</title>
    <link href="https://icbtbo.github.io/2021/09/09/os/os%EF%BC%9AIO%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://icbtbo.github.io/2021/09/09/os/os%EF%BC%9AIO%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-09-09T03:28:01.000Z</published>
    <updated>2021-09-09T11:33:56.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O分类"><a href="#I-O分类" class="headerlink" title="I/O分类"></a>I/O分类</h2><p>三种常见的设备<strong>接口类型</strong></p><ul><li><strong>字符设备</strong>：键鼠、串口等</li><li><strong>块设备</strong>：磁盘驱动器、磁带驱动器、光驱等</li><li><strong>网络设备</strong>：以太网、无线、蓝牙等</li></ul><p>设备<strong>访问特征</strong>：</p><ul><li><strong>字符设备</strong>：以字节为单位顺序访问；I/O命令使用get()、put()等，通常使用文件访问接口和语义</li><li><strong>块设备</strong>：均匀的数据块访问；I/O命令使用 原始I/O 或 文件系统接口 或 内存映射文件访问</li><li><strong>网络设备</strong>：格式化报文交换；I/O命令使用send/receive网络报文，通过网络接口支持多种网络协议</li></ul><p>同步与异步I/O：</p><ul><li>阻塞I/O Wait<ul><li>读数据时 进程进入等待状态 直到完成数据读出</li><li>写数据时 进程进入等待状态 直到设备完成数据写入处理</li></ul></li><li>非阻塞I/O Don’t Wait(可能会失败 或者少写)<ul><li>立即从read或write系统调用返回 返回值为成功传输的字节数</li><li>read或write的传输字节数可能为0</li></ul></li><li>异步I/O Tell Me Later<ul><li>读数据时 使用指针标记好用户缓冲区 立即返回 稍后内核将填充缓冲区并通知用户</li><li>写数据时 使用指针标记好用户缓冲区 立即返回 稍后内核将处理数据并通知用户</li></ul></li></ul><blockquote><p>IO请求的流程：</p><ol><li>用户发起 I/O请求</li><li>请求会发送到内核中的设备驱动</li><li>设备驱动将其转换为对硬件的控制</li><li>硬件控制完成之后 会产生中断 由内核的中断处理例程进行响应</li><li>回到设备驱动进行相应处理，最后回到用户态</li></ol><p>I/O请求的流程图可看下方I/O结构章节中的I/O请求生命周期</p></blockquote><h2 id="I-O结构"><a href="#I-O结构" class="headerlink" title="I/O结构"></a>I/O结构</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909151459.png" alt="Device_Connects_CPU" style="zoom:50%;" /><ul><li><p>设备控制器</p><ul><li>CPU和I/O设备间的接口</li><li>向CPU提供特殊指令和寄存器</li></ul></li><li><p>I/O地址</p><ul><li><p>CPU用来控制I/O硬件</p></li><li><p>内存地址或端口号：基于I/O指令或内存映射I/O</p><ul><li><p>I/O指令</p><ul><li>通过I/O端口号访问设备寄存器</li><li>特殊的CPU指令：out 0x21,AL</li></ul></li><li><p>内存映射I/O</p><ul><li>设备的寄存器/存储被映射到内存物理地址空间中</li><li>通过内存load/store指令完成I/O操作</li><li>MMU设置映射，硬件跳线或程序在启动时设置地址</li></ul></li></ul></li></ul></li><li><p>CPU与设备的通信方式</p><ul><li>轮询(CPU直接访问I/O端口或者是映射到的内存地址，不用中断控制器)</li><li>设备中断</li><li>DMA(将数据直接放到内存)</li></ul></li></ul><h3 id="内核I-O结构"><a href="#内核I-O结构" class="headerlink" title="内核I/O结构"></a>内核I/O结构</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909152232.png" alt="Kernel_I_O_Subsystem" style="zoom: 45%;" /><h3 id="I-O请求生命周期"><a href="#I-O请求生命周期" class="headerlink" title="I/O请求生命周期"></a>I/O请求生命周期</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909152251.png" alt="Life_cycle_of_I_O_Request" style="zoom:50%;" /><h2 id="I-O数据传输"><a href="#I-O数据传输" class="headerlink" title="I/O数据传输"></a>I/O数据传输</h2><ul><li>程序控制I/O(PIO Programmed I/O)<ul><li>通过CPU的 in/out 或者 load/store 传输所有数据</li><li>硬件简单 编程容易</li><li>消耗的CPU时间和数据量成正比</li><li>适用于简单的、小型的设备I/O</li></ul></li><li>直接内存访问(DMA)<ul><li>设备控制器可直接访问系统总线</li><li>控制器直接与内存互相传输数据</li><li>设备传输数据不影响CPU</li><li>需要CPU参与设置</li><li>适用于高吞吐量I/O</li></ul></li></ul><blockquote><p>DMA传输数据的操作：</p><ul><li>首先，CPU通过设置其寄存器来对DMA控制器进行编程，以使其知道在何处传输（下图中的步骤1）。<br><strong>它还向磁盘控制器发出命令，告诉它从磁盘读取数据到其内部缓冲区</strong>中并验证校验和。</li><li>当有效数据位于磁盘控制器的缓冲区中时，DMA可以开始。 <strong>DMA控制器通过通过总线向磁盘控制器</strong>发出读取请求来启动传输（步骤2）。该读取请求看起来与任何其他读取请求一样，并且磁盘控制器不知道（或不在乎）它是来自CPU还是来自DMA控制器。通常，<strong>要写入的内存地址在总线的地址线上，因此，当磁盘控制器从其内部缓冲区中获取下一个Word时，它就知道将其写入哪里。</strong>写入存储到存储器是另一个标准的总线周期（步骤3）。</li><li>写入完成后，磁盘控制器也会通过总线将确认信号发送到DMA控制器（步骤4）。然后，DMA控制器增加要使用的内存地址，并减少字节数。如果字节计数仍大于0，则重复步骤2至4，直到计数达到0。</li><li>那时，DMA控制器中断CPU，以通知传输现在已完成。操作系统启动时，不必将磁盘块复制到内存；它已经在那里。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909155807.png" alt="image-20210909155807745"></p></blockquote><p>有时操作系统需要了解设备的状态（例如I/O操作完成的时间、I/O操作期间遇到的错误等），那么如何获悉这些状态呢？</p><p>有两种方式：<strong>轮询</strong>和<strong>设备中断</strong></p><p><strong>轮询</strong>：</p><p>I/O设备在特定的状态寄存器中放置状态和错误信息，操作系统定期检测这些状态寄存器。</p><p>特点：</p><ul><li>简单</li><li>I/O操作频繁或不可预测时，开销大(因为I/O频繁)和延时长(因为不可预测)</li></ul><p><strong>设备中断</strong>：</p><p>设备中断处理例程</p><ol><li>CPU在 I/O 之前设置任务参数</li><li>CPU发出 I/O请求后 继续执行其他任务</li><li>I/O设备处理 I/O请求</li><li>I/O设备处理完成时 触发CPU中断请求</li><li>CPU接受中断 分发到相应中断处理例程</li></ol><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909160949.png" alt="Device_Interrupts" style="zoom: 33%;" /><p>特点：</p><ul><li>处理不可预测时间效果好(CPU会在每两条指令执行间隔去检查是否有中断请求)</li><li>开销相对较高(CPU中断频率太高)</li></ul><blockquote><p>轮询和设备中断方式各有优缺点，因此一些设备可能结合了轮询和设备中断。例如高带宽网络设备，它<strong>在第一个传入数据包到达前采用中断，之后轮询后面的数据包直到硬件缓存为空</strong>。</p></blockquote><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>磁盘I/O传输时间主要由寻道时间、旋转延时和数据传送时间组成，其中寻道时间所消耗的时间最长。因此，我们主要针对磁盘调度（磁盘访问请求顺序）进行优化，从而减少寻道时间。</p><p>接下来介绍一些常见的磁盘调度算法。</p><h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><p>按顺序处理请求，<strong>根据进程请求访问磁盘的先后顺序进行调度</strong>。</p><ul><li>公平对待所有进程</li><li>在有很多进程的情况下，接近随机调度的性能</li></ul><h3 id="最短服务时间优先-SSTF"><a href="#最短服务时间优先-SSTF" class="headerlink" title="最短服务时间优先(SSTF)"></a>最短服务时间优先(SSTF)</h3><p>选择从磁臂当前位置需要<strong>移动最少距离</strong>的I/O请求。</p><ul><li>可以保证每次寻道时间最短，但是不能保证总的寻道时间最短</li></ul><h3 id="扫描算法-SCAN"><a href="#扫描算法-SCAN" class="headerlink" title="扫描算法(SCAN)"></a>扫描算法(SCAN)</h3><p>磁臂在一个方向上移动，访问所有未完成的请求，<strong>只有移动到该方向的最外侧磁道或最内侧磁道才可以反向移动</strong>（即便在磁头移动的方向上已经没有请求，仍然必须移动到最内/外侧的磁道）。由于磁头移动的方式很像电梯，因此也被称为电梯算法(elevator algorithm)</p><ul><li>各个位置磁道的响应频率不平均（C-SCAN算法改进了这个缺点）</li></ul><h3 id="循环扫描算法-C-SCAN"><a href="#循环扫描算法-C-SCAN" class="headerlink" title="循环扫描算法(C-SCAN)"></a>循环扫描算法(C-SCAN)</h3><p>与SCAN相比，规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至最靠边缘的的磁道上（即另一端）而途中不处理任何请求</strong>。</p><ul><li><p>相比于SCAN算法，对于各个位置磁道响应频率比较平均，但平均寻道时间增加了</p></li><li><p>此外，就算磁盘边缘没有I/O请求的磁道也要走到头，浪费了时间。（ C-LOOK算法改进了这个缺点）</p></li></ul><h3 id="LOOK算法和C-LOOK算法"><a href="#LOOK算法和C-LOOK算法" class="headerlink" title="LOOK算法和C-LOOK算法"></a>LOOK算法和C-LOOK算法</h3><p>釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最边缘的被请求的磁道即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。</p><p><strong>注意，若无特别说明，也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度。</strong></p><h3 id="N步扫描-N-Step-SCAN-算法"><a href="#N步扫描-N-Step-SCAN-算法" class="headerlink" title="N步扫描(N-Step-SCAN)算法"></a>N步扫描(N-Step-SCAN)算法</h3><p>用于解决<strong>磁头粘着</strong>问题。</p><blockquote><p>磁头粘着(Arm Stickiness)现象：SSTF SCAN CSCAN等算法中，可能出现的磁头停留在某处不动的情况（例如进程反复请求对某一磁道的I/O操作可能会导致该现象）</p></blockquote><ul><li>将磁盘请求队列分成长度为N的子队列</li><li>子队列间：按FIFO算法依次处理所有子队列</li><li>子队列内：用扫描算法处理每个队列</li></ul><h3 id="双队列扫描算法-FSCAN"><a href="#双队列扫描算法-FSCAN" class="headerlink" title="双队列扫描算法(FSCAN)"></a>双队列扫描算法(FSCAN)</h3><p>FSCAN算法是N步扫描算法的简化，只将磁盘请求队列分成两个子队列，这样可以减少平均等待时间</p><ul><li>把磁盘I/O请求分成两个队列</li><li>交替使用扫描算法处理一个队列</li><li>新生成的磁盘I/O请求放入另一队列中 所有的新请求都将被推迟到下一次扫描时处理</li></ul><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><blockquote><p><strong>缓存</strong>：数据传输双方访问速度差异很大时，引入的速度匹配中间层</p></blockquote><p>磁盘缓存是磁盘扇区在内存中的缓存区</p><ul><li>磁盘缓存的调度算法很<strong>类似虚拟存储</strong>调度算法</li><li>磁盘的访问<strong>频率远低于</strong>虚拟存储中的内存访问频率</li><li>通常磁盘缓存调度算法会比虚拟存储<strong>复杂</strong></li></ul><h4 id="单缓存与双缓存"><a href="#单缓存与双缓存" class="headerlink" title="单缓存与双缓存"></a>单缓存与双缓存</h4><p>单缓存(Single Buffer Cache)</p><ul><li>读和写不能同时进行，速度受限</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909191000.png" alt="Single_Buffer_Cache" style="zoom:50%;" /><p>双缓存(Double Buffer Cache)</p><ul><li>读和写可同时进行</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909191014.png" alt="Double_Buffer_Cache" style="zoom:50%;" /><h4 id="访问频率置换算法-Frequency-based-Replacement"><a href="#访问频率置换算法-Frequency-based-Replacement" class="headerlink" title="访问频率置换算法(Frequency-based Replacement)"></a>访问频率置换算法(Frequency-based Replacement)</h4><ul><li>解决的问题<ul><li>在一段密集磁盘访问后 ，被密集访问的缓存块的引用计数迅速增大，从而使LFU算法的引用计数变化无法反映当前的引用情况（我的理解是，这些之前被密集访问的缓存块之后可能不在被访问，但因其计数很大，这些缓存块几乎永远不会被替换，从而产生问题）</li></ul></li><li>算法思路<ul><li>考虑磁盘访问的密集特征，对密集引用不计数</li><li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li></ul></li></ul><p><strong>具体实现</strong>：</p><p>把LRU算法中的特殊栈分成三部分，并在每个缓存块增加一个引用计数。</p><p><img src="https://yuerer.com/images/Frequency_based_Replacement.png" alt="Frequency_based_Replacement"></p><p>缓存未满时：</p><ul><li>栈中缓存块被访问时移到栈顶。如果该块在新区域，引用计数不变，否则引用计数加1<ul><li>在新区域中引用计数不变的目的是避免密集访问对引用计数的不利影响</li><li>在中间区域和旧区域中引用计数加1是为了使用LFU算法</li></ul></li><li>未缓存数据块读入后放在栈顶，引用计数为1</li><li>中间区域的定义是为了有一个过渡期，避免新读入的缓存块在第一次出新区域时（此时其计数较少，但之后可能被频繁访问）马上被置换 </li></ul><p>缓存已满时：</p><ul><li>在旧区域中引用计数最小的缓存块被置换</li></ul><p>至此，操作系统课程结束，完结撒花🎉！(^-^)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;I-O分类&quot;&gt;&lt;a href=&quot;#I-O分类&quot; class=&quot;headerlink&quot; title=&quot;I/O分类&quot;&gt;&lt;/a&gt;I/O分类&lt;/h2&gt;&lt;p&gt;三种常见的设备&lt;strong&gt;接口类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字符设备&lt;/st</summary>
      
    
    
    
    <category term="清华os课程" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os_lab8：文件系统</title>
    <link href="https://icbtbo.github.io/2021/09/08/os/lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://icbtbo.github.io/2021/09/08/os/lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-09-08T08:13:20.000Z</published>
    <updated>2021-09-09T02:05:02.460Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>设备驱动程序、文件系统、虚拟文件系统。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab7</code> 源代码，<code>lab8</code> 主要做了如下改动：</p><ul><li><p><code>proc.h</code> 扩展 <code>struct proc_struct</code> 成员属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span>                <span class="comment">// 当前进程的文件集信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前进程所在工作目录的 inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开文件表</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 共享此 files_struct 的进程个数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 用于互斥访问 files_struct</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;<span class="comment">// 文件状态 (无效、初始态、打开态、关闭态)</span></span><br><span class="line">    <span class="keyword">bool</span> readable;<span class="comment">// 可读</span></span><br><span class="line">    <span class="keyword">bool</span> writable;<span class="comment">// 可写</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">// 对应的文件描述符</span></span><br><span class="line">    <span class="keyword">off_t</span> pos;<span class="comment">// 目前的访问位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span><span class="comment">// 对应的 inode</span></span><br><span class="line">    <span class="keyword">int</span> open_count;<span class="comment">// 此文件打开的次数 (此实验中，该字段似乎没什么用。然而，对于 Linux 系统而言，该字段是具有意义的：父子进程共享文件描述符，它们会对应至相同的文件表项，该表项的 open_count 取值会增加)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在 Linux 系统中，每个打开的文件对应三种数据结构：文件描述符表、打开文件表、<code>inode</code> 表，其中前一者为进程级数据结构，后两者为系统级数据结构。<a href="https://blog.csdn.net/ai2000ai/article/details/79738422">https://blog.csdn.net/ai2000ai/article/details/79738422</a></p><p>在 <code>ucore</code> 中，每个打开的文件仅对应两种数据结构：打开文件表 (包含文件描述符表的信息)、<code>inode</code> 表，其中前者为进程级数据结构，后者为系统级数据结构。</p></blockquote></li><li><p><code>iobuf.[ch]</code> 提供数据读写的内核缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     </span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   </span><br><span class="line">    <span class="keyword">size_t</span> io_len;     </span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>dev.h</code> 规范设备抽象 (只要设备实现此结构所需内容，该系统便可应用此设备，用于屏蔽底层设备的不同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得一说的是，借助于上述内容，我们可以实现如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>inode.h</code> 规范 VFS 层级的 <code>inode</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="comment">// inode 对应的实际类型所存放的信息 (若是设备，则存放设备信息；若是特定 FS，则存放其详细的 inode 信息)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="comment">// inode 对应的实际类型 (特定设备、特定文件系统)</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="comment">// 此 inode 的引用计数</span></span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="comment">// 打开此 inode 的文件个数</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="comment">// inode 对应的抽象文件系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="comment">// 抽象 inode 的操作集</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VFS 层级，针对 inode 操作的众多定义，具体实现基于实际的文件系统</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>vfs.h</code> 规范 VFS 层级的 <code>fs</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="comment">// 具体文件系统的信息 (此实验仅涉及 sfs)。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;                                      </span><br><span class="line">    <span class="comment">// fs 对应的实际文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     </span><br><span class="line">    <span class="comment">// 针对 fs 的四大操作</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   </span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              </span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);          </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>vfs.h</code> 提供 VFS 层级的，针对文件、路径等内容的众多操作，它们进一步会调用 <code>inode_op-&gt;xxx</code> 完成具体功能。</p></blockquote></li><li><p><code>sysfile.[ch]</code> 提供关于文件系统调用的内核级封装</p><p>这部分提供的系统调用会进一步调用 VFS 层级的函数，从而实现相关功能。</p></li><li><p><code>vfsdev.c</code> 提供 <code>vfs_dev_t</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ucore 将设备也视为一种文件，因此也将其集成至 VFS。</span></span><br><span class="line"><span class="comment">// VFS 将设备表示为 vfs_dev_t，并将其串接为一个链表，以方便后续操作。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="comment">// 设备对应的 inode 信息 (十分重要，借助于它，ucore 才能统一设备与文件系统的操作)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="comment">// 设备所挂载的文件系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="comment">// 设备是否可挂载</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="comment">// 链接只用</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>sfs.h</code> 提供简易文件系统 SFS 的各种数据结构</p><p>下图为 SFS 的物理布局：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210908161934.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sfs superblock 内容的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">// 唯一标记 sfs </span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">// sfs 的总块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">// sfs 尚未使用的块数</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">// sfs 简介信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 的 硬盘inode 内容的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">// 文件大小 (字节单位)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">// 文件类型 (文件、目录、链接)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">// 硬链接数目</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">// 文件内容所占块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">// 块索引的直接索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">// 块索引的一级索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 目录文件内部一项的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">// 文件/目录的索引节点所占数据块索引值</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">// 文件/目录的名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述均为数据在硬盘中的组织形式，下述则是数据在内存中的组织形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 的 内存inode 内容的具体结构 (之所以区分硬盘和内存，一则额外信息需要保存，二则方便某些操作)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">// 硬盘 inode 的具体信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">// inode 号</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">// 此 inode 是否被修改</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">// 此 inode 待回收数，若其值为 0，需将其写回硬盘</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">// 用于互斥访问 sfs_disk_inode</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">// 链接之用</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 文件系统的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">// superblock 信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">// 所挂载的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">// freemap 表示的空闲块信息</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">// superblock/freemap 是否被修改</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">// 用于从硬盘获取非对齐块信息，以此作为缓冲，并复制给其他缓冲区</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">// 用于互斥访问 fs</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">// 用于互斥访问 io </span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">// sfs 所管部分 inode 的链表组织形式</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">// sfs 所管部分 inode 的 hash 表组织形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sfs_inode.c</code> 提供 SFS 关于 <code>inode</code> 操作的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 目录节点的操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 文件节点的操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="练习零"><a href="#练习零" class="headerlink" title="练习零"></a>练习零</h2><p>该练习用于了解 <code>ucore</code> 文件系统的实现机制与运行流程。</p><h3 id="文件系统的实现机制"><a href="#文件系统的实现机制" class="headerlink" title="文件系统的实现机制"></a>文件系统的实现机制</h3><p><code>ucore</code> 文件系统的实现机制详见 <code>fs_init()</code> ，我们对其进行简要分析：</p><ul><li><p><code>vfs_init()</code> 初始化 VFS</p><p>VFS 主要记录两大数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list;   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录的 inode 信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">bootfs_node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> bootfs_sem;</span><br></pre></td></tr></table></figure><p>因此，初始化上述变量即是 <code>vfs_init()</code> 的工作。</p></li><li><p><code>dev_init()</code> 初始化相关设备</p><p>此处设备指代 <code>stdin</code>、<code>stdout</code>、<code>disk0</code>，在此仅以 <code>stdin</code> 的初始化进行说明。</p><p><code>stdin</code> 初始化工作主要在于构建 <code>vfs_dev_t</code>，完成相关初始化，并将其加入至 <code>vdev_list</code>。</p><p><code>vfs_dev_t</code> 的详细信息具体如下 (可以看到：各字段均已填充完毕)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname; --&gt; <span class="string">&quot;stdin&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span>--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span>--&gt; <span class="literal">NULL</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;--&gt; <span class="literal">false</span> (设备不同，选项不同。对于 disk0，其选择即为 <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class">    <span class="title">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;--&gt; inode_type_device_info</span><br><span class="line">    <span class="keyword">int</span> ref_count;--&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">int</span> open_count;--&gt; <span class="number">0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>--&gt; <span class="literal">NULL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>--&gt; 在dev.c中声明的dev_node_ops (重申一次，这些操作具体由 struct device 所定义的四个函数实现)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;--&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;--&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);--&gt; stdin_open</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);--&gt; stdin_close</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);--&gt; stdin_io</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);--&gt; stdin_ioctl</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sfs_init()</code> 初始化 sfs</p><p><code>sfs_init()</code> 的工作在于：挂载 sfs 至 <code>disk0</code>，并使用 <code>disk0</code> 硬盘信息初始化 <code>fs</code>。(把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统).</p><p><code>fs</code> 的详细信息具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disk0 所指代的 vfs_dev_t-&gt;fs = 下述 struct fs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="comment">// 具体文件系统的信息 (此实验仅涉及 sfs)。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;         --&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span>                             </span></span><br><span class="line"><span class="class">    // <span class="title">fs</span> 对应的实际文件系统类型</span></span><br><span class="line"><span class="class">    <span class="title">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                --&gt; fs_type_sfs_info                     </span><br><span class="line">    <span class="comment">// 针对 fs 的四大操作</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);      --&gt; sfs_sync (此四者为 sfs 的具体实现)          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   --&gt; sfs_get_root</span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              --&gt; sfs_unmount</span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);          --&gt; sfs_cleanup</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>             --&gt; disk0 硬盘所存的 superblock</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>          --&gt; disk0 所指代的 <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>             --&gt; 新建 freemap，并使用 disk0 硬盘所存信息进行初始化</span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                   --&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                   --&gt; 新建的缓冲区  </span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                 --&gt; 初始化若干信号量</span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             </span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          </span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;            --&gt; 初始化链表            </span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;            --&gt; 初始化 hash 表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注：第二个内核线程 <code>init</code> 的主体实现 <code>init_main()</code> 会设置 <code>disk0</code> 的根目录 <code>inode</code> 为<code>bootfs_node</code>。</p></blockquote></li></ul><p>至此，<code>ucore</code> 文件系统已然实现。</p><h3 id="文件系统的运行流程"><a href="#文件系统的运行流程" class="headerlink" title="文件系统的运行流程"></a>文件系统的运行流程</h3><p>使用若干文件操作说明 <code>ucore</code> 文件系统的运行流程：</p><ul><li><p><code>SYS_open</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_open 陷入中断，经获取 path/open_flags 参数后，调用 sysfile_open() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_open() 进一步调用 file_open()，它首先从当前进程的文件集中分配 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，并调用 <span class="title">vfs_open</span>() 进行处理。</span></span><br><span class="line"><span class="class">3. <span class="title">vfs_open</span>() 进一步调用 <span class="title">vfs_lookup</span>() 去寻找 <span class="title">path</span> 对应文件的 <span class="title">inode</span>。</span></span><br><span class="line"><span class="class">1. <span class="title">vfs_lookup</span>() 借助于 <span class="title">get_device</span>() 获取 <span class="title">path</span> 最初目录的 <span class="title">inode</span> (对于路径 &quot;<span class="title">device</span>:</span>xxx<span class="string">&quot; 而言，即是 device 对应的 inode，它可通过遍历 vdev_list 找到；对于路径 &quot;</span>/xxx<span class="string">&quot; 而言，即是 / 对应的 inode，它可通过访问 bootfs_node 得到；对于路径 &quot;</span>xxx<span class="string">&quot;，即是工作目录对应的 inode`，它可通过访问 pwd 得到)。</span></span><br><span class="line"><span class="string">2. 随后，借助于 vop_lookup() 寻找该目录下对应文件的 inode (该目录的 inode 已知，则可直接调用其具体的 inode_ops)。</span></span><br><span class="line"><span class="string">4. 如果没有找到对应文件的 inode，而 open_flags 允许新建，则新建一个 inode (该目录是已知的，则其通过 inode_ops 调用的新建流程会自动设置,新建 inode 的 inode_ops 为该文件系统所允许的 inode_ops)，并完成相应的初始化工作。</span></span><br><span class="line"><span class="string">5. 使用上述得到的 inode 以及 open_flags 填充 struct file。</span></span><br><span class="line"><span class="string">6. 返回 file-&gt;fd 给用户进程。</span></span><br></pre></td></tr></table></figure></li><li><p><code>SYS_close</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_close 陷入中断，经获取 fd 参数后，调用 sysfile_close() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_close() 进一步调用 file_close()，它首先从当前进程的文件集中获取此 fd 对应的 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，并调用 <span class="title">fd_array_close</span>() 进行处理。</span></span><br><span class="line"><span class="class">3. <span class="title">fd_array_close</span>() 将 <span class="title">file</span>-&gt;</span>open_count 减一，如果此时为 <span class="number">0</span>，则调用 fd_array_free() 进行清理。</span><br><span class="line"><span class="number">4.</span> fd_array_free() 进一步调用 vfs_close()，它会依据 node-&gt;ref_count/open_count 是否为 <span class="number">0</span>，进一步调用 vop_close()/vop_reclaim() 完成善后工作 (由于 inode 已知，同样可直接调用特定文件系统的 inode_ops )。</span><br></pre></td></tr></table></figure></li><li><p><code>SYS_read</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_read 陷入中断，经获取 fd/base/len 参数后，调用 sysfile_read() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_read() 执行若干预处理操作 (判断是否存在该 fd、分配内核缓冲区)，使用 file_read() 进行读取。</span><br><span class="line"><span class="number">3.</span> file_read() 找到该 fd 对应的 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，经过权限是否允许的判断后，使用 <span class="title">vop_read</span>() 读取相关内容至内核缓冲区。</span></span><br><span class="line"><span class="class">4. <span class="title">vop_read</span>() 会基于 <span class="title">file</span>-&gt;</span> pos 找到相应的物理块，并进一步调用设备的 dev_node_ops 完成读取操作。</span><br><span class="line"><span class="number">5.</span> 层层返回，将内核缓冲区的数据拷贝至用户空间 (可能由于待读取的数据很多，它会多次重复执行 <span class="number">3</span>/<span class="number">4</span>/<span class="number">5</span>)。</span><br></pre></td></tr></table></figure></li><li><p><code>SYS_write</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_write 陷入中断，经获取 fd/base/len 参数后，调用 sysfile_write() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_write() 执行若干预处理操作 (判断是否存在该 fd、分配内核缓冲区、)。</span><br><span class="line"><span class="number">3.</span> 随后，sysfile_write() 拷贝用户空间数据至内核缓冲区，并使用 file_write() 进行写入。</span><br><span class="line"><span class="number">4.</span> file_write() 找到该 fd 对应的 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，经过权限是否允许的判断后，使用 <span class="title">vop_write</span>() 将内核缓冲区内容写入至相关设备。</span></span><br><span class="line"><span class="class">5. <span class="title">vop_write</span>() 会基于 <span class="title">file</span>-&gt;</span> pos 找到相应的物理块，并进一步调用设备的 dev_node_ops 完成写入操作。</span><br><span class="line"><span class="comment">// 可能由于待写入的数据很多，它会多次重复执行 3/4/5。</span></span><br></pre></td></tr></table></figure></li></ul><p>以用户态写文件函数write的整个执行过程为例，器流程图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210908184539.png" alt="image-20210908184539558"></p><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于实现文件读写的核心函数 <code>sfs_io_nolock()</code>。</p><blockquote><p>用户程序读文件需要使用系统调用。在用户程序执行<code>read</code>操作时会调用<code>sys_read</code>系统调用。根据ucore的中断机制实现，系统调用将通过<code>trap_dispatch</code>分发给<code>syscall</code>，随后分发给读的系统调用<code>sys_read</code>内核函数。</p><p><code>sys_read</code>内核函数需要进一步调用<code>sysfile_read</code>内核函数，进入到文件系统抽象层处理流程完成进一步的读文件操作。<code>sysfile_read</code>函数调用<code>file_read</code>函数，<code>file_read</code>函数调用<code>vop_read</code>函数接口进入到文件系统实例的读操作接口。</p><p><code>vop_read</code>函数实际上是对<code>sfs_read</code>的包装。sfs_read函数调用sfs_io函数。它有三个参数，node是对应文件的inode，iob是缓存，write表示是读还是写的布尔值（ 0表示读，1表示写） ，这里是0。函数先找到inode对应sfs和sin，<strong>然后调用sfs_io_nolock函数进行读取文件操作</strong>，最后调用iobuf_skip函数调整iobuf的指针。</p></blockquote><p><code>sfs_io_nolock</code>函数主要用来将磁盘中的一段数据读入到内存中或者将内存中的一段数据写入磁盘，其补充完整后的实现如下所示（ 完整代码见源代码 ，这里只展示补充的部分）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 未修改处</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="comment">// 判断 endpos 和 offset 是否在同一块中?</span></span><br><span class="line">        <span class="comment">// 若为同一块 则 size 为 endpos - offset。</span></span><br><span class="line">        <span class="comment">// 若不为同一块 则 size 为 SFS_BLKSIZE - blkoff(偏移) 为 第一块要读的大小。</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno++; nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间对齐的情况。</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno++, nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 末尾最后一块没对齐的情况。</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问答</strong></p><p>如何实现 UNIX 的 PIPE 机制？</p><p>简单来说，PIPE 用于两个进程通信，前者输出放至管道，后者输入取自管道，输入输出并不同步。那么，我么可以新建一个临时文件，再分别让这两个进程打开，各自构建出一个 <code>struct file</code>，即文件描述符。两个进程应当对应不同的 <code>struct file</code>，但是对应相同的 <code>struct inode</code> (其对应的实际数据应当直接存放于内核之中)。</p><p>另外，对于每个进程而言，其 <code>fd_array[0,1,2]</code> 分别指代输入、输出、错误输出。因此，应当修改前者的输出 <code>fd_array[1]</code> 和后者的输入 <code>fd_array[0]</code> 为上述的 <code>struct file</code>。</p></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现程序加载的核心函数 <code>load_icode()</code>。</p><p><code>load_icode()</code> 实现具体见源代码 (可类比 lab7 实现此函数)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">  <span class="comment">// create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf;</span><br><span class="line">  <span class="comment">// 使用 load_icode_read 获取elf文件头 （read raw data content in file and resolve elfhdr）</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; ++i) &#123;</span><br><span class="line">      <span class="comment">// 使用 load_icode_read 获取每个程序头部表信息（read raw data content in file and resolve proghdr based on info in elfhdr）</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * i)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">      <span class="comment">// call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line"><span class="comment">// call pgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 从磁盘上复制相应的内容到内存</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// all mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相比于 lab7 实现，该实现需要妥善放置 argc 和 kargv 至用户栈，因此需要一番计算，使得其尽量减少不必要存储消耗，且能保证 kargv[i] 能顺利索引到相应的字符串。</span></span><br><span class="line">    <span class="comment">// 先算出所有参数加起来的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> total_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        total_len += strnlen(kargv[i], EXEC_MAX_ARG_LEN) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户栈顶 减去所有参数加起来的长度 再 4字节对齐 找到 真正存放字符串参数的栈的位置</span></span><br><span class="line">    <span class="keyword">char</span> *arg_str = (USTACKTOP - total_len) &amp; <span class="number">0xfffffffc</span>;</span><br><span class="line">    <span class="comment">// 放字符串参数的栈的位置的下面 是存放指向字符串参数的指针</span></span><br><span class="line">    <span class="keyword">int32_t</span> *arg_ptr = (<span class="keyword">int32_t</span> *)arg_str - argc;</span><br><span class="line">    <span class="comment">// 指向字符串参数的指针下面 是参数的个数</span></span><br><span class="line">    <span class="keyword">int32_t</span> *stacktop = arg_ptr - <span class="number">1</span>;</span><br><span class="line">    *stacktop = argc;</span><br><span class="line">  <span class="comment">// 将参数字符串拷贝到用户栈中对应位置，并设置相应的指针指向拷贝过来的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> arg_len = strnlen(kargv[i], EXEC_MAX_ARG_LEN);</span><br><span class="line">        <span class="built_in">strncpy</span>(arg_str, kargv[i], arg_len);</span><br><span class="line">        *arg_ptr = arg_str;</span><br><span class="line">        arg_str += arg_len + <span class="number">1</span>;</span><br><span class="line">        ++arg_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;       <span class="comment">// 设置对应的栈指针</span></span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;课程主页：&lt;a href=&quot;https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title&quot;&gt;https://www.xuetangx.com/co</summary>
      
    
    
    
    <category term="清华os实验" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os：文件系统</title>
    <link href="https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-09-07T11:36:33.000Z</published>
    <updated>2021-09-08T03:20:56.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h2><h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p><strong>文件系统</strong>：操作系统中管理<strong>持久性数据</strong>的子系统，提供数据<strong>存储</strong>和<strong>访问</strong>功能</p><ul><li>组织、检索、读写访问功能</li><li>大多数计算机系统都有文件系统</li><li>Google也是一个文件系统</li></ul><p><strong>文件</strong>：具有符号名，由字节序列构成的数据项集合。</p><ul><li>文件系统的基本数据单位</li><li>文件名是文件的表示符号</li></ul><p><strong>文件系统的功能</strong></p><ul><li><p>分配文件磁盘空间</p></li><li><ul><li>管理文件块（位置和顺序）</li><li>管理空闲空间（位置）</li><li>分配算法（策略）</li></ul></li><li><p>管理文件集合：</p></li><li><ul><li>定位：通过文件名定位文件并读取其内容</li><li>命名：对文件命名</li><li>文件系统结构：文件的组织方式</li></ul></li><li><p>数据可靠和安全</p></li><li><ul><li>可靠：持久保存文件，避免错误和崩溃</li><li>安全：多层次保护数据安全，减少攻击危害</li></ul></li></ul><p><strong>文件的属性</strong>包括：名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等</p><p><strong>文件头</strong>：文件系统元数据中的文件信息</p><ul><li>文件属性</li><li>文件存储位置和顺序</li></ul><h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><ul><li><p>磁盘文件系统：文件存储在数据存储设备上，如磁盘</p></li><li><ul><li>例如FAT，NTFS，ext2/3，ISO9660</li><li>不同文件系统的安全要求不同，按照所需选取对应协议即可。</li></ul></li><li><p>数据库文件系统：</p></li><li><ul><li>文件特征是可被寻址（辨识）的</li><li>例如WinFS</li></ul></li><li><p>日志文件系统：</p></li><li><ul><li>记录文件系统的修改/事件</li></ul></li><li><p>网络/分布式文件系统</p></li><li><ul><li>例如：NFS，SMB，AFS，GFS</li></ul></li><li><p>特殊文件系统，如管道</p></li><li><p>虚拟文件系统</p></li></ul><p><strong>关于网络/分布式文件系统</strong></p><p>文件可以通过网络被共享</p><ul><li>文件位于远程服务器，客户端</li><li>客户端远程挂载服务器文件系统</li><li>标准系统文件访问被转换成远程访问</li><li>标准文件共享协议：NFS（UNIX），CIFS（Win）</li></ul><p>分布式文件系统的挑战：</p><ul><li>客户端和客户端上的用户辨识很复杂</li><li>比如NFS是不安全的</li><li>一致性问题</li><li>错误处理模式</li></ul><h2 id="文件组织和存储"><a href="#文件组织和存储" class="headerlink" title="文件组织和存储"></a>文件组织和存储</h2><h3 id="目录、别名和虚拟文件系统"><a href="#目录、别名和虚拟文件系统" class="headerlink" title="目录、别名和虚拟文件系统"></a>目录、别名和虚拟文件系统</h3><p>文件以目录的方式组织起来</p><ul><li>目录是一类特殊文件<ul><li>目录的内容是文件索引表&lt;文件名, 指向文件的指针&gt;</li></ul></li><li>目录和文件的树型结构<ul><li>早期的文件系统是扁平的(只有一层目录)</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203054.png" alt="Hierarchical_File_System" style="zoom:50%;" /><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>操作系统应该只允许内核修改目录以确保映射的完整性，应用程序通过系统调用访问目录。</p><p><strong>典型目录操作</strong>：搜索、创建、删除、列出、重命名、遍历</p><h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><ul><li>文件名的线性列表 包含了指向数据块的指针<ul><li>编程简单</li><li>执行搜索耗时</li></ul></li><li>哈希表<ul><li>减少目录搜索时间</li><li>可能会产生冲突（两个文件名的哈希值相同）</li><li>固定大小</li></ul></li></ul><h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><p>两个或多个文件名关联同一个文件</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203223.png" alt="Alias" style="zoom:50%;" /><ul><li>硬链接<ul><li>多个文件项指向一个文件(只在删除最后一个指向这个文件的文件名时，才真正删除该文件的实体)</li></ul></li><li>软链接<ul><li>通过快捷方式指向其他文件</li><li>通过存储真实文件的逻辑名称来实现</li></ul></li></ul><h4 id="文件目录中的循环"><a href="#文件目录中的循环" class="headerlink" title="文件目录中的循环"></a>文件目录中的循环</h4><p>父目录指向子目录，子目录又指回父目录，无限循环</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203500.png" alt="Directory_Loop" style="zoom:50%;" /><ul><li>解决循环的办法<ul><li>只允许到文件的链接 不允许在子目录里的链接</li><li>增加链接时 用循环检测算法确定是否合理(银行家算法 开销大)</li></ul></li><li>实际上是限制路径可遍历文件目录的长度</li></ul><h4 id="名字解析-路径遍历"><a href="#名字解析-路径遍历" class="headerlink" title="名字解析(路径遍历)"></a>名字解析(路径遍历)</h4><p>名字解析是指将逻辑名字转换成物理资源(文件)</p><ul><li>遍历文件名录直到找到目标文件</li></ul><p>当解析 <code>&quot;/bin/ls&quot;</code>时</p><ul><li>读取根目录的文件头(在磁盘固定位置)</li><li>读取根目录的数据块 搜索 <code>bin</code> 项</li><li>读取 <code>bin</code> 的文件头</li><li>读取 <code>bin</code> 的数据块 搜索 <code>ls</code> 项</li><li>读取 <code>ls</code> 的文件头</li></ul><p>当前工作目录(PWD)</p><ul><li>每个进程都会指向一个文件目录用于解析文件名(可以提高效率)</li><li>允许用户指定相对路径来代替绝对路径 如 <code>PWD=&quot;/bin”</code> 能够解析 <code>“ls”</code></li></ul><h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><p>文件系统需要先挂载才能被访问（未挂载的文件系统需要挂载在挂载点上）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203853.png" alt="Mounting_File_Systems" style="zoom:50%;" /><h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><ul><li>目的<ul><li>对所有不同文件系统的抽象</li></ul></li><li>功能<ul><li>提供相同的文件和文件系统接口</li><li>管理所有文件和文件系统关联的数据结构</li><li>高效查询例程 遍历文件系统</li><li>与特定文件系统模块的交互</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907204741.png" alt="File_system_implementation" style="zoom:50%;" /><p>文件系统基本数据结构包括（各中文件系统都应该有）：</p><ul><li><strong>文件卷控制块</strong>：每个文件系统一个，包括文件系统的详细信息如块、块大小、空余快、计数、指针等，如Unix中的superblock</li><li><strong>文件控制块</strong>：每个文件一个，包括文件的详细信息如访问权限、拥有者、大小、数据块位置等，如Unix中的vnode</li><li><strong>目录项</strong>：每个目录项对应一个子目录或文件，将目录项数据结构以及树形布局编码成数据结构，指向文件控制块、父目录、子目录。</li></ul><p>这些数据持久存入外存，当需要加载时进入内存，加载的时机分别为：</p><ul><li>卷控制模块：当文件系统挂载时进入内存</li><li>文件控制块：当文件被访问时进入内存</li><li>目录节点：在遍历一个文件路径时进入内存</li></ul><p><strong>文件系统的存储视图：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907205525.png" alt="File_system_storage" style="zoom:50%;" /><h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><p>背景：大多数文件都很小，一些文件非常大</p><ul><li>需要对小文件提供很好的支持，块空间不能太大</li><li>必须支持大文件，大文件访问必须高效</li></ul><p>如何表示分配给一个文件数据块的位置和顺序就成为一个问题。</p><p><strong>分配方式主要有如下几种</strong>：</p><ul><li>连续分配</li><li>链式分配</li><li>索引分配</li></ul><p>以下我们从存储效率和读写性能等方面来评定这些分配方式。</p><p><strong>连续分配</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907213822.png" alt="Continuous_Allocation" style="zoom:50%;" /><ul><li>文件头指定起始块和长度</li><li>分配策略包括最先匹配、最佳匹配</li><li>优点：文件读取表现好，访问高效（随机访问）。</li><li>缺点：碎片；文件增长时会出现问题</li></ul><p><strong>链式分配</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907213838.png" alt="Linked_Allocation" style="zoom:50%;" /><ul><li>文件以数据块链表方式存储</li><li>文件头包含了到第一块和最后一块的指针</li><li>优点：创建、增大、缩小很方便，没有碎片</li><li>缺点：不支持随机访问，访问效率低；可靠性差（破坏了一个链，后面的数据就会丢失）</li></ul><p><strong>索引分配</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214116.png" alt="Indexed_Allocation" style="zoom:50%;" /><ul><li>为每个文件创建一个索引数据块，其中存放指向文件数据块的指针列表</li><li>文件头包含了索引数据块指针</li><li>优点：直接访问，创建、增大、缩小很方便，没有碎片</li><li>缺点：对于小文件来说，有多余开销；多索引块才能实现大文件索引（一个索引快可能放不下所有索引）</li></ul><p>大文件可以使用链式索引或者多级索引实现。</p><p><strong>链式索引块</strong>(IB + IB + …)</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214257.png" alt="Link_Index_Allocation" style="zoom:50%;" /><p><strong>多级索引块</strong>(IB * IB * …)</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214306.png" alt="Multilevel_Index_Allocation" style="zoom:50%;" /><p><strong>UFS多级索引分配(UFS Unix File System)</strong></p><p>将各种分配方法融合到一起</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214349.png" alt="Unix_file_system" style="zoom:50%;" /><ul><li>文件头包含13个指针<ul><li>10个指针指向数据块</li><li>第1个指针指向索引块</li><li>第12个指针指向二级索引快</li><li>第13个指针指向三级索引快</li></ul></li><li>效果<ul><li>提高了文件大小限制阈值</li><li>动态分配数据块 文件扩展很容易</li><li>小文件开销小</li><li>只为大文件分配间接索引块 大文件在访问数据块时需要大量查询</li></ul></li></ul><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>采用什么数据结构来表示空闲空间？</p><p>可以使用<strong>位图</strong>：用一个01向量来表示整个存储空间的数据块占用情况。0表示空闲，1表示已经分配</p><p>其使用简单，但是会产生一个很大的向量</p><ul><li>维护起来工作量很大</li><li>假定空闲空间在磁盘中均匀分布，则找到空闲块之前平均扫描n/r个数据块（n为磁盘上数据块的总数，r为空闲块的数目）</li></ul><p>类似空间分配、页式存储等的思路，这里可以使用链表串联空闲空间。另外可以结合索引结构，实现索引链表，节省空间且容易查找。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220009.jpg" alt="img" style="zoom: 80%;" /><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>通常磁盘通过分区来最大限度减小寻道时间</p><ul><li>分区是一组柱面的集合</li><li>每个分区都可以视为逻辑上独立的磁盘</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220141.png" alt="Disk_partitioning" style="zoom:40%;" /><p>一个拥有完整文件系统实例的外存空间通常常驻在磁盘的单个分区上。</p><ul><li>可以将一个磁盘分为多个逻辑分区。</li><li>也可以将多个磁盘组成一个逻辑分区</li></ul><p>使用多个磁盘的好处：</p><ul><li>通过并行改善吞吐量</li><li>通过冗余改善可靠性和可用性</li></ul><p>冗余磁盘阵列（RAID）</p><ul><li>多种磁盘管理技术</li><li>RAID分类：RAID-0，RAID-1，RAID-5等</li><li>实现：可以通过操作系统内核的文件卷管理实现，也可以通过RAID硬件控制器</li></ul><p>RAID-0：磁盘条带化</p><ul><li>把数据块分成多个子块，存储在独立的磁盘中</li><li>通过独立磁盘上<strong>并行</strong>数据块访问提供<strong>更大的磁盘带宽</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220448.png" alt="RAID_0" style="zoom: 40%;" /><p>RAID-1：磁盘镜像</p><ul><li>向两个磁盘写入，从任意一个读取</li><li><strong>可靠性</strong>成倍增长，读取性能线性增加</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220536.png" alt="RAID_1" style="zoom:50%;" /><p>RAID-4：带校验的磁盘条带化</p><ul><li>数据块级的磁盘条带化+专用奇偶校验磁盘<ul><li>奇偶校验规则可阅读<a href="https://blog.csdn.net/weixin_30657541/article/details/98186875">这篇博文</a></li></ul></li><li>允许从任意一个故障磁盘中恢复，增大可靠性</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220640.png" alt="RAID_4" style="zoom:40%;" /><p>RAID-5：带分布式校验的磁盘条带化</p><p>减小对校验和所在磁盘的读写压力</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220722.png" alt="RAID_5" style="zoom: 40%;" /><p>RAID-3：如上的RAID-0,4,5基于数据块，也可以有基于位的条带化/校验结构。</p><p>RAID-6：增加一个奇偶校验块，容许更多的出错。</p><p><strong>RAID嵌套</strong></p><ul><li>RAID 0 + 1(条带化提高性能 再做一个磁盘镜像 可靠性提高)</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220826.png" alt="RAID_0+1" style="zoom:50%;" /><ul><li>RAID 1 + 0(先做磁盘镜像 再做条带化)</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220848.png" alt="RAID_1+0" style="zoom:50%;" /><h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>操作系统在打开文件表（进程独有的和系统级的）中维护的打开文件状态和信息</p><ul><li>文件指针<ul><li>最近一次读写位置</li><li>每个进程分别维护自己的打开文件指针</li></ul></li><li>文件打开计数<ul><li>当前打开文件的次数</li><li>最后一个进程关闭文件时 将其从打开文件表中移除</li></ul></li><li>文件的磁盘位置<ul><li>缓存数据访问信息</li></ul></li><li>访问权限<ul><li>每个进程的文件访问模式信息（<a href="https://blog.csdn.net/ai2000ai/article/details/79738422">其中各个数据结构之间的关系</a>）</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907200026.png" alt="image-20210907200026247" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907200103.png" alt="image-20210907200103570" style="zoom:80%;" /><h4 id="文件的用户视图和系统视图"><a href="#文件的用户视图和系统视图" class="headerlink" title="文件的用户视图和系统视图"></a>文件的用户视图和系统视图</h4><ul><li>文件的用户视图<ul><li>持久的数据结构</li></ul></li><li>系统访问接口<ul><li>字节序列的集合(Unix)</li><li>系统不关心存储在磁盘上的数据结构</li></ul></li><li>操作系统的文件视图<ul><li>数据块的集合</li><li>数据块是逻辑存储单元 而扇区是物理存储单元</li><li>块大小和扇区大小通常是不同的 通常是几个扇区构成一个数据块</li></ul></li></ul><h4 id="用户视图到系统视图的转换"><a href="#用户视图到系统视图的转换" class="headerlink" title="用户视图到系统视图的转换"></a>用户视图到系统视图的转换</h4><p>文件系统中的基本操作单位是数据块 <code>getc()和putc()</code>即使每次只访问1字节的数据 也需要缓存目标数据4096字节</p><ul><li>进程读文件<ul><li>获取字节所在的数据块(数据块是逻辑存储单位)</li><li>返回数据块内对应部分</li></ul></li><li>进程写文件<ul><li>获取数据块</li><li>修改数据块中对应部分</li><li>写回数据块</li></ul></li></ul><h4 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h4><p>操作系统需要了解进程如何访问文件</p><ul><li>顺序访问<ul><li>按字节依次读取</li><li>大多数文件访问都是顺序访问</li></ul></li><li>随机访问<ul><li>从中间读写</li><li>不常用 但很重要</li><li>虚拟内存中把内存页存储在文件</li></ul></li><li>索引访问<ul><li>依据数据特征进行索引</li><li>通常操作系统不完整提供索引访问</li><li>可以在索引内容的磁盘访问之上建立数据库来提供完整索引访问</li></ul></li></ul><h4 id="文件内部结构"><a href="#文件内部结构" class="headerlink" title="文件内部结构"></a>文件内部结构</h4><ul><li>无结构<ul><li>单词、字节序列</li></ul></li><li>简单记录结构<ul><li>分列</li><li>固定长度</li><li>可变长度</li></ul></li><li>复杂结构<ul><li>格式化的文档(PDF Word)</li><li>可执行文件</li></ul></li></ul><h4 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h4><p>多用户系统中的文件共享是很有必要的</p><ul><li>访问控制<ul><li>每个用户能够获得哪些文件的哪些访问权限</li><li>访问模式 读 写 执行 删除 列表</li></ul></li><li>文件访问控制列表(ACL)<ul><li>&lt;文件实体, 权限&gt;</li></ul></li><li>Unix模式<ul><li>&lt;用户|组|所有人, 读|写|可执行&gt;</li><li>用户标识ID<ul><li>识别用户 表明每个用户所允许的权限及保护模式</li></ul></li><li>组标识ID<ul><li>允许用户组成组 并指定了组访问权限</li></ul></li></ul></li></ul><h5 id="语义一致性"><a href="#语义一致性" class="headerlink" title="语义一致性"></a>语义一致性</h5><p>规定多进程如何同时访问共享文件</p><ul><li>与同步算法相似</li><li>因磁盘I/O和网络延迟而设计简单</li><li>Unix文件系统(UFS)语义(相当于把一致性问题丢回给用户自己处理)<ul><li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li><li>共享文件指针允许多用户同时读取和写入文件</li></ul></li><li>会话语义<ul><li>写入内容只有当文件关闭时可见(一次就要写完整 效率低)</li></ul></li><li>读写锁<ul><li>一些操作系统和文件系统提供该功能(又是将一致性问题抛给用户)</li></ul></li></ul><h3 id="文件缓存和打开文件管理"><a href="#文件缓存和打开文件管理" class="headerlink" title="文件缓存和打开文件管理"></a>文件缓存和打开文件管理</h3><p>多种磁盘缓存位置：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907211502.png" alt="Disk_cache" style="zoom:50%;" /><p>两种数据块缓存方式</p><ul><li>数据块缓存</li><li>页缓存： 统一缓存数据块和内存页</li></ul><h4 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h4><ul><li>数据块按需进入内存<ul><li>提供read()操作</li><li>预读 预先读取后面的数据块</li></ul></li><li>数据块使用后被缓存<ul><li>假设数据将会再次用到</li><li>写操作可能被缓存和延迟写入</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907212157.png" alt="Data_Block_cache" style="zoom:50%;" /><h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><ul><li>虚拟页式存储<ul><li>在虚拟地址空间中虚拟页面可映射到本地外存文件中</li></ul></li><li>文件数据块的页缓存<ul><li>在虚拟内存中文件数据块被映射成页</li><li>文件的读/写操作被转换成对内存的访问</li><li>可能导致缺页或被设置为脏页</li><li>会带来问题 页面置换算法需要协调虚拟存储和页缓存间的页面数</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907212211.png" alt="Page_cache" style="zoom:50%;" /><h4 id="文件系统中打开文件的数据结构"><a href="#文件系统中打开文件的数据结构" class="headerlink" title="文件系统中打开文件的数据结构"></a>文件系统中打开文件的数据结构</h4><ul><li>文件描述符<ul><li>每个被打开的文件都有一个文件描述符</li><li>文件状态信息<ul><li>目录项 当前文件指针 文件操作设置</li></ul></li></ul></li><li>打开文件表<ul><li>每个进程都有一个打开文件表</li><li>一个系统级的打开文件表</li><li>有文件被打开时 文件卷就不能被卸载</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907212238.png" alt="Open_file_table" style="zoom:50%;" /><h5 id="打开文件锁"><a href="#打开文件锁" class="headerlink" title="打开文件锁"></a>打开文件锁</h5><p>一些文件系统提供文件锁 用于协调多进程的文件访问</p><ul><li>强制<ul><li>根据锁保持情况和访问需求确定是否拒绝访问</li></ul></li><li>劝告<ul><li>进程可以查找锁的状态来决定怎么做</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件系统概念&quot;&gt;&lt;a href=&quot;#文件系统概念&quot; class=&quot;headerlink&quot; title=&quot;文件系统概念&quot;&gt;&lt;/a&gt;文件系统概念&lt;/h2&gt;&lt;h3 id=&quot;文件系统和文件&quot;&gt;&lt;a href=&quot;#文件系统和文件&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="清华os课程" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os：死锁和进程通信</title>
    <link href="https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2021-09-07T02:28:45.000Z</published>
    <updated>2021-09-07T09:06:29.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h3><p>死锁是由于竞争资源或者通信关系，两个或更多线程在执行中出现的，永远相互等待只能由其他进程引发的事件 的状态。</p><p><strong>我们使用进程和资源的关系来对死锁进行描述</strong>。系统中存在各种类型的资源（CPU执行时间、内存空间、I/O设备等），每类资源都可能有多个实例。</p><p>进程访问资源时，有如下流程：</p><ul><li>请求/获取：申请空闲资源</li><li>使用/占用：进程占用资源</li><li>释放：资源状态由占用变成空闲</li></ul><p>而资源可以分为如下两类：</p><ul><li><strong>可重用资源</strong>（Reusable）：资源不能删除，互斥，可重用，比如处理器、I/O通道，主副存、文件、数据库、信号量等等，在各占<strong>一部分</strong>资源时会出现死锁</li><li><strong>消耗资源</strong>（Consumable）：资源创建和销毁，在I/O缓冲区的中断、信号、消息等，相互等待通信时可能死锁。</li></ul><p>进程和资源之间的分配和占用可以用<strong>资源分配图</strong>表示，这是一个有向图，其中资源和进程间的分配和占用关系如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907103630.png" alt="Resource_allocation_mapping" style="zoom: 40%;" /><p><strong>出现死锁的必要条件</strong>：</p><ul><li>互斥<ul><li>任何时刻只能有一个进程使用一个资源实例</li></ul></li><li>持有并等待<ul><li>进程保持至少一个资源 并正在等待获取其他进程持有的资源</li></ul></li><li>非抢占<ul><li>资源只能在进程使用后自愿释放</li></ul></li><li>循环等待</li></ul><p>死锁和非死锁的资源分配图示例：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907103850.png" alt="Resource_allocation_mapping_Deadlock" style="zoom:50%;" /><blockquote><p>如上两个图中的情况的不同在于，图右的产生循环的资源都不止一个实例。</p></blockquote><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><ul><li><strong>死锁预防</strong>（prevention）：限制并发进程对资源的请求，使得系统在任何时刻都<strong>不满足死锁的必要条件</strong>（四个）。</li><li><strong>死锁避免</strong>（avoidance）：在分配资源前判断，只允许不会出现死锁的进程请求资源。</li><li><strong>死锁检测和恢复</strong>：在检测到运行系统进入死锁状态后，进行恢复。</li></ul><p>目前大多数操作系统都是由应用程序来解决死锁问题。</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件，即消除死锁的必要条件。</p><p>消除四个必要条件的做法：</p><ul><li>互斥：允许资源同时使用。比如在线编辑文档</li><li>持有并等待：进程请求资源时，要求它不持有其他任何资源。即要求所有进程在开始执行时，一次性地申请在整个运行过程中所需的全部资源（资源利用效率会变低）</li><li>非抢占：如果进程请求不能立即分配的资源，则释放占有资源，再分配时只对拥有所有所需资源的进程进行分配操作。</li><li>循环等待：对资源排序，要求进程按顺序请求资源</li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>利用额外的先验信息，在分配资源时进行动态检查，若分配后系统可能发生死锁，则不予分配，否则予以分配。</p><h5 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h5><ul><li>如果系统能按某种顺序为每个进程依次分配其所需的资源，直至所有进程都能运行完成，称此时系统处于安全状态</li><li>这种进程的顺序，如P4,P1,…,Pn, 称为安全序列</li><li>若不存在这样一个安全序列称此时系统处于不安全状态</li><li>如果不按安全序列分配资源，则系统可能会由安全状态进入不安全状态。</li></ul><blockquote><p>注意：不安全状态≠死锁</p><ul><li>处于不安全状态的系统不一定会发生死锁（具体原因可看<a href="https://blog.csdn.net/qq_34666857/article/details/104122776">这篇博文</a>）</li><li>处于安全状态的系统一定不会发生死锁</li></ul><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907110717.png" alt="image-20210907110701819"></p></blockquote><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>银行家算法就是一种基于资源安全状态判断的死锁避免算法，借鉴银行贷款的策略实现。</p><ul><li>申请资源的线程在第一次申请资源的时候需声明所需最大资源数，在满足所有资源要求并执行完成后，及时释放资源归还操作系统</li><li>若线程申请的资源数量不超过操作系统拥有的最大值时，操作系统尽量满足申请资源的线程的需求</li></ul><p>实现银行家算法时需要的数据结构如下（n 为线程数量，m 为资源类型数量）：</p><ul><li>总需求矩阵Max：各个线程对应每种资源的最大需求量（n x m 矩阵）</li><li>总剩余向量Available：各个资源的剩余量（长度为 m 的向量）</li><li>已分配矩阵Allocation：各个线程对应每种资源的已有量（n x m 矩阵）</li><li>未来需要矩阵Need：各个线程对应每种资源的需求差量（n x m 矩阵）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Need[i,j] = Max[i,j] - Allocation[i,j]</span><br></pre></td></tr></table></figure><p>银行家算法<strong>安全状态判断</strong>：</p><ol><li><p>初始化长度为 m 的Work向量和 长度为 n 的Finish向量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work = Available <span class="comment">// 当前资源剩余空闲量</span></span><br><span class="line">Finish[i] = <span class="literal">false</span> <span class="keyword">for</span> i : <span class="number">1</span>, <span class="number">2</span>, ..., n <span class="comment">// 线程i有没有完成</span></span><br></pre></td></tr></table></figure></li><li><p>寻找线程Ti，其满足以下条件:</p><ul><li>Finish[i] = false</li><li>Need[i] &lt;= Work</li></ul><p>没有找到满足条件的线程，则跳转到步骤4</p></li><li><p>找到线程Ti，则进行以下操作：</p><ul><li>Work = Work + Allocation[i]</li><li>Finish[i] = true</li><li>回到 步骤1</li></ul></li><li><p>检查所有线程是否满足 Finish[i] == true</p><ul><li>若都等于，则系统处于安全状态</li></ul></li></ol><p>知道了如何进行安全状态判断后，就有了整体的算法执行流程，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">初始化: Requesti 线程Ti的资源请求向量</span><br><span class="line">       Requesti[j] 线程Ti请求资源Rj的实例数量</span><br><span class="line">循环:</span><br><span class="line">1.如果 Requesti ≤ Need[i], 转到步骤2。否则, 拒绝资源申请, 因为线程已经超过了其最大要求</span><br><span class="line">2.如果 Requesti ≤ Available, 转到步骤3。否则, Ti 必须等待, 因为资源不可用</span><br><span class="line">3.通过安全状态判断来确定是否分配资源给Ti: 生成一个需要判断状态是否安全的资源分配环境</span><br><span class="line">- Available &#x3D; Available - Requesti;</span><br><span class="line">- Allocation[i] &#x3D; Allocation[i] + Requesti;</span><br><span class="line">- Need[i]&#x3D; Need[i] – Requesti;</span><br><span class="line">4.调用安全状态判断方法，</span><br><span class="line">- 若安全 则分配资源给Ti</span><br><span class="line">- 若不安全 则拒绝Ti的资源请求</span><br></pre></td></tr></table></figure><h4 id="死锁检测-Deadlock-Detection"><a href="#死锁检测-Deadlock-Detection" class="headerlink" title="死锁检测(Deadlock Detection)"></a>死锁检测(Deadlock Detection)</h4><p>死锁检测方法和银行家算法的系统安全状态判断是类似的。其执行流程如下：</p><ol><li>初始化 Work 和 Finish:<ul><li>Work = Available // work为当前资源剩余量</li><li>Allocation[i] &gt; 0时 Finish[i] = false 否则为 true // 线程是否完成</li></ul></li><li>寻找线程Ti满足:<ul><li>Finish[i] = false // 线程没有结束 且 此线程需要的资源量小于剩余资源量</li><li>Requesti &lt;= Work</li><li>若没有找到 则跳到步骤4</li></ul></li><li>将找到的线程拥有的资源释放回当前空闲资源<ul><li>Work = Work + Allocation[i]</li><li>Finish[i] = true</li><li>跳到步骤2</li></ul></li><li>检查所有线程的 Finish 若有一个为 false 则系统处于死锁状态</li></ol><p>算法的时间复杂度为O(n^2 x m)，若让操作系统检测系统是否处于死锁状态，开销比较大，因此实际场景操作系统不管死锁。</p><h4 id="死锁恢复-Deadlock-Recovery"><a href="#死锁恢复-Deadlock-Recovery" class="headerlink" title="死锁恢复(Deadlock Recovery)"></a>死锁恢复(Deadlock Recovery)</h4><ul><li><p>选择哪个进程去终止?</p><ul><li>终止所有死锁的进程</li><li>一次只终止一个进程直到死锁消除</li><li>终止进程的顺序应该是<ul><li>进程的优先级(选最低的)</li><li>进程已运行时间以及还需运行时间(运行时间越长越考虑留下 因为已经利用资源算了很长时间了)</li><li>进程已占用资源</li><li>进程完成需要的资源</li><li>终止进程数目(越少越好)</li><li>进程是交互还是批处理(让交互的继续执行)</li></ul></li></ul></li><li><p>怎么样终止进程? 资源抢占</p><ul><li>选择被抢占进程(成本最小的)</li><li>进程回退 返回到一些安全状态 重启进程到安全状态</li><li>可能出现饥饿 同一进程可能一直被选作抢占者</li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间进行通信和同步的机制。</p><h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><p>Inter-Processing Communication，后面我们都将进程通信简称为IPC。</p><p>IPC提供2个基本操作，发送（send）和接收（receive）。</p><p>进程通信流程</p><ol><li>在通信进程间建立通信链路</li><li>通过send/receive交换消息</li></ol><p>进程链路特征</p><ul><li>物理（如共享内存、硬件总线）</li><li>逻辑（如逻辑属性）</li></ul><h4 id="直接通信和间接通信"><a href="#直接通信和间接通信" class="headerlink" title="直接通信和间接通信"></a>直接通信和间接通信</h4><p>IPC可分为直接通信和间接通信：</p><p><strong>间接通信</strong>(通过系统维护的消息队列)，生命周期可以不同(两个进程不需要同时存在)</p><ul><li>每个消息队列都有一个唯一的标识</li><li>只有共享了相同消息队列的进程 才能够通信</li><li>通信链路属性<ul><li>只有共享了相同消息队列的进程 才建立连接</li><li>连接可以为单向也能为双向</li><li>消息队列可以与多个进程相关联</li></ul></li><li>间接通信流程<ol><li>创建一个新的消息队列</li><li>通过消息队列发送和接受消息(只关心消息队列是谁)</li><li>销毁消息队列</li></ol></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907164147.png" alt="Indirect_communication" style="zoom:50%;" /><p><strong>直接通信</strong>（两个进程必须同时存在才能进行通讯）</p><ul><li>进程必须正确命名对方</li><li>通信链路的属性<ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链路存在</li><li>链路可以为单向 但通常为双向</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907164211.png" alt="Direct_communication" style="zoom:50%;" /><h4 id="阻塞与非阻塞通信"><a href="#阻塞与非阻塞通信" class="headerlink" title="阻塞与非阻塞通信"></a>阻塞与非阻塞通信</h4><p>进程通信可划分为阻塞(同步)通信与非阻塞(异步)通信</p><p><strong>阻塞通信</strong></p><ul><li>阻塞发送<ul><li>发送者在发送消息后进入等待 直到接受者成功收到</li></ul></li><li>阻塞接受<ul><li>接受者在请求接受消息后进入等待 直到成功收到消息</li></ul></li></ul><p><strong>非阻塞通信</strong></p><ul><li>非阻塞发送<ul><li>发送者在消息发送后 可立即进行其他操作</li><li>没有消息发送时 接受者在请求接受消息后 接受不到任何消息(可以做别的事)</li></ul></li></ul><h4 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h4><p>进程发送的消息在链路上可能有三种缓冲方式</p><ul><li>0 容量<ul><li>发送方必须等待接收方(必须有接收方)</li></ul></li><li>有限容量<ul><li>通信链路缓冲队列满时 发送方必须等待</li></ul></li><li>无限容量<ul><li>发送方不需要等待</li></ul></li></ul><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>进程间的软件中断通知和处理机制(SIGKILL SIGSTOP SIGCONT)</p><ul><li>信号的接收处理<ul><li>捕获(Catch)：执行进程指定的信号处理函数</li><li>忽略(Ignore) ：执行操作系统指定的缺省处理(例如进程终止、进程挂起)</li><li>屏蔽(Mask) ：禁止进程接受和处理信号(可能是暂时的 当处理同样类型的信号)</li></ul></li><li>不足<ul><li>传送的信息量小，只有一个信号类型</li></ul></li></ul><h4 id="信号的实现"><a href="#信号的实现" class="headerlink" title="信号的实现"></a>信号的实现</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907165121.png" alt="Signal_implementation" style="zoom:50%;" /><h4 id="信号的使用示例"><a href="#信号的使用示例" class="headerlink" title="信号的使用示例"></a>信号的使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigproc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">signal(SIGINT, sigproc);   <span class="comment">// 为了兼容</span></span><br><span class="line"><span class="built_in">printf</span>(“you have pressed ctrl-c - disabled \n”);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitproc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="built_in">printf</span>(“ctrl-\\ pressed to quit\n”);   <span class="comment">/* this is “ctrl” &amp; “\” */</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    signal(SIGINT, sigproc);  <span class="comment">// signal 是注册信号的系统调用，摁下 ctrl+\ 时会发送SIGQUIT信号，</span></span><br><span class="line">  <span class="comment">// 摁下 ctrl+c 时会发送SIGINT信号</span></span><br><span class="line">    signal(SIGQUIT, quitproc);</span><br><span class="line"><span class="built_in">printf</span>(“ctrl-c disabled use ctrl-\\ to quit\n”);</span><br><span class="line"><span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe)"></a>管道(Pipe)</h3><p>进程间基于内存文件的通信机制，进程不知道也不关心另一端</p><ul><li>子进程从父进程继承文件描述符</li><li>缺省文件描述符 0 stdin, 1 stdout, 2 stderr</li></ul><h4 id="管道相关系统调用"><a href="#管道相关系统调用" class="headerlink" title="管道相关系统调用"></a>管道相关系统调用</h4><ul><li>读管道 read()，scanf() 是基于它实现的</li><li>写管道 write()，printf() 是基于它实现的</li><li>创建管道 pipe(rgfd)<ul><li>rgfd是2个文件描述符组成的数组</li><li>rgfd[0] 是读文件描述符</li><li>rgfd[1] 是写文件描述符</li></ul></li></ul><h4 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170054.png" alt="Pipe" style="zoom:50%;" /><ol><li>创建管道</li><li>为ls创建一个进程，设置其 stdout 为管道写端</li><li>为more创建一个进程，设置其 stdin 为管道读端</li></ol><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p><ul><li>每个消息(Message)是一个字节序列</li><li>相同标识的消息组成按先进先出顺序组成一个消息队列(Message Queues)</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170301.png" alt="Message_Queues" style="zoom:50%;" /><h4 id="消息队列的系统调用"><a href="#消息队列的系统调用" class="headerlink" title="消息队列的系统调用"></a>消息队列的系统调用</h4><ul><li>msgget()<ul><li>获取消息队列标识</li></ul></li><li>msgsnd()<ul><li>发送消息</li></ul></li><li>msgrcv()<ul><li>接收消息</li></ul></li><li>msgctl()<ul><li>消息队列控制</li><li>因为消息队列独立于创建它的进程 需要有系统调用完成消息队列的创建和销毁</li></ul></li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p><ul><li>进程<ul><li>每个进程都有私有内存地址空间</li><li>每个进程的内存地址空间需明确设置共享内存段</li></ul></li><li>线程<ul><li>同一进程中的线程总是共享相同的内存地址空间</li></ul></li><li>优点<ul><li>快速 方便地共享数据</li></ul></li><li>不足<ul><li>必须用额外的同步机制来协调数据访问</li></ul></li></ul><h4 id="共享内存的实现"><a href="#共享内存的实现" class="headerlink" title="共享内存的实现"></a>共享内存的实现</h4><p>通过页表项映射到同一物理页帧</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170400.png" alt="Share_memory_implement" style="zoom:50%;" /><ul><li>优点：速度最快<ul><li>没有系统调用干预 没有数据复制</li></ul></li><li>缺点：不提供同步</li></ul><h4 id="共享内存的系统调用"><a href="#共享内存的系统调用" class="headerlink" title="共享内存的系统调用"></a>共享内存的系统调用</h4><p>为了保证数据的完整性 需要信号量等机制协调共享内存的访问冲突</p><ul><li>shmget()<ul><li>创建共享段</li></ul></li><li>shmat()<ul><li>把共享段映射到进程地址空间</li></ul></li><li>shmdt()<ul><li>取消共享段到进程地址空间的映射</li></ul></li><li>shmctl()<ul><li>共享段的控制</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h2&gt;&lt;h3 id=&quot;死锁概念&quot;&gt;&lt;a href=&quot;#死锁概念&quot; class=&quot;headerlink&quot; title=&quot;死锁概念&quot;&gt;&lt;/a&gt;死锁概念&lt;/h</summary>
      
    
    
    
    <category term="清华os课程" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os_lab7:同步互斥</title>
    <link href="https://icbtbo.github.io/2021/09/06/os/lab7-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>https://icbtbo.github.io/2021/09/06/os/lab7-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</id>
    <published>2021-09-06T08:06:58.000Z</published>
    <updated>2021-09-08T09:25:47.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>临界区、信号量、条件变量、管程。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab6</code> 源代码，<code>lab7</code> 主要做了如下改动：</p><ul><li><code>sched.[ch]</code> 增加定时器机制，用以实现 <code>do_sleep()</code> 功能</li><li><code>wait.[ch]</code> 实现基于链表形式的等待队列</li><li><code>sem.[ch]</code> 实现信号量机制</li><li><code>monitor.[ch]</code> 实现基于管程的条件变量机制</li></ul><h2 id="练习零"><a href="#练习零" class="headerlink" title="练习零"></a>练习零</h2><p>该练习用于了解定时器机制的实现流程。</p><p>为实现此机制，首先需要使用相关数据结构以表示定时器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示定时器结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;       <span class="comment">// 定时器的到期时间 (实际实现中，各定时器按到期时间，由近至远串接至 timer_list。为简化定时更新操作，该字段含义变更为：当前定时器距离前一个定时器的时间间隔)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   <span class="comment">// 该定时器所对应的进程</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;    <span class="comment">// 链接至 timer_list</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器链表首部，用以串接各定时任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br></pre></td></tr></table></figure><p>各字段含义已经明确，<code>add_timer()/del_timer()</code> 的实现就比较简单，唯一需要注意的是：正确更新相关 <code>timer_t</code> 的 <code>expires</code> 字段。</p><p>接下来，便是如何动态感知定时器是否到期，从而唤醒相关进程？</p><p>对于操作系统而言，它借助于时钟中断以感知时间变化，因此当时钟中断发生时，它会调用特定函数 (<code>ucore</code> 中的 <code>run_time_list()</code> ) 以动态查询定时器链表中的定时器是否到期，若到期则执行相关唤醒操作，最后，动态更新当前进程的时间片信息，从而判断是否需要切换调度。</p><blockquote><p>简单提一下，用户进程如何使用定时器？</p><p>简单流程：用户调用 <code>sleep(time)</code> –&gt; 中断触发 <code>sys_sleep()</code> –&gt; 间接调用 <code>do_sleep(time)</code> –&gt; <code>add_timer()</code>。</p></blockquote><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解信号量机制的实现流程。</p><blockquote><p>为实现互斥方法，总共存在三种方案：基于软件设计、基于硬件中断、基于硬件提供的原子操作。</p><p>在 <code>ucore</code> 中，使用最简单的 “基于硬件中断” 实现信号量机制。</p></blockquote><p>先行给出信号量机制实现的形式化描述 (信号量实现基本与此相同)：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210906162405.png" alt="img" style="zoom: 50%;" /><p>对于信号量而言，它使用如下数据结构进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 共享资源的数目</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue; <span class="comment">// 欲共享该资源的等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head; <span class="comment">// 链首</span></span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列中的元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> <span class="comment">// 所涉的进程</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags;  <span class="comment">// 该进程放置于等待队列中的原因 (例如：信号量的P操作、定时)</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue;<span class="comment">// 所在的等待队列</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link;<span class="comment">// 链接至等待队列 wait_queue</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br></pre></td></tr></table></figure><p>信号量对应的 <code>P()/V()</code> 操作，具体见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P 操作</span></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">// 如果仍存在资源可访问，则直接访问即可。</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表明已不存在资源可访问，则将当前进程放置于等待队列内部。</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度其他进程运行。</span></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程再次运行，则表明其已获取资源。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前进程从等待队列中移除</span></span><br><span class="line">local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"><span class="comment">// 判断 唤醒该进程的原因 和 当时让该进程等待的原因是否一致， 若不一致则返回 wait-&gt;wakeup_flags （造成等待的原因）</span></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V 操作</span></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="comment">// local_intr_save 表示关中断，local_intr_restore 表示开中断。</span></span><br><span class="line">    <span class="comment">// 中断关闭，保证只有当前进程可以运行，从而保证这部分操作的原子性。</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">// 如果等待队列内部不存在等待进程，则资源数量加一，否则选择一个等待进程调度即可。</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然信号量形式化与具体实现并不相同，但是两者是等价的。</p><p>两者的主要差别在于：在形式化中，<code>sem</code> 大于等于零时，表示共享资源的剩余数目，小于零时，表示正在等待资源的进程的数量；在具体实现中，<code>value</code> 仅表示共享资源的剩余数目，等待进程用等待队列来管理 (此时，因为共享资源的剩余数目只可能大于等于零，而不可能小于零，所以 <code>value</code>大于等于零)。</p></blockquote><blockquote><p><strong>问答</strong></p><p>如何为用户态进程提供信号量机制？</p><p>肯定需要使用系统调用。</p><p>当用户态进程使用创建信号量的系统调用时，OS 内部创建 <code>semaphore_t</code> 结构体，但是返回给用户态进程的标识则是另一个 (可能的情况，在 PCB （pcb 保存在内核空间）内部维护信号量数组，返回的是信号量在此数组的下标)。</p><p>当用户态进程使用 <code>up/down</code> 的系统调用时，OS 从当前进程的 PCB 找到相应的 <code>semaphore_t</code> 结构体，然后执行相关操作即可。</p></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解基于管程的条件变量机制的实现流程。</p><blockquote><p>信号量可以实现互斥访问，也可实现进程间同步。因为基于信号量的进程间同步比较麻烦，而且容易出错误，因此出现了 <strong>条件变量</strong> (注意：条件变量仍是以信号量为基础)。</p><p>信号量和条件变量均是偏底层、用于互斥访问和进程间同步的方法，使用起来也是比较麻烦的。为进一步简化使用，更高层级的抽象形式 <strong>管程</strong> 便出现了。</p></blockquote><p>简而言之，<strong>管程</strong> 是一个黑盒，程序员往里扔的函数，它可确保在同一时刻，只有一个函数在执行 (亦因如此，确保其内部共享数据的互斥访问)。</p><blockquote><p>管程的实现方式分为多种，其主要区别在于：假定线程 A 因等待某条件而处于等待队列，线程 B 满足该条件后，线程 B 具有哪种行为？</p><ul><li><code>Mesa Semantics</code>：线程 B 执行 <code>cond_signal</code> ，因而线程 A 从等待队列移除，并放置于就绪队列，然后线程 B 继续执行。（java中使用这种）</li><li><code>Hanson Semantics</code>：线程 B 执行完成并退出的同时，执行 <code>cond_signal</code>，因而线程 A 从等待队列移除，并放置于就绪队列。</li><li><code>Hoare Semantics</code>：线程 B 执行 <code>cond_signal</code>，因而线程 A 从等待队列移除，并放置于就绪队列，然后立即阻塞线程 B，并等待线程 A 被执行。</li></ul><p>对于这三种方式，实际实现基于前两种 (因为可以减少一次上下文切换)，书本介绍基于后一种。（其中<code>Mesa Semantics</code>和<code>Hanson Semantics</code>类似，但<strong>前者是B线程先通知A线程，然后继续执行直到退出；而后者是B线程先退出，然后再通知A线程</strong>）</p><p>在 <code>ucore</code> 中，管程即是基于后一种实现的，由于需要保证 <code>cond_signal</code> 执行的同时，阻塞当前线程，因此其实现有些麻烦。</p><p>另外，管程属于更高层级的抽象形式，往往适用于 Java 等高级语言实现，这里实现一种基于 C 语言的、简化版的管程。</p></blockquote><p>管程基于信号量和条件变量而实现，信号量的实现前面已经谈及，在此给出<strong>条件变量实现</strong>的形式化描述 (条件变量实现基本与此大不相同)：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210906213516.png" alt="img" style="zoom:50%;" /><blockquote><p>根据此图，简单说明 <code>Mesa Semantics</code> 实现所存在的小缺陷。</p><p>线程 B 执行 <code>cond_signal</code> 后，它只是将线程 A 放置于就绪队列，此时即便调度至线程 A，由于其需要再次获取 <code>lock</code>，而此时 <code>lock</code> 仍归线程 B 所有，因此线程 A 仍无法运行，只能等待线程 B 执行完成并释放 <code>lock</code>，然后才能执行线程 A (如果调度线程 A 前调度了其他进程进入管程，有可能使得线程 A 的条件再次无法满足。因此，当线程 A 执行时，其需要循环判断条件是否满足)。</p></blockquote><p>对于管程而言，它使用如下数据结构进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 借助于信号量，间接使用等待队列 (最初设置信号量为 0)。</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 在此条件变量上等待的进程数量</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 所属的管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 互斥访问管程内部的数据结构，初始化为 1。</span></span><br><span class="line">    <span class="comment">// next_count 指代由于发出 cond_signal 而睡眠的进程数量，next 只是用于构建一个发出 cond_signal 而睡眠的进程的等待队列。此二者是实现 Hoare Semantics 的关键。</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;      </span><br><span class="line">    <span class="keyword">int</span> next_count;         </span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 管程内部的条件变量列表</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure><p>首先给出初始化过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始值 next_count 自然为 0。</span></span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// mutex 置 1，表示当前管程尚无进程访问，next 只是用于构建等待队列，因此置 0。</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); </span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 为条件变量分配空间，并依据字段含义进行初始化。</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123;</span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是条件变量的 <code>cond_wait()/cond_signal()</code>（Hoare Semantics），具体见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_signal</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前条件变量上并不存在等待进程，则直接返回，否则执行如下操作。</span></span><br><span class="line">   <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">monitor_t</span>* mon = cvp-&gt;owner;</span><br><span class="line">       mon-&gt;next_count++;</span><br><span class="line">       <span class="comment">// 唤醒当前条件变量所示等待队列上的一个。</span></span><br><span class="line">       up(&amp;(cvp-&gt;sem));</span><br><span class="line">       <span class="comment">// 将当前进程添加至 next 所示的等待队列上、使 next_count 加一，并选择调度其他进程。</span></span><br><span class="line">       down(&amp;(mon-&gt;next));</span><br><span class="line">       <span class="comment">// 再次执行时，当前进程唤醒，因而需要使next_count 减一。 </span></span><br><span class="line">       mon-&gt;next_count--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_wait</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前条件变量上等待进程数加一。</span></span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="keyword">monitor_t</span>* mon = cvp-&gt;owner;</span><br><span class="line">    <span class="comment">// 如果 next 所示的等待队列上存在进程，则唤醒其中的一个，否则唤醒管程等待队列上的一个。</span></span><br><span class="line">    <span class="keyword">if</span> (mon-&gt;next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        up(&amp;(mon-&gt;next));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        up(&amp;(mon-&gt;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前进程添加至等待队列，并选择调度其他进程。</span></span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    <span class="comment">// 再次执行时，表明条件已经满足，当前条件变量上等待进程数减一。</span></span><br><span class="line">    cvp-&gt;count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，当编写管程内部函数时，其格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------the real body of function--------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>似乎，高级语言内部实现管程是比较简单的。</p><p>对于一个普通的类而言，隐式添加成员变量 <code>mutex</code>、在各方法前后隐式添加获取和释放 <code>mutex</code> 的代码、向 <code>cond_wait()</code> 传递 <code>mutex</code> 即可(条件变量的设置和使用需要由用户编写，因为这部分涉及具体逻辑)。</p></blockquote><p>鉴于条件变量的两个操作难于理解，在此以一个例子进行说明。</p><p>所涉线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程 A:线程 B:</span><br><span class="line">......</span><br><span class="line">cond_wait();cond_signal();</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>执行流程(可参考下方的流程图，请注意图中一些变量名和函数名和代码中不同，但概念一样)：</p><ol><li>线程 A 获取 <code>mutex</code>，从而开始执行。后续因等待某条件发生，因而执行 <code>cond_wait()</code>。</li><li><code>cond_wait()</code> 执行后，将线程 A 添加至该条件变量对应的等待队列中，并调度其他线程执行 (因为目前 next 所示的等待队列为空，因而执行 <code>up(&amp;(mon-&gt;mutex))</code>，从而释放 <code>mutex</code>)。</li><li>线程 B 获取 <code>mutex</code>，从而开始执行。后续满足某条件，因而执行 <code>cond_signal()</code>。</li><li><code>cond_signal()</code> 执行后，唤醒该条件变量对应的等待队列上的一个线程，将当前线程添加至 <code>next</code> 所示的等待队列上，并调度其他线程执行。</li><li>线程 A 继续执行其函数体，后续因为 <code>next_count &gt; 0</code> 唤醒 <code>next</code> 所示等待队列上的一个线程，然后完成执行。</li><li>线程 B 继续执行其函数体，后续因为 <code>next_count = 0</code>，释放 <code>mutex</code>，然后完成执行。</li></ol><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210906213731.png" alt="lab7_monitor" style="zoom:50%;" /><p>针对上述流程，需要留意几点：</p><ol><li>线程 A 再次获取执行权限时，其并没有获取锁 <code>mutex</code>，而是继续使用线程 B 所获取的锁 <code>mutex</code>。因为线程 B 已经睡眠，因此这里不会发生互斥访问 。</li><li>线程 A 退出时，它所做的操作是唤醒线程 B，而非释放锁。释放锁的操作由最初获取锁的线程 B 自己释放。</li></ol><blockquote><p>综合说明 <code>Hoare Semantics</code> 实现中保证互斥访问的机制：</p><ol><li>线程间如果不存在条件变量的羁绊，则其依靠 <code>mutex</code> 实现互斥访问。</li><li>线程间如果存在条件变量的羁绊，执行 <code>cond_signal()</code> 的线程与执行 <code>cond_wait()</code> 的线程共享前者的锁，但是由于 <code>cond_signal()</code> 执行会阻塞一个、唤醒一个，故仍然保证互斥访问。</li></ol></blockquote><p>用管程解决哲学家就餐问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">check_sync.c:</span><br><span class="line"><span class="comment">// 测试编号为i的哲学家是否能获得刀叉 如果能获得 则将状态改为正在吃 并且 尝试唤醒 因为wait操作睡眠的进程</span></span><br><span class="line"><span class="comment">// cond_signal 还会阻塞自己 等被唤醒的进程唤醒自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拿刀叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));    <span class="comment">// P操作进入临界区</span></span><br><span class="line">    state_condvar[i] = HUNGRY; <span class="comment">// 饥饿状态 准备进食</span></span><br><span class="line">    phi_test_condvar(i); <span class="comment">// 测试当前是否能获得刀叉 </span></span><br><span class="line">    <span class="keyword">while</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">        cond_wait(&amp;mtp-&gt;cv[i]); <span class="comment">// 若不能拿 则阻塞自己 等其它进程唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放刀叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex)); <span class="comment">// P操作进入临界区</span></span><br><span class="line">    state_condvar[i] = THINKING; <span class="comment">// 思考状态</span></span><br><span class="line">    phi_test_condvar(LEFT); <span class="comment">// 试试左右两边能否获得刀叉</span></span><br><span class="line">    phi_test_condvar(RIGHT);</span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>) <span class="comment">// 有哲学家睡在 signal操作 则将其唤醒</span></span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex)); <span class="comment">// 离开临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体函数，创建若干线程模拟哲学家就餐问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_condvar</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123; <span class="comment">/* arg is the No. of philosopher 0~N-1*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_condvar\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* iterate*/</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is thinking\n&quot;</span>,iter,i); <span class="comment">/* thinking*/</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_condvar(i); </span><br><span class="line">        <span class="comment">/* need two forks, maybe blocked */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is eating\n&quot;</span>,iter,i); <span class="comment">/* eating*/</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_condvar(i); </span><br><span class="line">        <span class="comment">/* return two forks back*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_condvar quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;课程主页：&lt;a href=&quot;https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title&quot;&gt;https://www.xuetangx.com/co</summary>
      
    
    
    
    <category term="清华os实验" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os：信号量</title>
    <link href="https://icbtbo.github.io/2021/09/04/os/os%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://icbtbo.github.io/2021/09/04/os/os%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2021-09-04T11:55:38.000Z</published>
    <updated>2021-09-04T13:37:30.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量概念"><a href="#信号量概念" class="headerlink" title="信号量概念"></a>信号量概念</h2><p>信号量（Semaphore）是另一种临界区的保护机制，它是操作系统提供的一种协调共享资源访问的方法。<strong>它将资源纳入全局考虑，从操作系统的层面对资源进行宏观的调配</strong>。</p><p>这个机制由Dijkstra在20世纪60年代提出，是早期操作系统的主要同步机制。</p><p>信号量是一种抽象的数据结构：</p><ul><li>由一个整型变量(sem)和两个原子操作组成</li><li>P() sem - 1 若 sem &lt; 0 进入等待 否则继续</li><li>V() sem + 1 若 sem &lt;= 0 唤醒一个等待进程</li></ul><p>信号量中的整数sem就是这个<strong>系统资源剩余量</strong>。具体的实现接口P()和V()，分别是荷兰语中<strong>增加prolagg</strong>和<strong>减少verhoog</strong>的缩写。</p><p>信号量的具体实现伪代码（其中sem是剩余资源）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> sem;</span><br><span class="line">WaitQueue q;  <span class="comment">// 等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">sem--;</span><br><span class="line"><span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Add thread t to q;</span><br><span class="line">block(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">sem++;</span><br><span class="line"><span class="keyword">if</span> (sem &lt;= <span class="number">0</span>) &#123; <span class="comment">// 说明队列中有线程在等待</span></span><br><span class="line">Remove a thread t from q;</span><br><span class="line">Wakeup(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量的特性：</strong></p><ul><li><p><code>sem</code>是由操作系统全局保护的整数变量</p><ul><li>信号量的相关操作是<strong>原子操作</strong></li><li><code>sem</code>初始化完成后，只能通过<code>P()</code>和<code>V()</code>操作更改</li><li><code>P()</code>可能阻塞，<code>V()</code>不会阻塞</li></ul></li><li><p>通常假定信号量是“公平的”：</p></li><li><ul><li>线程不会无限地阻塞在<code>P()</code>操作</li><li>假定信号量等待按先进先出</li></ul></li></ul><h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>信号量可分为<strong>二进制信号量</strong>（资源数目为0或1）和<strong>资源信号量</strong>（资源数目为任何非负值），基于其一可以实现另一个（两者等价）。</p><p>信号量可以用于实现临界区的<strong>互斥访问</strong>和线程间的<strong>条件同步</strong>。</p><p><strong>用信号量实现临界区的互斥访问</strong>，示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Critical Section;</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure><p>必须成对使用P()操作和V()操作，不能颠倒、重复或遗漏</p><p><strong>此外，利用P和V配对的性质，可以将P和V分开，从而实现条件同步</strong>，示例如下：</p><p><strong>同步目标</strong>是线程B执行完X部分的代码后，线程A才能执行N部分的代码。</p><p>实现方式如下图所示：线程A中，如果调用P，那么信号量将变为-1，进入<strong>等待状态</strong>（这是信号量设计中很精髓的FIFO）。线程B调用V之后，信号量变为0，这时A重新开始运行，从而就实现了两个线程的同步。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904201438.jpg" alt="img" style="zoom: 67%;" /><p><strong>生产者-消费者问题</strong>：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904201514.png" alt="Producer-consumer_problem" style="zoom:50%;" /><ul><li>任何时候只能有一个线程操作缓冲区（互斥访问）</li><li>缓冲区空时，消费者必须等待生产者（条件同步）</li><li>缓冲区满时，生产者必须等待消费者（条件同步）</li></ul><p>用信号量描述在这个问题当中的约束（缓冲区大小为n）：</p><ul><li>二进制信号量mutex用于互斥访问缓冲区，初始化为1</li><li>资源信号量fullBuffers表示当前占满的缓冲区数量，用于限制读出，初始化为0</li><li>资源信号量emptyBuffers表示当前为空的缓冲区数量，用于限制写入，初始化为n</li></ul><p>伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&#123;</span></span><br><span class="line">mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">fullBuffers = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">emptyBuffers = <span class="keyword">new</span> Semaphore(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其生产、消费两个过程相互对称，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">emptyBuffers-&gt;P();<span class="comment">//条件同步</span></span><br><span class="line">mutex-&gt;P();    <span class="comment">//互斥访问</span></span><br><span class="line">Add c to buffer; <span class="comment">//核心操作</span></span><br><span class="line">mutex-&gt;V();    <span class="comment">//互斥访问</span></span><br><span class="line">fullBuffers-&gt;V();<span class="comment">//条件同步</span></span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::Withdraw(c)&#123;</span><br><span class="line">fullBuffers-&gt;P();<span class="comment">//条件同步</span></span><br><span class="line">mutex-&gt;P();    <span class="comment">//互斥访问</span></span><br><span class="line">Add c to buffer; <span class="comment">//核心操作</span></span><br><span class="line">mutex-&gt;V();    <span class="comment">//互斥访问</span></span><br><span class="line">emptyBuffers-&gt;V();<span class="comment">//条件同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用信号量的困难在于：</p><ul><li>读/开发都比较困难</li><li>容易出错</li><li>不能系统性地解决死锁问题</li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是一种更为现代的实现<strong>互斥访问</strong>的方法。与临界区相比，管程有更好的封装，如果设计得当，则处理各种问题时，使用将极为便捷。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904205047.png" alt="Synchronization_method_monitor" style="zoom: 50%;" /><h3 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h3><ul><li>一个锁<ul><li>控制管程代码的互斥访问</li></ul></li><li>0或者多个条件变量(0个条件变量 则和 信号量差不多)<ul><li>管理共享数据的并发访问</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904204647.png" alt="Monitor" style="zoom:50%;" /><h4 id="条件变量-Condition-Variable"><a href="#条件变量-Condition-Variable" class="headerlink" title="条件变量(Condition Variable)"></a><strong>条件变量(Condition Variable)</strong></h4><p><strong>管程内的等待机制</strong></p><ul><li>进入管程的线程因资源被占用而进入等待状态</li><li>每个条件变量表示一种等待原因 对应一个等待队列</li><li>Wait()操作<ul><li>将自己阻塞在等待队列中</li><li>唤醒一个等待者或释放管程的互斥访问</li></ul></li><li>Signal()操作<ul><li>将等待队列中的一个线程唤醒</li><li>如果等待队列为空 则等同于空操作</li></ul></li></ul><p><strong>条件变量实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class Condition &#123;</span><br><span class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>; <span class="comment">// 等待线程数</span></span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">    numWaiting++; <span class="comment">// 有线程处于等待状态</span></span><br><span class="line">    Add <span class="keyword">this</span> thread t  to q;</span><br><span class="line">    release(lock); <span class="comment">// 释放管程的访问权</span></span><br><span class="line">    schedule(); <span class="comment">//need mutex</span></span><br><span class="line">    require(lock); <span class="comment">// 请求管程访问权</span></span><br><span class="line">&#125;</span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果等待队列为空 则为空操作</span></span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t); <span class="comment">//need mutex</span></span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与信号量的一个最为重要的不同在于，使用条件变量时，如果进入等待状态，还能暂时放弃管程的互斥访问等待事件出现时恢复，从而并行进行其他操作，而不是简单地像对临界区那样“固守”。<br>这一点是使用了条件变量的好处，可以看到中途释放了lock。</p></blockquote><h3 id="用管程解决生产者-消费者问题"><a href="#用管程解决生产者-消费者问题" class="headerlink" title="用管程解决生产者-消费者问题"></a>用管程解决生产者-消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 管程入口的锁</span></span><br><span class="line">  Lock lock;</span><br><span class="line">    <span class="comment">// 缓冲区里的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 用信号量解决的时候 不能把检查条件放在申请互斥操作的后面 是因为会产生死锁 因为都申请了互斥操作了 别的线程           * 不可读不可写 当前线程只能一直在那等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 而用管程不同 它可以放弃管程的互斥访问权限 调度到其他线程去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BoundedBuffer::Deposit(c) &#123;</span><br><span class="line">     <span class="comment">// 管程进入申请</span></span><br><span class="line">  lock-&gt;Acquire();</span><br><span class="line">  <span class="comment">// 判断缓冲区是否已经满了,满了就等待条件满足时再继续执行</span></span><br><span class="line">    <span class="keyword">while</span> (count == n)</span><br><span class="line">        notFull.Wait(&amp;lock);</span><br><span class="line"> </span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.Signal();</span><br><span class="line">  <span class="comment">// 管程释放</span></span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c) &#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)    </span><br><span class="line">        notEmpty.Wait(&amp;lock);</span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    count--;</span><br><span class="line">  <span class="comment">// 将等待线程中的其中一个唤醒</span></span><br><span class="line">    notFull.Signal();</span><br><span class="line">    </span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过良好的设计封装，可以降低使用过程的使用难度。具体使用情景下，Deposit和Remove都只需要简单的对外接口，但有着有效的互斥访问机制。</p><h3 id="管程分类"><a href="#管程分类" class="headerlink" title="管程分类"></a>管程分类</h3><p>管程中的条件变量按照不同的释放处理方式分为两种：</p><ul><li>Hansen管程(当前正在执行的线程更优先)<ul><li>用于真实OS或Java中</li></ul></li><li>Hoare管程<ul><li>多见于教材</li></ul></li></ul><h4 id="Hansen管程"><a href="#Hansen管程" class="headerlink" title="Hansen管程"></a>Hansen管程</h4><p>当前正在执行的线程优先级更高，因此线程连续执行，所以其效率更高</p><ul><li>条件变量释放仅是一个提示，需要重新检查条件 （用 while）</li></ul><p>因为另一个线程中释放了条件变量后还是在继续往下执行，有可能在这段期间条件变量发生变化，所以仍然需要检查条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hansen_style::Deposit()&#123;</span><br><span class="line">  lock-&gt;acquire();</span><br><span class="line">  <span class="keyword">while</span> (count == n) &#123; <span class="comment">// 这里是 while</span></span><br><span class="line">       notFull.wait(&amp;lock); </span><br><span class="line">  &#125;</span><br><span class="line">  Add thing;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">  lock-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904205923.png" alt="Hansen_monitor" style="zoom:50%;" /><h4 id="Hoare管程"><a href="#Hoare管程" class="headerlink" title="Hoare管程"></a>Hoare管程</h4><p>等待条件变量的优先级更高</p><ul><li>条件变量释放同时表示放弃管程访问</li><li>释放后条件变量的状态可用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hoare_style::Deposit()&#123;</span><br><span class="line">  lock-&gt;acquire();</span><br><span class="line">  <span class="keyword">if</span> (count == n) &#123; <span class="comment">// 这里是 if</span></span><br><span class="line">       notFull.wait(&amp;lock); </span><br><span class="line">  &#125;</span><br><span class="line">  Add thing;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">  lock-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904205933.png" alt="Hoare_monitor" style="zoom:50%;" /><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>5个哲学家围绕一张圆桌坐</p><ul><li>桌子放5支叉子</li><li>每两个哲学家之间放一支</li><li>哲学家动作包含思考和就餐<ul><li>进餐时需同时拿到左右两边两把叉子</li><li>思考时将两支叉子放回原处</li></ul></li><li>要求不出现有人永远拿不到叉子的情况</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904211005.png" alt="Dining_philosophers_problem" style="zoom:50%;" /><h4 id="信号量解决哲学家就餐问题"><a href="#信号量解决哲学家就餐问题" class="headerlink" title="信号量解决哲学家就餐问题"></a>信号量解决哲学家就餐问题</h4><p>方案1</p><ul><li>会发生死锁!</li><li>当五个哲学家同时拿起左边的叉子 所有人都在等待别人放下右边的叉子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 5支叉子的信号量初值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 哲学家编号：0 － 4</span></span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(fork[i]); <span class="comment">// 拿左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 拿右边的叉子</span></span><br><span class="line">        eat();</span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案2</p><ul><li>互斥访问正确</li><li>每次只能有一个哲学家进餐 性能差</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为1</span></span><br><span class="line">semaphore mutex; <span class="comment">// 互斥信号量，初值1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 哲学家编号：0 － 4</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span> </span>&#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex); <span class="comment">// 进入临界区 只有一个哲学家能就餐</span></span><br><span class="line"></span><br><span class="line">        P(fork[i]); <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        eat();</span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        V(mutex); <span class="comment">// 退出临界区</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方案3</p><ul><li>根据编号不同 采取不同动作 避免都拿到一部分资源构造环路的情况</li><li>没有死锁 并允许多人(最多两人)同时就餐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">// 哲学家编号：0 － 4</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span> </span>&#123;</span><br><span class="line">        think();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// 偶数 先拿左 后拿右 奇数 先拿右 后拿左</span></span><br><span class="line">            P(fork[i]); <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">            P(fork[i]); <span class="comment">// 去拿左边的叉子 </span></span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>共享资源的两类使用者</p><ul><li>读者 只读取数据 不修改</li><li>写者 读取和修改数据</li><li>读读允许<ul><li>同一时刻允许有多个读者同时读</li></ul></li><li>读写互斥<ul><li>没有写者时 读者才能读</li><li>没有读者时 写者才能写</li></ul></li><li>写写互斥<ul><li>没有其他写者时 写者才能写</li></ul></li></ul><h4 id="读者写者问题的优先策略"><a href="#读者写者问题的优先策略" class="headerlink" title="读者写者问题的优先策略"></a>读者写者问题的优先策略</h4><ul><li>读者优先策略<ul><li>只要有读者正在读状态 后来的读者都能直接进入</li><li>若读者持续不断进入 则写者就处于饥饿</li></ul></li><li>写者优先策略<ul><li>只要有写者就绪 写者应尽快执行写操作</li><li>若写者持续不断就绪 则读者就处于饥饿</li></ul></li></ul><h4 id="信号量解决读者写者问题"><a href="#信号量解决读者写者问题" class="headerlink" title="信号量解决读者写者问题"></a>信号量解决读者写者问题</h4><p><strong>此方案 读者优先</strong>（<a href="https://blog.csdn.net/mch2869253130/article/details/84320971">用信号量解决读者写者问题的写者优先方案</a>）</p><ul><li>信号量WriteMutex<ul><li>控制读写操作互斥</li><li>初始化为 1</li></ul></li><li>读者计数Rcount<ul><li>正在进行读操作的读者数目</li><li>初始化为 0</li></ul></li><li>信号量CountMutex(对 Rcount 进行保护)<ul><li>控制对读者计数的互斥修改</li><li>初始化为 1</li></ul></li></ul><p>Write线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(WriteMutex); <span class="comment">// 读写互斥</span></span><br><span class="line">    write();</span><br><span class="line">V(WriteMutex);</span><br></pre></td></tr></table></figure><p>Reader线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P(CountMutex); <span class="comment">// 保护 Rcount</span></span><br><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">    P(WriteMutex); </span><br><span class="line">    <span class="comment">// 只在第一个读者 开启读写互斥 </span></span><br><span class="line">++Rcount; <span class="comment">// 加一读者</span></span><br><span class="line">V(CountMutex);</span><br><span class="line">read();</span><br><span class="line">P(CountMutex);</span><br><span class="line">--Rcount;</span><br><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">    V(WriteMutex); </span><br><span class="line">    <span class="comment">// 没有读者了 让写者有机会访问临界区去写</span></span><br><span class="line">V(CountMutex);</span><br></pre></td></tr></table></figure><h4 id="管程解决读者写者问题"><a href="#管程解决读者写者问题" class="headerlink" title="管程解决读者写者问题"></a>管程解决读者写者问题</h4><p><strong>此方案 写者优先</strong></p><p>管程的状态变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AR = <span class="number">0</span>; <span class="comment">// 当前读的读者</span></span><br><span class="line">AW = <span class="number">0</span>; <span class="comment">// 当前写的写者</span></span><br><span class="line">WR = <span class="number">0</span>; <span class="comment">// 等待读的读者</span></span><br><span class="line">WW = <span class="number">0</span>; <span class="comment">// 等待写的写者</span></span><br><span class="line">Lock lock;</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br></pre></td></tr></table></figure><p>读者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Database::Read() &#123;</span><br><span class="line">    <span class="comment">// Wait until no writers;</span></span><br><span class="line">    StartRead(); </span><br><span class="line">    read database;</span><br><span class="line">    <span class="comment">// check out – wake up waiting writers; </span></span><br><span class="line">    DoneRead();</span><br><span class="line">&#125;</span><br><span class="line">Database::StartRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">  <span class="comment">// 只要有写者就等 说明写者优先</span></span><br><span class="line">    <span class="keyword">while</span> ((AW+WW) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.wait(&amp;lock);</span><br><span class="line">        WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line">Database::DoneRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AR--;</span><br><span class="line">   <span class="comment">// 当前没有读者且有等待写的写者 则唤醒 写者</span></span><br><span class="line">    <span class="keyword">if</span> (AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Database::Write() &#123;</span><br><span class="line">    <span class="comment">// Wait until no readers/writers;</span></span><br><span class="line">    StartWrite(); </span><br><span class="line">    write database;</span><br><span class="line">    <span class="comment">// check out-wake up waiting readers/writers; </span></span><br><span class="line">    DoneWrite(); </span><br><span class="line">&#125;</span><br><span class="line">Database::StartWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">  <span class="comment">// 只要有正在写的写者或者正在读的读者 就等(不等 等待读的读者 说明写者优先)</span></span><br><span class="line">    <span class="keyword">while</span> ((AW+AR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.wait(&amp;lock);</span><br><span class="line">        WW--;</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line">Database::DoneWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AW--;</span><br><span class="line">    <span class="keyword">if</span> (WW &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 优先唤醒等待写的写者</span></span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有等待写的写者 才唤醒等待读的读者</span></span><br><span class="line">        okToRead.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信号量概念&quot;&gt;&lt;a href=&quot;#信号量概念&quot; class=&quot;headerlink&quot; title=&quot;信号量概念&quot;&gt;&lt;/a&gt;信号量概念&lt;/h2&gt;&lt;p&gt;信号量（Semaphore）是另一种临界区的保护机制，它是操作系统提供的一种协调共享资源访问的方法。&lt;strong&gt;</summary>
      
    
    
    
    <category term="清华os课程" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os：同步互斥</title>
    <link href="https://icbtbo.github.io/2021/09/03/os/os%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
    <id>https://icbtbo.github.io/2021/09/03/os/os%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</id>
    <published>2021-09-03T13:21:10.000Z</published>
    <updated>2021-09-04T05:55:32.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景、问题和基本概念"><a href="#背景、问题和基本概念" class="headerlink" title="背景、问题和基本概念"></a>背景、问题和基本概念</h2><p>对于独立程序</p><ul><li><p>不和其他程序共享资源</p></li><li><p>输入状态决定结果，具有确定性</p></li><li><p>可重现起始条件</p><blockquote><p>在计算机科学中，<strong>再现性</strong>是指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果</p></blockquote></li><li><p>调度顺序不重要</p></li></ul><p>但对于并发进程来说，多个进程间有资源共享，可能会因为不同顺序出现相互的干扰。从而</p><ul><li>产生不确定性</li><li>不可重现</li><li>未定义行为，程序错误是间歇性发生的</li></ul><p>实际上我们又希望使用多进程并发执行，提升效率、实现协同、模块化设计等，所以我们需要使用一些方式来克服并发设计的坏处（例如，使用一些原子操作）。</p><blockquote><p>原子操作（Atomic Operation）指一次不存在任何中断或者失败的操作，要么操作完成，要么没有执行，不会出现半途而废、部分执行的情况。</p></blockquote><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>进程的交互关系，根据相互感知程度的不同分为如下三种：</p><table><thead><tr><th>相互感知的程度</th><th>交互关系</th><th>进程间的影响</th></tr></thead><tbody><tr><td>相互不感知</td><td>独立</td><td>一个进程的操作对于其他进程的结果没有影响</td></tr><tr><td>间接感知（双方都与第三方方交互，如共享资源 ）</td><td>通过共享进行协作</td><td>一个进程的结果依赖于共享资源的状态</td></tr><tr><td>直接感知（双方直接交互，如通信）</td><td>通过通信进行协作</td><td>一个进程的结果依赖于从其他进程获得的信息</td></tr></tbody></table><p>同步问题的解决方案主要基于<strong>间接感知</strong>的部分，其中主要会有如下三种状态：</p><ul><li>互斥（mutual exclusion）：一个进程占用资源，其他进程无法使用</li><li>死锁（deadlock）：多个进程各占用部分资源，形成循环等待</li><li>饥饿（starvation）：其他进程轮流占用资源，一个进程一直得不到资源</li></ul><p>其中最为基本的状态称为互斥，这即是一个良好的原子操作的思路。</p><p>我们将互斥资源存放的位置称为<strong>临界区</strong>，其上资源同时只允许一个进程的访问，临界区附近的代码结构通常如下：</p><ul><li>进入区（entry section）：检查是否可以进入临界区的一段代码，如果可以进入，则设定“正在进入临界区”标志</li><li>临界区（critical section）：进程中访问临界资源的一段需要互斥执行的代码</li><li>退出区（exit section）：清除“正在访问临界区”标志</li><li>剩余区（remainder section）：跟同步互斥无关的代码</li></ul><p>临界区的访问规则如下：</p><ul><li>空闲则入：没有进程在临界区时，任何进程可以进入</li><li>忙则等待：有进程在临界区时，其他进程均不能进入临界区</li><li>有限等待：等待进入临界区的进程不能无限等待</li><li>让权等待(可选)：不需要访问临界区的进程，应当释放CPU</li></ul><p>在具体实现过程当中，我们必须满足前三条规则。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h3><p>禁止硬件中断响应，因而对一个正在运行的不会发生上下文切换，且没有并发。</p><ul><li>硬件将中断处理延迟到中断使能之后</li><li>现代计算机体系结构都提供指令来实现禁用中断</li></ul><p>缺点：</p><ol><li>禁用中断之后，进程无法停止</li></ol><ul><li>整个系统都会为此停下来</li><li>可能导致其他进程处于饥饿状态</li></ul><ol start="2"><li>临界区可能很长，无法确定中断响应时间</li></ol><p>所以应该谨慎使用。</p><h3 id="软件方法"><a href="#软件方法" class="headerlink" title="软件方法"></a>软件方法</h3><p>设置一些全局的共享变量，来标识两个线程对互斥资源的占用情况，从而实现同步。</p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn; <span class="comment">// 表示该谁进入临界区</span></span><br><span class="line">boolean flag[]; <span class="comment">// 表示进程申请进入临界区</span></span><br></pre></td></tr></table></figure><p>进程i 进入区代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"> <span class="comment">//这里相当于谦让，让另一个进程优先获得权限</span></span><br><span class="line">turn = j;</span><br><span class="line"><span class="keyword">while</span> (flag[j] &amp;&amp; turn == j)</span><br></pre></td></tr></table></figure><p>退出区代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag[i] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当进程 j 没有申请进入临界区 则 flag[j] = false;  turn = j;</p><p>那么进程 i 可以直接进入临界区</p><p>当进程 j 也申请进入临界区 则 flag[j] = true; turn 有 两种情况 当 进程 i 先写 turn = j; 进程 j 后写 turn = i; 时 turn = i;</p><p>那么进程 i 可以进入临界区 进程 j 不可以进入临界区</p><p>也就是说先写turn这个标志的能进入临界区，后写的要等待</p></blockquote><p>Peterson算法完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> ( flag[j] &amp;&amp; turn == j);</span><br><span class="line">    </span><br><span class="line">            CRITICAL SECTION</span><br><span class="line"></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            REMAINDER SECTION</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="Dekkers算法"><a href="#Dekkers算法" class="headerlink" title="Dekkers算法"></a>Dekkers算法</h4><p>Dekkers算法是Peterson算法的扩展。对比 Peterson算法，其优点是可以很方便扩展到多个线程（即Eisenberg and McGuire’s Algorithm）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> flag[j] == <span class="literal">true</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> turn != i &#123;</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> turn != i;</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        CRITICAL SECTION</span><br><span class="line"></span><br><span class="line">    turn = j;</span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">        EMAINDER SECTION</span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>进程 i 申请进入临界区 flag[i] = true;<br>当进程 j 也申请进入临界区 则 flag[j] = true;<br>这时再判断 turn 这个共享变量 允许哪个进程进入临界区<br>若不允许 则将进程 flag[i] = false; 并一直等待 直到允许</p></blockquote><h4 id="N线程的软件方法-Eisenberg-和-McGuire"><a href="#N线程的软件方法-Eisenberg-和-McGuire" class="headerlink" title="N线程的软件方法(Eisenberg 和 McGuire)"></a>N线程的软件方法(Eisenberg 和 McGuire)</h4><p>将线程排成环 若要进入临界区 则将 线程的 flag 标志 填写好 再去看 turn 标志</p><ul><li>线程Ti要等待从 turn 到 i-1的线程 都退出临界区后才能访问临界区</li><li>线程Ti退出时 将turn改成下一个请求线程</li></ul><blockquote><p><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1217">https://piazza.com/class/i5j09fnsl7k5x0?cid=1217</a> 详细解释</p></blockquote><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904123218.png" alt="Eisenberg_McGuire" style="zoom:50%;" /><h4 id="基于软件同步方法的缺点"><a href="#基于软件同步方法的缺点" class="headerlink" title="基于软件同步方法的缺点"></a>基于软件同步方法的缺点</h4><ul><li>复杂<ul><li>需要两个进程间共享变量</li></ul></li><li>需要忙等待<ul><li>浪费CPU时间 (需要频繁查询共享变量的状态)</li></ul></li></ul><h3 id="更高级的抽象方法"><a href="#更高级的抽象方法" class="headerlink" title="更高级的抽象方法"></a>更高级的抽象方法</h3><blockquote><p>现代CPU体系结构提供的一些特殊原子操作指令</p><p><strong>测试和置位指令(TS Test-and-Set)</strong></p><ul><li>从内存单元中读取值</li><li>测试该值是否为1(真或假)</li><li>内存单元值设置为1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *target)</span></span>&#123;</span><br><span class="line">    boolean rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>交换指令(Exchange)</strong></p><p>交换内存中的两个值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span> <span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>将上述的想法抽象成一个二进制的数据结构（锁定/解锁），称为锁（lock）。<br>它有两个主要API：</p><ul><li>Lock::Acquire() 申请锁</li><li>Lock::Release() 释放锁</li></ul><p>将相关的互斥操作封装好之后，使用锁来控制临界区访问就会变得非常简单。</p><p><strong>TS指令实现自旋锁(Spinlock)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 通过TS指令 读出 value的值 然后写入1</span></span><br><span class="line"><span class="comment">    若value为0 说明锁被释放 TS指令读出0 并写入 1 进入临界区</span></span><br><span class="line"><span class="comment">    若value为1 说明锁为忙状态 TS指令读出1 并写入 1 状态并没有改变 但是陷入循环 一直等待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">   <span class="keyword">while</span> (test-<span class="keyword">and</span>-<span class="built_in">set</span>(value))</span><br><span class="line">      ; <span class="comment">//spin</span></span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但上述的自旋等待锁存在忙等待</strong>的问题，我们可以在锁的数据结构中加入等待队列，避免CPU自旋。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">   WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        若锁处于忙状态则将当前进程加入等待队列并执行调度程序</span></span><br><span class="line"><span class="comment">        使得其他进程可以占用CPU继续执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">while</span> (test-<span class="keyword">and</span>-<span class="built_in">set</span>(value)) &#123;</span><br><span class="line">      add <span class="keyword">this</span> TCB to wait <span class="built_in">queue</span> q;</span><br><span class="line">      schedule();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">   value = <span class="number">0</span>;</span><br><span class="line">   remove one thread t from q;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将等待进程放到就绪队列里去 相当于唤醒等待进程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   wakeup(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原子操作指令锁特征</strong></p><ul><li><p>优点</p><ul><li>适用于单处理机或者共享内存的多处理机中任意数量的进程同步(禁用中断只适用于单处理机, 多处理机的情况下 禁止单个处理机的中断, 其他处理机仍然能够响应中断)</li><li>简单且容易证明</li><li>支持多临界区</li></ul></li><li><p>缺点：</p><ul><li>忙等待消耗处理器时间</li><li>可能会导致饥饿</li><li>可能会导致死锁：高优先级拥有CPU，低优先级拥有独占资源</li></ul></li></ul><h3 id="常用三种同步实现方法总结"><a href="#常用三种同步实现方法总结" class="headerlink" title="常用三种同步实现方法总结"></a>常用三种同步实现方法总结</h3><ul><li>禁用中断(仅限于单处理机)</li><li>软件方法(共享变量 复杂)</li><li>原子操作指令(单处理机或多处理机均可)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景、问题和基本概念&quot;&gt;&lt;a href=&quot;#背景、问题和基本概念&quot; class=&quot;headerlink&quot; title=&quot;背景、问题和基本概念&quot;&gt;&lt;/a&gt;背景、问题和基本概念&lt;/h2&gt;&lt;p&gt;对于独立程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不和其他程序共享资源&lt;/p&gt;
</summary>
      
    
    
    
    <category term="清华os课程" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os_lab6:调度器</title>
    <link href="https://icbtbo.github.io/2021/09/02/os/lab6-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://icbtbo.github.io/2021/09/02/os/lab6-%E8%B0%83%E5%BA%A6%E5%99%A8/</id>
    <published>2021-09-02T11:40:42.000Z</published>
    <updated>2021-09-08T09:25:31.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>进程调度算法。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab5</code> 源代码，<code>lab6</code> 主要做了如下改动：</p><ul><li><p><code>proc.h</code> 扩展 <code>struct proc_struct</code> 成员属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span>                       <span class="comment">// 该进程所在的 run_queue</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_link;                      <span class="comment">// 以链表形式链接各就绪进程</span></span><br><span class="line">    <span class="keyword">int</span> time_slice;                             <span class="comment">// 该进程所占用的 CPU 时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> lab6_run_pool;            <span class="comment">// FOR LAB6 ONLY: 以优先队列形式链接各就绪进程</span></span><br><span class="line">    <span class="comment">// 当前进程的 stride 和优先级属性。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_stride;                       <span class="comment">// FOR LAB6 ONLY: 该进程对应的 stride 属性 (此二者用于 stride 调度算法)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_priority;                     <span class="comment">// FOR LAB6 ONLY: 该进程对应的 priority 属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>alloc_proc()</code> 实现中，增加这些属性的初始化工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">skew_heap_init(&amp;(proc-&gt;lab6_run_pool));</span><br><span class="line">proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">proc-&gt;lab6_priority = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>schedule.[ch]</code> 增加调度器框架信息</p><p><code>ucore</code> 调度器框架使用 <code>struct sched_class</code> 加以表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 调度器名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 初始化调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">// 进程入队</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// 进程出队</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// 选择待运行的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// 时钟触发的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ucore</code> 调度器具体使用 <code>struct run_queue</code> 进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_list;<span class="comment">// 进程集合的链表形式    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_num;<span class="comment">// 进程集合总数</span></span><br><span class="line">    <span class="keyword">int</span> max_time_slice;<span class="comment">// 进程运行的最大时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> *lab6_run_pool;<span class="comment">// For LAB6 ONLY: 进程集合的优先队列形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>trap.c</code> 更新时钟中断的处理程序</p><p>每当发生时钟中断，调用 <code>ucore</code> 调度器的 <code>proc_tick()</code> 函数，从而使得调度器能够动态感知时间变化，并更新相关进程的某些调度属性信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        sched_class_proc_tick(current);</span><br></pre></td></tr></table></figure></li><li><p><code>default_sched.[ch]</code> 实现 Round-Robin 调度算法</p></li><li><p><code>sched.c</code> 更新 <code>wakeup_proc()</code> 操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// proc 若未处于 RUNNABLE 状态，则置为此状态。</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 若当前进程并非 proc，则将 proc 入队 (出现情况：当前进程创建子进程，子进程的 do_fork 最后一步会调用此函数，从而将其入队管理)。</span></span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>skew_heap.h</code> 提供斜堆的具体实现</p></li></ul><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解 Round-Robin 调度算法的具体实现。</p><p>Round-Robin 调度算法比较简单，直接查看其源代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 RR，只需初始化进程集合，并重置相关属性即可 (max_time_slice 属性由调用者自主设置)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 放置当前进程于进程集合尾部。</span></span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="comment">// 如果其所剩时间片为 0，或不符合条件，则重置之。</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新其他属性。</span></span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，进程集合中删除此进程，并初始化此进程的 run_link 即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择进程集合首部元素作为待运行的进程即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次发生时钟中断，更新当前进程可用的时间片，如果可用时间片为 0，则设置 need_resched 以调度其他进程 (该字段在 trap() 的 if(!in_kernel) 内起作用)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将默认的处理器调度算法设为RR</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;RR_scheduler&quot;</span>,</span><br><span class="line">    .init = RR_init,</span><br><span class="line">    .enqueue = RR_enqueue,</span><br><span class="line">    .dequeue = RR_dequeue,</span><br><span class="line">    .pick_next = RR_pick_next,</span><br><span class="line">    .proc_tick = RR_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>结合具体算法描述<strong>ucore调度执行过程</strong>：</p><ul><li>正如前文中所提及到的那样，在ucore中调用调度器的主体函数（不包括init，proc_tick）的代码仅存在在wakeup_proc和schedule，前者的作用在于将某一个指定进程放入可执行进程队列中，后者在于将当前执行的进程放入可执行队列中，然后将队列中选择的下一个执行的进程取出执行；</li><li>当需要将某一个进程加入就绪进程队列中，则需要将这个进程的能够使用的时间片进行初始化，然后将其插入到使用链表组织的队列的对尾；这就是具体的Round-Robin enqueue函数的实现；</li><li>当需要将某一个进程从就绪队列中取出的时候，只需要将其直接删除即可；</li><li>当需要取出执行的下一个进程的时候，只需要将就绪队列的队头取出即可；</li><li>每当出现一个时钟中断，则会将当前执行的进程的剩余可执行时间减1，一旦减到了0，则将其标记为可以被调度的，这样在ISR中的后续部分就会调用schedule函数将这个进程切换出去；</li></ul><p>简要说明如何设计实现<strong>多级反馈队列调度算法</strong>：</p><ul><li><p>在proc_struct中添加总共N个多级反馈队列的入口，每个队列都有着各自的优先级，编号越大的队列优先级约低，并且优先级越低的队列上时间片的长度越大，为其上一个优先级队列的两倍；并且在PCB中记录当前进程所处的队列的优先级；</p></li><li><p>处理调度算法初始化的时候需要同时对N个队列进行初始化；</p></li><li><p>在处理将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低1级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去；</p></li><li><p>在同一个优先级的队列内使用时间片轮转算法；</p></li><li><p>在选择下一个执行的进程的时候，有限考虑高优先级的队列中是否存在任务，如果不存在才转而寻找较低优先级的队列；（有可能导致饥饿）</p></li><li><p>从就绪进程集合中删除某一个进程就只需要在对应队列中删除即可；</p></li><li><p>处理时间中断的函数不需要改变；</p></li><li><p>至此完成了多级反馈队列调度算法的具体设计；</p></li></ul></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现 Stride 调度算法。</p><p>首先简单介绍 Stride 调度算法的基本思想：Stride 调用算法仍是基于时间片以调度进程，但是它每次选择进展最慢 (表征进程的 <code>struct proc_struct</code> 结构中，<code>stride</code> 表示当前进程的进展度，<code>BIG_STRIDE / priority</code> 表征当前进程被调度后的进展增加值) 的进程加以调度。</p><blockquote><p>stride相关资料：<a href="http://web.eecs.umich.edu/~mosharaf/Readings/Stride.pdf">http://web.eecs.umich.edu/~mosharaf/Readings/Stride.pdf</a></p></blockquote><p>接下来，给出 Stride 调度算法的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BIG_STRIDE 取值具有一定原因，它可以保证即使 stride 取值溢出，仍可正确实现两个进程的 stride 比较操作，原理请看下方问答。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE    (((uint32_t)-1) / 2) <span class="comment">// 即 0X7FFFFFFF</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个进程的 stride 比较操作，用于构建斜堆。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_stride_comp_f</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Stride，只需初始化进程集合，并重置相关属性即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list)); <span class="comment">// 是否初始化进程集合的链表形式都可，因为不会用到。</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队，插入当前进程至斜堆，并更新相关属性。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;  </span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     <span class="comment">// 如果尚未初始化 priority，则默认取值为 1。</span></span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          proc-&gt;lab6_priority = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">           proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     proc-&gt;rq = rq;</span><br><span class="line">     rq-&gt;proc_num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，斜堆删除特定进程。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     rq-&gt;proc_num--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择 stride 最小的进程作为待运行的进程（斜堆的顶就是 stride 值最小的进程），并更新其 stride 取值。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">stride_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool != <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span>* <span class="title">proc</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">          proc-&gt;lab6_stride += (BIG_STRIDE / proc-&gt;lab6_priority);</span><br><span class="line">          <span class="keyword">return</span> proc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 RR 所取操作相同。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;time_slice --;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认调度策略为 stride</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">     .name = <span class="string">&quot;stride_scheduler&quot;</span>,</span><br><span class="line">     .init = stride_init,</span><br><span class="line">     .enqueue = stride_enqueue,</span><br><span class="line">     .dequeue = stride_dequeue,</span><br><span class="line">     .pick_next = stride_pick_next,</span><br><span class="line">     .proc_tick = stride_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如何证明STRIDE_MAX – STRIDE_MIN &lt;= PASS_MAX？</p><ul><li>假如该命题不成立，则可以知道就绪队列在上一次找出用于执行的进程的时候，假如选择的进程是P，那么存在另外一个就绪的进程P’，并且有P’的stride比P严格地小（因为步进值最大为PASS_MAX，若该命题不成立，那么上一次调度时被选择执行并增加stride的进程一定不是stride最小的进程）。这也就说明上一次调度出了问题，这和stride算法的设计是相违背的；因此通过反证法证明了上述命题的成立；</li></ul><p>在 ucore 中，目前Stride是采用无符号的32位整数表示。则BigStride应该取多少，才能保证比较的正确性？</p><ul><li><p>开始有A=B,最大步进值S</p></li><li><p>B+S不溢出，则需A&lt;B+S，即0&lt;S,即S&lt;2^31</p></li><li><p>B+S溢出代表B+S &gt;= 2^32</p><p>溢出后B’ = B+S-2^32</p><p>此时为使 A-B’ &lt; 0,需要 A &gt;= B’+2^31</p><p>即A &gt;= B+S-2^32+2^31=B+S-2^31</p><p>又由A=B，有0&gt;=S-2^31，即S&lt;=2^31</p></li><li><p>综合有S&lt;2^31，即S&lt;=0x7FFFFFFF</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;课程主页：&lt;a href=&quot;https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title&quot;&gt;https://www.xuetangx.com/co</summary>
      
    
    
    
    <category term="清华os实验" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E5%AE%9E%E9%AA%8C/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>os：处理机调度</title>
    <link href="https://icbtbo.github.io/2021/09/01/os/os%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <id>https://icbtbo.github.io/2021/09/01/os/os%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</id>
    <published>2021-09-01T12:16:01.000Z</published>
    <updated>2021-09-02T11:38:39.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理器调度概念"><a href="#处理器调度概念" class="headerlink" title="处理器调度概念"></a>处理器调度概念</h1><h2 id="调度的技术背景"><a href="#调度的技术背景" class="headerlink" title="调度的技术背景"></a>调度的技术背景</h2><p>在此前我们已经介绍了进程和线程机制， 它们可以使得CPU能够更加有效地展现并发处理的能力。</p><p>对于资源基本管理单位的进程来说，CPU资源的当前占用者切换是基本的并发思路。</p><p>但有如下两个问题：</p><ol><li>如何从就绪队列中选出下一个运行（占用CPU）的<strong>进程</strong></li><li>从多个CPU中选出就绪进程中当前准备使用的的<strong>CPU</strong></li></ol><p>这两个选择任务就交由调度算法来实现。</p><h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>调度程序除了解决上述提到的进程线程选择之外，还需进行<strong>调度时机</strong>的选择</p><p>当前系统为<strong>非抢占系统</strong>时，内核在如下两种情况下运行调度程序：</p><ul><li>进程从运行状态切换到等待状态(等待某个事件)</li><li>进程被终结了</li></ul><p>当前系统为<strong>抢占系统</strong>时，内核在如下情况下运行调度程序：</p><ul><li>中断请求被服务例程响应完成时<ul><li>进程从 运行状态 切换到 就绪状态</li></ul></li><li>当前进程被抢占<ul><li>进程时间片用完</li><li>某进程从 等待状态 切换到 就绪状态 (它的优先级更高，因此会发生抢占)</li></ul></li></ul><h1 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h1><h2 id="评定调度算法好坏的指标"><a href="#评定调度算法好坏的指标" class="headerlink" title="评定调度算法好坏的指标"></a>评定调度算法好坏的指标</h2><p>从运行效率来说：</p><ul><li><strong>CPU使用率</strong>：CPU处于忙状态的时间百分比</li><li><strong>吞吐量</strong>：单位时间内完成的进程数量</li></ul><p>从用户使用来说：</p><ul><li><strong>周转时间</strong>：进程从初始化到完成（包括等待）的时间</li><li><strong>等待时间</strong>：进程在就绪队列中等待的时间</li><li><strong>响应时间</strong>：从提交请求到产生响应所花费的总时间</li></ul><p>调度算法的要求：希望“更快”的服务<br>对于“更快”我们有两个层面的描述：</p><ul><li>传输文件时，我们希望高带宽，对应调度算法的<strong>高吞吐量</strong></li><li>玩游戏时，我们希望实时响应，对应调度算法的<strong>低响应延迟</strong></li></ul><p>这两个因素是独立的。我们的设计也分别基于这两个方向。</p><h2 id="调度策略的低时延目标"><a href="#调度策略的低时延目标" class="headerlink" title="调度策略的低时延目标"></a>调度策略的低时延目标</h2><p>减少响应时间：及时处理用户的输入请求，尽快将输出反馈给用户</p><p>减少平均响应时间的波动：可预测性和稳定性比高差异低平均更好</p><p>低延迟调度改善了用户的交互体验</p><h2 id="调度策略的吞吐量目标"><a href="#调度策略的吞吐量目标" class="headerlink" title="调度策略的吞吐量目标"></a>调度策略的吞吐量目标</h2><p>增加吞吐量：减少开销并实现系统资源高效利用</p><p>减少等待时间：减少每个进程的等待时间</p><p>要点：</p><ul><li>操作系统需要保证吞吐量不受用户交互影响</li><li>吞吐量是操作系统的计算带宽</li></ul><h2 id="调度的公平性目标"><a href="#调度的公平性目标" class="headerlink" title="调度的公平性目标"></a>调度的公平性目标</h2><p>除上述两条对于单用户的使用设计目标外，对于多用户的使用公平性。</p><ol><li>保证每个进程占用相同的CPU时间</li><li>保证每个进程的等待时间相同（因此，一个用户使用多个进程，其等待时间也相应增加）</li></ol><p>公平性通常会牺牲一定程度的时延。</p><h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="就绪队列优先级"><a href="#就绪队列优先级" class="headerlink" title="就绪队列优先级"></a>就绪队列优先级</h2><h3 id="先来先服务算法-FCFS，First-Come-First-Served"><a href="#先来先服务算法-FCFS，First-Come-First-Served" class="headerlink" title="先来先服务算法(FCFS，First Come, First Served)"></a>先来先服务算法(FCFS，First Come, First Served)</h3><p>依据进程进入就绪队列的先后顺序排列</p><ul><li>进程进入等待或结束状态时，就绪队列中下一个进程占用CPU</li></ul><p><strong>先来先服务算法的特征</strong>：</p><ul><li>优点<ul><li>简单</li></ul></li><li>缺点<ul><li>平均等待时间波动较大 (短进程排在长进程后面，如下图所示)</li><li>I/O资源和CPU资源的利用率较低 (CPU密集型的进程导致I/O闲置时，I/O密集型进程仍然需要等待)</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210901205431.png" alt="FCFS_TAT" style="zoom:50%;" /><blockquote><p>P1，P2，P3的到达的时间都是时刻0</p></blockquote><h3 id="短进程优先算法-SPN，Shortest-Process-Next"><a href="#短进程优先算法-SPN，Shortest-Process-Next" class="headerlink" title="短进程优先算法(SPN，Shortest Process Next)"></a>短进程优先算法(SPN，Shortest Process Next)</h3><p>选择就绪队列中<strong>预期的执行时间最短</strong>的进程占用CPU进入运行状态（就绪队列按照预期的执行时间来排序。）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902111244.png" alt="SPN" style="zoom:40%;" /><blockquote><p>当有一个新的进程进入就绪队列，且它的预期执行时间比当前正在执行的进程所剩的执行时间还短，允许其抢占，则为 SRT: Shortest Remaining Time (短剩余时间优先)</p></blockquote><p><strong>短进程优先算法的特征:</strong></p><ul><li>可能导致饥饿<ul><li>连续的短进程流会使长进程无法获得CPU资源</li></ul></li><li>如何预测进程的执行时间<ul><li>可以询问用户，用户可能不知道；也有可能给出过于乐观的估计，比如用户觉得自己的工作能很快做完（“欺骗”），但发现卡死了，这时候可以手动中止这个运行时间较长的程序。</li><li>用过去预测未来。利用过去的情况来预测某个进程的执行时间。 $\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n$​ ， $\tau_i$为第$i$次的估计值</li></ul></li></ul><h3 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h3><p>是短进程优先算法的改进，防止预估时间较长的进程长时间被抢占出现饥饿现象</p><p>选择就绪队列中响应比R值最高的进程，响应比R定义为：$R = \frac {w + s} {s}$ （其中w为等待时间，s为预估执行时间）</p><p><strong>这个算法关注了等待时间，防止了长进程频繁被抢占和无限期推迟。</strong></p><h2 id="时间控制"><a href="#时间控制" class="headerlink" title="时间控制"></a>时间控制</h2><p>以上是从进程排列来考虑的调度算法，我们也可以从时间资源分配入手。</p><h3 id="时间片轮转算法-RR，Round-Robin"><a href="#时间片轮转算法-RR，Round-Robin" class="headerlink" title="时间片轮转算法(RR，Round Robin)"></a>时间片轮转算法(RR，Round Robin)</h3><ul><li>将时间片 q 作为分配处理机资源的基本时间单位</li><li>时间片结束时，按 FCFS(先来先服务)算法切换到下一个就绪进程</li><li>每个进程分到了 1 / n(进程总数) 的时间</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902111332.png" alt="RR" style="zoom:50%;" /><blockquote><p>基于FCFS给出的进程队列，操作系统给队头交替分配相应的处理器资源。如果执行完退出，没有执行完回到队尾</p></blockquote><p><strong>时间片轮转算法特征:</strong></p><p>有额外的上下文切换开销 (正常情况下是在 进程进入等待状态或结束状态时 才切换进程)</p><ul><li>当时间片太大时<ul><li>等待时间过长</li><li>极限情况退化成 FCFS(先来先服务)</li></ul></li><li>当时间片太小时<ul><li>反应迅速，但产生大量的上下文切换</li><li>大量上下文切换开销影响系统的吞吐量(单位时间内 运行的总进程数)</li></ul></li><li>时间片长度选择目标<ul><li>通常为 10ms左右 为一个时间片</li><li>维持上下文开销处于 1% 以内</li></ul></li></ul><h3 id="多级队列调度算法-MQ，Multilevel-Queues"><a href="#多级队列调度算法-MQ，Multilevel-Queues" class="headerlink" title="多级队列调度算法(MQ，Multilevel Queues)"></a>多级队列调度算法(MQ，Multilevel Queues)</h3><ul><li>就绪队列被划分为多个独立的子序列 (例如可以分为前台和后台)</li><li>每个队列拥有自己的调度策略</li><li>队列间调度<ul><li>固定优先级<ul><li>先处理前台 后处理后台</li><li>可能导致饥饿</li></ul></li><li>时间片轮转<ul><li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li><li>80% CPU时间用于前台 20% CPU时间用于后台</li></ul></li></ul></li></ul><h3 id="多级反馈队列算法-MLFQ，Multilevel-Feedback-Queues"><a href="#多级反馈队列算法-MLFQ，Multilevel-Feedback-Queues" class="headerlink" title="多级反馈队列算法(MLFQ，Multilevel Feedback Queues)"></a>多级反馈队列算法(MLFQ，Multilevel Feedback Queues)</h3><p><strong>进程可在不同队列间移动</strong>的多级队列算法。</p><p>首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程；对于同一个队列中的各个进程，按照FCFS分配时间片调度。</p><ul><li>时间片大小随优先级级别增加（级别增加，优先级降低）而增加</li><li>进程在当前时间片没有完成，则降到下一优先级（会被分配更大的时间片）</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902111954.png" alt="MLFQ" style="zoom:50%;" /><p><strong>多级反馈队列算法特征：</strong></p><ul><li>CPU密集型进程的优先级会下降的很快</li><li>I/O密集型进程保留在高优先级</li></ul><h3 id="公平共享调度算法-FSS，Fair-Share-Scheduling"><a href="#公平共享调度算法-FSS，Fair-Share-Scheduling" class="headerlink" title="公平共享调度算法(FSS，Fair Share Scheduling)"></a>公平共享调度算法(FSS，Fair Share Scheduling)</h3><p>FSS 控制用户对系统资源的访问</p><ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源</li></ul><p>未使用的资源按比例分配，没有达到资源使用率目标的组获得更高优先级</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902112301.png" alt="FSS" style="zoom:50%;" /><h3 id="传统调度算法总结"><a href="#传统调度算法总结" class="headerlink" title="传统调度算法总结"></a>传统调度算法总结</h3><blockquote><p>若采用某个调度算法时，每个进程都有机会被调度，则该调度算法是公平的</p></blockquote><ul><li>先来先服务算法(FCFS)<ul><li>不公平 平均等待时间变动大</li></ul></li><li>短进程优先算法(SPN)<ul><li>平均周转时间最小</li><li>需要精确的预测执行时间</li><li>不公平，可能导致饥饿</li></ul></li><li>最高响应比优先算法(HRRN)<ul><li>基于 SPN调度(关注等待时间)</li><li>不可抢占</li></ul></li><li>时间片轮转算法(RR)<ul><li>公平 平均等待时间较差 交互比较好</li></ul></li><li>多级反馈队列算法(MLFQ)<ul><li>多种算法的集合(在实际系统中所使用)</li></ul></li><li>公平共享调度(FSS)<ul><li>公平</li></ul></li></ul><h1 id="实时调度和多处理器调度"><a href="#实时调度和多处理器调度" class="headerlink" title="实时调度和多处理器调度"></a>实时调度和多处理器调度</h1><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时操作系统不仅要求功能正确，还要约定的时间得以保证。</p><p>时间约束的<strong>及时性</strong>和<strong>可预测性</strong>比速度、平均性能更重要。</p><p>要保证时间能极大概率满足一个具体要求。</p><p>几个概念：</p><ul><li>实时任务：对时限有要求的任务</li></ul><p><img src="https://pic3.zhimg.com/80/v2-d09496ae911d7a8f99f11e1ca83a2112_720w.jpg" alt="img"></p><ul><li><p>周期实时任务：一系列相似的规律重复的实时任务。由周期、最大执行时间、使用率等决定。波动越小，使用率就可以越高。</p></li><li><p>硬实时和软实时：硬实时必须要满足时限，可以保证系统的确定性，否则会导致严重后果；而软实时只需尽量满足，无法达成时可以降低要求。</p></li><li><p>可调度性：一个操作系统可以满足任务的时限要求。</p></li><li><ul><li>需要确定实时任务的执行顺序</li><li>进行动态或静态的优先级调度</li></ul></li></ul><p>这里给出两个理论上可调度的实时调度算法，不要求掌握。</p><ul><li>速率单调调度算法RM：通过周期安排优先级，周期越短越早安排。</li><li>最早截止时间优先算法EDF：截止时间越早优先级越高。</li></ul><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多个处理器组成一个多处理器系统，处理器之间共享负载。</p><p><strong>对称处理器调度：</strong></p><ul><li>各处理器都有自己的调度机制</li><li>访问共享资源时再进行同步</li></ul><p><strong>对称多处理器进程分配：</strong></p><ul><li><strong>静态进程分配</strong><ul><li>进程从开始到结束都被分配到一个固定的处理机上执行</li><li>每个处理机有自己的就绪队列</li><li>调度开销小</li><li>各处理机可能忙闲不均</li></ul></li><li><strong>动态进程分配</strong><ul><li>进程在执行中可分配到任意空闲处理机上执行</li><li>所有处理机共享一个就绪队列</li><li>调度开销大</li><li>各处理机的负载是均衡的</li></ul></li></ul><h2 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h2><p>优先级置是我们不希望发生的一种调度状态。在该种状态下，一个高优先级任务间接被一个低优先级任务所抢先。</p><blockquote><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/maimang1001/article/details/7343045">说说优先级倒置（Priority inversion）blog.csdn.net</a></p></blockquote><p>这往往出现在一个高优先级任务<strong>等待访问</strong>一个被低优先级任务正在使用的<strong>临界资源</strong>时。并且此时，该低优先级任务被一个次高优先级的任务所抢先，从而<strong>无法及时地释放该临界资源</strong>。从而阻塞了高优先级任务。如下图。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902114018.png" alt="priority_inversion" style="zoom:50%;" /><blockquote><p>注：临界资源指一次只能被一个进程占用的资源，这些资源是互斥体。</p></blockquote><p><strong>如何解决优先级反置?</strong></p><p>为了保证这个互斥体资源不被次高级进程抢走，常见地，我们有如下两种策略：</p><ul><li>优先级继承(Priority Inheritance)</li><li>优先级天花板协议(Priority Ceiling Protocol)</li></ul><p><strong>优先级继承(Priority Inheritance)</strong></p><p>占用资源的低优先级进程，继承申请资源的高优先级进程的优先级。</p><p>以下图为例，T1为优先级最高的进程，T3为最低。t4之后为什么让T3先执行，就是使用了优先级继承的策略，将T3的优先级提高到和T1一样，从而让已经占有临界区资源的进程先运行。从图中可以看出，如果t4之后资源s被次高级的T2所抢占，那么T1和T3还需要等很长时间。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902114320.png" alt="priority_inheritance" style="zoom:60%;" /><blockquote><p>注意，只有在占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级。如上图中的t3到t4之间发生的。</p></blockquote><h5 id="优先级天花板协议-Priority-Ceiling-Protocol"><a href="#优先级天花板协议-Priority-Ceiling-Protocol" class="headerlink" title="优先级天花板协议(Priority Ceiling Protocol)"></a>优先级天花板协议(Priority Ceiling Protocol)</h5><p>占用资源进程的优先级，和所有可能申请该资源的进程的最高优先级相同。</p><ul><li>不管是否发生等待，都提升占用资源进程的优先级</li><li>从而当任务执行临界区时就不会被阻塞</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;处理器调度概念&quot;&gt;&lt;a href=&quot;#处理器调度概念&quot; class=&quot;headerlink&quot; title=&quot;处理器调度概念&quot;&gt;&lt;/a&gt;处理器调度概念&lt;/h1&gt;&lt;h2 id=&quot;调度的技术背景&quot;&gt;&lt;a href=&quot;#调度的技术背景&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="清华os课程" scheme="https://icbtbo.github.io/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="操作系统" scheme="https://icbtbo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
