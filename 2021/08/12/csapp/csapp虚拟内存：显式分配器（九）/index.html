<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>csapp虚拟内存：显式分配器（九） | sjc的搬砖小屋</title><meta name="keywords" content="虚拟内存,内存分配"><meta name="author" content="icbtbo"><meta name="copyright" content="icbtbo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="介绍了如何利用动态内存分配器显式分配内存；介绍了堆内存中块的多种数据结构。">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp虚拟内存：显式分配器（九）">
<meta property="og:url" content="https://icbtbo.github.io/2021/08/12/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/index.html">
<meta property="og:site_name" content="sjc的搬砖小屋">
<meta property="og:description" content="介绍了如何利用动态内存分配器显式分配内存；介绍了堆内存中块的多种数据结构。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icbtbo.github.io/img/default_bg.png">
<meta property="article:published_time" content="2021-08-12T07:55:59.000Z">
<meta property="article:modified_time" content="2021-08-12T08:06:15.952Z">
<meta property="article:author" content="icbtbo">
<meta property="article:tag" content="虚拟内存">
<meta property="article:tag" content="内存分配">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icbtbo.github.io/img/default_bg.png"><link rel="shortcut icon" href="/img/home.png"><link rel="canonical" href="https://icbtbo.github.io/2021/08/12/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-12 16:06:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="sjc的搬砖小屋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/niu.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_bg.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sjc的搬砖小屋</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">csapp虚拟内存：显式分配器（九）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-12T07:55:59.000Z" title="发表于 2021-08-12 15:55:59">2021-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-12T08:06:15.952Z" title="更新于 2021-08-12 16:06:15">2021-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/">《深入理解计算机系统》</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>对应于书中的9.9。</p>
<hr>
<ul>
<li>虚拟页的存在是作为虚拟内存和物理内存传输数据块的单位，是由一系列连续的虚拟内存地址组成的，并且这些虚拟地址的特点由虚拟页定义。而虚拟内存段是将一系列大量的连续的具有相似特点的虚拟地址聚集起来，且虚拟内存段也描述了这些虚拟地址的一些特点，并且这些虚拟地址以虚拟页为单位进行组织，即虚拟内存段包含虚拟页。<br>我们使用虚拟内存时是以虚拟地址为单位的，只是根据我们对其使用方式的不同要求和权限，会处于不同虚拟段中的不同虚拟页中。</li>
<li>当调用<code>malloc</code>函数来分配块时，首先会在空闲链表中寻找是否有合适的空闲块，如果尝试了合并空闲块还是没找到，则会调用<code>sbrk</code>函数来向内核申请更大的堆内存。所以在一开始将堆与匿名文件映射时，堆内存为0，则第一次调用<code>malloc</code>函数时，会直接调用<code>sbrk</code>函数来申请得到一块大的空闲块，该空闲块可能会比你尝试分配的块大，然后就一直在这个堆中进行操作。</li>
<li>堆的起始地址到<code>brk</code>之间是已申请的堆内存，可以在里面进行动态内存分配，而<code>brk</code>之外的是未申请的堆内存，只有当找不到合适的空闲块时，才会向内核申请更大的可用空间，此时就会移动<code>brk</code>。</li>
</ul>
<hr>
<p>除了上一章介绍的通过<code>mmap</code>函数能让用户自定义内存映射，将磁盘文件映射到虚拟内存中以外，也可以在运行时使用<strong>动态内存分配器（Dynamic Memory Allocator）</strong>来分配额外的虚拟内存。动态内存分配器维护着虚拟内存中的堆段，将堆视为一组不同大小的块的集合，每个块由若干个连续的虚拟地址构成（一个块不一定处在同一个虚拟页），每个块具有<strong>两种状态：</strong></p>
<ul>
<li><strong>已分配：</strong>已分配的块能为应用程序所用，且块会保持已分配状态直到被释放</li>
<li><strong>空闲的：</strong>空闲的块无法使用，直到它被分配</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110902.jpg" alt="img" style="zoom:80%;" />

<p>而在最开始进行内存映射时，堆是与匿名文件关联起来的，所以堆是一个全0的段，即处于空闲状态，它紧跟在未初始的数据段后面，向地址更大的方向延伸，且内核对每个进程都维护了<code>brk</code>变量来指向堆顶。</p>
<p>动态内存分配器具有两种类型，都要求由应用程序显示分配块，但是由不同实体来负责释放已分配的块：</p>
<ul>
<li><strong>显示分配器（Explicit Allocator）：</strong>要求应用程序显示释放已分配的块。比如C中通过<code>malloc</code>来分配块，再通过<code>free</code>来显示释放已分配的块，C++中的<code>new</code>和<code>delete</code>相同。</li>
<li><strong>隐式分配器（Implicit Allocator）：</strong>由分配器检测哪些块已不被应用程序使用，就自动释放这些块。这种隐式分配器称为<strong>垃圾收集器（Garbage Collector）</strong>，而这种过程称为<strong>垃圾收集（Garbage Collection）</strong>。比如Java、ML和Lisp。</li>
</ul>
<p>程序使用动态内存分配器来动态分配内存的<strong>意义在于：</strong>有些数据结构只有在程序运行时才知道大小。通过这种方式就无需通过硬编码方式来指定数组大小，而是根据需要动态分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span>, i, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一章主要介绍管理堆内存的显示分配器。</p>
<hr>
<h2 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a><code>malloc</code>和<code>free</code>函数</h2><p>C中提供了malloc显示分配器，程序可以通过<code>malloc</code>函数来显示地从堆中分配块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br></pre></td></tr></table></figure>

<p>该函数会返回一个指向大小至少为<code>size</code>字节的未初始化内存块的指针，且根据程序的编译时选择的字长，来确定内存地址对齐的位数，比如<code>-m32</code>表示32位模式，地址与8对齐，<code>-m64</code>表示64位模式，地址与16对齐。如果函数出现错误，则返回NULL，并设置<code>errno</code>。我们也可以使用<code>calloc</code>函数来将分配的内存块初始化为0，也可以使用<code>realloc</code>函数来改变已分配块的大小。</p>
<p>程序可以通过<code>free</code>函数来释放已分配的堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>ptr</code>参数要指向通过<code>malloc</code>、<code>calloc</code>或<code>realloc</code>函数获得的堆内存。</p>
<p>动态内存分配器可以使用<code>mmap</code>和<code>munmap</code>函数，也可以使用<code>sbrk</code>函数来向内核申请堆内存空间，只有先申请获得堆内存空间后，才能尝试对块进行分配让应用程序使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line">`brk`函数会将`brk`设置为`addr`指定的值。`sbrk`函数通过`incr`来增加`brk`</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>incr</code>小于0时，会减小<code>brk</code>来解除已分配的堆内存</li>
<li>当<code>incr</code>等于0时，会返回当前的<code>brk</code>值</li>
<li>当<code>incr</code>大于0时，会增加<code>brk</code>来分配更多的堆内存</li>
</ul>
<p>当<code>sbrk</code>函数运行正常时，会返回之前的<code>brk</code>值，否则会返回-1并设置<code>errno</code>为<code>ENOMEM</code>。</p>
<p>当我们使用<code>malloc</code>函数申请较小的堆内存时，会通过<code>brk</code>或<code>sbrk</code>函数设置<code>brk</code>来实现。<code>brk</code>和<code>sbrk</code>函数分配的堆内存类似于缓冲池，每次<code>malloc</code>从缓冲池获得内存时，如果缓冲池大小不够，就会调用<code>brk</code>或<code>sbrk</code>函数来扩充缓冲池，然后从该缓冲池中获得对应的内存，而<code>free</code>函数就会将应用程序使用的内存空间归还缓冲池。</p>
<p><strong>通过<code>sbrk</code>和<code>brk</code>函数来针对小块内存的申请，会产生内存碎片问题。对于大块内存的申请，会直接使用<code>mmap</code>函数，直接将大段的虚拟地址空间与匿名文件关联起来，就不会有内存碎片问题</strong>。</p>
<p>在本章节中，以字为单位进行操作，每个字为4字节，并进行双字对齐（下图中，一格代表一字）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812105756.jpg" alt="img"></p>
<p><strong>注意：</strong></p>
<ul>
<li>分配堆内存时，会进行地址对齐</li>
<li>释放内存后，其指针不会被删除，所以要谨慎被删除的指针的使用</li>
</ul>
<h2 id="显示分配器的要求和目标"><a href="#显示分配器的要求和目标" class="headerlink" title="显示分配器的要求和目标"></a>显示分配器的要求和目标</h2><p>显示分配器的<strong>要求</strong>有：</p>
<ul>
<li>只要满足每个释放请求都对应于一个由以前分配请求获得的已分配的块，则应用程序可以以任意顺序发送分配请求和释放请求。</li>
<li>分配器必须立即响应请求，不允许对请求进行重排列或缓存。</li>
<li>为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆内。</li>
<li>为了能保存任意类型的数据对象，分配必须对齐块。（比如讲解<code>struct</code>时，它根据对齐要求对起始虚拟地址是有要求的）</li>
<li>当块被分配了，分配器不允许对其进行修改或移动，因为已分配块属于应用程序了。</li>
</ul>
<p>显示分配器的<strong>目标</strong>为：吞吐率最大化和内存使用率最大化</p>
<ul>
<li><p>吞吐率是指每个单位时间内完成的请求数。一个分配请求的最差运行时间与空闲块的数量成线性关系（要一次搜索每个空闲块来确定是否适合），而一个释放请求的运行时间是常数，则我们可以通过最小化分配请求和释放请求的平均运行时间来最大化吞吐率，主要约束项在分配请求。</p>
</li>
<li><p>一个系统中所有进程分配的虚拟内存的全部数量是受磁盘上的交换空间限制的，所以要尽可能最大化内存使用率。首先，我们给定n个分配请求和释放请求的序列 $R_0,R_1,…,R_k,…,R_{n-1}$ ，然后定义以下概念：</p>
</li>
<li><ul>
<li><strong>有效载荷（Payload）：</strong>应用程序请求一个p字节的块，则该已分配的块的有效载荷为p字节。（分配器为了对齐要求和块的格式，可能会申请比p更大的块）</li>
<li><strong>聚集有效载荷（Aggregate Payload）</strong>P：当前已分配的块的有效载荷之和</li>
<li>然后我们可以通过<code>brk</code>变量来确定堆当前的大小 $H_k$ （假设是单调不递减的）<br>由此我们可以确定前k+1个请求的<strong>峰值利用率（Peak Utilization）</strong>$U_k = \frac{max_{i \leq k}P_i}{H_k}$ 。通过峰值利用率就能确定分配器使用堆的效率，并且对于任意的分配和释放序列，最大的 $P_i$ 是相同的。在理想状态下，每个块的内容都是有效载荷，所以利用率为1。</li>
</ul>
</li>
</ul>
<p>造成堆内存使用效率低下的主要原因是<strong>碎片（Fragmentation）</strong>现象，当空闲的内存不能满足分配请求时就会产生碎片，主要分为两种：</p>
<ul>
<li><strong>内部碎片（Internal Fragmentation）：</strong>当已分配的块比有效载荷大时，就会产生内部碎片。比如分配器为了满足对齐要求或保存块的数据结构，就会对分配块增加额外的内存空间。我们可以通过已分配块的大小与其有效载荷的差来量化内部碎片，则内部碎片的数量主要取决于之前请求的模式和分配器的实现方法。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110939.jpg" alt="img" style="zoom:80%;" />

<ul>
<li><strong>外部碎片（External Fragmentation）：</strong>当空闲的内存合起来够满足一个分配请求，但单独一个空闲内存不够时，就会产生外部碎片。外部碎片比较难进行量化，因为它主要取决于未来请求的模式，所以分配器通常试图维持少量的大的空闲块。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110948.jpg" alt="img" style="zoom:80%;" />

<p>为了让分配器能平衡吞吐率和利用率，需要考虑以下几个<strong>问题：</strong></p>
<ul>
<li>如何记录堆中空闲的块？</li>
<li>如何选择一个合适的空闲块来放置一个新分配的块？</li>
<li>再将一个新分配的块放置在某个空闲块后，如何处理空闲块中剩余部分？</li>
<li>如何处理一个刚刚被释放的块？</li>
<li>当我们对一个指针调用<code>free</code>时，怎么知道要释放多少内存？</li>
</ul>
<h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>对于堆内存中的块，我们可以将其定义为以下数据结构形式</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110955.jpg" alt="img" style="zoom:80%;" />

<p>则每个块由三部分构成：</p>
<ul>
<li><strong>头部：</strong>大小为一个字（一个字为4字节），可以用来保存块大小，如果我们添加一个双字的对齐要求，则块大小就总是8的倍数，则头部中表示块大小的低3位就总是0，我们可以拿这3位来表示该块是否被分配。（则一个块最大只能是 $2^{29}-1$字节)</li>
<li><strong>有效载荷：</strong>应用通过<code>malloc</code>请求的有效载荷</li>
<li><strong>填充：</strong>可选的，分配器可用来处理外部碎片，或满足对齐要求。</li>
</ul>
<p>我们通过块的这种数据结构来组织堆内存，则通过块头部的块大小来将堆中的所有块链接起来。分配器可以通过遍历所有块，然后通过块头部的字段来判断该块是否空闲的，来间接遍历整个空闲块集合。我们可以通过一个大小为0的已分配块来作为<strong>终止头部（Terminating Header）</strong>，来表示结束块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812111253.png" alt="img"></p>
<blockquote>
<p>头部标记为（大小（字节）/已分配位）</p>
</blockquote>
<p><strong>注意：</strong>计算块大小时，要先将有效载荷加上块头部大小，然后再计算满足对齐要求时的块大小。</p>
<p>由于地址对齐要求和分配器对块格式的选择，会对<strong>最小块</strong>的大小有限制，没有已分配的块和空闲块比最小块还小，如果比最小块还小，就会变成外部碎片（所以最小块越大，内部碎片程度越高）。比如这里如果对齐要求是双字8字节的，则最小块大小为双字：第一个字用来保存头部，另一个字用来满足对齐要求。</p>
<h4 id="选择空闲块"><a href="#选择空闲块" class="headerlink" title="选择空闲块"></a>选择空闲块</h4><p>当应用请求一个k字节的空闲块时，分配器会搜索空闲链表，并根据不同的<strong>放置策略（Placement Policy）</strong>来确定使用的空闲块：</p>
<ul>
<li><p><strong>首次适配（First Fit）：</strong>分配器从头开始搜索空闲链表，选择第一个块大小大于k的空闲块。</p>
</li>
<li><ul>
<li><strong>优点：</strong>趋向于将大的空闲块保留在空闲链表后面。</li>
<li><strong>缺点：</strong>空闲链表开始部分会包含很多碎片</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812111626.jpg" alt="img" style="zoom:67%;" />

<ul>
<li><p><strong>下一次适配（Next Fit）：</strong>分配器从上一次查询结束的地方开始进行搜索，选择第一个块大小大于k的空闲块。</p>
</li>
<li><ul>
<li><strong>优点：</strong>运行比首次适配块一些，可以跳过开头的碎片</li>
<li><strong>缺点：</strong>内存利用率比首次适配低很多</li>
</ul>
</li>
<li><p><strong>最佳适配（Best Fit）：</strong>分配器会查找所有空闲块，选择块大小大于k的最小空闲块。</p>
</li>
<li><ul>
<li><strong>优点：</strong>内存利用率比前两者都高一些</li>
<li><strong>缺点：</strong>需要遍历完整的空闲链表</li>
</ul>
</li>
</ul>
<p>如果分配器可以找到满足要求的空闲块，则需要<strong>确定如何使用这个空闲块：</strong></p>
<ul>
<li>如果空闲块与k大小相近，则可以直接使用这一整个空闲块</li>
<li>如果空闲块比k大很多，如果直接使用整个空闲块，则会造成很大的内部碎片，所以会尝试对该空闲块进行分割，一部分用来保存k字节数据，另一部分构成新的空闲块。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812111802.jpg" alt="img" style="zoom:80%;" />

<p>如果分配器找不到满足要求的空闲块，则会首先尝试将物理上相邻的两个空闲块合并起来创建一个更大的空闲块，如果还是不满足要求，则分配器会调用<code>sbrk</code>函数来向内核申请额外的堆内存，然后将申请到的新空间当做是一个空闲块。</p>
<h4 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h4><p>当我们尝试释放分配块时，如果当前块与其他空闲块相邻，则会产生<strong>假碎片（Fault Fragmentation）</strong>现象，即许多可用的空闲块被分割为小的无法使用的空闲块，此时分配器就可以合并相邻空闲块来解决假碎片问题，具有以下策略：</p>
<ul>
<li><p><strong>立即合并（Immediate Coalescing）：</strong>当我们释放一个分配块时，就合并与其相邻的空闲块。</p>
</li>
<li><ul>
<li><strong>优点：</strong>可在常数时间内完成</li>
<li><strong>缺点：</strong>可能一个空闲块会被来回分割和合并，产生抖动</li>
</ul>
</li>
<li><p><strong>推迟合并（Deferred Coalescing）：</strong>当找不到合适的空闲块时，再扫描整个堆来合并所有空闲块。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112351.jpg" alt="img" style="zoom:80%;" />

<p>为了高效合并前一个空闲块，需要使用<strong>边界标记（Boundary Tag）</strong>技术，使得当前块能迅速判断前一个块是否为空闲的</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112438.jpg" alt="img" style="zoom:80%;" />

<p>在块的数据结构中，会添加一个块头部的副本到脚部。这样当前块从起始位置向前偏移一个字长度，就能得到前一个块的脚部，通过脚部就能判断前一个快是否为空闲的，并且也能得到前一个块的大小。且当前块通过自己头部的块大小就能得到下一个块的头部，由此来判断下一个块是否空闲，以及下一个块的大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112553.jpg" alt="img"></p>
<p>可以将所有情况分成以下几种：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112637.jpg" alt="img" style="zoom:80%;" />

<ul>
<li>前一块和后一块都是分配的：此时不会发生合并操作。</li>
<li>前一块是已分配的，后一块是空闲的：当前块会将头部中的块大小设置为当前快的大小和下一块大小之和，并且修改下一块的脚部。</li>
<li>前一块是空闲的，下一块是已分配的：前一块会将头部中的块大小设置为自己的块大小和当前块大小之和，并且修改当前块的脚部。</li>
<li>前一块和当前快都是空闲的：前一块会将头部中的块大小设置为这三个块的大小之和，并修改下一块的脚部。</li>
</ul>
<p>该技术的缺点是会显著增加内存开销，由于引入了脚部，使得有效载荷大小变小，而使得内部碎片变多了，并且最小块的大小变大导致外部碎片也变多了。</p>
<p>我们可以对其进行优化，有些情况是不需要边界标记的，只有在合并时才需要脚部，而我们只会在空闲块上进行合并，所以在已分配的块上可以不需要脚部，那空闲块如何判断前一个块是否为已分配的呢？可以在自己的头部的3个位中用一个位来标记前一个块是否为空闲的，如果前一个块为已分配的，则无需关心前一个块的大小，因为不会进行合并；如果前一个块为空闲的，则前一个块自己就有脚部，说明了前一个块的大小，则可以顺利进行合并操作。</p>
<blockquote>
<p>通过合并操作，空闲块的两侧一定都是已分配的块。</p>
</blockquote>
<p><strong>隐式空闲链表的特点总结：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112840.jpg" alt="img" style="zoom:80%;" />

<h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>由于隐式空闲列表的块分配耗费时间与堆块的总数呈线性关系，其对于通用的分配器是不适合的。</p>
<p>一种更好的方法是将空闲块组织成某种形式的显示数据结构。因为空闲块中除了头部和脚部以外都是没有被使用的，所以可以在空闲块中的其余部分引入其他信息，这里引入了一个指向前一个空闲块的<code>pred</code>指针，还有一个指向下一个空闲块的<code>succ</code>指针，由此就将空闲块组织成双向链表形式。 但是这种方法需要更大的空闲最小块，否则不够存放两个指针，这就提高了外部碎片的程度。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812151512.jpg" alt="img" style="zoom:80%;" />

<p>对于已分配块，可以通过头部和脚部来得到地址相邻两个块的信息，而对于空闲块，可以通过头部和脚部来得到地址相邻两个块，也可以通过两个指针直接获得相邻的两个空闲块。<strong>注意：</strong>逻辑上看这两个空闲块是相邻的，但物理地址上不一定是相邻的，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812151627.jpg" alt="img"></p>
<p>分配器使用这种形式的块结构，可以将首次适配时间从块总数的线性时间降低为空闲块总数的线性时间（因为要依次遍历检索到满足要求的空闲块）。比如我们这里存在以下3个空闲块的双向链表，此时想要分配中间的空闲块，且对其进行分割</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812152357.jpg" alt="img" style="zoom:80%;" />

<p>此时就会获得以下形式，因为已分配块可以根据指针来定位，所以不需要额外进行链接。而空闲块会从中分割出合适的部分用于分配，其余部分作为新的空闲块，此时只要更新对应的指针就行。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812152415.jpg" alt="img" style="zoom:80%;" />

<p>而当我们想要释放已分配块时，它并不在空闲链表中，要将其放在空闲链表什么位置？我们对空闲链表的维护会影响释放已分配块的时间：</p>
<ul>
<li><strong>后进先出（LIFO）策略：</strong>将释放的已分配块放到空闲链表开始的地方，则只需要常数时间就能释放一个块。如果使用后进先出和首次适配策略，则分配器会先检索最近使用过的块。但是碎片化会比地址顺序策略严重。</li>
<li><strong>地址顺序策略：</strong>释放一个块需要遍历空闲链表，保证链表中每个空闲块的地址都小于它后继的地址。这种策略的首次适配会比后进先出的首次适配有更高的内存利用率。</li>
</ul>
<p>接下来以LIFO策略为例，说明在四种情况下如何进行空闲块合并：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153523.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况一：要释放的块前后都为已分配的块</center>

<p>我们可以通过后面块的头部以及前面块的脚部来得知相邻两个块的已分配状况（这就是保留头部和脚部的意义）。由于相邻的都是已分配的块，所以不会进行空闲块合并，直接更新Root的<code>succ</code>指针使其指向要释放的块，而让要释放的块的<code>pred</code>指向Root，<code>succ</code>指向原来第一个空闲块，然后更新原来的第一个空闲块的<code>pred</code>指针。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153514.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况一解决方案</center>

<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153504.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况二：要释放的块后面为空闲块，前面为已分配的块</center>

<p>要释放的块后面为空闲块，则需要将当前块和后一块进行合并。我们可以简单地修改头部和脚部直接将两个空闲块合并，但是后一块为空闲块，会处于空闲链表的某个位置，所以要修改后一块的前后两个空闲块的指针，使其跳过后一块。然后修改对应指针就行。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153455.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况二的解决方案</center>

<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153447.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况三：要释放的块前面为空闲块，后面为已分配的块</center>

<p>和情况二类似。如果不是LIFO策略，其实可以直接保留前一个块的指针。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153434.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况三的解决方案</center>

<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153425.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况四：当前块的前后两个块都为空闲块</center>

<p>情况四其实就是情况二和三的合并。对于前后两个空闲块，直接让其指针前后的两个空闲块修改指针跳过，然后修改头部和脚部进行合并</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153415.jpg" alt="img" style="zoom:80%;" />

<center style="color:#C0C0C0;text-decoration:underline">情况四的解决方案</center>

<p><strong>显示链表特点总结：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153407.jpg" alt="img" style="zoom:80%;" />

<h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><p>为了减少分配时间，可以使用<strong>分离存储（Segregrated Storage）</strong>方法，首先将所有空闲块根据块大小分成不同类别，称为<strong>大小类（Size Class）</strong>，比如可以根据2幂次分成</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153623.png" alt="img"></p>
<p>这样不同空闲块就落在不同的大小类中，然后对于每个大小类都生成自己独立的空闲链表，然后分配器根据大小类的大小，将对应的空闲链表按照升序保存在数组中。由此能极大加快分配速度。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153701.jpg" alt="img" style="zoom:80%;" />

<p>当我们想要分配一个大小为n的块时，会首先根据空闲链表数组确定对应的大小类，找到合适的空闲链表，搜索是否有合适的空闲块，如果有，可以对其进行分割，则剩下的部分要放到合适合适的空闲链表中，如果没有合适的空闲块，则会找下一个更大的大小类，重复上述步骤。</p>
<p>如果遍历了所有大小类的空闲链表还是找不到合适的空闲块时，分配器就会向内核申请更大的堆内存空间，然后将作为一个空闲块放在最大的大小类的空闲链表中。</p>
<p>当我们想要释放一个块时，需要对其地址周围的空闲块进行合并，然后将其放在合适的大小类中。</p>
<p>分离的空闲链表是当前最好的分配器类型，对于吞吐量方面，由于将原来巨大的空闲链表根据大小类将其划分为很多小的空闲链表，使得在单一空闲链表中搜索速度快很多，对于内存利用率方面，由于大小类的存在，使得你正在搜索的空闲链表是最适合你想要分配的大小，在这里使用首次适配策略就能得到接近在整个空闲链表中使用最佳适配策略的性能。最极端的情况是为每个块都设置一个大小类，这样就等于最佳适配策略的性能了。</p>
<h4 id="简单分离存储"><a href="#简单分离存储" class="headerlink" title="简单分离存储"></a>简单分离存储</h4><p>简单分离存储具有以下<strong>特点：</strong></p>
<ul>
<li>每个大小类中都只包含大小相同的块，且块大小就是这个大小类中最大元素的大小。比如<code>&#123;5~8&#125;</code>就只包含大小为8的空闲块。</li>
<li>不执行分割</li>
<li>不执行合并</li>
</ul>
<p>当进行分配时，会根据块大小先找到对应的空闲链表，如果存在空闲块则直接分配第一个空闲块，如果不存在，则分配器向内核请求得到一个固定大小的虚拟内存片，然后将其划分为大小相同的空闲块，将其链接起来得到新的空闲链表。</p>
<p>当进行释放时，直接将其插入对应的空闲链表头部。</p>
<ul>
<li><strong>优点：</strong>分配和释放块都是常数时间，不分割，不合并，已分配块不需要头部和脚部，空闲链表只需是单向的，因此最小块为单字大小。</li>
<li><strong>缺点：</strong>由于使用分割和合并，所以会有大量的内部和外部碎片。</li>
</ul>
<h4 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配"></a>分离适配</h4><p>分离适配的分配器维护一个空闲链表的数组，每个链表和一个大小类相关联，包含大小不同的块。分配块时，确定请求的大小类，对适当的空闲链表做首次适配，如果找到合适的块，可以分割它，将剩余的部分插入适当的空闲链表中；如果没找到合适的块，查找更大的大小类的空闲链表。如果没有合适的块，就向内核请求额外的堆内存，从这堆内存中分割出合适的块，然后将剩余部分放到合适的大小类中。每释放一个块时，就进行合并，并将其放到合适的大小类中。</p>
<p>分离适配方法比较常见，如GNU malloc包。这种方法既快、利用率也高。</p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>伙伴系统（Buddy System）是分离适配的一种特例，要求每个大小类都是2的幂。假设一个堆大小为$2^m$​，为每个大小为 $2^k$ 的空闲块都维护了对应的空闲链表。最开始只有一个 $2^m$ 大小的空闲块：</p>
<ul>
<li><strong>请求分配时：</strong>找到第一个可用的大小为 $2^j$ 的空闲块，将其递归平均分割直到刚好能装下我们的数据。每次分割下来的另一部分为伙伴，被放在相应的空闲链表中。</li>
<li><strong>请求释放时：</strong>会不断合并空闲的伙伴，直到遇到一个已分配的伙伴就停止。</li>
</ul>
<p>我们可以通过地址和块大小很快计算出伙伴地址。主要优点在于快速搜索和快速合并，但是会造成大量的内部碎片。</p>
<h2 id="隐式分配器"><a href="#隐式分配器" class="headerlink" title="隐式分配器"></a>隐式分配器</h2><p>显示分配器要求应用程序显示地调用<code>free</code>函数来释放已分配块，比如以下代码中在<code>garbage</code>函数中调用了<code>malloc</code>函数来分配块，但是函数返回时并没进行释放，使得<code>p</code>指向的分配块始终保持已分配的状态，则分配器就无权对该分配块进行操作，由于<code>p</code>保存在函数<code>garbage</code>的栈帧中，当<code>garbage</code>返回时也丢失了<code>p</code>，所以这个已分配块就变成了垃圾，无法被使用，直到程序终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">garbage</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>而在隐式分配器中，分配器会释放程序不再使用的已分配块，自动对其调用<code>free</code>函数进行释放。则应用程序只需要显示分配自己需要的块，而回收过程由分配器自动完成。</p>
<p>隐式分配器也被称为垃圾收集器，关于垃圾收集器的相关知识可参考jvm的<a href="https://icbtbo.github.io/2021/06/04/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">这篇博文</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">icbtbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icbtbo.github.io/2021/08/12/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/">https://icbtbo.github.io/2021/08/12/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icbtbo.github.io" target="_blank">sjc的搬砖小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">虚拟内存</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a></div><div class="post_share"><div class="social-share" data-image="/img/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/20/os/os%EF%BC%9A%E5%90%AF%E5%8A%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"><img class="prev-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">os：启动、中断、异常和系统调用（一）</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/11/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/"><img class="next-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">csapp虚拟内存：系统（九）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/11/csapp/csapp虚拟内存：概念（九）/" title="csapp虚拟内存：概念（九）"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="title">csapp虚拟内存：概念（九）</div></div></a></div><div><a href="/2021/08/11/csapp/csapp虚拟内存：系统（九）/" title="csapp虚拟内存：系统（九）"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="title">csapp虚拟内存：系统（九）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/niu.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">icbtbo</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/icbtbo"><i class="fab fa-github"></i><span>Github</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E5%92%8Cfree%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">malloc和free函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">显示分配器的要求和目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">隐式空闲链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">选择空闲块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">合并空闲块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">显示空闲链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E7%9A%84%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">分离的空闲链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%86%E7%A6%BB%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">简单分离存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%80%82%E9%85%8D"><span class="toc-number">2.3.2.</span> <span class="toc-text">分离适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">伙伴系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">隐式分配器</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:独立功能的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现">Redis设计与实现:独立功能的实现</a><time datetime="2022-01-05T12:59:07.000Z" title="发表于 2022-01-05 20:59:07">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:多机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现">Redis设计与实现:多机数据库的实现</a><time datetime="2022-01-05T01:35:35.000Z" title="发表于 2022-01-05 09:35:35">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:单机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现">Redis设计与实现:单机数据库的实现</a><time datetime="2022-01-04T06:38:05.000Z" title="发表于 2022-01-04 14:38:05">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" title="Redis设计与实现:数据结构与对象"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:数据结构与对象"/></a><div class="content"><a class="title" href="/2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" title="Redis设计与实现:数据结构与对象">Redis设计与实现:数据结构与对象</a><time datetime="2021-12-18T09:16:04.000Z" title="发表于 2021-12-18 17:16:04">2021-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/" title="kafka进阶篇：可靠性探究、应用、监控和高级应用"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kafka进阶篇：可靠性探究、应用、监控和高级应用"/></a><div class="content"><a class="title" href="/2021/11/25/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/" title="kafka进阶篇：可靠性探究、应用、监控和高级应用">kafka进阶篇：可靠性探究、应用、监控和高级应用</a><time datetime="2021-11-25T01:59:17.000Z" title="发表于 2021-11-25 09:59:17">2021-11-25</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By icbtbo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'pLWJLVgdxc6WLcEaFgEr2tQ2-gzGzoHsz',
      appKey: 'OAmeyAUV6TdXoX5n1hSX4ELm',
      placeholder: '请留下你的小脚印～',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      master: 'f94877d77182a6f9068fc12b5545e1f5',
      tagMeta: ["博主","小伙伴","访客"],
      friends: ["52dc4d80afb3aeab1d0deab1aa45a7b5","fd99ca470e7b5e8e2b4f76d6ed26d6cf"]
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>