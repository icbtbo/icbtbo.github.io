<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>os：死锁和进程通信 | sjc的搬砖小屋</title><meta name="keywords" content="操作系统"><meta name="author" content="icbtbo"><meta name="copyright" content="icbtbo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="死锁死锁概念死锁是由于竞争资源或者通信关系，两个或更多线程在执行中出现的，永远相互等待只能由其他进程引发的事件 的状态。 我们使用进程和资源的关系来对死锁进行描述。系统中存在各种类型的资源（CPU执行时间、内存空间、I&#x2F;O设备等），每类资源都可能有多个实例。 进程访问资源时，有如下流程：  请求&#x2F;获取：申请空闲资源 使用&#x2F;占用：进程占用资源 释放：资源状态由占用变成空闲  而资源可以分为如下两类：">
<meta property="og:type" content="article">
<meta property="og:title" content="os：死锁和进程通信">
<meta property="og:url" content="https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="sjc的搬砖小屋">
<meta property="og:description" content="死锁死锁概念死锁是由于竞争资源或者通信关系，两个或更多线程在执行中出现的，永远相互等待只能由其他进程引发的事件 的状态。 我们使用进程和资源的关系来对死锁进行描述。系统中存在各种类型的资源（CPU执行时间、内存空间、I&#x2F;O设备等），每类资源都可能有多个实例。 进程访问资源时，有如下流程：  请求&#x2F;获取：申请空闲资源 使用&#x2F;占用：进程占用资源 释放：资源状态由占用变成空闲  而资源可以分为如下两类：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icbtbo.github.io/img/default_bg.png">
<meta property="article:published_time" content="2021-09-07T02:28:45.000Z">
<meta property="article:modified_time" content="2021-09-07T09:06:29.254Z">
<meta property="article:author" content="icbtbo">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icbtbo.github.io/img/default_bg.png"><link rel="shortcut icon" href="/img/home.png"><link rel="canonical" href="https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-07 17:06:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="sjc的搬砖小屋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/niu.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">86</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_bg.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sjc的搬砖小屋</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">os：死锁和进程通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-07T02:28:45.000Z" title="发表于 2021-09-07 10:28:45">2021-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-07T09:06:29.254Z" title="更新于 2021-09-07 17:06:29">2021-09-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%85%E5%8D%8Eos%E8%AF%BE%E7%A8%8B/">清华os课程</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h3><p>死锁是由于竞争资源或者通信关系，两个或更多线程在执行中出现的，永远相互等待只能由其他进程引发的事件 的状态。</p>
<p><strong>我们使用进程和资源的关系来对死锁进行描述</strong>。系统中存在各种类型的资源（CPU执行时间、内存空间、I/O设备等），每类资源都可能有多个实例。</p>
<p>进程访问资源时，有如下流程：</p>
<ul>
<li>请求/获取：申请空闲资源</li>
<li>使用/占用：进程占用资源</li>
<li>释放：资源状态由占用变成空闲</li>
</ul>
<p>而资源可以分为如下两类：</p>
<ul>
<li><strong>可重用资源</strong>（Reusable）：资源不能删除，互斥，可重用，比如处理器、I/O通道，主副存、文件、数据库、信号量等等，在各占<strong>一部分</strong>资源时会出现死锁</li>
<li><strong>消耗资源</strong>（Consumable）：资源创建和销毁，在I/O缓冲区的中断、信号、消息等，相互等待通信时可能死锁。</li>
</ul>
<p>进程和资源之间的分配和占用可以用<strong>资源分配图</strong>表示，这是一个有向图，其中资源和进程间的分配和占用关系如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907103630.png" alt="Resource_allocation_mapping" style="zoom: 40%;" />

<p><strong>出现死锁的必要条件</strong>：</p>
<ul>
<li>互斥<ul>
<li>任何时刻只能有一个进程使用一个资源实例</li>
</ul>
</li>
<li>持有并等待<ul>
<li>进程保持至少一个资源 并正在等待获取其他进程持有的资源</li>
</ul>
</li>
<li>非抢占<ul>
<li>资源只能在进程使用后自愿释放</li>
</ul>
</li>
<li>循环等待</li>
</ul>
<p>死锁和非死锁的资源分配图示例：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907103850.png" alt="Resource_allocation_mapping_Deadlock" style="zoom:50%;" />

<blockquote>
<p>如上两个图中的情况的不同在于，图右的产生循环的资源都不止一个实例。</p>
</blockquote>
<h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><ul>
<li><strong>死锁预防</strong>（prevention）：限制并发进程对资源的请求，使得系统在任何时刻都<strong>不满足死锁的必要条件</strong>（四个）。</li>
<li><strong>死锁避免</strong>（avoidance）：在分配资源前判断，只允许不会出现死锁的进程请求资源。</li>
<li><strong>死锁检测和恢复</strong>：在检测到运行系统进入死锁状态后，进行恢复。</li>
</ul>
<p>目前大多数操作系统都是由应用程序来解决死锁问题。</p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件，即消除死锁的必要条件。</p>
<p>消除四个必要条件的做法：</p>
<ul>
<li>互斥：允许资源同时使用。比如在线编辑文档</li>
<li>持有并等待：进程请求资源时，要求它不持有其他任何资源。即要求所有进程在开始执行时，一次性地申请在整个运行过程中所需的全部资源（资源利用效率会变低）</li>
<li>非抢占：如果进程请求不能立即分配的资源，则释放占有资源，再分配时只对拥有所有所需资源的进程进行分配操作。</li>
<li>循环等待：对资源排序，要求进程按顺序请求资源</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>利用额外的先验信息，在分配资源时进行动态检查，若分配后系统可能发生死锁，则不予分配，否则予以分配。</p>
<h5 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h5><ul>
<li>如果系统能按某种顺序为每个进程依次分配其所需的资源，直至所有进程都能运行完成，称此时系统处于安全状态</li>
<li>这种进程的顺序，如P4,P1,…,Pn, 称为安全序列</li>
<li>若不存在这样一个安全序列称此时系统处于不安全状态</li>
<li>如果不按安全序列分配资源，则系统可能会由安全状态进入不安全状态。</li>
</ul>
<blockquote>
<p>注意：不安全状态≠死锁</p>
<ul>
<li>处于不安全状态的系统不一定会发生死锁（具体原因可看<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34666857/article/details/104122776">这篇博文</a>）</li>
<li>处于安全状态的系统一定不会发生死锁</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907110717.png" alt="image-20210907110701819"></p>
</blockquote>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>银行家算法就是一种基于资源安全状态判断的死锁避免算法，借鉴银行贷款的策略实现。</p>
<ul>
<li>申请资源的线程在第一次申请资源的时候需声明所需最大资源数，在满足所有资源要求并执行完成后，及时释放资源归还操作系统</li>
<li>若线程申请的资源数量不超过操作系统拥有的最大值时，操作系统尽量满足申请资源的线程的需求</li>
</ul>
<p>实现银行家算法时需要的数据结构如下（n 为线程数量，m 为资源类型数量）：</p>
<ul>
<li>总需求矩阵Max：各个线程对应每种资源的最大需求量（n x m 矩阵）</li>
<li>总剩余向量Available：各个资源的剩余量（长度为 m 的向量）</li>
<li>已分配矩阵Allocation：各个线程对应每种资源的已有量（n x m 矩阵）</li>
<li>未来需要矩阵Need：各个线程对应每种资源的需求差量（n x m 矩阵）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Need[i,j] = Max[i,j] - Allocation[i,j]</span><br></pre></td></tr></table></figure>



<p>银行家算法<strong>安全状态判断</strong>：</p>
<ol>
<li><p>初始化长度为 m 的Work向量和 长度为 n 的Finish向量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work = Available <span class="comment">// 当前资源剩余空闲量</span></span><br><span class="line">Finish[i] = <span class="literal">false</span> <span class="keyword">for</span> i : <span class="number">1</span>, <span class="number">2</span>, ..., n <span class="comment">// 线程i有没有完成</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>寻找线程Ti，其满足以下条件:</p>
<ul>
<li>Finish[i] = false</li>
<li>Need[i] &lt;= Work</li>
</ul>
<p>没有找到满足条件的线程，则跳转到步骤4</p>
</li>
<li><p>找到线程Ti，则进行以下操作：</p>
<ul>
<li>Work = Work + Allocation[i]</li>
<li>Finish[i] = true</li>
<li>回到 步骤1</li>
</ul>
</li>
<li><p>检查所有线程是否满足 Finish[i] == true</p>
<ul>
<li>若都等于，则系统处于安全状态</li>
</ul>
</li>
</ol>
<p>知道了如何进行安全状态判断后，就有了整体的算法执行流程，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">初始化: Requesti 线程Ti的资源请求向量</span><br><span class="line">       Requesti[j] 线程Ti请求资源Rj的实例数量</span><br><span class="line">循环:</span><br><span class="line">1.如果 Requesti ≤ Need[i], 转到步骤2。否则, 拒绝资源申请, 因为线程已经超过了其最大要求</span><br><span class="line">2.如果 Requesti ≤ Available, 转到步骤3。否则, Ti 必须等待, 因为资源不可用</span><br><span class="line">3.通过安全状态判断来确定是否分配资源给Ti: 生成一个需要判断状态是否安全的资源分配环境</span><br><span class="line">	- Available &#x3D; Available - Requesti;</span><br><span class="line">	- Allocation[i] &#x3D; Allocation[i] + Requesti;</span><br><span class="line">	- Need[i]&#x3D; Need[i] – Requesti;</span><br><span class="line">4.调用安全状态判断方法，</span><br><span class="line">	- 若安全 则分配资源给Ti</span><br><span class="line">	- 若不安全 则拒绝Ti的资源请求</span><br></pre></td></tr></table></figure>

<h4 id="死锁检测-Deadlock-Detection"><a href="#死锁检测-Deadlock-Detection" class="headerlink" title="死锁检测(Deadlock Detection)"></a>死锁检测(Deadlock Detection)</h4><p>死锁检测方法和银行家算法的系统安全状态判断是类似的。其执行流程如下：</p>
<ol>
<li>初始化 Work 和 Finish:<ul>
<li>Work = Available // work为当前资源剩余量</li>
<li>Allocation[i] &gt; 0时 Finish[i] = false 否则为 true // 线程是否完成</li>
</ul>
</li>
<li>寻找线程Ti满足:<ul>
<li>Finish[i] = false // 线程没有结束 且 此线程需要的资源量小于剩余资源量</li>
<li>Requesti &lt;= Work</li>
<li>若没有找到 则跳到步骤4</li>
</ul>
</li>
<li>将找到的线程拥有的资源释放回当前空闲资源<ul>
<li>Work = Work + Allocation[i]</li>
<li>Finish[i] = true</li>
<li>跳到步骤2</li>
</ul>
</li>
<li>检查所有线程的 Finish 若有一个为 false 则系统处于死锁状态</li>
</ol>
<p>算法的时间复杂度为O(n^2 x m)，若让操作系统检测系统是否处于死锁状态，开销比较大，因此实际场景操作系统不管死锁。</p>
<h4 id="死锁恢复-Deadlock-Recovery"><a href="#死锁恢复-Deadlock-Recovery" class="headerlink" title="死锁恢复(Deadlock Recovery)"></a>死锁恢复(Deadlock Recovery)</h4><ul>
<li><p>选择哪个进程去终止?</p>
<ul>
<li>终止所有死锁的进程</li>
<li>一次只终止一个进程直到死锁消除</li>
<li>终止进程的顺序应该是<ul>
<li>进程的优先级(选最低的)</li>
<li>进程已运行时间以及还需运行时间(运行时间越长越考虑留下 因为已经利用资源算了很长时间了)</li>
<li>进程已占用资源</li>
<li>进程完成需要的资源</li>
<li>终止进程数目(越少越好)</li>
<li>进程是交互还是批处理(让交互的继续执行)</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么样终止进程? 资源抢占</p>
<ul>
<li>选择被抢占进程(成本最小的)</li>
<li>进程回退 返回到一些安全状态 重启进程到安全状态</li>
<li>可能出现饥饿 同一进程可能一直被选作抢占者</li>
</ul>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间进行通信和同步的机制。</p>
<h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><p>Inter-Processing Communication，后面我们都将进程通信简称为IPC。</p>
<p>IPC提供2个基本操作，发送（send）和接收（receive）。</p>
<p>进程通信流程</p>
<ol>
<li>在通信进程间建立通信链路</li>
<li>通过send/receive交换消息</li>
</ol>
<p>进程链路特征</p>
<ul>
<li>物理（如共享内存、硬件总线）</li>
<li>逻辑（如逻辑属性）</li>
</ul>
<h4 id="直接通信和间接通信"><a href="#直接通信和间接通信" class="headerlink" title="直接通信和间接通信"></a>直接通信和间接通信</h4><p>IPC可分为直接通信和间接通信：</p>
<p><strong>间接通信</strong>(通过系统维护的消息队列)，生命周期可以不同(两个进程不需要同时存在)</p>
<ul>
<li>每个消息队列都有一个唯一的标识</li>
<li>只有共享了相同消息队列的进程 才能够通信</li>
<li>通信链路属性<ul>
<li>只有共享了相同消息队列的进程 才建立连接</li>
<li>连接可以为单向也能为双向</li>
<li>消息队列可以与多个进程相关联</li>
</ul>
</li>
<li>间接通信流程<ol>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接受消息(只关心消息队列是谁)</li>
<li>销毁消息队列</li>
</ol>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907164147.png" alt="Indirect_communication" style="zoom:50%;" />

<p><strong>直接通信</strong>（两个进程必须同时存在才能进行通讯）</p>
<ul>
<li>进程必须正确命名对方</li>
<li>通信链路的属性<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链路存在</li>
<li>链路可以为单向 但通常为双向</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907164211.png" alt="Direct_communication" style="zoom:50%;" />

<h4 id="阻塞与非阻塞通信"><a href="#阻塞与非阻塞通信" class="headerlink" title="阻塞与非阻塞通信"></a>阻塞与非阻塞通信</h4><p>进程通信可划分为阻塞(同步)通信与非阻塞(异步)通信</p>
<p><strong>阻塞通信</strong></p>
<ul>
<li>阻塞发送<ul>
<li>发送者在发送消息后进入等待 直到接受者成功收到</li>
</ul>
</li>
<li>阻塞接受<ul>
<li>接受者在请求接受消息后进入等待 直到成功收到消息</li>
</ul>
</li>
</ul>
<p><strong>非阻塞通信</strong></p>
<ul>
<li>非阻塞发送<ul>
<li>发送者在消息发送后 可立即进行其他操作</li>
<li>没有消息发送时 接受者在请求接受消息后 接受不到任何消息(可以做别的事)</li>
</ul>
</li>
</ul>
<h4 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h4><p>进程发送的消息在链路上可能有三种缓冲方式</p>
<ul>
<li>0 容量<ul>
<li>发送方必须等待接收方(必须有接收方)</li>
</ul>
</li>
<li>有限容量<ul>
<li>通信链路缓冲队列满时 发送方必须等待</li>
</ul>
</li>
<li>无限容量<ul>
<li>发送方不需要等待</li>
</ul>
</li>
</ul>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>进程间的软件中断通知和处理机制(SIGKILL SIGSTOP SIGCONT)</p>
<ul>
<li>信号的接收处理<ul>
<li>捕获(Catch)：执行进程指定的信号处理函数</li>
<li>忽略(Ignore) ：执行操作系统指定的缺省处理(例如进程终止、进程挂起)</li>
<li>屏蔽(Mask) ：禁止进程接受和处理信号(可能是暂时的 当处理同样类型的信号)</li>
</ul>
</li>
<li>不足<ul>
<li>传送的信息量小，只有一个信号类型</li>
</ul>
</li>
</ul>
<h4 id="信号的实现"><a href="#信号的实现" class="headerlink" title="信号的实现"></a>信号的实现</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907165121.png" alt="Signal_implementation" style="zoom:50%;" />

<h4 id="信号的使用示例"><a href="#信号的使用示例" class="headerlink" title="信号的使用示例"></a>信号的使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigproc</span><span class="params">()</span> </span>&#123; 		</span><br><span class="line">signal(SIGINT, sigproc);   <span class="comment">// 为了兼容</span></span><br><span class="line">	<span class="built_in">printf</span>(“you have pressed ctrl-c - disabled \n”);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitproc</span><span class="params">()</span> </span>&#123; 		 </span><br><span class="line">	<span class="built_in">printf</span>(“ctrl-\\ pressed to quit\n”);   <span class="comment">/* this is “ctrl” &amp; “\” */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    signal(SIGINT, sigproc);  <span class="comment">// signal 是注册信号的系统调用，摁下 ctrl+\ 时会发送SIGQUIT信号，</span></span><br><span class="line">  														<span class="comment">// 摁下 ctrl+c 时会发送SIGINT信号</span></span><br><span class="line">    signal(SIGQUIT, quitproc);</span><br><span class="line">	<span class="built_in">printf</span>(“ctrl-c disabled use ctrl-\\ to quit\n”);</span><br><span class="line">	<span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe)"></a>管道(Pipe)</h3><p>进程间基于内存文件的通信机制，进程不知道也不关心另一端</p>
<ul>
<li>子进程从父进程继承文件描述符</li>
<li>缺省文件描述符 0 stdin, 1 stdout, 2 stderr</li>
</ul>
<h4 id="管道相关系统调用"><a href="#管道相关系统调用" class="headerlink" title="管道相关系统调用"></a>管道相关系统调用</h4><ul>
<li>读管道 read()，scanf() 是基于它实现的</li>
<li>写管道 write()，printf() 是基于它实现的</li>
<li>创建管道 pipe(rgfd)<ul>
<li>rgfd是2个文件描述符组成的数组</li>
<li>rgfd[0] 是读文件描述符</li>
<li>rgfd[1] 是写文件描述符</li>
</ul>
</li>
</ul>
<h4 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170054.png" alt="Pipe" style="zoom:50%;" />

<ol>
<li>创建管道</li>
<li>为ls创建一个进程，设置其 stdout 为管道写端</li>
<li>为more创建一个进程，设置其 stdin 为管道读端</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p>
<ul>
<li>每个消息(Message)是一个字节序列</li>
<li>相同标识的消息组成按先进先出顺序组成一个消息队列(Message Queues)</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170301.png" alt="Message_Queues" style="zoom:50%;" />

<h4 id="消息队列的系统调用"><a href="#消息队列的系统调用" class="headerlink" title="消息队列的系统调用"></a>消息队列的系统调用</h4><ul>
<li>msgget()<ul>
<li>获取消息队列标识</li>
</ul>
</li>
<li>msgsnd()<ul>
<li>发送消息</li>
</ul>
</li>
<li>msgrcv()<ul>
<li>接收消息</li>
</ul>
</li>
<li>msgctl()<ul>
<li>消息队列控制</li>
<li>因为消息队列独立于创建它的进程 需要有系统调用完成消息队列的创建和销毁</li>
</ul>
</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p>
<ul>
<li>进程<ul>
<li>每个进程都有私有内存地址空间</li>
<li>每个进程的内存地址空间需明确设置共享内存段</li>
</ul>
</li>
<li>线程<ul>
<li>同一进程中的线程总是共享相同的内存地址空间</li>
</ul>
</li>
<li>优点<ul>
<li>快速 方便地共享数据</li>
</ul>
</li>
<li>不足<ul>
<li>必须用额外的同步机制来协调数据访问</li>
</ul>
</li>
</ul>
<h4 id="共享内存的实现"><a href="#共享内存的实现" class="headerlink" title="共享内存的实现"></a>共享内存的实现</h4><p>通过页表项映射到同一物理页帧</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170400.png" alt="Share_memory_implement" style="zoom:50%;" />

<ul>
<li>优点：速度最快<ul>
<li>没有系统调用干预 没有数据复制</li>
</ul>
</li>
<li>缺点：不提供同步</li>
</ul>
<h4 id="共享内存的系统调用"><a href="#共享内存的系统调用" class="headerlink" title="共享内存的系统调用"></a>共享内存的系统调用</h4><p>为了保证数据的完整性 需要信号量等机制协调共享内存的访问冲突</p>
<ul>
<li>shmget()<ul>
<li>创建共享段</li>
</ul>
</li>
<li>shmat()<ul>
<li>把共享段映射到进程地址空间</li>
</ul>
</li>
<li>shmdt()<ul>
<li>取消共享段到进程地址空间的映射</li>
</ul>
</li>
<li>shmctl()<ul>
<li>共享段的控制</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">icbtbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">https://icbtbo.github.io/2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icbtbo.github.io" target="_blank">sjc的搬砖小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/07/os/os%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><img class="prev-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">os：文件系统</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/06/os/lab7-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"><img class="next-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">os_lab7:同步互斥</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/24/os/os：虚拟存储概念/" title="os:虚拟存储概念（四）"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-24</div><div class="title">os:虚拟存储概念（四）</div></div></a></div><div><a href="/2021/08/23/os/lab2-物理内存管理/" title="os_lab2:物理内存管理"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-23</div><div class="title">os_lab2:物理内存管理</div></div></a></div><div><a href="/2021/08/31/os/lab4-内核线程管理/" title="os_lab4:内核线程管理"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-31</div><div class="title">os_lab4:内核线程管理</div></div></a></div><div><a href="/2021/09/02/os/lab6-调度器/" title="os_lab6:调度器"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-02</div><div class="title">os_lab6:调度器</div></div></a></div><div><a href="/2021/09/09/os/os：IO子系统/" title="os：IO子系统"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-09</div><div class="title">os：IO子系统</div></div></a></div><div><a href="/2021/09/04/os/os：信号量/" title="os：信号量"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-04</div><div class="title">os：信号量</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/niu.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">icbtbo</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">86</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/icbtbo"><i class="fab fa-github"></i><span>Github</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">死锁概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">死锁处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">安全状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B-Deadlock-Detection"><span class="toc-number">1.2.3.</span> <span class="toc-text">死锁检测(Deadlock Detection)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D-Deadlock-Recovery"><span class="toc-number">1.2.4.</span> <span class="toc-text">死锁恢复(Deadlock Recovery)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">进程通信概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E5%92%8C%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">直接通信和间接通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">阻塞与非阻塞通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E7%BC%93%E5%86%B2"><span class="toc-number">2.1.3.</span> <span class="toc-text">通信链路缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7-Signal"><span class="toc-number">2.2.</span> <span class="toc-text">信号(Signal)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">信号的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">信号的使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-Pipe"><span class="toc-number">2.3.</span> <span class="toc-text">管道(Pipe)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">管道相关系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">管道示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">消息队列的系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">共享内存的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">共享内存的系统调用</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/15/Netty%E7%9A%84FastThreadLocal/" title="Netty的FastThreadLocal"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty的FastThreadLocal"/></a><div class="content"><a class="title" href="/2022/06/15/Netty%E7%9A%84FastThreadLocal/" title="Netty的FastThreadLocal">Netty的FastThreadLocal</a><time datetime="2022-06-15T07:04:51.000Z" title="发表于 2022-06-15 15:04:51">2022-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/" title="Netty的对象池技术：Recycler"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty的对象池技术：Recycler"/></a><div class="content"><a class="title" href="/2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/" title="Netty的对象池技术：Recycler">Netty的对象池技术：Recycler</a><time datetime="2022-06-13T13:08:25.000Z" title="发表于 2022-06-13 21:08:25">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:独立功能的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现">Redis设计与实现:独立功能的实现</a><time datetime="2022-01-05T12:59:07.000Z" title="发表于 2022-01-05 20:59:07">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:多机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现">Redis设计与实现:多机数据库的实现</a><time datetime="2022-01-05T01:35:35.000Z" title="发表于 2022-01-05 09:35:35">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:单机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现">Redis设计与实现:单机数据库的实现</a><time datetime="2022-01-04T06:38:05.000Z" title="发表于 2022-01-04 14:38:05">2022-01-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By icbtbo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'pLWJLVgdxc6WLcEaFgEr2tQ2-gzGzoHsz',
      appKey: 'OAmeyAUV6TdXoX5n1hSX4ELm',
      placeholder: '请留下你的小脚印～',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      master: 'f94877d77182a6f9068fc12b5545e1f5',
      tagMeta: ["博主","小伙伴","访客"],
      friends: ["52dc4d80afb3aeab1d0deab1aa45a7b5","fd99ca470e7b5e8e2b4f76d6ed26d6cf"]
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>