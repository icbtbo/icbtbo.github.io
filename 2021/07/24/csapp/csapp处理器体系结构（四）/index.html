<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>csapp处理器体系结构（四） | sjc的搬砖小屋</title><meta name="keywords" content="处理器体系结构"><meta name="author" content="icbtbo"><meta name="copyright" content="icbtbo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="提供一些硬件设计背景，描述处理器中使用的基本结构块以及它们如何连接和操作的；给出一个基于顺序操作、功能正确的Y86-64处理器，它每个时钟周期执行一条完整的Y86-64指令；创建一个流水线化的处理器（Pipelined processor），处理器将每条指令分成五个阶段，每个阶段在独立的硬件部分或阶段处理，由此处理器能同时执行五条指令的不同阶段。">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp处理器体系结构（四）">
<meta property="og:url" content="https://icbtbo.github.io/2021/07/24/csapp/csapp%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/index.html">
<meta property="og:site_name" content="sjc的搬砖小屋">
<meta property="og:description" content="提供一些硬件设计背景，描述处理器中使用的基本结构块以及它们如何连接和操作的；给出一个基于顺序操作、功能正确的Y86-64处理器，它每个时钟周期执行一条完整的Y86-64指令；创建一个流水线化的处理器（Pipelined processor），处理器将每条指令分成五个阶段，每个阶段在独立的硬件部分或阶段处理，由此处理器能同时执行五条指令的不同阶段。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icbtbo.github.io/img/default_bg.png">
<meta property="article:published_time" content="2021-07-24T07:39:49.000Z">
<meta property="article:modified_time" content="2021-08-20T13:44:03.460Z">
<meta property="article:author" content="icbtbo">
<meta property="article:tag" content="处理器体系结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icbtbo.github.io/img/default_bg.png"><link rel="shortcut icon" href="/img/home.png"><link rel="canonical" href="https://icbtbo.github.io/2021/07/24/csapp/csapp%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-20 21:44:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="sjc的搬砖小屋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/niu.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">86</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_bg.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sjc的搬砖小屋</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">csapp处理器体系结构（四）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-24T07:39:49.000Z" title="发表于 2021-07-24 15:39:49">2021-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-20T13:44:03.460Z" title="更新于 2021-08-20 21:44:03">2021-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/">《深入理解计算机系统》</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="硬件控制语言HCL"><a href="#硬件控制语言HCL" class="headerlink" title="硬件控制语言HCL"></a>硬件控制语言HCL</h2><p><strong>硬件描述语言（Hardware Description Language，HDL）</strong>可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。<strong>逻辑合成程序（Logic Synthesis）</strong>可以根据HDL的描述来生成有效的电路设计。所以从手工设计电路到合成生成的转变，就好像从手写汇编到高级语言的转变。</p>
<p><strong>硬件控制语言（Hardware Control Language，HCL）只</strong>表达硬件设计的控制部分，只有有限的操作集合，也没有模块化，可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-hcl.pdf">这里</a>。</p>
<p>这门课开发了将HCL翻译成Verilog的工具，然后结合基本硬件单元的Verilog代码，就能产生HDL描述，由此就能合成实际能工作的微处理器了。可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-verilog.pdf">这里</a>。</p>
<h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>当前逻辑<code>1</code>是由1.0伏特左右的高电压表示，逻辑<code>0</code>是由0.0伏特左右的低电压表示。</p>
<p>实现一个数字系统主要有<strong>三个组成部分：</strong></p>
<ol>
<li>计算对位进行操作的函数的组合逻辑</li>
<li>存储位的存储器单元</li>
<li>控制存储器单元更新的时钟信号</li>
</ol>
<h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>逻辑门是数字电路的<strong>基本计算单元</strong>。如下图所示</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724154528.jpg" alt="img" style="zoom:80%;" />

<p>其中第一行是布尔表达式，第二行是标准符号，第三行是HCL表达式。我们可以将AND和OR扩展到多个输入的版本。</p>
<blockquote>
<p><strong>注意：</strong>1. 逻辑门只对单个位的值进行操作。2. 当一个门的输入发生变化时，输出会很快相应变化。</p>
</blockquote>
<p>将很多逻辑门组合成一个实现某种功能的网，就能构成<strong>计算块（Computational block）</strong>，称为<strong>组合电路（Combinational Circuits）</strong>。想要构建有效的组合电路，有以下<strong>限制：</strong></p>
<ul>
<li><p>每个逻辑门的输入必须连接到以下其中之一：</p>
</li>
<li><ul>
<li>一个系统输入</li>
<li>某个存储器单元的输出</li>
<li>某个逻辑门的输出</li>
</ul>
</li>
<li><p>两个或多个逻辑门的输出不能连接在一起</p>
</li>
<li><p>网络不能形成回路</p>
</li>
</ul>
<p>简单的组合电路示例：</p>
<p><strong>例1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724154745.jpg" alt="img"></p>
<p><strong>HCL表达式：</strong><code>bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</code></p>
<p><strong>功能：</strong>用来判断输入<code>a</code>和<code>b</code>是否相同，结果保存在<code>eq</code>中。</p>
<p><strong>例2：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724154816.jpg" alt="img"></p>
<p><strong>HCL表达式：</strong><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></p>
<p><strong>功能：</strong>该组合电路称为<strong>多路复用器（Multiplexor，MUX）</strong>， 当<code>s=1</code>时，<code>out</code>的值就是<code>a</code>的值；当<code>s=0</code>时，<code>out</code>值就是<code>b</code>的值。</p>
<p><strong>HCL表达式和C语言逻辑表达式区别：</strong></p>
<ul>
<li>组合电路中输出会持续响应输入的变化，而C语言只有在程序执行过程中遇到了才进行求值</li>
<li>逻辑门只允许对0和1进行操作，而C语言将0表示为FASLE，将其余任意值表示为TRUE</li>
<li>C语言中逻辑表达式存在部分求值的特点（例如，如果一个AND或OR操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了），组合逻辑中不存在</li>
</ul>
<p>以上HCL都是对单个位进行运算的，可以很容易对其进行扩展实现对数据<strong>字（Word）</strong>进行操作的电路。</p>
<p><strong>例1：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155200.jpg" alt="img" style="zoom:50%;" />

<p>直接合并64个位级相等的组合电路，再加上一个逻辑与门，就能得到一个64位的字级相等组合电路。右边是对其的抽象，其中实线表示字级信号，虚线表示布尔信号。</p>
<p>为了简单，可以将所有字级信号都声明为int，不指定字的大小，则该组合电路可以由两个int类型的参数A和B构成的HCL表达式描述<code>bool Eq = (A == B);</code>。</p>
<p><strong>例2：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155207.jpg" alt="img" style="zoom:50%;" />

<p>这是一个64位字级多路复用器电路。这里只产生了一次<code>!s</code>，可以减少需要的逻辑门数量。在HCL中，多路复用器函数可以用<strong>情况表达式（Case Expression）</strong>来描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  select1 : expr1;</span><br><span class="line">  select2 : expr2;</span><br><span class="line">  ...</span><br><span class="line">  selectk : exprk;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中，<code>select</code>是布尔表达式，<code>expr</code>是字级表达式。</p>
<blockquote>
<p><strong>注意：</strong>1. 在HCL中，不要求不同的选择表达式之间是互斥的，但是实际的多路复用器的信号必须互斥。2. 选择表达式是<strong>顺序求值</strong>的，所以后续的选择表达式可以在之前的选择表达式的基础上进行简化。</p>
</blockquote>
<p>右侧是字级多路复用器的抽象，根据HCL表达式可知，首先根据<code>s</code>的值来判断是否选择<code>A</code>，如果不选择，就一定会选择<code>B</code>。</p>
<p><strong>例3：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155853.jpg" alt="img" style="zoom:67%;" />

<p>这是一个通过两个信号来控制的四路复用器。对应的HCL表达式为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Out4 = [</span><br><span class="line">  !s1 &amp;&amp; !s2 : A; #00</span><br><span class="line">  !s1        : B; #01</span><br><span class="line">  !s2        : C; #10</span><br><span class="line">  1          : D; #11</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>而我们需要从两位<code>code</code>中提取出两个信号，可以通过相等测试：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code == 2 || code == 3;</span><br><span class="line">bool s0 = code == 1 || code == 3; </span><br></pre></td></tr></table></figure>

<p>也可以通过<strong>判断集合关系</strong>的方式，其通用格式为<code>iexpr in &#123;iexpr1, iexpr2, ..., iexprk&#125;</code>，所以可以表示为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code in &#123;2,3&#125;;</span><br><span class="line">bool s0 = code in &#123;1,3&#125;; </span><br></pre></td></tr></table></figure>

<p>比较重要的一个字级组合电路是<strong>算数/逻辑单元（ALU）</strong>，它包含3个输入：标号为A和B的两个数据输入，以及一个控制输入。根据控制输入的值来选择要对A和B进行的运算。如下图所示，是位Y86-64设计的ALU模型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155918.jpg" alt="img"></p>
<blockquote>
<p><strong>注意：</strong>组合电路值进行逻辑运算，不涉及存储信息，当某个抽象能够存储信息，就不是组合电路。</p>
</blockquote>
<h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>为了产生<strong>时序电路（Sequential Circuit）</strong>，即存在状态并且能在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。而这些存储设备是由同一个具有周期性信号的<strong>时钟</strong>控制的，决定什么时候将新值保存到存储器中。</p>
<p>主要有<strong>两类存储器设备：</strong></p>
<ul>
<li><p><strong>时钟寄存器（寄存器）：</strong>存储单个位或字，主要作为电路不同部分的组合逻辑之间的屏障。</p>
</li>
<li><p><strong>随机访问存储器（内存）：</strong>存储多个字，用地址来选择读写哪个字。<strong>包括：</strong></p>
<ul>
<li><p><strong>处理器的虚拟内存系统：</strong>通过操作系统对存储器进行抽象，使得处理器可以在很大的地址空间中访问，地址为虚拟内存的索引值。</p>
</li>
<li><p><strong>寄存器文件：</strong>是一个以寄存器标识符为地址，存储着对应程序寄存器值的随机访问存储器。在IA32或Y86-64处理器中，有15个程序寄存器（<code>%rax</code>~`%r14`）。</p>
</li>
</ul>
</li>
</ul>
<p>这里要注意区分机器级编程中的寄存器和硬件中的寄存器</p>
<ul>
<li><strong>硬件：</strong>寄存器指的是时钟寄存器，直接将它的输入和输出连接到电路的其他部分。这里称为<strong>硬件寄存器</strong>。</li>
<li><strong>机器级编程：</strong>寄存器代表的是存储在寄存器文件中的，CPU中少数可寻址的字，地址为寄存器标识符。这里称为<strong>程序寄存器</strong>。</li>
</ul>
<h3 id="硬件寄存器"><a href="#硬件寄存器" class="headerlink" title="硬件寄存器"></a>硬件寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724160252.jpg" alt="img"></p>
<p>如上图所示，硬件寄存器大多数时候会保持在稳定状态x，产生的输出也是它当前的状态。当寄存器的输入发生改变时，寄存器的输出也不会马上变化，而是等时钟变成高电位时，才会将当前状态修改为输入值。由此将当前寄存器两侧的逻辑电路分隔开来。</p>
<p>Y86-64处理器会使用硬件寄存器老保存程序计数器（PC）、条件代码（CC）和程序状态（Stat）。</p>
<h3 id="寄存器文件"><a href="#寄存器文件" class="headerlink" title="寄存器文件"></a>寄存器文件</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724160319.jpg" alt="img"></p>
<p>寄存器文件包含两个读端口和一个写端口，意味着能读取两个程序寄存器的同时对第三个程序寄存器进行写操作。这里的地址就是程序寄存器标识符。</p>
<p>寄存器文件的写入操作受时钟信号控制，只有当时钟为高电平时，才将<code>valW</code>中的值写入<code>dstw</code>指示的程序寄存器中。</p>
<h3 id="虚拟内存系统"><a href="#虚拟内存系统" class="headerlink" title="虚拟内存系统"></a>虚拟内存系统</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724160403.jpg" alt="img"></p>
<p>处理器用虚拟内存来保存程序数据。<code>read</code>和<code>write</code>是两个标志位，用来控制当前是要读还是写。包含通过逻辑电路实现的边界检查，如果地址超过虚拟内存地址空间，就会使得<code>error=1</code>。</p>
<p>虚拟内存的写入操作受时钟信号控制，只有当<code>write=1</code>并且时钟为高电平时，才会将<code>data in</code>的数据保存到对应地址的位置。</p>
<blockquote>
<p><strong>注意：</strong>向存储器（时钟寄存器、随机访问存储器）写入值时会受到时钟的控制，所以存在时序，而向存储器读取值时不受到时钟的控制，不存在时序，可以直接将其近似于逻辑电路，输入地址，一段延迟后，就会将值返回到输出中。</p>
</blockquote>
<h1 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h1><h2 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h2><p>想要定义一个指令集体系结构，需要包含：</p>
<ul>
<li>定义状态单元</li>
<li>指令集和他们的编码</li>
<li>编程规范和异常事件处理</li>
</ul>
<p>这几个方面的具体内容感觉没必要记，详细内容可以查看书中对应章节，这里给出一个Y86-64程序示例：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724161150.png" alt="image-20210724161150116" style="zoom: 67%;" />

<h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><h3 id="处理指令的阶段"><a href="#处理指令的阶段" class="headerlink" title="处理指令的阶段"></a>处理指令的阶段</h3><p>处理一条指令我们可以将其划分成若干个阶段：</p>
<ol>
<li><p><strong>取指（Fetch）：</strong>根据程序计数器PC从内存中读取指令字节。然后完成以下步骤</p>
</li>
<li><ol>
<li>从指令中提取出指令指示符字节，并且确定出指令代码（<code>icode</code>）和指令功能（<code>ifun</code>）</li>
<li>如果存在寄存器指示符，则从指令中确定两个寄存器标识符<code>rA</code>和<code>rB</code></li>
<li>如果存在常数字，则从指令中确定<code>ValC</code></li>
<li>根据指令指令长度以及指令地址，可确定下一条指令的地址<code>valP</code></li>
</ol>
</li>
<li><p><strong>译码（Decode）：</strong>如果存在<code>rA</code>和<code>rB</code>，则译码阶段会从寄存器文件中读取<code>rA</code>和<code>rB</code>的值<code>valA</code>和<code>valB</code>。对于<code>push</code>和<code>pop</code>指令，译码阶段还会从寄存器文件中读取<code>%rsp</code>的值。</p>
</li>
<li><p><strong>执行（Execute）：</strong>算术逻辑单元（ALU）会根据<code>ifun</code>的值执行对应的计算，得到结果<code>valE</code>，包括</p>
</li>
<li><ol>
<li>计算运算结果，会设置条件码的值，则条件传送和跳转指令会根据<code>ifun</code>来确定条件码组合，确定是否跳转或传送。</li>
<li>计算内存引用的有效地址</li>
<li>增加或减少栈指针</li>
</ol>
</li>
<li><p><strong>访存（Memory）：</strong>写入内存或从内存读取数据<code>valM</code>。</p>
</li>
<li><p><strong>写回（Write Back）：</strong>将结果写入寄存器文件中。</p>
</li>
<li><p><strong>更新PC（PC Update）：</strong>将PC更新为<code>valP</code>，使其指向下一条指令。</p>
</li>
</ol>
<p>我们要做的工作就是将每条不同指令所需要的计算放入到上述那个通用框架中，以<code>OPq</code>、<code>rrmovq</code>和<code>irmovq</code>为例：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724164106.png" alt="image-20210724164106626" style="zoom:67%;" />

<blockquote>
<p>这里可以发现，相同<code>icode</code>具有相同的步骤，而相同的<code>ifun</code>在执行阶段具有相同的计算方式，比如<code>addq</code>、<code>jmp</code>和<code>rrmovq</code>的<code>ifun</code>都是0，所以都进行加法计算。</p>
</blockquote>
<h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>我们可以得到顺序实现的SEQ硬件结构：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724172712.png" alt="image-20210724172704176" style="zoom:80%;" />

<ul>
<li>白色方框为时钟寄存器；蓝色方框为硬件单元，当做黑盒子而不关心细节设计；白色圆圈表示线路名字。</li>
<li>宽度为字长的数据使用粗线；宽度为字节或更窄的数据用细线；单个位的数据用虚线，主要表示控制值。</li>
<li>灰色圆角矩形表示控制逻辑块，能在不同硬件单元之间传递数据，以及操作这些硬件单元，使得对每个不同的指令执行指定的运算。是本章的重点，会给出对应的HCL表达式</li>
</ul>
<p>SEQ的实现包括组合逻辑和两种存储器：时钟寄存器（程序计数器和条件码寄存器）和随机访问存储器（寄存器文件、指令内存和数据内存）。我们知道组合逻辑和存储器的读取是没有时序的，只要输入一给定，输出就会发生对应的变化。但是存储器的写入是受到时钟的控制的，只有当时钟为高电位时，才会将值写入存储器中。</p>
<p>所以涉及到写数据的存储器（程序计数器、条件码寄存器、寄存器文件和数据内存）就需要对时序进行明确的控制，才能控制好指令各阶段的执行顺序。为了保证每条指令执行的结果能和上一节中介绍的顺序执行的结果相同，我们要保证指令的计算<strong>不会回读</strong>，即处理器不需要为了完成一条指令的执行而去读取由该指令更新的状态。因为该指令更新的状态是写入数据，需要经过一个时钟周期，如果该指令需要读取更新过的状态，就需要空出一个时钟周期。</p>
<p>我们通过寄存器和内存的时钟控制，由此设计了上一节中的指令执行阶段，这样能够保证即使所有状态同时更新，也能等价于顺序执行各个阶段，也保证了能够在一个周期中完成一条指令。</p>
<p>具体示例可看书中图4-25。</p>
<h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>SEQ所需要的控制块的逻辑用HCL进行描述。</p>
<p>由于内容过多，在这里我们仅对SEQ取指阶段中各控制块的逻辑，其余阶段可看书中相应章节。</p>
<p>首先给出各指令的编码：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724182642.jpg" alt="img" style="zoom:50%;" />

<p>取指阶段：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724182712.jpg" alt="img" style="zoom:80%;" />

<p>该部分访问<strong>内存硬件单元</strong>。首先以PC作为第一个字节的地址，一次从内存中读取10个字节。灰色部分是我们需要确定的HCL表达式</p>
<ul>
<li><code>icode</code>为第一字节的高4位，当指令地址越界时，指令内存会返回<code>imem_error</code>信号，此时直接将其表示为<code>nop</code>指令，否则获得高4位值</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word icode = [</span><br><span class="line">  imem_error : INOP;</span><br><span class="line">  1          : imem_icode;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ifun</code>为第一字节的低4位，当出现<code>imem_error</code>信号时，会使用默认功能码，否则获得低4位值</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word ifun = [</span><br><span class="line">  imem_error : FNONE;</span><br><span class="line">  1          : imem_ifun;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>instr_valid</code>表示是否为合法指令</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool instr_valid = icode in &#123;</span><br><span class="line">  INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>need_regids</code>表示该指令否包含寄存器指示符字节，如果指令不含有寄存器指示符字节，则会将其赋值为<code>0xFF</code>。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_regids = icode in &#123;</span><br><span class="line">  IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>need_valC</code>表示该指令是否含有常数字节</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_valC = icode in &#123;</span><br><span class="line">  IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PC增加器会根据PC值、<code>need_valC</code>和<code>need_regids</code>来确定<code>valP</code>值，则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valP &#x3D; PC+1+need_regids+8*need_valC</span><br></pre></td></tr></table></figure>

<h3 id="SEQ性能"><a href="#SEQ性能" class="headerlink" title="SEQ性能"></a>SEQ性能</h3><p>我们通过将指令执行过程划分成了若干个阶段，使得我们能通过统一框架来描述各个指令执行的过程，也能进一步减少需要的硬件。但是由于每次时钟变为高电平时需要写入数据，使得需要在一个时间周期内完成所有步骤，所以我们要求时钟周期特别慢。</p>
<p>比如执行<code>ret</code>时，当前PC指向<code>ret</code>指令的地址，当时钟变为高电平时，我们需要在下一次时钟变为高电平之前，完成：两次从寄存器文件读取<code>%rsp</code>内容，通过ALU计算<code>%rsp</code>上移8字节的地址，根据<code>%rsp</code>从内存中获得返回地址，然后将新的<code>%rsp</code>值写回寄存器文件中（此时由于时钟还是低电平，所以还没有真实写入，只是设置为了值）。由此能够保证在下一个时钟变为高电平时，能够把正确的<code>%rsp</code>值写回寄存器文件中。</p>
<p>而且我们可以发现，<strong>指令执行的不同阶段是在处理器的不同硬件部分，所以完全可以让不同指令同时运行，只要求他们处于不同阶段</strong>，这也是下一节中流水线的主要思想。</p>
<h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><h2 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191507.jpg">  </p>
<p>如上图所示是一个非流水线化的计算硬件。当信号输入到组合逻辑中时，通过一系列逻辑门经过300ps获得输出信号，然后经过20ps将结果加载到寄存器中，由于时钟周期控制存储器写入的频率，为了保证当时钟变为高电平之前，能够得到将计算好的结果放到寄存器的输入端口，则这里的时钟周期设定为300+20=320ps。</p>
<p>我们将从头到尾执行一条指令所需的时间称为<strong>延迟（Delay）</strong>，则这里延迟为320ps。我们将系统在单位时间内能执行的指令数目称为<strong>吞吐量（Throughput）</strong>，则</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191419.png" alt="image-20210724191419109"></p>
<p>意味着一秒能执行3.12G条指令。</p>
<p>由于这个是非流水线化的计算硬件，所以从流水线图中可以看到在开始下一条指令之前必须完成上一条指令。如果我们将组合逻辑根据不同功能，通过<strong>流水线寄存器（Pipline Register）</strong>划分成独立的三阶段，就能得到简易的流水线化计算硬件。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191433.jpg" alt="img" style="zoom:67%;" />

<p>由于每阶段的组合逻辑实现独立的功能，并且能通过流水线寄存器来控制进入下一阶段的时机，所以如上图的流水线图所示，只需要通过流水线寄存器控制每个阶段只执行一条指令，就能流水线化地执行指令。</p>
<p>对于每个阶段，我们需要100ps的组合逻辑计算时间以及20ps加载到寄存器的时间，所以我们这里能将时钟周期设定为120ps。并且我们可以发现每过一个时钟周期就有一条指令完成，所以吞吐量变为了8.33GIPS，提高了2.67倍。但是每条指令需要经过3个时钟周期，所以延迟为360ps，变为原来的1.12倍。</p>
<p>所以<strong>流水线特点</strong>为：提高系统的吞吐量，但是会轻微增加延迟。</p>
<h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><h3 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h3><p>处理器中的某些硬件单元，比如ALU或内存，是无法划分成多个延迟较小的单元的，这使得我们划分的不同阶段的组合逻辑具有不同的延迟。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191811.jpg" alt="img" style="zoom:67%;" />

<p>如上图所示，其中组合逻辑B需要150ps进行计算。由于整个系统共用一个时钟周期，为了保证组合逻辑B能在一个时钟周期内计算出正确结果，使得保存到流水线寄存器中，我们就需要将时钟周期设定为150+20=170ps，这使得系统吞吐量变为5.88GIPS，而运行一条指令需要的延迟为3*170=510ps。</p>
<p><strong>注意：</strong>想要吞吐量最大，我们需要使得时钟周期尽可能小，而时钟周期受到最慢的组合逻辑的限制，所以我们可以将最小的组合逻辑的时间加上一个寄存器的时延作为时钟周期。想要延迟最小，就不使用流水线。</p>
<h3 id="流水线过深，收益下降"><a href="#流水线过深，收益下降" class="headerlink" title="流水线过深，收益下降"></a>流水线过深，收益下降</h3><p>我们将每个组合逻辑进一步划分成更小的部分，构建更深的流水线</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191824.jpg" alt="img" style="zoom:80%;" />

<p>这里时钟周期变为70ps，则吞吐量为14.29GIPS。这里我们可以发现，虽然我们将组合逻辑分成了更小的单元，使得组合逻辑的时延缩小了两倍，但是吞吐量的性能并没有提升两倍。这是由于更深的流水线，会扩大寄存器时延的影响，在70ps的时钟周期中，寄存器的时延就占了28.6%，意味着更深的流水线的吞吐量会依赖于寄存器时延的性能。</p>
<h3 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h3><p>我们之前考虑流水线时，只有当指令之间是不相关时才是完全正确的。但是真实系统中，指令之间存在两种形式的相关：<strong>数据相关（Data Dependency）</strong>，下一条指令会用到这条指令计算出来的结果；<strong>控制相关（Control Denpendency）</strong>，一条指令要确定下一条指令的位置。这些相关可能会导致流水线产生计算错误，称为<strong>冒险（Hazard）</strong>，包括：<strong>数据冒险（Data Hazard）</strong>和<strong>控制冒险（Control Hazard）</strong>。</p>
<h2 id="Y86-64流水线实现"><a href="#Y86-64流水线实现" class="headerlink" title="Y86-64流水线实现"></a>Y86-64流水线实现</h2><h3 id="SEQ-和PIPE"><a href="#SEQ-和PIPE" class="headerlink" title="SEQ+和PIPE-"></a>SEQ+和PIPE-</h3><p>为了平衡一个流水线系统各个阶段的延迟，需要使用<strong>电路重定时（Circuit Retiming）</strong>在不改变逻辑行为的基础上，修改系统的状态表示。如下图所示，顺序实现的SEQ中，更新PC阶段是在时钟周期结束时才执行的，通过组合电路计算得到的<code>icode</code>、<code>Cnd</code>、<code>valC</code>、<code>valM</code>和<code>valP</code>通过组合电路计算得到新的PC，将其保存到PC的时钟寄存器中。但是这些值是在不同阶段中计算出来的，所以SEQ+新增了一系列状态寄存器来保存之前计算出来的结果，然后将更新PC阶段放到了时钟周期开始执行，这样在每个阶段时钟周期变成高电平时就会将该阶段计算出来的值保存到状态寄存器中，然后PC逻辑电路就能根据当前的状态寄存器的值来预测下一步的PC值。</p>
<p>对应的SEQ+硬件结构在这里就不给出了（书中图4-40），可以发现将更新PC阶段移到了时钟周期开始的位置。</p>
<p>我们可以在各个阶段中加入流水线寄存器，并将信号重新排列来将SEQ+转换成初步的流水线处理器PIPE-，硬件结构如下图所示</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724192903.jpg" alt="preview" style="zoom:67%;" />

<h3 id="处理控制相关"><a href="#处理控制相关" class="headerlink" title="处理控制相关"></a>处理控制相关</h3><p>对于<code>call</code>和<code>jmp</code>指令，下一条指令的地址就是<code>valC</code>，而除了条件分支和<code>ret</code>指令外，下一条指令的地址就是<code>valP</code>，这些指令不存在控制相关，使得流水线处理器能够每个时钟周期就处理一条指令。如果出现了条件分支，则需要该指令运行到执行阶段后才知道是否选择该分支，如果出现了<code>ret</code>指令，则需要该指令运行到访存阶段，才知道返回地址，此时就存在了控制相关，使得处理器要经过几个时钟周期才知道要运行的下一条指令的地址，所以<strong>控制冒险只会出现在条件分支和<code>ret</code>指令中</strong>，我们可以通过预测下一条PC来处理这个问题。</p>
<ul>
<li><p><strong>条件分支：</strong>我们可以通过<strong>分支预测</strong>技术来预测分支方向，并根据预测开始取值。常见的技术包括：</p>
</li>
<li><ul>
<li><strong>总是选择（always taken，AT）：</strong>总是预测处理器选择了条件分支，因此预测PC值为<code>valC</code>，成功率大约为60%。</li>
<li><strong>从不选择（never taken，NT）：</strong>总是预测处理器不选择条件分支，因此预测PC值为<code>valP</code>，成功率大约为40%。</li>
<li><strong>反向选择、正向不选择（backward taken, forward not-taken，BTFNT）：</strong>条件分支通常用于循环操作，当跳转地址比下一条指令地址小，说明进入了循环，否则退出循环，而循环通常会执行多次，因此当跳转地址比下一条指令地址低就选择分支，否则就不选择分支， 成功率大约为65%。</li>
</ul>
</li>
<li><p><code>ret</code>指令：常见的技术包括</p>
</li>
<li><ul>
<li>暂停处理新指令，直到<code>ret</code>指令通过写回阶段知道下一条指令的地址</li>
<li>在取指单元中放入一个硬件栈，保存过程调用指令产生的返回地址</li>
</ul>
</li>
</ul>
<p>当预测PC出现错误时出现控制冒险，会执行错误的指令，所以会极大影响流水线处理器的性能，后面再讨论这个问题。</p>
<p>在本文中，条件分支使用AT策略，<code>ret</code>指令使用第一条策略。从PIPE-硬件结构中可知，在取值阶段首先根据<code>icode</code>从<code>valP</code>和<code>valC</code>中选出预测的PC值，对于<code>call</code>和条件分支使用<code>valC</code>，其他指令使用<code>valP</code>。然后<code>Select PC</code>逻辑电路再从<code>predPC</code>、<code>M_valA</code>和<code>W_valM</code>中进行选择。我们推测为什么是这样的</p>
<ul>
<li><strong>条件分支：</strong>首先条件分支在取指阶段会直接选择条件分支，使得<code>predPC</code>为<code>valC</code>，则当条件分支执行到译码阶段时，<code>valC</code>对应的指令就会在取指阶段开始执行。当条件分支执行到执行阶段时，可以通过<code>CC</code>知道是否真的要选择条件分支，如果真的选择分支，则继续执行，否则条件分支的下一条指令地址应该是<code>valP</code>，此时该条件分支对应的<code>valP</code>保存在<code>M_valA</code>中，所以可以让<code>Select PC</code>选择<code>M_valA</code>来重新执行条件分支的部分。</li>
<li><strong>ret指令</strong>：当执行<code>ret</code>指令时，会暂停传入新的指令，知道<code>ret</code>指令执行到访存阶段时，才从内存中读取了下一条指令的返回地址，保存在<code>W_valM</code>中，所以<code>Select PC</code>可以选择<code>W_valM</code>来执行返回地址对应的指令。</li>
</ul>
<h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>流水线冒险主要包含数据冒险和控制冒险，当程序状态的读写<strong>不处于同一阶段</strong>，就可能出现数据冒险，当出现分支预测错误或<code>ret</code>指令时，会出现控制冒险。</p>
<p>在Y86-64中，程序状态包含程序寄存器、内存、条件码寄存器和状态寄存器。程序寄存器的读取处于译码阶段，而写入处于写回阶段，因此程序寄存器会出现数据冒险的可能，以以下代码为例</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210820214336.jpg" alt="img" style="zoom: 75%;" />

<p>我们在代码中插入了三行<code>nop</code>指令，则当<code>addq %rdx, %rax</code>处于译码阶段读取寄存器时，第一行和第二行指令已经完成了对寄存器<code>%rdx</code>和<code>%rax</code>的写入操作，因此该代码不会出现数据冒险，但是如果减少<code>nop</code>指令，第一行和第二行指令还没完成对寄存器的写入操作时，<code>addq %rdx, %rax</code>已经处于译码阶段读取寄存器了，此时就会读取到错误的值而出现数据冒险。由于读取操作和写入操作相差3个时钟周期，所以如果一条指令的操作数被它前面三条指令中的任何一条修改时，就会出现数据冒险。</p>
<p>而内存的读写都处于访存阶段、条件码寄存器的读写都处于执行阶段因此它们不会出现数据冒险的情况，而我们为每个阶段都在流水线寄存器中保留了stat值，所以当异常发生时，处理器就能有条理地停止。</p>
<p>所以这里我们主要探讨程序寄存器数据冒险和控制冒险。</p>
<h4 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h4><p>我们可以在执行阶段中插入一段自动产生的<code>nop</code>指令，来保持寄存器、内存、条件码和程序状态不变，使得当前指令停在译码阶段，并且会控制程序计数器不变，使得下一条指令停在取指阶段，直到产生指令的源操作数的指令通过了写回阶段。</p>
<p>该方法指令要停顿最少一个最多三个时钟周期，严重降低整体的吞吐量。</p>
<h4 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h4><p>对于以下代码我们可以发现，在第四个周期<code>I1</code>处于访存阶段而<code>I2</code>处于执行阶段，都还没有将<code>valE</code>保存在<code>%rdx</code>和<code>%rax</code>中，所以<code>I3</code>的译码阶段无法从寄存器文件中读取到正确的<code>%rax</code>和<code>%rdx</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724194438.jpg" alt="img"></p>
<p>但是即使还没有将<code>valE</code>保存到对应的寄存器文件中，其实<code>I1</code>在执行阶段已经将<code>%rdx</code>的值保存到流水线寄存器M中<code>M_valE</code>，而<code>I2</code>在执行阶段通过ALU计算得到了<code>%rax</code>的值<code>e_valE</code>，所以即使没有写入对应的寄存器文件中，已经能从<code>M_valE</code>和<code>e_valE</code>得到<code>%rax</code>和<code>%rbx</code>的值了，所以<code>I3</code>的译码阶段可以从以下形式</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA = R[%rdx]</span><br><span class="line">valB = R[%rax]</span><br></pre></td></tr></table></figure>

<p>变成</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA = M_valE</span><br><span class="line">valB = e_valE</span><br></pre></td></tr></table></figure>

<p>此时就不存在数据冒险，以及暂停了。</p>
<p>除了通过ALU的计算结果来转发，还能通过内存来进行转发，并且通过当前阶段的<code>dstE</code>和<code>dstM</code>与目标指令的<code>srcA</code>和<code>srcB</code>进行判断来决定是否转发。在处理器中，<code>valA</code>和<code>valB</code>一共有5个转发源：</p>
<ul>
<li><code>e_valE</code>：在执行阶段，ALU中计算得到的结果<code>valE</code>，通过<code>E_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li>
<li><code>M_valE</code>：将ALU计算的结果<code>valE</code>保存到流水线寄存器M中，通过<code>M_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li>
<li><code>m_valM</code>：在访存阶段，从内存中读取的值<code>valM</code>，通过<code>M_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li>
<li><code>W_valM</code>：将内存中的值<code>valM</code>保存到流水线寄存器W中，通过<code>W_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li>
<li><code>W_valE</code> ：将ALU计算的结果<code>valE</code>保存到流水线寄存器W中，通过<code>W_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li>
</ul>
<h4 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h4><p>有一类数据冒险不能单纯用转发完成。我们考虑以下代码，可以发现在执行<code>0x032</code>指令的译码阶段时，<code>%rbx</code>的值通过转发技术可以从<code>M_valE</code>中获得，但是<code>%rax</code>的值需要<code>0x028</code>指令执行到访存阶段，才能从内存中读取到<code>%rax</code>的值，但是当前<code>0x028</code>指令处于执行阶段，所以无法通过转发技术来解决这个数据冒险。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724194936.jpg" alt="img" style="zoom:67%;" />

<p>我们可以通过<strong>加载互锁（Load Interlock）</strong>方法来处理这种加载/使用数据冒险，其实就是引入了暂停，如下图所示，当<code>0x032</code>指令执行到译码阶段时，对该指令暂停一个时钟周期（所谓的<strong>插入气泡</strong>），此时<code>0x028</code>指令就能执行到访存阶段，此时就能从<code>m_valM</code>中获得<code>%rax</code>的值。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724194952.jpg" alt="img" style="zoom:67%;" />

<p><strong>结合加载互锁和转发技术足以解决所有类型的数据冒险</strong>，并且对模型的吞吐量不会造成很大的影响。</p>
<h4 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h4><p>控制冒险只会出现在<code>ret</code>指令和跳转指令预测错方向时产生。</p>
<ul>
<li><code>ret</code>指令</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195257.jpg" alt="img" style="zoom:67%;" />

<p>对于以上代码，对应的流水线图为</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195318.jpg" alt="img" style="zoom: 67%;" />

<p>可以发现，当执行<code>call proc</code>时，在取指阶段就能获得<code>valC</code>表示下一条指令的地址，所以会取到<code>ret</code>指令。而<code>ret</code>指令只有运行到访存阶段时才能获得返回地址<code>valM</code>，并且在写回阶段的时钟电平变高时，才会写入PC寄存器中，所以需要在<code>ret</code>指令后添加3个bubble。</p>
<ul>
<li>跳转指令</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195329.jpg" alt="img" style="zoom:80%;" />

<p>对于以上代码，对应的流水线图为</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195500.jpg" alt="img" style="zoom:67%;" />

<p>首先对于跳转分支，我们采用AT策略，所以在执行<code>jne target</code>的取指阶段时获得的<code>valC</code>会直接作为下一条指令的地址。当跳转指令运行执行阶段时，就会通过<code>CC</code>和<code>ifun</code>得知是否预测正确，此时已经将下一条指令运行到译码阶段，第二条指令运行到了取指阶段，如果预测错误，就会分别插入两个bubble，避免运行到后续阶段，改变程序员可见状态，会浪费两个时钟周期</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。当前的ISA包含三种内部产生的异常：1. halt指令；2. 非法指令码和功能码组合的指令；3. 取值或数据读写访问非法地址。外部产生的异常包括：接收到一个网络接口受到新包的信号、点击鼠标的信号等等。</p>
<p>在我们的ISA中，希望处理器遇到异常时，会停止并设置适当的状态码。<strong>要求：</strong>异常指令之前的所有指令已经完成，后续的指令都不能修改条件码寄存器和内存。流水线系统包含以下问题：</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195641.jpg" alt="img" style="zoom:80%;" />

<ol>
<li>当同时多条指令引起异常时，处理器应该向操作系统报告哪个异常？<strong>基本原则：</strong>由流水线中最深的指令引起的异常，优先级最高，因为指令在流水线中越深的阶段，表示该指令越早执行。</li>
<li>在分支预测中，当预测分支中出现了异常，而后由于预测错误而取消该指令时，需要取消异常。</li>
</ol>
<p>在PIPE硬件架构中，我们对每个流水线寄存器中都设置了一个<code>stat</code>信号，用来保存当前阶段的异常信号，随着流水线的进行，就能解决以上问题：</p>
<ol>
<li><code>stat</code>信号只是简单存放在流水线寄存器的状态字段中，不会对流水线中的指令流有任何影响，保证了异常指令之前的指令都能完成，但是要进制流水线中后面的指令不能更新条件码寄存器和内存。</li>
<li>当出现异常的指令到达写回阶段时，由于流水线中的指令是顺序执行的，所以能保证当前异常是最早出现的异常。</li>
<li>当条件分支预测错误时，直接取消该指令后，<code>stat</code>信号就不会保存下去了。</li>
<li>最终流水线寄存器W中的<code>stat</code>信号会被记录为程序状态。</li>
</ol>
<h2 id="流水线控制逻辑"><a href="#流水线控制逻辑" class="headerlink" title="流水线控制逻辑"></a>流水线控制逻辑</h2><p>会讨论流水线中低级机制，使得流水线控制逻辑能将指令阻塞在流水线寄存器或往流水线中插入一个气泡。并且在流水线中，还有些特殊情况是其他机制不能处理的，包括：加载/使用冒险、处理<code>ret</code>、预测错误的分支、异常等情况。</p>
<h3 id="暂停和气泡"><a href="#暂停和气泡" class="headerlink" title="暂停和气泡"></a>暂停和气泡</h3><p>暂停和气泡是流水线中低级的机制，<strong>暂停</strong>能将指令阻塞在某个阶段，往流水线中插入<strong>bubble</strong>能使得流水线继续运行，但是不会改变当前阶段的寄存器、内存、条件码或程序状态。这两个状态决定了当时钟电平变高时，如何修改流水线寄存器。</p>
<p>对于正常状态，即不是用暂停和bubble时，只要时钟电平变高，就会将流水线寄存器的状态修改为输入值，并作为新的输出。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195906.jpg" alt="img" style="zoom:67%;" />

<ul>
<li><strong>暂停</strong></li>
</ul>
<p>通过加入流水线寄存器，我们将指令的执行划分成了不同的阶段，并且每个阶段的输入就是流水线寄存器中的内容，所以如果我们想要将指令暂停在某个阶段时，我们可以直接将该阶段的流水线寄存器固定不变，使得该阶段的输入信息保持不变，就能在该阶段反复地执行指令，就是的指令阻塞在当前阶段了。</p>
<p>所以将指令暂停在某个阶段，就是当时钟电平变高时，保持该阶段的流水线寄存器的状态不变</p>
<img src="https://pic1.zhimg.com/80/v2-bce6ccb8cf8e5cf86a1d8c4969ff54d8_720w.jpg" alt="img" style="zoom:67%;" />

<ul>
<li><strong>bubble</strong></li>
</ul>
<p>当时钟电平变高时，上一阶段指令的执行结果会保存到当前阶段的流水线寄存器，执行当前阶段后就会修改程序员可见状态，当我们想要保持程序员可见状态不变，可以插入一个bubble，使得寄存器状态设置成某个固定的复位配置，得到一个等效于<code>nop</code>指令的状态，相当于取消指令的运行</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195937.jpg" alt="img" style="zoom:67%;" />

<h3 id="加载-使用冒险"><a href="#加载-使用冒险" class="headerlink" title="加载/使用冒险"></a>加载/使用冒险</h3><p><code>mrmovq</code>和<code>popq</code>指令<code>I1</code>会从内存中读取值保存到寄存器中，但是是在访存阶段才会读取到内存的值，所以如果下一条指令<code>I2</code>会读取这个寄存器的值，就会出现加载/使用冒险，因为当<code>I2</code>处于译码阶段读取寄存器值时，<code>I1</code>还是处于执行阶段，所以无法读取到内存的值。<strong>触发条件</strong>为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125; </span><br></pre></td></tr></table></figure>

<p><strong>理想处理方式</strong>为：固定流水线寄存器D和F，使得指令<code>I2</code>和下一条指令<code>I3</code>能分别阻塞在译码阶段和取指阶段，然后在译码阶段后面插入一个时钟周期的bubble，使得<code>I1</code>和前面的指令可以继续向后执行一个时钟周期，则<code>I1</code>此时处于访存阶段，就能读取到内存的值了。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200112.png" alt="img" style="zoom:80%;" />

<p>所以当触发了加载/使用冒险时，流水线寄存器会如下设置一个时钟周期</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200140.png" alt="img" style="zoom:67%;" />

<h3 id="处理ret指令"><a href="#处理ret指令" class="headerlink" title="处理ret指令"></a>处理<code>ret</code>指令</h3><p>执行<code>ret</code>指令时，会从栈中读取返回地址作为下一条指令的地址，所以当<code>ret</code>执行到访存阶段时，才能读取到下一条指令的地址，然后在写回阶段的时钟电路变成高电平时，才会将其写入流水线寄存器M中，然后将<code>M_valM</code>传回去到<code>Select PC</code>逻辑模块。<strong>触发条件</strong>为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRET in &#123;D_icode, E_icode, M_icode&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理想处理方式</strong>为：当<code>ret</code>执行到译码阶段时，会触发触发条件，此时就固定流水线寄存器F，就能保持不断读取下一条指令<code>I2</code>，并且后面在译码阶段插入3个时钟周期的bubble（根据取指阶段的HCL，会不断执行<code>valP</code>的错误指令，但是通过插入bubble，使得它只能执行到取指阶段），使得<code>ret</code>指令能向后执行3个时钟周期到达写回阶段，此时就能直接通过<code>W_valM</code>获得下一个PC的地址。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200155.jpg" alt="img" style="zoom:80%;" />

<p>所以当触发了<code>ret</code>指令时，流水线寄存器会如下设置3个时钟周期</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200205.png" alt="img" style="zoom:67%;" />

<h3 id="预测错误的分支"><a href="#预测错误的分支" class="headerlink" title="预测错误的分支"></a>预测错误的分支</h3><p>我们采用AT分支预测策略，所以当遇到条件分支指令<code>I1</code>时，会直接跳转到对应的地址开始执行，只有当<code>I1</code>执行到执行阶段时，才能通过<code>e_Cnd</code>判断是否发生跳转，此时已经执行了后续的两个指令<code>I2</code>和<code>I3</code>，分别处于译码阶段和取指阶段。预测错误的<strong>触发条件</strong>为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E_icode == IJXX &amp;&amp; !e_Cnd</span><br></pre></td></tr></table></figure>

<p>当出现预测错误时，说明我们并不需要执行已经执行了的<code>I2</code>和<code>I3</code>指令，<strong>理想的处理方式</strong>为：直接在译码阶段插入bubbl中断<code>I3</code>，在执行阶段插入bubble中断<code>I2</code>，然后将正确的指令放入取指阶段开始执行，所以分支预测错误最多损耗两个时钟周期。</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200228.jpg" alt="img" style="zoom:80%;" />

<p>所以当触发了预测错误的分支时，流水线寄存器就会如下设置一个时钟周期</p>
<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200257.png" alt="img" style="zoom:67%;" />

<h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3><p>当出现<code>halt</code>指令、错误的指令码和函数码组合的指令或内存地址错误时，就会出现异常，所以异常通常在取指阶段和访存阶段被发现，对于异常<strong>理想的处理方式</strong>为：异常指令之前的指令都能完成，之后的指令都不会修改程序员可见状态，异常指令到达写回阶段时停止执行。</p>
<p>但是存在以下<strong>困难：</strong>异常在取指阶段和访存阶段被发现，程序员可见状态在执行阶段、访存阶段和写回阶段被修改。</p>
<p>我们首先在所有阶段的流水线寄存器中都包含一个程序状态信号<code>stat</code>，即使出现了异常，也只是将其当做普通信号传到下一阶段。当异常指令到达访存阶段时，后续的三条指令分别处于执行阶段、译码阶段和取指阶段，只有处于执行阶段的指令会修改条件码寄存器，所以要禁止执行阶段中的指令设置条件码。并且在访存阶段插入bubble，使得异常指令执行到写回阶段时，下一条指令就阻塞在执行阶段，不会到达访存阶段来修改内存。由于流水线处理器是按顺序处理指令的，所以第一次在写回阶段检测到异常指令就是最新的异常，所以只要在写回阶段检测到异常指令，就暂停写回，并暂停流水线。</p>
<p><strong>触发条件</strong>为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_stat in &#123;SADR, SINS, SHLT&#125; || W_stat in &#123;SADR, SINS, SHLT&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊情况组合"><a href="#特殊情况组合" class="headerlink" title="特殊情况组合"></a>特殊情况组合</h3><p>特殊情况在这里不记录，详情可以看书中对应章节。</p>
<h2 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h2><h3 id="多周期指令"><a href="#多周期指令" class="headerlink" title="多周期指令"></a>多周期指令</h3><p>我们提供的Y86-64指令集只有简单的操作，在执行阶段都能在一个时钟周期内完成，但是如果要实现整数乘法和除法以及浮点数运算，我们首先要增加额外的硬件来执行这些计算，并且这些指令在执行阶段通常都需要多个时钟周期才能完成，所以执行这些指令时，我们需要平衡流水线各个部分之间的关系。</p>
<p>实现多周期指令的简单方法是直接暂停取指阶段和译码阶段，直到执行阶段执行了所需的时钟周期后才恢复，这种方法的性能通常比较差。</p>
<p>常见的方法是使用独立于主流水线的特殊硬件功能单元来处理复杂的操作，通常会有一个功能单位来处理整数乘法和除法，还有一个功能单位来处理浮点数运算。在译码阶段中遇到多周期指令时，就可以将其发射到对应的功能单元进行运算，而主流水线会继续执行其他指令，使得多周期指令和其他指令能在功能单元和主流水线中并发执行。但是如果不同功能单元以及主流水线的指令存在数据相关时，就需要暂停系统的某部分来解决数据冒险。也同样可以使用暂停、转发以及流水线控制。</p>
<h3 id="与存储系统的接口"><a href="#与存储系统的接口" class="headerlink" title="与存储系统的接口"></a>与存储系统的接口</h3><p>我们假设了取指单元和数据内存都能在一个时钟周期内读写内存中的任意位置，但是实际上并不是。</p>
<ol>
<li>处理器的存储系统是由多种硬件存储器和管理虚拟内存的操作系统共同组成的，而存储系统包含层次结构，最靠近处理器的一层是<strong>高速缓存（Cache）存储器</strong>，能够提供对最常使用的存储器位置的快速访问。典型系统中包含一个用于读指令的cache和一个用于读写数据的cache，并且还有一个<strong>翻译后备缓冲器（Translation Look-aside Buffer，TLB）</strong>来提供从虚拟地址到物理地址的快速翻译。将TLB和cache结合起来，大多数时候能再一个时钟周期内读指令并读写数据。</li>
<li>当我们想要的引用位置不在cache中时，则出现高速缓存<strong>不命中（Miss）</strong>，则流水线会将指令暂停在取指阶段或访存阶段，然后从较高层次的cache或处理器的内存中找到不命中的数据，然后将其保存到cache中，就能恢复指令的运行。这通常需要3~20个时钟周期。</li>
<li>如果我们没有从较高层次的cache或处理器的内存中找到不命中的数据，则需要从磁盘存储器中寻找。硬件会先产生一个<strong>缺页（Page Fault）</strong>异常信号，然后调用操作系统的异常处理程序代码，则操作系统会发起一个从磁盘到主存的传送操作，完成后操作系统会返回原来的程序，然后重新执行导致缺页异常的指令。其中访问磁盘需要数百万个时钟周期，操作系统的缺页中断处理程序需要数百个时钟周期。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">icbtbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icbtbo.github.io/2021/07/24/csapp/csapp%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/">https://icbtbo.github.io/2021/07/24/csapp/csapp%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icbtbo.github.io" target="_blank">sjc的搬砖小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">处理器体系结构</a></div><div class="post_share"><div class="social-share" data-image="/img/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/31/csapp/csapp%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%EF%BC%88%E4%BA%94%EF%BC%89/"><img class="prev-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">csapp优化程序性能（五）</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/23/csapp/csapp%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%EF%BC%88%E4%B8%89%EF%BC%89/"><img class="next-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">csapp程序的机器级表示（三）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/niu.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">icbtbo</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">86</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/icbtbo"><i class="fab fa-github"></i><span>Github</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80HCL"><span class="toc-number">1.1.</span> <span class="toc-text">硬件控制语言HCL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">逻辑设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">组合逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E6%97%B6%E9%92%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">存储器和时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">硬件寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">寄存器文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">虚拟内存系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Y86-64指令集体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">Y86-64的顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">处理指令的阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">SEQ硬件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E9%98%B6%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">SEQ阶段的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ%E6%80%A7%E8%83%BD"><span class="toc-number">2.2.4.</span> <span class="toc-text">SEQ性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.</span> <span class="toc-text">流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E9%80%9A%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">流水线的通用原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.1.1.</span> <span class="toc-text">流水线的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">不一致的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%BF%87%E6%B7%B1%EF%BC%8C%E6%94%B6%E7%9B%8A%E4%B8%8B%E9%99%8D"><span class="toc-number">3.1.3.</span> <span class="toc-text">流水线过深，收益下降</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3"><span class="toc-number">3.1.4.</span> <span class="toc-text">指令相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y86-64%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">Y86-64流水线实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEQ-%E5%92%8CPIPE"><span class="toc-number">3.2.1.</span> <span class="toc-text">SEQ+和PIPE-</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">3.2.2.</span> <span class="toc-text">处理控制相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.</span> <span class="toc-text">流水线冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%9A%82%E5%81%9C%E6%9D%A5%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">用暂停来避免数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%BD%AC%E5%8F%91%E6%9D%A5%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">用转发来避免数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">加载&#x2F;使用数据冒险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">避免控制冒险</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.2.4.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="toc-number">3.3.</span> <span class="toc-text">流水线控制逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E5%92%8C%E6%B0%94%E6%B3%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">暂停和气泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-%E4%BD%BF%E7%94%A8%E5%86%92%E9%99%A9"><span class="toc-number">3.3.2.</span> <span class="toc-text">加载&#x2F;使用冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86ret%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">处理ret指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-number">3.3.4.</span> <span class="toc-text">预测错误的分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.5.</span> <span class="toc-text">异常指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%BB%84%E5%90%88"><span class="toc-number">3.3.6.</span> <span class="toc-text">特殊情况组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.</span> <span class="toc-text">额外内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.1.</span> <span class="toc-text">多周期指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.2.</span> <span class="toc-text">与存储系统的接口</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/15/Netty/Netty%E7%9A%84FastThreadLocal/" title="Netty的FastThreadLocal"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty的FastThreadLocal"/></a><div class="content"><a class="title" href="/2022/06/15/Netty/Netty%E7%9A%84FastThreadLocal/" title="Netty的FastThreadLocal">Netty的FastThreadLocal</a><time datetime="2022-06-15T07:04:51.000Z" title="发表于 2022-06-15 15:04:51">2022-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/" title="Netty的对象池技术：Recycler"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty的对象池技术：Recycler"/></a><div class="content"><a class="title" href="/2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/" title="Netty的对象池技术：Recycler">Netty的对象池技术：Recycler</a><time datetime="2022-06-13T13:08:25.000Z" title="发表于 2022-06-13 21:08:25">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:独立功能的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现">Redis设计与实现:独立功能的实现</a><time datetime="2022-01-05T12:59:07.000Z" title="发表于 2022-01-05 20:59:07">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:多机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现">Redis设计与实现:多机数据库的实现</a><time datetime="2022-01-05T01:35:35.000Z" title="发表于 2022-01-05 09:35:35">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:单机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现">Redis设计与实现:单机数据库的实现</a><time datetime="2022-01-04T06:38:05.000Z" title="发表于 2022-01-04 14:38:05">2022-01-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By icbtbo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'pLWJLVgdxc6WLcEaFgEr2tQ2-gzGzoHsz',
      appKey: 'OAmeyAUV6TdXoX5n1hSX4ELm',
      placeholder: '请留下你的小脚印～',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      master: 'f94877d77182a6f9068fc12b5545e1f5',
      tagMeta: ["博主","小伙伴","访客"],
      friends: ["52dc4d80afb3aeab1d0deab1aa45a7b5","fd99ca470e7b5e8e2b4f76d6ed26d6cf"]
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>