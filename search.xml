<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty的延时任务处理神器：时间轮HashedWheelTimer</title>
      <link href="2022/06/22/Netty/Netty%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%EF%BC%9A%E6%97%B6%E9%97%B4%E8%BD%AEHashedWheelTimer/"/>
      <url>2022/06/22/Netty/Netty%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%EF%BC%9A%E6%97%B6%E9%97%B4%E8%BD%AEHashedWheelTimer/</url>
      
        <content type="html"><![CDATA[<h3 id="定时任务的基础知识"><a href="#定时任务的基础知识" class="headerlink" title="定时任务的基础知识"></a>定时任务的基础知识</h3><p>首先，我们先了解下什么是定时任务？定时器有非常多的使用场景，大家在平时工作中应该经常遇到，例如生成月统计报表、财务对账、会员积分结算、邮件推送等，都是定时器的使用场景。定时器一般有三种表现形式：按固定周期定时执行、延迟一定时间后执行、指定某个时刻执行。</p><p>定时器的本质是设计一种数据结构，能够存储和调度任务集合，而且 deadline 越近的任务拥有更高的优先级。那么定时器如何知道一个任务是否到期了呢？定时器需要通过轮询的方式来实现，每隔一个时间片去检查任务是否到期。</p><p>所以定时器的内部结构一般需要一个任务队列和一个异步轮询线程，并且能够提供三种基本操作：</p><ul><li>Schedule 新增任务至任务集合；</li><li>Cancel 取消某个任务；</li><li>Run 执行到期的任务。</li></ul><p>JDK 原生提供了三种常用的定时器实现方式，分别为 Timer、DelayedQueue 和 ScheduledThreadPoolExecutor。下面我们逐一对它们进行介绍。</p><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 属于 JDK 比较早期版本的实现，它可以实现固定周期的任务，以及延迟任务。Timer 会起动一个异步线程去执行到期的任务，任务可以只被调度执行一次，也可以周期性反复执行多次。我们先来看下 Timer 是如何使用的，示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">10000</span>, <span class="number">1000</span>);  <span class="comment">// 10s 后调度一个周期为 1s 的定时任务</span></span><br></pre></td></tr></table></figure><p>可以看出，任务是由 TimerTask 类实现，TimerTask 是实现了 Runnable 接口的抽象类，Timer 负责调度和执行 TimerTask。接下来我们看下 Timer 的内部构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        thread.setName(name);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskQueue 是由数组结构实现的小根堆，deadline 最近的任务位于堆顶端，queue[1] 始终是最优先被执行的任务。所以使用小根堆的数据结构，Run 操作时间复杂度 O(1)，新增 Schedule 和取消 Cancel 操作的时间复杂度都是 O(logn)。</p><p>Timer 内部启动了一个 TimerThread 异步线程，不论有多少任务被加入数组，始终都是由 TimerThread 负责处理。TimerThread 会定时轮询 TaskQueue 中的任务，如果堆顶的任务的 deadline 已到，那么执行任务；如果是周期性任务，执行完成后重新计算下一次任务的 deadline，并再次放入小根堆；如果是单次执行的任务，执行结束后会从 TaskQueue 中删除。</p><h4 id="DelayedQueue"><a href="#DelayedQueue" class="headerlink" title="DelayedQueue"></a>DelayedQueue</h4><p>DelayedQueue 是 JDK 中一种可以延迟获取对象的阻塞队列，其内部是采用优先级队列 PriorityQueue 存储对象。DelayQueue 中的每个对象都必须实现 Delayed 接口，并重写 compareTo 和 getDelay 方法。DelayedQueue 的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;SampleTask&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> SampleTask(now + <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> SampleTask(now + <span class="number">2000</span>));</span><br><span class="line"></span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> SampleTask(now + <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date(delayQueue.take().getTime()));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SampleTask</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Long.compare(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS), o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> unit.convert(time - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue 提供了 put() 和 take() 的阻塞方法，可以向队列中添加对象和取出对象。对象被添加到 DelayQueue 后，会根据 compareTo() 方法进行优先级排序。getDelay() 方法用于计算消息延迟的剩余时间，只有 getDelay &lt;=0 时，该对象才能从 DelayQueue 中取出。</p><p>DelayQueue 在日常开发中最常用的场景就是实现重试机制。例如，接口调用失败或者请求超时后，可以将当前请求对象放入 DelayQueue，通过一个异步线程 take() 取出对象然后继续进行重试。如果还是请求失败，继续放回 DelayQueue。为了限制重试的频率，可以设置重试的最大次数以及采用指数退避算法设置对象的 deadline，如 2s、4s、8s、16s ……以此类推。</p><p>相比于 Timer，DelayQueue 只实现了任务管理的功能，需要与异步线程配合使用。DelayQueue 使用优先级队列实现任务的优先级排序，新增 Schedule 和取消 Cancel 操作的时间复杂度也是 O(logn)。</p><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>上文中介绍的 Timer 其实目前并不推荐用户使用，它是存在不少设计缺陷的。</p><ul><li>Timer 是单线程模式。如果某个 TimerTask 执行时间很久，会影响其他任务的调度。</li><li>Timer 的任务调度是基于系统绝对时间的，如果系统时间不正确，可能会出现问题。</li><li>TimerTask 如果执行出现异常，Timer 并不会捕获，会导致线程终止，其他任务永远不会执行。</li></ul><p>为了解决 Timer 的设计缺陷，JDK 提供了功能更加丰富的 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor 提供了周期执行任务和延迟执行任务的特性，下面通过一个例子先看下 ScheduledThreadPoolExecutor 如何使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>), <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS); <span class="comment">// 1s 延迟后开始执行任务，每 2s 重复执行一次</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 继承于 ThreadPoolExecutor，因此它具备线程池异步处理任务的能力。线程池主要负责管理创建和管理线程，并从自身的阻塞队列中不断获取任务执行。线程池有两个重要的角色，分别是任务和阻塞队列。ScheduledThreadPoolExecutor 在 ThreadPoolExecutor 的基础上，重新设计了任务 ScheduledFutureTask 和阻塞队列 DelayedWorkQueue。ScheduledFutureTask 继承于 FutureTask，并重写了 run() 方法，使其具备周期执行任务的能力。DelayedWorkQueue 内部是优先级队列，deadline 最近的任务在队列头部。对于周期执行的任务，在执行完会重新设置时间，并再次放入队列中。ScheduledThreadPoolExecutor 的实现原理可以用下图表示。</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206221953863.png" alt="image-20220622195327691" style="zoom:80%;" /><h3 id="时间轮原理分析"><a href="#时间轮原理分析" class="headerlink" title="时间轮原理分析"></a>时间轮原理分析</h3><p>技术有时就源于生活，例如排队买票可以想到队列，公司的组织关系可以理解为树等，而时间轮算法的设计思想就来源于钟表。如下图所示，时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206221955672.png" alt="image-20220622195536604"></p><p>任务是如何添加到时间轮当中的呢？可以根据任务的到期时间进行取模，然后将任务分布到不同的 slot 中。如上图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。假如现在需要调度一个 3s 后执行的任务，应该加入 2+3=5 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 零 4 个 slot，需要放入第 (2+12)%8=6 个 slot。</p><p>那么当时针走到第 6 个 slot 时，怎么区分每个任务是否需要立即执行，还是需要等待下一圈 round，甚至更久时间之后执行呢？所以我们需要把 round 信息保存在任务中。例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round=0，需要立即执行；第二个任务 round=1，需要等待 1<em>8=8s 后执行；第三个任务 round=2，需要等待 2</em>8=8s 后执行。所以当时针转动到对应 slot 时，只执行 round=0 的任务，slot 中其余任务的 round 应当减 1，等待下一个 round 之后执行。</p><p>上面介绍了时间轮算法的基本理论，可以看出时间轮有点类似 HashMap，如果多个任务如果对应同一个 slot，处理冲突的方法采用的是拉链法。在任务数量比较多的场景下，适当增加时间轮的 slot 数量，可以减少时针转动时遍历的任务个数。</p><p>时间轮定时器最大的优势就是，任务的新增和取消都是 O(1) 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。HashedWheelTimer 是 Netty 中时间轮算法的实现类，下面我就结合 HashedWheelTimer 的源码详细分析时间轮算法的实现原理。</p><h3 id="Netty-HashedWheelTimer-源码解析"><a href="#Netty-HashedWheelTimer-源码解析" class="headerlink" title="Netty HashedWheelTimer 源码解析"></a>Netty HashedWheelTimer 源码解析</h3><p>在开始学习 HashedWheelTimer 的源码之前，需要了解 HashedWheelTimer 接口定义以及相关组件，才能更好地使用 HashedWheelTimer。</p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><p>HashedWheelTimer 实现了接口 io.netty.util.Timer，Timer 接口是我们研究 HashedWheelTimer 一个很好的切入口。一起看下 Timer 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timer 接口提供了两个方法，分别是创建任务 newTimeout() 和停止所有未执行任务 stop()。从方法的定义可以看出，Timer 可以认为是上层的时间轮调度器，通过 newTimeout() 方法可以提交一个任务 TimerTask，并返回一个 Timeout。TimerTask 和 Timeout 是两个接口类，它们有什么作用呢？我们分别看下 TimerTask 和 Timeout 的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TimerTask <span class="title">task</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Timeout 持有 Timer 和 TimerTask 的引用，而且通过 Timeout 接口可以执行取消任务的操作。Timer、Timeout 和 TimerTask 之间的关系如下图所示：</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206221958047.png" alt="image-20220622195809955" style="zoom:80%;" /><p>清楚 HashedWheelTimer 的接口定义以及相关组件的概念之后，接下来我们就可以开始使用它了。</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p>通过下面这个简单的例子，我们看下 HashedWheelTimer 是如何使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"></span><br><span class="line">        Timeout timeout1 = timer.newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;timeout1: &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timeout1.isExpired()) &#123;</span><br><span class="line"></span><br><span class="line">            timeout1.cancel();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer.newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;timeout2: &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        timer.newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;timeout3: &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timeout2: Mon Nov 09 19:57:04 CST 2020</span><br><span class="line"></span><br><span class="line">timeout3: Mon Nov 09 19:57:09 CST 2020</span><br></pre></td></tr></table></figure><p>简单的几行代码，基本展示了 HashedWheelTimer 的大部分用法。示例中我们通过 newTimeout() 启动了三个 TimerTask，timeout1 由于被取消了，所以并没有执行。timeout2 和 timeout3 分别应该在 1s 和 3s 后执行。然而从结果输出看并不是，timeout2 和 timeout3 的打印时间相差了 5s，这是由于 timeout2 阻塞了 5s 造成的。由此可以看出，<strong>时间轮中的任务执行是串行的，当一个任务执行的时间过长，会影响后续任务的调度和执行，很可能产生任务堆积的情况</strong>。</p><p>至此，对 HashedWheelTimer 的基本使用方法已经有了初步了解，下面我们开始深入研究 HashedWheelTimer 的实现原理。</p><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>我们先从 HashedWheelTimer 的构造函数看起，结合上文中介绍的时间轮算法，一起梳理出 HashedWheelTimer 的内部实现结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> tickDuration, </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit, </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> ticksPerWheel, </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel); <span class="comment">// 创建时间轮的环形数组结构</span></span><br><span class="line"></span><br><span class="line">    mask = wheel.length - <span class="number">1</span>; <span class="comment">// 用于快速取模的掩码 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> duration = unit.toNanos(tickDuration); <span class="comment">// 转换成纳秒处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    workerThread = threadFactory.newThread(worker); <span class="comment">// 创建工作线程</span></span><br><span class="line"></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>; <span class="comment">// 是否开启内存泄漏检测</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts; <span class="comment">// 最大允许等待任务数，HashedWheelTimer 中任务超出该阈值时会抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 HashedWheelTimer 的实例数超过 64，会打印错误日志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line"></span><br><span class="line">        WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        reportTooManyInstances();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashedWheelTimer 的构造函数清晰地列举出了几个核心属性：</p><ul><li><strong>threadFactory</strong>，线程池，但是只创建了一个线程；</li><li><strong>tickDuration</strong>，时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot；</li><li><strong>unit</strong>，表示 tickDuration 的时间单位；</li><li><strong>ticksPerWheel</strong>，时间轮上一共有多少个 slot，默认 512 个。分配的 slot 越多，占用的内存空间就越大；</li><li><strong>leakDetection</strong>，是否开启内存泄漏检测；</li><li><strong>maxPendingTimeouts</strong>，最大允许等待任务数。</li></ul><p>下面我们看下 HashedWheelTimer 是如何创建出来的，我们直接跟进 createWheel() 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">    HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wheel;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line"></span><br><span class="line">        normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间轮的创建就是为了创建 HashedWheelBucket 数组，每个 HashedWheelBucket 表示时间轮中一个 slot。从 HashedWheelBucket 的结构定义可以看出，HashedWheelBucket 内部是一个双向链表结构，双向链表的每个节点持有一个 HashedWheelTimeout 对象，HashedWheelTimeout 代表一个定时任务。每个 HashedWheelBucket 都包含双向链表 head 和 tail 两个 HashedWheelTimeout 节点，这样就可以实现不同方向进行链表遍历。关于 HashedWheelBucket 和 HashedWheelTimeout 的具体功能下文再继续介绍。</p><p>因为时间轮需要使用 &amp; 做取模运算，所以数组的长度需要是 2 的次幂。normalizeTicksPerWheel() 方法的作用就是找到不小于 ticksPerWheel 的最小 2 次幂，这个方法实现的并不好，可以参考 JDK HashMap 扩容 tableSizeFor 的实现进行性能优化如下所示。当然 normalizeTicksPerWheel() 只是在初始化的时候使用，所以并无影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = ticksPerWheel - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashedWheelTimer 初始化的主要工作我们已经介绍完了，其内部结构与上文中介绍的时间轮算法类似，如下图所示。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206222030810.png" alt="image-20220622201054928"></p><p>接下来我们围绕定时器的三种基本操作，分析下 HashedWheelTimer 是如何实现添加任务、执行任务和取消任务的。</p><h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>HashedWheelTimer 初始化完成后，如何向 HashedWheelTimer 添加任务呢？我们自然想到 HashedWheelTimer 提供的 newTimeout() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line"></span><br><span class="line">        pendingTimeouts.decrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Number of pending timeouts (&quot;</span></span><br><span class="line"></span><br><span class="line">            + pendingTimeoutsCount + <span class="string">&quot;) is greater than or equal to maximum allowed pending &quot;</span></span><br><span class="line"></span><br><span class="line">            + <span class="string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start(); <span class="comment">// 1. 如果 worker 线程没有启动，需要启动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime; <span class="comment">// 计算任务的 deadline</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        deadline = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline); <span class="comment">//  2. 创建定时任务</span></span><br><span class="line"></span><br><span class="line">    timeouts.add(timeout); <span class="comment">// 3. 添加任务到 Mpsc Queue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br></pre></td></tr></table></figure><p>newTimeout() 方法主要做了三件事，分别为启动工作线程，创建定时任务，并把任务添加到 Mpsc Queue。HashedWheelTimer 的工作线程采用了懒启动的方式，不需要用户显示调用。这样做的好处是在时间轮中没有任务时，可以避免工作线程空转而造成性能损耗。先看下启动工作线程 start() 的源码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (WORKER_STATE_UPDATER.<span class="keyword">get</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                workerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;cannot be started once stopped&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Invalid WorkerState&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startTimeInitialized.<span class="keyword">await</span>();</span><br><span class="line">        &#125; catch (InterruptedException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程的启动之前，会通过 CAS 操作获取工作线程的状态，如果已经启动，则直接跳过。如果没有启动，再次通过 CAS 操作更改工作线程状态，然后启动工作线程。启动的过程是直接调用的 Thread#start() 方法，我们暂且先不关注工作线程具体做了什么，下文再继续分析。</p><p>回到 newTimeout() 的主流程，接下来的逻辑就非常简单了。根据用户传入的任务延迟时间，可以计算出任务的 deadline，然后创建定时任务 HashedWheelTimeout 对象，最终把 HashedWheelTimeout 添加到 Mpsc Queue 中。看到这里，你会不会有个疑问，为什么不是将 HashedWheelTimeout 直接添加到时间轮中呢？而是先添加到 Mpsc Queue？Mpsc Queue 可以理解为多生产者单消费者的线程安全队列。可以猜到 HashedWheelTimer 是想借助 Mpsc Queue 保证多线程向时间轮添加任务的线程安全性。</p><p>那么什么时候任务才会被加入时间轮并执行呢？此时还没有太多信息，接下来我们只能工作线程 Worker 里寻找问题的答案。</p><h4 id="工作线程-Worker"><a href="#工作线程-Worker" class="headerlink" title="工作线程 Worker"></a>工作线程 Worker</h4><p>工作线程 Worker 是时间轮的核心引擎，随着时针的转动，到期任务的处理都由 Worker 处理完成。下面我们定位到 Worker 的 run() 方法一探究竟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;(); <span class="comment">// 未处理任务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        startTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            startTime = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick(); <span class="comment">// 1. 计算下次 tick 的时间, 然后sleep 到下次 tick</span></span><br><span class="line">            <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123; <span class="comment">// 可能因为溢出或者线程中断，造成 deadline &lt;= 0</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask); <span class="comment">// 2. 获取当前 tick 在 HashedWheelBucket 数组中对应的下标</span></span><br><span class="line"></span><br><span class="line">                processCancelledTasks(); <span class="comment">// 3. 移除被取消的任务</span></span><br><span class="line"></span><br><span class="line">                HashedWheelBucket bucket =</span><br><span class="line"></span><br><span class="line">                        wheel[idx];</span><br><span class="line"></span><br><span class="line">                transferTimeoutsToBuckets(); <span class="comment">// 4. 从 Mpsc Queue 中取出任务加入对应的 slot 中</span></span><br><span class="line"></span><br><span class="line">                bucket.expireTimeouts(deadline); <span class="comment">// 5. 执行到期的任务</span></span><br><span class="line"></span><br><span class="line">                tick++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间轮退出后，取出 slot 中未执行且未被取消的任务，并加入未处理任务列表，以便 stop() 方法返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">            bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将还没来得及添加到 slot 中的任务取出，如果任务未取消则加入未处理任务列表，以便 stop() 方法返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                unprocessedTimeouts.add(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        processCancelledTasks();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程 Worker 的核心执行流程是代码中的 do-while 循环，只要 Worker 处于 STARTED 状态，就会执行 do-while 循环，我们把该过程拆分成为以下几个步骤，逐一分析。</p><ul><li>通过 waitForNextTick() 方法计算出时针到下一次 tick 的时间间隔，然后 sleep 到下一次 tick。</li><li>通过位运算获取当前 tick 在 HashedWheelBucket 数组中对应的下标</li><li>移除被取消的任务。</li><li>从 Mpsc Queue 中取出任务加入对应的 HashedWheelBucket 中。</li><li>执行当前 HashedWheelBucket 中的到期任务。</li></ul><h5 id="waitForNextTick"><a href="#waitForNextTick" class="headerlink" title="waitForNextTick()"></a>waitForNextTick()</h5><p>首先看下 waitForNextTick() 方法是如何计算等待时间的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line">        <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> currentTime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">            sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sleepTimeMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 tickDuration 可以推算出下一次 tick 的 deadline，deadline 减去当前时间就可以得到需要 sleep 的等待时间。所以 tickDuration 的值越小，时间的精准度也就越高，同时 Worker 的繁忙程度越高。如果 tickDuration 设置过小，为了防止系统会频繁地 sleep 再唤醒，会保证 Worker 至少 sleep 的时间为 1ms 以上。</p><p>Worker 从 sleep 状态唤醒后，接下来会执行第二步流程，通过按位与的操作计算出当前 tick 在 HashedWheelBucket 数组中对应的下标。按位与比普通的取模运算效率要快很多，前提是时间轮中的数组长度是 2 的次幂，掩码 mask 为 2 的次幂减 1，这样才能达到与取模一样的效果。</p><p>接下来 Worker 会调用 processCancelledTasks() 方法处理被取消的任务，所有取消的任务都会加入 cancelledTimeouts 队列中，Worker 会从队列中取出任务，然后将其从对应的 HashedWheelBucket 中删除，删除操作为基本的链表操作。processCancelledTasks() 的源码比较简单，我们在此就不展开了。</p><h5 id="transferTimeoutsToBuckets"><a href="#transferTimeoutsToBuckets" class="headerlink" title="transferTimeoutsToBuckets()"></a>transferTimeoutsToBuckets()</h5><p>之前我们还留了一个疑问，Mpsc Queue 中的任务什么时候加入时间轮的呢？答案就在 transferTimeoutsToBuckets() 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次时针 tick 最多只处理 100000 个任务，以防阻塞 Worker 线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> calculated = timeout.deadline / tickDuration; <span class="comment">// 计算任务需要经过多少个 tick</span></span><br><span class="line"></span><br><span class="line">        timeout.remainingRounds = (calculated - tick) / wheel.length; <span class="comment">// 计算任务需要在时间轮中经历的圈数 remainingRounds</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// 如果任务在 timeouts 队列里已经过了执行时间, 那么会加入当前 HashedWheelBucket 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">        HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line"></span><br><span class="line">        bucket.addTimeout(timeout);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transferTimeoutsToBuckets() 的主要工作就是从 Mpsc Queue 中取出任务，然后添加到时间轮对应的 HashedWheelBucket 中。每次时针 tick 最多只处理 100000 个任务，一方面避免取任务的操作耗时过长，另一方面为了防止执行太多任务造成 Worker 线程阻塞。</p><p>根据用户设置的任务 deadline，可以计算出任务需要经过多少次 tick 才能开始执行以及需要在时间轮中转动圈数 remainingRounds，remainingRounds 会记录在 HashedWheelTimeout 中，在执行任务的时候 remainingRounds 会被使用到。因为时间轮中的任务并不能够保证及时执行，假如有一个任务执行的时间特别长，那么任务在 timeouts 队列里已经过了执行时间，也没有关系，Worker 会将这些任务直接加入当前HashedWheelBucket 中，所以过期的任务并不会被遗漏。</p><h5 id="expireTimeouts"><a href="#expireTimeouts" class="headerlink" title="expireTimeouts()"></a>expireTimeouts()</h5><p>任务被添加到时间轮之后，重新再回到 Worker#run() 的主流程，接下来就是执行当前 HashedWheelBucket 中的到期任务，跟进 HashedWheelBucket#expireTimeouts() 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        HashedWheelTimeout next = timeout.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            next = remove(timeout);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line"></span><br><span class="line">                timeout.expire(); <span class="comment">// 执行任务</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line"></span><br><span class="line">                        <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line"></span><br><span class="line">            next = remove(timeout);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            timeout.remainingRounds --; <span class="comment">// 未到执行时间，remainingRounds 减 1</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timeout = next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行任务的操作比较简单，就是从头开始遍历 HashedWheelBucket 中的双向链表。如果 remainingRounds &lt;=0，则调用 expire() 方法执行任务，timeout.expire() 内部就是调用了 TimerTask 的 run() 方法。如果任务已经被取消，直接从链表中移除。否则表示任务的执行时间还没到，remainingRounds 减 1，等待下一圈即可。</p><p>至此，工作线程 Worker 的核心逻辑 do-while 循环我们已经讲完了。当时间轮退出后，Worker 还会执行一些后置的收尾工作。Worker 会从每个 HashedWheelBucket 取出未执行且未取消的任务，以及还来得及添加到 HashedWheelBucket 中的任务，然后加入未处理任务列表，以便 stop() 方法统一处理。</p><h4 id="停止时间轮"><a href="#停止时间轮" class="headerlink" title="停止时间轮"></a>停止时间轮</h4><p>回到 Timer 接口两个方法，newTimeout() 上文已经分析完了，接下来我们就以 stop() 方法为入口，看下时间轮停止都做了哪些工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Worker 线程无法停止时间轮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"></span><br><span class="line">                HashedWheelTimer.class.getSimpleName() +</span><br><span class="line"></span><br><span class="line">                        <span class="string">&quot;.stop() cannot be called from &quot;</span> +</span><br><span class="line"></span><br><span class="line">                        TimerTask.class.getSimpleName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试通过 CAS 操作将工作线程的状态更新为 SHUTDOWN 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line"></span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">            workerThread.interrupt(); <span class="comment">// 中断 Worker 线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                workerThread.join(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">assert</span> closed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> worker.unprocessedTimeouts(); <span class="comment">// 返回未处理任务的列表</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程是 Worker 线程，它是不能发起停止时间轮的操作的，是为了防止有定时任务发起停止时间轮的恶意操作。停止时间轮主要做了三件事，首先尝试通过 CAS 操作将工作线程的状态更新为 SHUTDOWN 状态，然后中断工作线程 Worker，最后将未处理的任务列表返回给上层。</p><p>到此为止，HashedWheelTimer 的实现原理我们已经分析完了。再来回顾一下 HashedWheelTimer 的几个核心成员。</p><ul><li><strong>HashedWheelTimeout</strong>，任务的封装类，包含任务的到期时间 deadline、需要经历的圈数 remainingRounds 等属性。</li><li><strong>HashedWheelBucket</strong>，相当于时间轮的每个 slot，内部采用双向链表保存了当前需要执行的 HashedWheelTimeout 列表。</li><li><strong>Worker</strong>，HashedWheelTimer 的核心工作引擎，负责处理定时任务。</li></ul><h3 id="时间轮进阶应用"><a href="#时间轮进阶应用" class="headerlink" title="时间轮进阶应用"></a>时间轮进阶应用</h3><p>Netty 中的时间轮是通过固定的时间间隔 tickDuration 进行推动的，如果长时间没有到期任务，那么会存在时间轮空推进的现象，从而造成一定的性能损耗。此外，如果任务的到期时间跨度很大，例如 A 任务 1s 后执行，B 任务 6 小时之后执行，也会造成空推进的问题。</p><p>那么上述问题有没有什么解决方案呢？在研究 Kafka 的时候，Kafka 也有时间轮的应用，它的实现思路与 Netty 是存在区别的。因为 Kafka 面对的应用场景是更加严苛的，可能会存在各种时间粒度的定时任务，那么 Kafka 是否有解决时间跨度问题呢？我们接下来就简单介绍下 Kafka 的优化思路。</p><p>Kafka 时间轮的内部结构与 Netty 类似，如下图所示。Kafka 的时间轮也是采用环形数组存储定时任务，数组中的每个 slot 代表一个 Bucket，每个 Bucket 保存了定时任务列表 TimerTaskList，TimerTaskList 同样采用双向链表的结构实现，链表的每个节点代表真正的定时任务 TimerTaskEntry。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206222030978.png" alt="image-20220622202215623"></p><p>为了解决空推进的问题，Kafka 借助 JDK 的 DelayQueue 来负责推进时间轮。DelayQueue 保存了时间轮中的每个 Bucket，并且根据 Bucket 的到期时间进行排序，最近的到期时间被放在 DelayQueue 的队头。Kafka 中会有一个线程来读取 DelayQueue 中的任务列表，如果时间没有到，那么 DelayQueue 会一直处于阻塞状态，从而解决空推荐的问题。这时候你可能会问，DelayQueue 插入和删除的性能不是并不好吗？其实 Kafka 采用的是一种权衡的策略，把 DelayQueue 用在了合适的地方。DelayQueue 只存放了 Bucket，插入和删除任务还是通过时间轮来进行。Bucket 的数量并不多，相比空推进带来的影响是利大于弊的。</p><p>而为了解决任务时间跨度很大的问题，Kafka 引入了层级时间轮，如下图所示。当任务的 deadline 超出当前所在层的时间轮表示范围时，就会尝试将任务添加到上一层时间轮中，跟钟表的时针、分针、秒针的转动规则是同一个道理。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206222031649.png" alt="image-20220622203105446"></p><p>从图中可以看出，第一层时间轮每个时间格为 1ms，整个时间轮的跨度为 20ms；第二层时间轮每个时间格为 20ms，整个时间轮跨度为 400ms；第三层时间轮每个时间格为 400ms，整个时间轮跨度为 8000ms。每一层时间轮都有自己的指针，每层时间轮走完一圈后，上层时间轮也会相应推进一格。</p><p>假设现在有一个任务到期时间是 450ms 之后，应该放在第三层时间轮的第一格。随着时间的流逝，当指针指向该时间格时，发现任务到期时间还有 50ms，这里就涉及时间轮降级的操作，它会将任务重新提交到时间轮中。此时发现第一层时间轮整体跨度不够，需要放在第二层时间轮中第三格。当时间再经历 40ms 之后，该任务又会触发一次降级操作，放入到第一层时间轮，最后等到 10ms 后执行任务。</p><p>由此可见，Kafka 的层级时间轮的时间粒度更好控制，可以应对更加复杂的定时任务处理场景，适用的范围更广。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashedWheelTimer 的源码通俗易懂，其设计思想值得我们借鉴。在平时开发中如果有类似的任务处理机制，可以尝试套用 HashedWheelTimer 的工作模式。</p><p>HashedWheelTimer 并不是十全十美的，使用的时候需要清楚它存在的问题：</p><ul><li>如果长时间没有到期任务，那么会存在时间轮空推进的现象。</li><li>只适用于处理耗时较短的任务，由于 Worker 是单线程的，如果一个任务执行的时间过长，会造成 Worker 线程阻塞。</li><li>相比传统定时器的实现方式，内存占用较大。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> 时间轮 </tag>
            
            <tag> 延时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的FastThreadLocal</title>
      <link href="2022/06/15/Netty/Netty%E7%9A%84FastThreadLocal/"/>
      <url>2022/06/15/Netty/Netty%E7%9A%84FastThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="FastThreadLocal-为什么快"><a href="#FastThreadLocal-为什么快" class="headerlink" title="FastThreadLocal 为什么快"></a>FastThreadLocal 为什么快</h1><p>FastThreadLocal 的实现与 ThreadLocal 非常类似，Netty 为 FastThreadLocal 量身打造了 FastThreadLocalThread 和 InternalThreadLocalMap 两个重要的类。</p><p>FastThreadLocalThread 是对 Thread 类的一层包装，每个线程对应一个 InternalThreadLocalMap 实例。只有 FastThreadLocal 和 FastThreadLocalThread 组合使用时，才能发挥 FastThreadLocal 的性能优势。</p><p>FastThreadLocalThread 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 FastThreadLocalThread 主要扩展了 InternalThreadLocalMap 字段，我们可以猜测到 FastThreadLocalThread 主要使用 InternalThreadLocalMap 存储数据，而不再是使用 Thread 中的 ThreadLocalMap。所以想知道 FastThreadLocalThread 高性能的奥秘，必须要了解 InternalThreadLocalMap 的设计原理。</p><p>我们知道 ThreadLocal 的一个重要缺点，就是 ThreadLocalMap 采用线性探测法解决 Hash 冲突使得性能较慢，那么 InternalThreadLocalMap 又是如何优化的呢？首先一起看下 InternalThreadLocalMap 的内部构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalThreadLocalMap</span> <span class="keyword">extends</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_ARRAY_LIST_INITIAL_CAPACITY = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRING_BUILDER_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRING_BUILDER_MAX_SIZE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object UNSET = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> BitSet cleanerFlags;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InternalThreadLocalMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">super</span>(newIndexedVariableTable());</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] newIndexedVariableTable() &#123;</span><br><span class="line"></span><br><span class="line">        Object[] array = <span class="keyword">new</span> Object[<span class="number">32</span>];</span><br><span class="line">        Arrays.fill(array, UNSET);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextVariableIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = nextIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nextIndex.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;too many thread-local indexed variables&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnpaddedInternalThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="keyword">new</span> ThreadLocal&lt;InternalThreadLocalMap&gt;();</span><br><span class="line"><span class="comment">// 用于递增索引</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextIndex = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 保存具体值的 Object 数组</span></span><br><span class="line">    Object[] indexedVariables;</span><br><span class="line"></span><br><span class="line">    UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123;</span><br><span class="line">        <span class="keyword">this</span>.indexedVariables = indexedVariables;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出，InternalThreadLocalMap 与 ThreadLocalMap 一样都是采用数组的存储方式。</p><p>但是 InternalThreadLocalMap 并没有使用线性探测法来解决 Hash 冲突，而是<strong>在 FastThreadLocal 初始化的时候分配一个数组索引 ，index 的值采用原子类 AtomicInteger 保证顺序递增，通过调用 <code>InternalThreadLocalMap.nextVariableIndex()</code> 方法获得</strong>。然后<strong>在读写数据的时候通过数组下标 index 直接定位到 FastThreadLocal 的位置</strong>，时间复杂度为 O(1)。</p><p>如果数组下标递增到非常大，那么数组也会比较大，所以 FastThreadLocal 是通过空间换时间的思想提升读写性能。下面通过一幅图描述 InternalThreadLocalMap、index 和 FastThreadLocal 之间的关系。</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206151526060.png" alt="image-20220615152609978" style="zoom:80%;" /><p>对比 ThreadLocal , FastThreadLocal 使用 Object 数组替代了 Entry 数组，Object[0] 存储的是一个Set&lt;FastThreadLocal&lt;?&gt;&gt; 集合，从数组下标 1 开始都是直接存储的 value 数据，不再采用 ThreadLocal 的键值对形式进行存储。</p><h1 id="FastThreadLocal-源码分析"><a href="#FastThreadLocal-源码分析" class="headerlink" title="FastThreadLocal 源码分析"></a>FastThreadLocal 源码分析</h1><p>FastThreadLocal 的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;String&gt; THREAD_NAME_LOCAL = <span class="keyword">new</span> FastThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;TradeOrder&gt; TRADE_THREAD_LOCAL = <span class="keyword">new</span> FastThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tradeId = i;</span><br><span class="line"></span><br><span class="line">            String threadName = <span class="string">&quot;thread-&quot;</span> + i;</span><br><span class="line"><span class="comment">// 注意，这里使用 FastThreadLocalThread，否则性能不会得到提升，反而会更差</span></span><br><span class="line">            <span class="keyword">new</span> FastThreadLocalThread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                THREAD_NAME_LOCAL.set(threadName);</span><br><span class="line">                TradeOrder tradeOrder = <span class="keyword">new</span> TradeOrder(tradeId, tradeId % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;已支付&quot;</span> : <span class="string">&quot;未支付&quot;</span>);</span><br><span class="line">                TRADE_THREAD_LOCAL.set(tradeOrder);</span><br><span class="line">                System.out.println(<span class="string">&quot;threadName: &quot;</span> + THREAD_NAME_LOCAL.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;tradeOrder info：&quot;</span> + TRADE_THREAD_LOCAL.get());</span><br><span class="line">            &#125;, threadName).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FastThreadLocal 的使用方法几乎和 ThreadLocal 保持一致，只需要把代码中 Thread、ThreadLocal 替换为 FastThreadLocalThread 和 FastThreadLocal 即可。</p><h2 id="FastThreadLocal-set"><a href="#FastThreadLocal-set" class="headerlink" title="FastThreadLocal.set()"></a>FastThreadLocal.set()</h2><p>首先给出 set 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123; <span class="comment">// 1. value 是否为缺省值</span></span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get(); <span class="comment">// 2. 获取当前线程的 InternalThreadLocalMap</span></span><br><span class="line">        setKnownNotUnset(threadLocalMap, value); <span class="comment">// 3. 将 InternalThreadLocalMap 中数据替换为新的 value</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FastThreadLocal.set() 方法虽然入口只有几行代码，但是内部逻辑是相当复杂的。我们首先还是抓住代码主干，一步步进行拆解分析。set() 的过程主要分为三步：</p><ol><li>判断 value 是否为缺省值，如果等于缺省值，那么直接调用 remove() 方法。这里我们还不知道缺省值和 remove() 之间的联系是什么，我们暂且把 remove() 放在最后分析。</li><li>如果 value 不等于缺省值，接下来会获取当前线程的 InternalThreadLocalMap。</li><li>然后将 InternalThreadLocalMap 中对应数据替换为新的 value。</li></ol><h3 id="InternalThreadLocalMap-get"><a href="#InternalThreadLocalMap-get" class="headerlink" title="InternalThreadLocalMap.get()"></a>InternalThreadLocalMap.get()</h3><p>首先我们看下 InternalThreadLocalMap.get() 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123; <span class="comment">// 当前线程是否为 FastThreadLocalThread 类型</span></span><br><span class="line">        <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> slowGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    InternalThreadLocalMap threadLocalMap = thread.threadLocalMap(); <span class="comment">// 获取 FastThreadLocalThread 的 threadLocalMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> threadLocalMap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap; </span><br><span class="line">    InternalThreadLocalMap ret = slowThreadLocalMap.get(); <span class="comment">// 从 JDK 原生 ThreadLocal 中获取 InternalThreadLocalMap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果为空，则先设置值</span></span><br><span class="line">        ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">        slowThreadLocalMap.set(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InternalThreadLocalMap.get() 逻辑很简单，如果当前线程是 FastThreadLocalThread 类型，那么直接通过 fastGet() 方法获取 FastThreadLocalThread 的 threadLocalMap 属性即可。如果此时 InternalThreadLocalMap 不存在，直接创建一个返回。</p><blockquote><p>关于 InternalThreadLocalMap 的初始化在上文中已经介绍过，它会初始化一个长度为 32 的 Object 数组，数组中填充着 32 个缺省对象 UNSET 的引用。</p></blockquote><p>而如果当前线程不是 FastThreadLocalThread 类型，则会调用 slowGet() 方法来获取。当嵌线程不是FastThreadLocalThread 类型时，线程内部是没有 InternalThreadLocalMap 属性的，Netty 在 UnpaddedInternalThreadLocalMap 中保存了一个 JDK 原生的 ThreadLocal，ThreadLocal 中存放着 InternalThreadLocalMap，此时获取 InternalThreadLocalMap 就退化成 JDK 原生的 ThreadLocal 获取。</p><p>获取 InternalThreadLocalMap 的过程已经讲完了，下面看下 setKnownNotUnset() 如何将数据添加到 InternalThreadLocalMap 的。</p><h3 id="setKnownNotUnset"><a href="#setKnownNotUnset" class="headerlink" title="setKnownNotUnset()"></a>setKnownNotUnset()</h3><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setKnownNotUnset</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123; <span class="comment">// 1. 找到数组下标 index 位置，设置新的 value</span></span><br><span class="line">        addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>); <span class="comment">// 2. 将 FastThreadLocal 对象保存到待清理的 Set 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setKnownNotUnset() 主要做了两件事：</p><ol><li>找到数组下标 index 位置，设置新的 value。</li><li>将 FastThreadLocal 对象保存到待清理的 Set 中。</li></ol><p>首先我们看下第一步 threadLocalMap.setIndexedVariable() 的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line"></span><br><span class="line">        Object oldValue = lookup[index]; </span><br><span class="line">        lookup[index] = value; <span class="comment">// 直接将数组 index 位置设置为 value，时间复杂度为 O(1)</span></span><br><span class="line">        <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        expandIndexedVariableTableAndSet(index, value); <span class="comment">// 容量不够，先扩容再设置值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexedVariables 就是 InternalThreadLocalMap 中用于存放数据的数组，如果数组容量大于 FastThreadLocal 的 index 索引，那么直接找到数组下标 index 位置将新 value 设置进去，事件复杂度为 O(1)。在设置新的 value 之前，会将之前 index 位置的元素取出，如果旧的元素还是 UNSET 缺省对象，那么返回成功。</p><p>如果数组容量不够了怎么办呢？InternalThreadLocalMap 会自动扩容，然后再设置 value。接下来看看 expandIndexedVariableTableAndSet() 的扩容逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandIndexedVariableTableAndSet</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object[] oldArray = indexedVariables;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldCapacity = oldArray.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newCapacity = index;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">1</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">2</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">4</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt;  <span class="number">8</span>;</span><br><span class="line">    newCapacity |= newCapacity &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    newCapacity ++;</span><br><span class="line"></span><br><span class="line">    Object[] newArray = Arrays.copyOf(oldArray, newCapacity);</span><br><span class="line">    Arrays.fill(newArray, oldCapacity, newArray.length, UNSET);</span><br><span class="line">    newArray[index] = value;</span><br><span class="line">    indexedVariables = newArray;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的位移操作是不是似曾相识？我们去翻阅下 JDK HashMap 中扩容的源码，其中有这么一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 InternalThreadLocalMap 实现数组扩容几乎和 HashMap 完全是一模一样的。InternalThreadLocalMap 以 index 为基准进行扩容，将数组扩容后的容量向上取整为 2 的次幂。然后将原数组内容拷贝到新的数组中，空余部分填充缺省对象 UNSET，最终把新数组赋值给 indexedVariables。</p><blockquote><p>为什么 InternalThreadLocalMap 以 index 为基准进行扩容，而不是原数组长度呢？假设现在初始化了 70 个 FastThreadLocal，但是这些 FastThreadLocal 从来没有调用过 set() 方法，此时数组还是默认长度 32。当第 index = 70 的 FastThreadLocal 调用 set() 方法时，如果按原数组容量 32 进行扩容 2 倍后，还是无法填充 index = 70 的数据。所以使用 index 为基准进行扩容可以解决这个问题，但是如果 FastThreadLocal 特别多，数组的长度也是非常大的。</p></blockquote><p>回到 setKnownNotUnset() 的主流程，向 InternalThreadLocalMap 添加完数据之后，接下就是将 FastThreadLocal 对象保存到待清理的 Set 中。我们继续看下 addToVariablesToRemove() 是如何实现的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">addToVariablesToRemove</span>(<span class="params">InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span> v = threadLocalMap.indexedVariable(variablesToRemoveIndex); <span class="comment">// 获取数组下标为 0 的元素</span></span><br><span class="line">    <span class="built_in">Set</span>&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="literal">null</span>) &#123;</span><br><span class="line">        variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, <span class="built_in">Boolean</span>&gt;()); <span class="comment">// 创建 FastThreadLocal 类型的 Set 集合</span></span><br><span class="line">        threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove); <span class="comment">// 将 Set 集合填充到数组下标 0 的位置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        variablesToRemove = (<span class="built_in">Set</span>&lt;FastThreadLocal&lt;?&gt;&gt;) v; <span class="comment">// 如果不是 UNSET，Set 集合已存在，直接强转获得 Set 集合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    variablesToRemove.add(variable); <span class="comment">// 将 FastThreadLocal 添加到 Set 集合中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>variablesToRemoveIndex 是采用 static final 修饰的变量，在 FastThreadLocal 初始化时 variablesToRemoveIndex 被赋值为 0。InternalThreadLocalMap 首先会找到数组下标为 0 的元素，如果该元素是缺省对象 UNSET 或者不存在，那么会创建一个 FastThreadLocal 类型的 Set 集合，然后把 Set 集合填充到数组下标 0 的位置。如果数组第一个元素不是缺省对象 UNSET，说明 Set 集合已经被填充，直接强转获得 Set 集合即可。这就解释了 InternalThreadLocalMap 的 value 数据为什么是从下标为 1 的位置开始存储了，因为 0 的位置已经被 Set 集合占用了。</p><p>为什么 InternalThreadLocalMap 要在数组下标为 0 的位置存放一个 FastThreadLocal 类型的 Set 集合呢？这时候我们回过头看下 remove() 方法。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">getIfSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((FastThreadLocalThread) thread).threadLocalMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slowThreadLocalMap.get();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object v = threadLocalMap.removeIndexedVariable(index); <span class="comment">// 删除数组下标 index 位置对应的 value</span></span><br><span class="line">    removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>); <span class="comment">// 从数组下标 0 的位置取出 Set 集合，并删除当前 FastThreadLocal</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onRemoval((V) v); <span class="comment">// 空方法，用户可以继承实现</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 remove 操作之前，会调用 InternalThreadLocalMap.getIfSet() 获取当前 InternalThreadLocalMap。有了之前的基础，理解 getIfSet() 方法就非常简单了，如果是 FastThreadLocalThread 类型，直接取 FastThreadLocalThread 中 threadLocalMap 属性。如果是普通线程 Thread，从 ThreadLocal 类型的 slowThreadLocalMap 中获取。 </p><p>找到 InternalThreadLocalMap 之后，InternalThreadLocalMap 会从数组中定位到下标 index 位置的元素，并将 index 位置的元素覆盖为缺省对象 UNSET。接下来就需要清理当前的 FastThreadLocal 对象，此时 Set 集合就派上了用场，InternalThreadLocalMap 会取出数组下标 0 位置的 Set 集合，然后删除当前 FastThreadLocal。</p><p>最后 onRemoval() 方法起到什么作用呢？Netty 只是留了一处扩展，并没有实现，用户需要在删除的时候做一些后置操作，可以继承 FastThreadLocal 实现该方法。</p><h2 id="FastThreadLocal-get"><a href="#FastThreadLocal-get" class="headerlink" title="FastThreadLocal.get()"></a>FastThreadLocal.get()</h2><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line"></span><br><span class="line">    Object v = threadLocalMap.indexedVariable(index); <span class="comment">// 从数组中取出 index 位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (V) v;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> initialize(threadLocalMap); <span class="comment">// 如果获取到的数组元素是缺省对象，执行初始化操作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">indexedVariable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index &lt; lookup.length? lookup[index] : UNSET;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    V v = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        v = initialValue();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line"></span><br><span class="line">    addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据当前线程是否是 FastThreadLocalThread 类型找到 InternalThreadLocalMap，然后取出从数组下标 index 的元素，如果 index 位置的元素不是缺省对象 UNSET，说明该位置已经填充过数据，直接取出返回即可。如果 index 位置的元素是缺省对象 UNSET，那么需要执行初始化操作。可以看到，initialize() 方法会调用用户重写的 initialValue 方法构造需要存储的对象数据，如下所示。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final FastThreadLocal&lt;<span class="built_in">String</span>&gt; threadLocal = <span class="keyword">new</span> FastThreadLocal&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">String</span> <span class="function"><span class="title">initialValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造完用户对象数据之后，接下来就会将它填充到数组 index 的位置，然后再把当前 FastThreadLocal 对象保存到待清理的 Set 中。添加的过程和之前一致，不再赘述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此为止，FastThreadLocal 最核心的两个方法 set()/get() 已经分析完了。下面有两个问题我们再深入思考下。</p><ol><li>FastThreadLocal 真的一定比 ThreadLocal 快吗？答案是不一定的，只有使用FastThreadLocalThread 类型的线程才会更快，如果是普通线程反而会更慢。</li><li>FastThreadLocal 会浪费很大的空间吗？虽然 FastThreadLocal 采用的空间换时间的思路，但是在 FastThreadLocal 设计之初就认为不会存在特别多的 FastThreadLocal 对象，而且在数据中没有使用的元素只是存放了同一个缺省对象的引用，并不会占用太多内存空间。</li></ol><p>相对于 ThreadLocal，简单总结下 FastThreadLocal 的优势。</p><ul><li><strong>高效查找</strong>。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</li><li><strong>安全性更高</strong>。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 remove() 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 FastThreadLocalRunnable，FastThreadLocalRunnable 最后会执行 FastThreadLocal.removeAll() 将 Set 集合中所有 FastThreadLocal 对象都清理掉，</li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> FastThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的对象池技术：Recycler</title>
      <link href="2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/"/>
      <url>2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/</url>
      
        <content type="html"><![CDATA[<h1 id="Recycler-示例代码"><a href="#Recycler-示例代码" class="headerlink" title="Recycler 示例代码"></a>Recycler 示例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;User&gt; userRecycler = <span class="keyword">new</span> Recycler&lt;User&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> User <span class="title">newObject</span><span class="params">(Handle&lt;User&gt; handle)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在对象实例中存储handle以便使用实例进行回收操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Recycler.Handle&lt;User&gt; handle;</span><br><span class="line">        </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Recycler.Handle&lt;User&gt; handle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.handle = handle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User user1 = userRecycler.get(); <span class="comment">// 1、从对象池获取 User 对象</span></span><br><span class="line"></span><br><span class="line">        user1.setName(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 2、设置 User 对象的属性</span></span><br><span class="line"></span><br><span class="line">        user1.recycle(); <span class="comment">// 3、回收对象到对象池</span></span><br><span class="line"></span><br><span class="line">        User user2 = userRecycler.get(); <span class="comment">// 4、从对象池获取对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(user2.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台的输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码示例中定义了对象池实例 userRecycler，其中实现了 <code>newObject()</code> 方法，如果对象池没有可用的对象，会调用该方法新建对象。此外需要创建 Recycler.Handle 对象与 User 对象进行绑定，这样我们就可以通过<code>userRecycler.get()</code> 从对象池中获取 User 对象，如果对象不再使用，通过调用 User 类实现的<code>recycle()</code>方法即可完成回收对象到对象池。</p><h1 id="Recycler-设计思想"><a href="#Recycler-设计思想" class="headerlink" title="Recycler 设计思想"></a>Recycler 设计思想</h1><p>对象池与内存池的都是为了提高 Netty 的并发处理能力，我们知道 Java 中频繁地创建和销毁对象的开销是很大的，所以很多人会将一些通用对象缓存起来，当需要某个对象时，优先从对象池中获取对象实例。通过重用对象，不仅避免频繁地创建和销毁所带来的性能损耗，而且对 JVM GC 是友好的，这就是对象池的作用。</p><p>在Recycler中一共有四个核心组件：<strong>Stack</strong>、<strong>WeakOrderQueue</strong>、<strong>Link</strong>、<strong>DefaultHandle</strong>，接下来我们逐一进行介绍。</p><h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206132124361.png" alt="image-20220613212414282" style="zoom:80%;" /><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack 是整个对象池的顶层数据结构，描述了整个对象池的构造，用于存储当前本线程回收的对象。在多线程的场景下，Netty 为了避免锁竞争问题，每个线程都会持有各自的对象池，内部通过 FastThreadLocal 来实现每个线程的私有化(关于 FastThreadLocal 的内容可参考<a href="https://icbtbo.github.io/2022/06/15/Netty%E7%9A%84FastThreadLocal/">Netty的FastThreadLocal</a>)。</p><p>先看下 Stack 的数据结构，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Recycler&lt;T&gt; parent; <span class="comment">// 所属的 Recycler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;Thread&gt; threadRef; <span class="comment">// 所属线程的弱引用</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger availableSharedCapacity; <span class="comment">// 异线程回收对象时，其他线程能保存的被回收对象的最大个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxDelayedQueues; <span class="comment">// WeakOrderQueue最大个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity; <span class="comment">// 对象池的最大大小，默认最大为 4k</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ratioMask; <span class="comment">// 控制对象的回收比率，默认只回收 1/8 的对象 (默认值为7)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DefaultHandle&lt;?&gt;[] elements; <span class="comment">// 存储缓存数据的数组（Default中存着缓存的对象）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 缓存的 DefaultHandle 对象个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> handleRecycleCount = -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// WeakOrderQueue 链表的三个重要节点</span></span><br><span class="line">    <span class="keyword">private</span> WeakOrderQueue cursor, prev;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WeakOrderQueue head;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应上面 Recycler 的内部结构图，Stack 包括用于存储缓存数据的 DefaultHandle 数组，以及维护了 WeakOrderQueue 链表中的三个重要节点。</p><p>除此之外，Stack 其他的重要属性在源码中已经全部以注释的形式标出，大部分已经都非常清楚，其中 availableSharedCapacity 是比较难理解的，每个 Stack 会维护一个 WeakOrderQueue 的链表，每个 WeakOrderQueue 节点会保存非当前线程的其他线程所回收的对象，例如图中 ThreadA 表示当前线程，WeakOrderQueue 的链表存储着 ThreadB、ThreadC 等其他线程回收的对象。availableSharedCapacity 的初始化方式为 new AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY))，默认大小为 16K，其他线程在回收对象时，最多可以回收 ThreadA 创建的对象个数不能超过 availableSharedCapacity。</p><p>还有一个疑问就是既然 Stack 是每个线程私有的，为什么 availableSharedCapacity 还需要用 AtomicInteger 呢？因为 ThreadB、ThreadC 等多个线程可能都会创建 ThreadA 的 WeakOrderQueue，存在同时操作 availableSharedCapacity 的情况。</p><h2 id="WeakOrderQueue"><a href="#WeakOrderQueue" class="headerlink" title="WeakOrderQueue"></a>WeakOrderQueue</h2><p>WeakOrderQueue 用于存储其他线程回收到的当前线程所分配的对象，并且在合适的时机，Stack 会从这些 WeakOrderQueue 中收割对象。例如，当ThreadB 回收到 ThreadA 所分配的对象时，就会将该对象放到 ThreadA 的 WeakOrderQueue 当中。</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>每个 WeakOrderQueue 中都包含一个 Link 链表，回收的对象都会被存在 Link 链表中的节点上，每个 Link 节点默认存储 16 个对象，当一个 Link 节点存储满了会创建新的 Link 节点放入链表尾部。</p><h2 id="DefaultHandle"><a href="#DefaultHandle" class="headerlink" title="DefaultHandle"></a>DefaultHandle</h2><p>DefaultHandle 实例中保存了实际回收的对象，Stack 和 WeakOrderQueue 都使用 DefaultHandle 存储回收的对象。在 Stack 中包含一个 elements 数组，该数组保存的是 DefaultHandle 实例。WeakOrderQueue 中每个 Link 节点所存储的 16 个对象也是使用 DefaultHandle 表示的。</p><h1 id="Recycler-获取对象原理"><a href="#Recycler-获取对象原理" class="headerlink" title="Recycler 获取对象原理"></a>Recycler 获取对象原理</h1><p>从代码示例中可以看出，从对象池中获取对象的入口是在 Recycler#get() 方法，直接定位到源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get(); <span class="comment">// 获取当前线程缓存的 Stack</span></span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop(); <span class="comment">// 从 Stack 中弹出一个 DefaultHandle 对象</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle); <span class="comment">// 创建的对象并保存到 DefaultHandle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Recycler#get() 方法的逻辑非常清晰，首先通过 FastThreadLocal 获取当前线程的唯一栈缓存 Stack，然后尝试从栈顶弹出 DefaultHandle 对象实例，若栈中存在实例则直接返回，否则会调用 newObject 生成一个新的对象，完成 handle 与用户对象和 Stack 的绑定。</p><p>那么 Stack 是如何从 elements 数组中弹出 DefaultHandle 对象实例的呢？只是从 elements 数组中取出一个实例吗？我们一起跟进下 stack.pop() 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 elements 数组为空，就尝试从其他线程回收的对象中转移一些到 elements 数组当中</span></span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size]; <span class="comment">// 将实例从栈顶弹出</span></span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled multiple times&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Stack 的 elements 数组中有可用的对象实例，直接将对象实例弹出；如果 elements 数组中没有可用的对象实例，会调用 scavenge 方法，scavenge 的作用是从其他线程回收的对象实例中转移一些到 elements 数组当中，也就是说，它会想办法从 WeakOrderQueue 链表中迁移部分对象实例。</p><p>每个 Stack 会有一个 WeakOrderQueue 链表，每个 WeakOrderQueue 节点都存储着相应异线程回收的对象，那么以什么样的策略从 WeakOrderQueue 链表中迁移对象实例呢？继续跟进 scavenge 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从 WeakOrderQueue 中转移对象实例到 Stack 中</span></span><br><span class="line">    <span class="keyword">if</span> (scavengeSome()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果迁移失败，就会重置 cursor 指针到 head 节点</span></span><br><span class="line">    prev = <span class="keyword">null</span>;</span><br><span class="line">    cursor = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = <span class="keyword">this</span>.cursor; <span class="comment">// cursor 指针指向当前 WeakorderQueueu 链表的读取位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 cursor 指针为 null, 则是第一次从 WeakorderQueueu 链表中获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = <span class="keyword">this</span>.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 不断循环从 WeakOrderQueue 链表中找到一个可用的对象实例</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试迁移 WeakOrderQueue 中部分对象实例到 Stack 中,若成功直接退出循环并返回</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已退出的线程还有数据，则将这些数据全都转移到 stack 的 elements 数组中</span></span><br><span class="line">            <span class="keyword">if</span> (cursor.hasFinalData()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将已退出的线程从 WeakOrderQueue 链表中移除</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 cursor 指针指向下一个 WeakOrderQueue</span></span><br><span class="line">        cursor = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scavenge 的源码中首先会从 cursor 指针指向的 WeakOrderQueue 节点回收部分对象到 Stack 的 elements 数组中，如果没有回收到数据就会将 cursor 指针移到下一个 WeakOrderQueue，重复执行以上过程直至回到到对象实例为止。具体的流程可以结合下图来理解。</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202206132200685.png" alt="image-20220613220058574" style="zoom:80%;" /><p>此外，每次移动 cursor 时，都会检查 WeakOrderQueue 对应的线程是否已经退出了，如果线程已经退出，那么线程中的对象实例都会被回收，然后将 WeakOrderQueue 节点从链表中移除。</p><p>那每次 Stack 从 WeakOrderQueue 链表会回收多少数据呢？我们依然结合上图讲解，每个 WeakOrderQueue 中都包含一个 Link 链表，Netty 每次会回收其中的一个 Link 节点所存储的对象（不一定有16个）。从图中可以看出，Link 内部会包含一个读指针 readIndex，每个 Link 节点默认存储 16 个对象，读指针到链表尾部就是可以用于回收的对象实例，每次回收对象时，readIndex 都会从上一次记录的位置开始回收。</p><p>在回收对象实例之前，Netty 会计算出可回收对象的数量（transfer 方法中），加上 Stack 中已有的对象数量后，如果超过 Stack 的当前容量且小于 Stack 的最大容量，会对 Stack 进行扩容。为了防止回收对象太多导致 Stack 的容量激增，在每次回收时 Netty 会调用 dropHandle 方法控制回收频率，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dropHandle</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!handle.hasBeenRecycled) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((++handleRecycleCount &amp; ratioMask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Drop the object.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handle.hasBeenRecycled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dropHandle 方法中主要靠 hasBeenRecycled 和 handleRecycleCount 两个变量控制回收的频率，会从每 8 个未被收回的对象中选取一个进行回收，其他的都被丢弃掉。</p><p>到此为止，从 Recycler 中获取对象的主流程已经讲完了，简单总结为两点：</p><ul><li>当 Stack 中 elements 有数据时，直接从栈顶弹出。</li><li>当 Stack 中 elements 没有数据时，尝试从 WeakOrderQueue 中回收一个 Link 包含的对象实例到 Stack 中，然后从栈顶弹出。</li></ul><h1 id="Recycler-回收对象原理"><a href="#Recycler-回收对象原理" class="headerlink" title="Recycler 回收对象原理"></a>Recycler 回收对象原理</h1><p> 同样从上文代码示例中定位到对象回收的源码入口为 DefaultHandle#recycle()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;object does not belong to handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;?&gt; stack = <span class="keyword">this</span>.stack;</span><br><span class="line">    <span class="keyword">if</span> (lastRecycledId != recycleId || stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack#push</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class="line">      <span class="comment">// 同线程时</span></span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异线程时</span></span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在回收对象时，会向 Stack 中 push 对象，push 会分为同线程回收和异线程回收两种情况，分别对应 pushNow 和 pushLater 两个方法，我们逐一进行分析。</p><h2 id="同线程对象回收"><a href="#同线程对象回收" class="headerlink" title="同线程对象回收"></a>同线程对象回收</h2><p>如果是当前线程回收自己分配的对象时，会调用 Stack#pushNow 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) &#123; <span class="comment">// 防止被多次回收</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;recycled already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 超出最大容量 2. 控制回收速率</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同线程回收对象的逻辑非常简单，就是直接向 Stack 的 elements 数组中添加数据，对象会被存放在栈顶指针指向的位置。如果超过了 Stack 的最大容量，那么对象会被直接丢弃，同样这里使用了 dropHandle 方法控制对象的回收速率，每 8 个对象会有一个被回收到 Stack 中。</p><h2 id="异线程对象回收"><a href="#异线程对象回收" class="headerlink" title="异线程对象回收"></a>异线程对象回收</h2><p>异线程回收对象时，会调用 pushLater 方法。我们合理得猜测，异线程并不会将对象添加到 Stack 中，而是会与 WeakOrderQueue 直接打交道，下面是 Stack#pushLater 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get(); <span class="comment">// 当前线程帮助其他线程回收的对象对应的 WeakOrderQueue</span></span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>); <span class="comment">// 取出对象绑定的 Stack 对应的 WeakOrderQueue</span></span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 最多帮助 2*CPU 核数的线程回收线程</span></span><br><span class="line">        <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY); <span class="comment">// WeakOrderQueue.DUMMY 表示当前线程无法再帮助该 Stack 回收对象</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建 WeakOrderQueue</span></span><br><span class="line">        <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">        <span class="comment">// drop object</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(item); <span class="comment">// 添加对象到 WeakOrderQueue 的 Link 链表中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pushLater 的实现过程可以总结为两个步骤：<strong>获取 WeakOrderQueue</strong>，<strong>添加对象到 WeakOrderQueue 中</strong>。</p><ul><li>首先看下如何获取 WeakOrderQueue 对象。通过 FastThreadLocal 取出当前对象的 DELAYED_RECYCLED 缓存，DELAYED_RECYCLED 存放着当前线程帮助其他线程回收的对象对应的 Stack 以及 WeakOrderQueue 之间的映射关系。例如，假如 item 是 ThreadA 分配的对象，当前线程是 ThreadB，此时 ThreadB 帮助 ThreadA 回收 item，那么 DELAYED_RECYCLED 放入的 key 是 StackA。</li><li>然后从 delayedRecycled 中取出 StackA 对应的 WeakOrderQueue，如果 WeakOrderQueue 不存在，那么为 StackA 新创建一个 WeakOrderQueue，并将其加入 DELAYED_RECYCLED 缓存。WeakOrderQueue.allocate() 会检查帮助 StackA 回收的对象总数是否超过 2K 个，如果没有超过 2K，会将 StackA 的 head 指针指向新创建的 WeakOrderQueue，否则不再为 StackA 回收对象。</li></ul><p>当然 ThreadB 不会只帮助 ThreadA 回收对象，它可以帮助其他多个线程回收，所以 DELAYED_RECYCLED 使用的 Map 结构，为了防止 DELAYED_RECYCLED 内存膨胀，Netty 也采取了保护措施，从 delayedRecycled.size() &gt;= maxDelayedQueues 可以看出，每个线程最多帮助 2 倍 CPU 核数的线程回收线程，如果超过了该阈值，假设当前对象绑定的为 StackX，那么将在 Map 中为 StackX 放入一种特殊的 WeakOrderQueue.DUMMY，表示当前线程无法帮助 StackX 回收对象。</p><p>接下来我们继续分析对象是如何被添加到 WeakOrderQueue 的，直接跟进 queue.add(item) 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    handle.lastRecycledId = id;</span><br><span class="line">    Link tail = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">int</span> writeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表尾部的 Link 已经写满，那么再新建一个 Link 追加到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 检查是否超过对应 Stack 可以存放的其他线程帮助回收的最大对象数</span></span><br><span class="line">        <span class="keyword">if</span> (!head.reserveSpace(LINK_CAPACITY)) &#123;</span><br><span class="line">            <span class="comment">// Drop it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.tail = tail = tail.next = <span class="keyword">new</span> Link();</span><br><span class="line">        writeIndex = tail.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail.elements[writeIndex] = handle; <span class="comment">// 添加对象到 Link 尾部</span></span><br><span class="line">    handle.stack = <span class="keyword">null</span>; <span class="comment">// handle 的 stack 属性赋值为 null</span></span><br><span class="line">    tail.lazySet(writeIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在向 WeakOrderQueue 写入对象之前，会先判断 Link 链表的 tail 节点是否还有空间存放对象。如果还有空间，直接向 tail Link 尾部写入数据，否则直接丢弃对象。如果 tail Link 已经没有空间，会新建一个 Link 之后再存放对象，但在新建 Link 之前会检查异线程帮助回收的对象总数是否超过了 Stack 设置的阈值，如果超过了阈值，那么对象也会被丢弃掉。</p><p>对象被添加到 Link 之后，handle 的 stack 属性被赋值为 null，而在取出对象的时候，handle 的 stack 属性又再次被赋值回来，为什么这么做呢，岂不是很麻烦？如果不这么做的话，若是 Stack 不再使用，期望被 GC 回收，但JVM发现 handle 中还持有 Stack 的引用，那么Stack就无法被 GC 回收，从而造成内存泄漏。</p><p>到此为止，Recycler 如何回收对象的实现原理就全部分析完了，在多线程的场景下，Netty 考虑的还是非常细致的，Recycler 回收对象时向 WeakOrderQueue 中存放对象，而从 Recycler中 获取对象时，WeakOrderQueue 中的对象会作为 Stack 的储备，而且有效地解决了跨线程回收的问题，是一个挺新颖别致的设计。</p><h1 id="Recycler-在-Netty-中的应用"><a href="#Recycler-在-Netty-中的应用" class="headerlink" title="Recycler 在 Netty 中的应用"></a>Recycler 在 Netty 中的应用</h1><p>其中比较常用的有 PooledHeapByteBuf 和 PooledDirectByteBuf，分别对应的堆内存和堆外内存的池化实现。例如我们在使用 PooledDirectByteBuf 的时候，并不是每次都去创建新的对象实例，而是从对象池中获取预先分配好的对象实例，不再使用 PooledDirectByteBuf 时，被回收归还到对象池中。</p><p>此外，内存池的 MemoryRegionCache 也有使用到对象池，MemoryRegionCache 中保存着一个队列，队列中每个 Entry 节点用于保存内存块，Entry 节点在 Netty 中就是以对象池的形式进行分配和释放。</p>]]></content>
      
      
      <categories>
          
          <category> Netty学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> 对象池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现:独立功能的实现</title>
      <link href="2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis通过<code>MULTI</code>，<code>EXEC</code>，<code>WATCH</code>等命令实现事务功能。</p><p>事务是将<strong>多个命令打包</strong>，然后<strong>原子地按顺序地执行</strong>的机制，执行期间服务器<strong>不会中断事务</strong>执行其他客户端的命令请求。下面展示了一次完整事务的执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET <span class="string">&quot;name&quot;</span> <span class="string">&quot;The Design and Implementation of Redis&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET <span class="string">&quot;name&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;The Design and Implementation of Redis&quot;</span></span><br></pre></td></tr></table></figure><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>可以看出，事务主要有3个阶段：事务开始、命令入队、事务执行。</p><p><strong>事务开始</strong></p><p>MULTI命令表示事务的开始，将客户端从非事务状态切换为事务状态，在flags属性中<strong>打开<code>REDIS_MULTI</code>标识</strong>。</p><p><strong>命令入队</strong></p><p>当客户端处于事务状态时，命令不会被立即执行（除了EXEC、DISCARD、WATCH、MULTI），而是加入事务队列。</p><p><strong>事务队列</strong></p><p>客户端的事务状态保存在mstate里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisCLient</span>&#123;</span></span><br><span class="line">    <span class="comment">//事务状态</span></span><br><span class="line">    multiState mstate;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>事务状态包括<strong>事务队列</strong>和<strong>入队命令计数器</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    <span class="comment">//数组，事务队列</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="comment">//入队命令计数器</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>事务队列的实例结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>先入队的命令先放入数组，后入队的后放入。</p><p><strong>执行事务</strong></p><p>当收到客户端的EXEC命令时，将立即执行，然后服务器遍历客户端的事务队列，保存命令，执行命令，返回结果给客户端，最后移除事务标识。</p><h3 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h3><p>WATCH命令是一个<strong>乐观锁</strong>，可以在EXEC前<strong>监视任意数量的键</strong>，如果在EXEC执行时，发现这些被监视的键被修改过，服务器将拒绝执行事务。</p><p><strong>使用WATCH命令监视数据库键</strong></p><p>每个Redis数据库都保存着watched_keys字典，键是某个被WATCHED命令<strong>监视的键</strong>，值是一个链表，记录所有<strong>监视该键的客户端</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//正在被WATCHED命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb；</span><br></pre></td></tr></table></figure><p><strong>监控机制的触发&amp;事务安全</strong></p><p>在执行数据库修改命令时，都会调用<code>multi.c/touchWatchKey</code>函数对watched_keys字典进行检查，查看是否有客户端正在监视的刚被命令修改过的键，如果有，将watched_keys该键对应的值，也就是监听的客户端都打开<code>REDIS_DIRTY_CAS</code>标识，表示事务的<strong>安全性已经被破坏</strong>。此时，服务器拒绝执行该客户端的事务。</p><h3 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h3><p>Redis的事务有原子性、一致性和隔离性，当Redis运行在特定的持久化模式下时，才具有持久性。</p><p><strong>原子性</strong></p><p>Redis事务队列中的命令，要么全部都执行，要么一个都不执行，因此，具有原子性。Redis进行事务命令入队时，如果命令入队出错，会被拒绝执行。但是命令的语法错误（执行错误），不会导致整个命令不被执行，也就是说Redis不支持事务的回滚机制。</p><p>下面例子表示发生<strong>入队错误</strong>（一致性时将提到入队错误和执行错误）时，事务中的所有命令都不会被执行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET msg &quot;he1lo&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;get&#x27; command</span><br><span class="line">redis&gt; GET msg</span><br><span class="line">QUEUED </span><br><span class="line">redis&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>发生执行错误，不影响其他命令的执行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot; # msg键是一个字符串</span><br><span class="line">OK</span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SADD fruit &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; RPUSH msg &quot;good bye&quot; &quot;bye bye&quot; #错误地对字符串键msg执行列表键的命令</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; SADD alphabet &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC </span><br><span class="line">1) (integer) 3</span><br><span class="line">2)(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3)(integer) 3</span><br></pre></td></tr></table></figure><p>不支持事务回滚是考虑到了复杂性，与其<strong>简单高效的理念不符</strong>，并且Redis的设计者认为，Redis事务的执行时错误通常都是<strong>编程错误</strong>产生的，在开发环境中会有，但生产环境不应该出现，因此，没有设计回滚机制。</p><p><strong>一致性</strong></p><p>一致性表示在事务的执行前后，成功与否，数据库<strong>都是一致的</strong>，也就是数据符合数据库本身定义和要求，<strong>没有非法或无效错误数据</strong>。</p><p>Redis通过简单的错误检测来保证一致性。</p><ol><li>入队错误</li></ol><p>在2.6.5之后的版本，如果一个事务在入队时出现了命令不存在，Redis则拒绝执行这个事务。</p><ol start="2"><li>执行错误</li></ol><p>对于命令执行期间发现的错误，<strong>不会影响其他命令</strong>的执行。服务器会识别出错的命令，并进行相应处理，这些命令不会对数据库做修改，不影响一致性。</p><ol start="3"><li>服务器停机</li></ol><p>如果Redis在执行事务过程中停机，数据也是一致的。如果没有开启持久化，重启后数据库是空白的。开启持久化后，重启后会还原到一致状态。</p><p><strong>隔离性</strong></p><p>事务的隔离性是指，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响。</p><p>Redis是单线程的，并且服务器保证在执行事务期间<strong>不会对事务进行中断</strong>，因此Redis的事务总是以串行的方式运行，是具有隔离性的。</p><p><strong>持久性</strong></p><p>持久性的意思是，事务执行的结果被<strong>永久性地保存</strong>，执行事务的结果不会丢失。</p><p>因为Redis没有单独为事务队列提供持久化功能，所以<strong>取决于持久化模式</strong>，只有AOF方式持久化并且appendsync的值为always，而且没有打开<code>no-appendfsync-on-rewrite</code>时，才具有持久性。因为其他方式并不能保证事务的执行结果被第一时间保存到硬盘里。</p><blockquote><p>注：<code>no-appendfsync-on-rewrite</code>打开后，在执行<code>BGSAVE</code>和<code>BGREWRITEAOF</code>时会暂停对AOF文件的同步。</p></blockquote><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求。可通过两个参数配置：</p><ul><li><code>slowlog-log-slower-than</code>：执行时间超过多少微秒的命令会被记录到日志上。</li><li><code>slowlog-max-len</code>：指定服务器最多保存多少条慢查询日志，超过时会删除最久的那条日志。</li></ul><p>可以使用<code>CONSIG SET slowlog-log-slower-than &lt;microsecond&gt;</code>直接<strong>修改配置</strong>，使用<code>SLOWLOG GET</code>来<strong>查询慢查询日志</strong>。</p><p><strong>慢查询记录的保存</strong></p><p>相关慢查询日志的属性记录在redisServer中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID，初始为0，每产生一条就加1</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span> *slow1og;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="number">1</span>ong slowlog_1og_slower_than;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-max-len选项的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slowlog是一个链表，有几个节点就表示有几条慢查询日志，节点是一个slowlogEntry实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slow1ogEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="number">1</span>ong id;</span><br><span class="line">    <span class="comment">//命令执行时的时间，格式为UNIX时间戥</span></span><br><span class="line">    <span class="keyword">time_t</span> time;</span><br><span class="line">    <span class="comment">//执行命令消耗的时间，以微秒为单位</span></span><br><span class="line">    <span class="number">1</span>ong <span class="keyword">long</span> duration;</span><br><span class="line">    <span class="comment">//命令与命令参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">&#125; slowlogEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新添加的日志会被放到slowlog链表的表头。</p><h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><p>执行MONITOR命令，客户端就成为了监视器，<strong>实时接收并打印服务器处理的命令</strong>。当其他客户端发送请求时，服务器除了执行，还会将相关信息发送给所有监视器。</p><p><strong>成为监视器</strong></p><p>redisServer中有monitors链表，记录所有成为监视器的客户端。如果某个客户端发送MONITOR命令，就会打开它的<code>REDIS_MONITOR</code>标志，并将其插入到该链表的<strong>尾部</strong>。</p><p><strong>向监视器发送命令信息</strong></p><p>服务器处理命令前都会调用<code>replicationFeedMonitors</code>函数，将相关信息发送给各个监视器。主要是封装要发送给监视器的信息、遍历监视器、发送信息这三步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的重点是Redis的事务，其他的作以了解。</p>]]></content>
      
      
      <categories>
          
          <category> 《Redis设计与实现》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现:多机数据库的实现</title>
      <link href="2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在Redis中，可通过SLAVEOF命令或配置文件中设置slaveof选项，让一个服务器去复制另一个服务器，被复制的为主服务器，对其复制的称为从服务器。</p><h3 id="旧版本复制功能的实现"><a href="#旧版本复制功能的实现" class="headerlink" title="旧版本复制功能的实现"></a>旧版本复制功能的实现</h3><p>Redis在2.8以前使用旧版本复制，在从服务器断线重连时会遇上低效的情况。</p><p>Redis的复制功能分为<strong>同步</strong>和<strong>命令传播</strong>俩操作：</p><ul><li>同步用于把从服务器的数据库状态<strong>更新至主服务器的数据库状态</strong>。</li><li>命令传播是在主服务器的<strong>数据库状态被修改</strong>导致主从数据库状态不一致时，让主从回到一致的过程。</li></ul><p><strong>同步</strong></p><p>从服务器对主服务器的同步（下文以主从代替），需要向主服务器发送SYNC命令，具体步骤：</p><ol><li>从向主发送SYNC命令。</li><li>主接收并<strong>执行BGSAVE</strong>，后台生成RDB文件，并用一个<strong>缓冲区记录</strong>现在开始执行的所有写命令。</li><li>BGSAVE执行完毕时，主将RDB文件发给从，从接收并载入，更新数据库状态。</li><li>主将其记录在<strong>缓冲区的所有写命令</strong>发给从，从执行写命令。</li></ol><p>下图展示了同步的过程：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941116.jpg" alt="img"></p><p><strong>命令传播</strong></p><p>当主发生写操作时，主从同步需要通过命令传播，具体步骤：</p><ol><li>主将写命令发送给从。</li><li>从接收并执行相同的写命令。</li></ol><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>旧版复制的缺陷主要体现在断线重连上：</p><p>主因为网络原因中断复制，但从通过自动重连连上主，并继续复制主。此时，从发送SYNC命令，希望将<strong>断线期间</strong>由于对主的写操作造成的主从数据库不一致状态同步回一致状态，但SYNC每次都会<strong>重新生成RDB文件</strong>，将<strong>所有的</strong>数据库状态都写到RDB，这就造成了资源的<strong>大量浪费</strong>。</p><p>SYNC命令对性能的损耗比较高主要表现在：</p><ol><li>主执行BGSAVE生成RDB文件会消耗<strong>CPU、内存和磁盘I/O资源</strong>。</li><li>主需要发送RDB，消耗<strong>网络资源</strong>。</li><li>从接收并载入RDB，载入期间是<strong>阻塞的无法处理命令</strong>。</li></ol><p>因此，必须是真正有必要时才调用SYNC命令。</p><h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><p>Redis从2.8开始使用PSYNC代替SYNC命令来执行同步操作。</p><p>PSYNC有完整重同步和部分重同步的两种模式：</p><ul><li><p>完整重同步用于初次复制的情况，与SYNC命令一样。</p></li><li><p>部分重同步用于处理断线重连后的情况，重连后，主服务器将<strong>断线期间执行的写命令</strong>发送给从服务器，从只需接收并执行这些命令。</p><p>部分重同步的执行过程：</p><ul><li>从向主发送PSYNC命令，请求同步数据。</li><li>主判断后，确认需要执行部分重同步时，返回给从**+COUNTINUE**。</li><li>主将断线期间的写命令发送给从。</li></ul><p>下图展示了部分重同步的过程：</p></li></ul><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941165.jpg" alt="img"></p><h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h3><p>部分重同步基于三个部分实现：</p><ul><li>主从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区</li><li>服务器运行ID</li></ul><p><strong>复制偏移量</strong></p><p>主从都会维护一个复制偏移量，记录<strong>存储数据的字节数</strong>，当主服务器向从服务器传播N个字节数据时，主的复制偏移量会加N，从接收到之后也会加N。通过偏移量<strong>判断数据库状态是否一致</strong>。但有一个问题，就是从服务器重连后，需要执行部分还是完整重同步，这时候就需要复制积压缓冲区来帮忙判断。</p><p><strong>复制积压缓冲区</strong></p><p>复制积压缓冲区由主服务器维护，是固定长度的<strong>先进先出队列</strong>，默认1M。当入队元素大于队列长度时，最先入队的元素会被弹出。主服务器在命令传播时，不仅将写命令发给从，还会将<strong>写命令入队至积压缓冲区</strong>。</p><p>下图展示了传播的命令发给从并写入缓冲区的过程：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941262.jpg" alt="img"></p><p>复制积压缓冲区会保存最近写的命令，并为队列中的<strong>每个字节记录复制偏移量</strong>。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941357.jpg" alt="img"></p><p>当从服务器重连后，发送PSYNC并将自己的复制偏移量也发送给主服务器，主服务器拿着复制偏移量去复制积压缓冲区找，如果<strong>存在</strong>则进行部分重同步并给从服务器<strong>发送+CONTINUE</strong>回复，否则进行完整重同步。</p><p>复制积压缓冲区大小应该根据实际场景的两个因素进行调整：</p><ul><li>断线重连平均时间</li><li>主服务器平均每秒产生写命令的数据量</li></ul><p>一般得将这两个指标相乘后再乘以2，作为复制积压缓冲区的大小，应对大多数断线情况。</p><p><strong>服务器运行ID</strong></p><p>服务器运行ID决定断线后执行哪种同步方式，主从都有运行ID，是自动生成的40个随机十六进制字符。主从第一次复制时，从服务器会保存主服务器的ID，断线后也会向主服务器发送这个ID，如果<strong>不同则进行完整重同步</strong>（之前的主服务器由于某些原因连接断开，重新选举的情况）；相同则部分重同步。</p><h3 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h3><p>PSYNC命令调用方法有两种：</p><ul><li>从服务器第一次复制时，会发送<code>PSYNC ? -1</code>命令，请求完整重同步。</li><li>已经复制过的情况，向主服务器发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>命令，一个是主服务器运行ID，一个是积压缓冲区的偏移量。</li></ul><p>主服务器接收后有3种返回值：</p><ul><li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>：表示执行<strong>完整重同步</strong>，从服务器会将这两个变量保存。</li><li><code>+CONTINUE</code>：执行<strong>部分重同步</strong>，从服务器等待缺失数据的发送。</li><li><code>-ERR</code>：主服务器版本低于2.8，执行<strong>完整重同步</strong>操作。</li></ul><p>下图展示了PSYNC的执行流程： </p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201050941507.jpg" alt="img"></p><h3 id="一次完整的主从复制过程"><a href="#一次完整的主从复制过程" class="headerlink" title="一次完整的主从复制过程"></a>一次完整的主从复制过程</h3><p>一次完整的复制过程可以分为设置主服务器的地址和端口、建立套接字连接、发送PING命令、身份验证、发送端口信息、同步、命令传播。</p><ul><li><p><strong>设置主服务器的地址和端口</strong></p><p>当客户端向服务器发送SLAVEOF命令时，从服务器会将主服务器的ip和端口都保存后发送OK。这是一个<strong>异步命令</strong>，所以复制工作在回复OK后再执行。</p></li><li><p><strong>建立套接字连接</strong></p><p>从服务器此时创建连接主服务器的套接字，如果套接字能成功连接，从服务器会给它关联一个处理复制工作的<strong>文件事件处理器</strong>（负责接收RDB，传播的命令等）。主从成功连接后，主服务器会创建从服务器的客户端状态。</p></li><li><p><strong>发送PING命令</strong></p><p>从服务器在套接字连接后做的第一个工作就是发送PING命令，检查套接字<strong>读写状态是否正常</strong>；主服务器<strong>能否正常处理命令请求</strong>。而主服务器会根据网络状态、能够处理给出对应回复。一旦回复超时或返回错误，从服务器就会断开并重连主服务器。</p></li><li><p><strong>身份验证</strong></p><p>检查从服务器是否设置masterauth，如果设置则进行身份验证。</p></li><li><p><strong>发送端口信息</strong></p><p>身份验证后，从服务器向主服务器发送自己监听的端口号，主服务器保存这个端口号。</p></li><li><p><strong>同步</strong></p><p>从服务器发送PSYNC命令，主从互相成为对方的客户端，都能够执行命令并回复，执行同步操作，看是完整重同步还是部分重同步。</p></li><li><p><strong>命令传播</strong></p><p>完成同步后，进入该阶段，主服务器将写命令发送给从服务器，从服务器接收并执行。</p></li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>在命令传播阶段，从服务器默认<strong>1秒一次</strong>发送<code>REPLCONF ACK &lt;replication_offset&gt;</code>命令给主服务器，replication_offset是复制偏移量。这么做有3个作用：</p><ul><li>检测主从网络状态</li><li>辅助实现min-slave选项</li><li>检测命令丢失</li></ul><p><strong>检测主从网络状态</strong></p><p>下面分别说这三个作用。检测网络连接很好理解，如果主服务器超过一秒没收到从服务器的<code>REPLCONF ACK</code>则表示连接有问题。</p><p><strong>辅助实现min-slave选项</strong></p><p>Redis的<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>可<strong>防止主服务器在不安全的情况下执行写命令</strong>。如果设置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3 </span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示从服务器数量少于3或3个从服务器延迟大于等于10s时，主服务器拒绝写命令。</p><p><strong>检测命令丢失</strong></p><p>通过发送的偏移量，主服务器会判断命令是否有丢失，如果丢失，就从积压缓冲区里找到并<strong>补发</strong>。</p><blockquote><p>注：Redis2.8之前版本并<strong>不会注意</strong>到丢失数据，所以保持主从数据一致性最好使用以上版本。</p></blockquote><h2 id="Sentinel机制"><a href="#Sentinel机制" class="headerlink" title="Sentinel机制"></a>Sentinel机制</h2><p>Sentinel（哨兵）是Redis的<strong>高可用性</strong>的解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及属下的所有从服务器。当主服务器下线时，自动将下线的某个主服务器属下的某个从服务器<strong>升级</strong>为新的主服务器。从而实现<strong>故障转移</strong>，当原来的主服务器重新上线时，会被降级为从服务器。</p><p>下面展示了哨兵监视主从的状态：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051117188.jpg" alt="img"></p><p>下面主要讲解Sentinel系统对主服务器执行故障转移的整个过程。</p><h3 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h3><p>启动Sentinel有两种方式：</p><ul><li><code>redis-sentinel /path/to/your/sentinel.conf</code></li><li><code>redis-server /path/to/your/sentinel.conf --sentinel</code></li></ul><p>俩命令效果相同，启动时需要执行以下步骤：</p><ol><li>初始化服务器。</li><li>将普通Redis服务器使用的代码替换成Sentinel专用代码。</li><li>初始化Sentinel状态。</li><li>根据配置文件，初始化Sentinel的监视主服务器列表。</li><li>创建连向主服务器的网络连接。</li></ol><p>接下来对这些步骤进行详细说明。</p><p><strong>初始化服务器</strong></p><p>Sentinel实际上是一个特殊的Redis服务器，所以很多地方和Redis服务器的初始化有些类似。只不过少了RDB或AOF文件的载入等操作。</p><p><strong>使用Sentinel专用代码</strong></p><p>将加载的常量，命令表（决定了Sentinel可以执行哪些命令）等替换为Sentinel专用的。</p><p><strong>初始化Sentinel状态</strong></p><p>初始化一个<code>sentinel.c/sentinelState</code>结构，记录Sentinel的状态，保存了服务器中所有与Sentinel相关的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span>&#123;</span></span><br><span class="line">    <span class="comment">//当前纪元，选举计数器，用于实现故障转移</span></span><br><span class="line">    uint64_ t current_ epoch;</span><br><span class="line">    <span class="comment">//（重点）保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line">    <span class="comment">//字典的键是主服务器的名字，值是一个指向sentine1RedisInstance结构的指针</span></span><br><span class="line">    dict masters;</span><br><span class="line">    <span class="comment">//是否进入了TILT模式</span></span><br><span class="line">    <span class="keyword">int</span> tilt;</span><br><span class="line">    <span class="comment">//目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="keyword">int</span> running_ scripts;</span><br><span class="line">    <span class="comment">//进入TILT模式的时间</span></span><br><span class="line">    mstime_ <span class="keyword">_t</span> tilt_ start_ time;</span><br><span class="line">    <span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    mstime_ t previous_ time ;</span><br><span class="line">    <span class="comment">//一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_ <span class="built_in">queue</span>;</span><br><span class="line">&#125;sentinel;</span><br></pre></td></tr></table></figure><p><strong>初始化master属性</strong></p><p>masters字典的值是一个指向sentine1RedisInstance结构的指针，而一个sentine1RedisInstance实例包括主服务器、从服务器或另一个Sentinel。实例结构如下，了解一下，故障转移的可以先不关注：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="comment">//标识值，记录了实例的类型，以及该实例的当前状态.</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//实例的名字.</span></span><br><span class="line">    <span class="comment">//主服务器的名字由用户在配置文件中设置</span></span><br><span class="line">    <span class="comment">//从服务器以及Sentinel 的名字由Sentinel 自动设置</span></span><br><span class="line">    <span class="comment">//格式为ip:port</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">//实例的运行ID .</span></span><br><span class="line">    <span class="keyword">char</span> *runid;</span><br><span class="line">    <span class="comment">//配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> config_epoch;</span><br><span class="line">    <span class="comment">//实例的地址</span></span><br><span class="line">    sentinelAddr *addr;</span><br><span class="line">    <span class="comment">// SENTINEL down-after-milliseconds 选项设定的值</span></span><br><span class="line">    <span class="comment">//实例无响应多少毫秒之后才会被判断为主观下线</span></span><br><span class="line">    <span class="keyword">mstime_t</span> down_after_period;</span><br><span class="line">    <span class="comment">//判断这个实例为客观下线所需的支持投票数量</span></span><br><span class="line">    <span class="keyword">int</span> quorum;</span><br><span class="line">    <span class="comment">//在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="keyword">int</span> paral1el_syncs;</span><br><span class="line">    <span class="comment">//刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_timeout;</span><br><span class="line">  <span class="comment">// 当该实例为主服务器时，该属性记录其从服务器</span></span><br><span class="line">  dict slaves;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>创建连向主服务器的网络连接</strong></p><p>Sentinel会为监视的主服务器创建两个异步网络连接：</p><ul><li><strong>命令连接</strong>：专用于向主服务器发送命令，接收命令回复。</li><li><strong>订阅连接</strong>：专用于订阅主服务器<code>__sentinel__:hello</code>频道。（由于Redis的发布订阅消息不会保存，客户端断线就会丢失，为了不丢失，必须使用专门的频道连接）</li></ul><h3 id="获取主从服务器信息"><a href="#获取主从服务器信息" class="headerlink" title="获取主从服务器信息"></a>获取主从服务器信息</h3><p>Sentinel默认<strong>10秒一次</strong>通过命令连接向被监视的主服务器发送<strong>INFO</strong>命令，获取主服务器信息。</p><p>主要获取主服务器本身信息（如服务器运行ID），下属从服务器信息（如ip，port，offset）。对主服务器实例和从服务器实例的相应属性进行更新，如果没有某个从服务器的信息就会创建一个实例结构，放到主服务器实例的slaves字典中，键为ip+端口，值为sentinelRedisInstance。</p><p>除了创建新实例，还会创建连接到从服务器的<strong>命令连接</strong>和<strong>订阅连接</strong>。在创建命令连接后，Sentinel默认<strong>10秒一次</strong>通过命令连接向从服务器并发送<strong>INFO</strong>命令，获取从服务器信息（运行ID，角色，ip和端口，优先级等）。之后根据这些信息对从服务器的实例结构进行更新。</p><h3 id="向主服务器和从服务器发送消息"><a href="#向主服务器和从服务器发送消息" class="headerlink" title="向主服务器和从服务器发送消息"></a>向主服务器和从服务器发送消息</h3><p>sentinel默认以两秒一次，通过命令连接向服务器的<code>__sentinel__:hello</code>频道发送消息，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure><p>参数包含sentinel本身<code>（s_...）</code>和主服务器<code>（m_...）</code>的运行ID，ip，端口号，配置纪元等参数。</p><h3 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h3><p>Sentinel与一个主服务器或从服务器建立订阅连接后，会发送<code>SUBSCRIBE _sentinel_:hello</code>命令。</p><p>也就是Sentinel通过命令连接发送信息到频道，又通过订阅连接接收频道中的信息。一个Sentinel发的信息也会被其他Sentinel接收，根据信息记录的Sentinel运行id和接收信息的Sentinel<strong>运行id是否相同</strong>，来决定<strong>是否处理</strong>这条消息。通过这种透明的沟通机制，Sentinel可以对各自监听的服务器信息进行更新。</p><p><strong>更新sentinels字典</strong></p><p>根据接收而来的消息，Sentinel会更新实例结构中sentinels字典保存的所有Sentinel实例的信息。键为Sentinel的ip+端口，值为某个Sentinel的实例。消息接收者会检查发送消息的Sentinel（源sentinel）结构是否在sentinels字典，若存在则更新，没有则创建实例，和自己相同的sentinel不会被放入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span>&#123;</span></span><br><span class="line">    dict *sentinels;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种发布订阅的方式，Sentinel不需要各自发信息告诉对方，而是监视同一个主服务器的多个Sentinel自动发现对方。</p><p><strong>创建连向其他Sentinel的命令连接</strong></p><p>sentinel也会为对方互相创建命令连接，最终监视同一主服务器的多个sentinel会形成一个<strong>网络</strong>。但他们互相之间<strong>不会创建订阅连接</strong>，因为他们通过主或从服务器发来的频道来发现未知的sentinel。</p><p>下图展示了多个sentinel通过命令连接形成网络：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051117254.jpg" alt="img"></p><h3 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h3><p>Sentinel默认每秒与创建命令连接的实例（主服务器，从服务器，其他sentinel）发送PING命令，通过回复判断是否在线。如果实例返回除了<code>+PONG</code>，<code>-LOADING</code>，<code>-MASTERRDOWN</code>之外的回复或未及时回复，就认为是<strong>无效回复</strong>。</p><p>根据配置文件的<code>down-after-milliseconds</code>指定的<strong>主观下线所需时长内</strong>是否一直无效回复，来判断实例是否已经主观下线。下线了就将实例的的flags标识属性打开<code>SRI_S_DOWN</code>标识。由于每个Sentinel中的主观下线时间配置都可以不同，所有有可能<strong>某个Sentinel判断主观下线时，另一个Sentinel认为在线状态</strong>。</p><h3 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h3><p>当Sentinel判断主服务器为主观下线时，还会向其他Sentinel询问，得到足量数量的已下线判断后，就会判定服务器为客观下线，并执行故障转移。</p><p><strong>发送sentinel is-master-down-by-addr命令</strong></p><p>Sentinel使用：<code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current. epoch&gt; &lt;runid&gt;</code>命令询问其他Sentinel是否同意主服务器下线。这些参数分别是Sentinel的ip，端口，配置纪元和运行id。</p><p><strong>接收sentinel is-master-down-by-addr命令</strong></p><p>其他哨兵节点接收并返回三个参数的Multi Bulk回复：</p><ol><li><down_state>：是对主服务器的检查结果，1表示已下线；0表示未下线。</li><li><leader_runid>：如果是*，表示该命令用于检测服务器状态；如果是Sentinel的运行id用于选举领头Sentinel。</li><li><leader_epoch>：选举计数器，用于选举领头sentinel。</li></ol><p><strong>接收sentinel is-master-down-by-addr命令的回复</strong></p><p>统计其他Sentinel同意主服务器已下线数量，当数量超过配置值（quorum参数）时，sentinel会将主服务器实例的flags属性的<code>SRI_O_DOWN</code>属性打开，表示已进入客观下线状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="comment">//判断这个实例为客观下线所需的支持投票数量</span></span><br><span class="line">    <span class="keyword">int</span> quorum;</span><br><span class="line">    ...</span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure><h3 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h3><p>当主服务器被判断为客观下线时，sentinel会协商选举领头sentinel，并由领头sentinel对下线主服务器执行故障转移操作。</p><p>当<code>SENTINEL is-master-down-by-addr</code>命令已经确认主服务器客观下线时，Sentinel还会<strong>再发送</strong>带有选举性质的该命令，并且带上自己的运行ID。如果接收命令的Sentinel还没设置局部领头时，就会将这个运行ID作为自己的<strong>Multi Bulk回复参数</strong>。根据回复参数来判断多少sentinel将自己设置为局部领头。可能根据网络延迟，有的Sentinel命令比其他Sentinel都先到达，并且胜出（必须有<strong>半数以上</strong>的票），那么就由它负责故障转移。</p><p>若一次选举没有产生领头Sentinel，一段时间后再次选举，直到选出为止。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>故障转移包括3步：</p><ol><li>在已下线的主服务器属下从服务器里选出一个将其转为主服务器。</li><li>让其他从服务器都复制新主服务器。</li><li>当原来的主服务器再次上线时，让他成为新主服务器的从服务器。</li></ol><p><strong>选出新主服务器</strong></p><p>如何选新的主服务器？Sentinel会将所有从服务器放入列表，<strong>一项一项</strong>过滤：</p><ul><li>删除处于下线或断线状态的从服务器。</li><li>删除最近5秒没有回复过领头<code>sentinel INFO</code>命令的从服务器。</li><li>删除与已下线主服务器段开时间超过<code>down-after-milliseconds*10</code>毫秒的从服务器。</li></ul><p>然后根据<strong>优先级排序</strong>，相同则选<strong>偏移量最大</strong>的，再相同则选运行ID最小的。</p><p>选出来之后，对这个从服务器发送<code>SLAVEOF no one</code>命令，然后以<strong>每秒一次</strong>的频率向它发送<code>INFO</code>命令，观察返回的role属性如果变成master，就表示顺利升级为主服务器了。</p><p><strong>修改从服务器的复制目标</strong></p><p>向所有其他从服务器发送<code>SLAVEOF</code>命令，让他们都去复制新的主服务器。</p><p><strong>将旧的主服务器变为从服务器</strong></p><p>当原来的主服务器上线时，Sentinel就会向它发送<code>SLAVEOF</code>命令，让他成为新主服务器的从服务器。</p><h2 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h2><p>集群是Redis提供的<strong>分布式数据库</strong>方案，通过<strong>分片</strong>来进行数据共享并提供复制和故障转移的功能。主要对集群的节点，槽指派，命令执行，重新分片，转向，故障转移，消息进行介绍。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>集群由多个节点组成，通过<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>可以将节点连接起来。这个命令主要是将目标节点加入到当前Redis所在的集群中。下面从启动节点，集群相关数据结构，命令实现来介绍节点内容。</p><p><strong>启动节点</strong></p><p>Redis服务器在启动时会根据<code>cluster-enable</code>配置是否为yes来决定是否开启集群模式。</p><p>集群中的节点除了使用redisServer，redisClient之外，还用<code>cluster.h/clusterNode</code>结构、<code>cluster.h/clusterLink</code>结构、<code>cluster.h/clusterState</code>结构来保存集群数据。</p><p><strong>集群数据结构</strong></p><p>集群的每个节点都会用clusterNode来保存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; .</span><br><span class="line">    <span class="comment">//节点的名字，由40个十六进制字符组成</span></span><br><span class="line">    <span class="keyword">char</span> name [REDIS_CLUSTER_NAMELEN] ; </span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="comment">//使用各种不同的标识值记录节点的角色(比如主节点或者从节点),</span></span><br><span class="line">    <span class="comment">//以及节点目前所处的状态(比如在线或者下线)。</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">    <span class="comment">//节点的IP地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN] ;</span><br><span class="line">    <span class="comment">//节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>link属性保存了连接节点所需的有关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">//连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime ;</span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息( message )。</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    <span class="comment">//输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf ;</span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> <span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每个节点都保存一个集群状态，记录在当前节点下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line">    <span class="comment">//集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">//集群当前的状态:是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量（下一节谈）</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//集群节点名单(包括myself节点)</span></span><br><span class="line">    <span class="comment">//键为节点名字，值为节点对应的clusterNode结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">    ...</span><br><span class="line">&#125; clusterState;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>CLUSTER MEET命令的实现</strong></p><p>通过向节点A发送<code>CLUSTER MEET</code>命令，让目标节点B加入集群，进行<strong>握手</strong>，执行过程如下：</p><ol><li>客户端发送该命令给节点A，节点A会创建一个节点B的clusterNode结构，添加到clusterState.nodes中。</li><li>解析IP地址和端口号，向节点B发送MEET消息（最后一节会讲消息）。</li><li>同理，节点B收到后，会为A创建clusterNode结构并添加到nodes。</li><li>节点B向A发送PONG消息。</li><li>节点A收到后向B发送一条PING消息。</li><li>节点B收到后直到A成功感知到B，握手完成。</li></ol><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504000.jpg" alt="img"></p><p>之后，节点A将节点B的信息通过<strong>Gossip协议</strong>（最后一节消息中将提到）传播给集群中的其他节点。</p><h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><p>Redis通过分片方式保存键值对，集群的整个数据库被分为<strong>16384</strong>个槽（slot），数据库的每个键都属于某一个槽，每个节点可处理0~16384个槽。当集群中的<strong>每个槽都归某个节点</strong>管理，集群处于上线状态；但凡有一个没人管，集群处于下线状态。</p><p>发送<code>CLUSTER ADDSLOTS &lt;slot&gt; [slot...]</code>命令，可以将槽委派给某个节点负责。下面介绍槽的实现。</p><p><strong>记录节点的槽指派信息</strong></p><p>clusterNode有slots和numslot属性记录了节点负责处理的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//二进制位数组，长度为16384/8=2048字节，</span></span><br><span class="line">    <span class="comment">//每个索引8位，根据0和1判断该槽是否被该节点负责</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slot[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//负责处理的槽数量</span></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如该节点负责0~7的槽，存储结构如下：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504094.png" alt="img"></p><p>通过这种设计，检查某节点<strong>是否负责处理某个槽</strong>或者<strong>让节点负责某个槽</strong>的操作的时间复杂度都为**O(1)**。</p><p><strong>传播节点的槽指派信息</strong></p><p>节点除了将自己负责的槽记录在<code>clusterNode.slots</code>中，还会将这个数组通过<strong>消息发送</strong>给其他节点，让他们都知道自己负责什么槽。其他节点接收消息后，会对<code>clusterStaste.nodes</code>字典中对应的<code>clusterNode.slots</code>数据进行更新。</p><p><strong>记录集群所有槽的指派信息</strong></p><p>clusterState会维护集群中每个节点管理槽的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果slot[i]指向空，说明该槽<strong>没有被节点管理</strong>；如果指向具体某个clusterNode，说明该槽由这个节点管理。</p><p>总结一下，<code>clusterState.slots</code>数组记录<strong>集群中所有槽的信息</strong>；<code>clusterNode.slots</code>数组记录当前节点<strong>负责槽的信息</strong>。前者方便知道某个槽指派给谁，后者方便知道某个槽是否指派给自己，或者发送自己槽的指派信息。（因为被指派后，还需要向其他节点发送消息告知）。</p><p><strong>CLUSTER ADDSLOTS命令的实现</strong></p><p>这个命令的执行其实就是把上面讲的几小节知识给串起来。主要是用来指派槽给节点负责的，接收该命令后，首先会遍历所有传入的槽（命令入参）检查其是否都是未指派的，如果<strong>有一个被指派了就报错</strong>。如果都未指派，将这些槽委派给当前节点，更新<code>clusterState.slots</code>数组指向当前节点的clusterNode；然后将<code>clusterNode.slots</code>数组中对应的索引<strong>二进制位设置为1</strong>。最后，<strong>发送消息</strong>告诉集群中其他节点，自己负责这些槽。</p><h3 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h3><p>当客户端对节点发送与数据库键有关的命令时，接收命令的节点会计算属于哪个槽，检查这个槽是否指派给自己（根据key的<strong>CRC-16校验和16383做与操作</strong>来确定槽号i，再根据clusterState.slots[i]是否指向当前节点的clusterNode判断是否自己负责的）。</p><p>如果不是指派给自己的，就（找负责该槽的节点的ip和端口，指引客户端转向它）向客户端<strong>返回MOVED错误</strong>，引导客户端指向正确的节点并再次发送命令。</p><blockquote><p>注：通过<code>CLUSTER KEYSLOT &lt;key&gt;</code>可查看某个key对应的槽号。</p></blockquote><p><strong>MOVED错误</strong></p><p>MOVED错误格式为：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p><p>在集群模式下，会被隐藏，客户端会进行自动转向并重发命令。节点的转向其实就是<strong>换对应套接字</strong>来发送命令。下面演示了对7000端口的节点操作键命令并被引导转向到真正存储该键的服务器（7001端口）的过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1: 7000&gt; SET msg &quot;hello&quot;</span><br><span class="line">-&gt; Redirected to slot [6257] located at 127.0.0.1: 7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; GET msg</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure><p><strong>节点数据库的实现</strong></p><p>节点对数据的存储和单机Redis的实现是一样的，只不过节点只能使用0号库。还需要维护一个<code>slots_to_keys</code>跳跃表关联槽号和键。<strong>分值是槽号，成员就是键</strong>。当节点往数据库添加新键时，节点就会在<code>slots_to_keys</code>中进行<strong>关联</strong>，反之则删除关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    ...</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p><p>重新分片通过集群管理软件redis-trib执行，步骤如下：</p><ol><li>redis-trib对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让<strong>目标节点准备</strong>好，要导入键值对了。</li><li>redis-trib对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让<strong>源节点准备好</strong>，要转移键值对了。</li><li>redis-trib 向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令， 获得最多count个属于槽slot的键值对的键名( key name )，这实际上就是个<strong>批量分片</strong>的意思。</li><li>对于步骤3获得的每个键名，redis-trib都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_ port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点。</li><li>重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点。</li><li>redis-trib向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_ id&gt;</code>命令，将槽slot指派给目标节点这个信息，通过<strong>消息发送至整个集群</strong>，让所有节点感知。</li></ol><p>整体迁移的流程图：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504126.jpg" alt="img"></p><h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>当客户端向源节点发送与数据库键相关的命令，并且该键恰好属于<strong>被迁移的槽</strong>时，源节点会先查自己有没有，有就返回；<strong>没有则返回ASK错误</strong>，指引客户端向正在导入该槽的目标节点发送命令。这个命令和MOVED类似，不会直接打印错误。比如端口7000是源节点，”love”键的槽（16198槽）正在被迁移到7001就会这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1: 7000&gt; GET &quot;love&quot;</span><br><span class="line">-&gt; Redirected to slot [16198] located at 127.0.0.1: 7001</span><br><span class="line">&quot;you get the key &#x27;love&#x27;&quot;</span><br><span class="line">127.0.0.1: 7001&gt;</span><br></pre></td></tr></table></figure><p><strong>CLUSTER SETSLOT IMPORTING的实现</strong></p><p>clusterState.importing_slots_from数组记录当前节点正在从其他节点导入的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode *importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下指向空，当执行<code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>时，会将目标节点（当前节点）<code>clusterState.importing_slots_from[i]</code>设置为source_id所代表节点的clusterNode。</p><p><strong>CLUSTER SETSLOT MIGRATING的实现</strong></p><p>clusterState结构的migrating_slot_to数组记录了当前节点正在迁移至其他节点的槽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    clusterNode *migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下指向空，当执行<code>CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code>时，会将源节点<code>clusterState.migrating_slots_to[i]</code>设置为target_id所代表节点的clusterNode。</p><p><strong>ASK错误</strong></p><p>如果节点收到一个关于键key的命令请求，并且键key所属的槽正好指派给了该节点，那么该节点会尝试在自己的数据库里查找键key，找到则返回，如果没找到则检查<code>clusterState.migrating_slots_to[i]</code>，是否正在迁移，如果<strong>正在迁移</strong>，就向客户端返回ASK错误，引导其去<strong>导入槽的节点查询</strong>。</p><p>客户端接收到ASK错误后，根据IP和端口，转向目标节点，然后先向目标节点发送<strong>ASKING</strong>命令，再重新发送要执行的命令。</p><p><strong>ASKING命令</strong></p><p>这个命令的唯一作用就是打开发送该命令客户端的<code>REDIS_ASKING</code>标识。有了这个标识后，节点会<strong>为正在导入的键执行命令</strong>。这个标识是<strong>一次性</strong>的，如果再对刚才的key执行相关操作，该节点会返回MOVED错误（因为重分片未结束，它不是负责该槽的节点）。下面表示相关判断过程：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201051504212.jpg" alt="img"></p><p><strong>ASK错误与MOVED错误的区别</strong></p><p>这两个错误都会导致客户端转向：</p><ul><li>MOVED错误代表槽的负责权<strong>已经从一个节点到了另一个节点</strong>。</li><li>ASK错误只是两个节点再迁移槽过程中使用的<strong>临时措施</strong>。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>Redis集群中的节点分主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点（相当于备份，<strong>不处理读请求</strong>），并在被复制节点下线时，代替下线主节点继续处理命令请求。</p><p>接下来介绍节点的复制方法，检测节点是否下线方法及对下线节点故障转移方法。</p><p><strong>设置从节点</strong></p><p>向节点发送命令<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为指定节点的从节点并对主节点开始复制。主要过程是：</p><ol><li>接收命令节点在<code>clusterState.node</code>字典中找到node_id对应节点的clusterNode，然后将<code>clusterState.myself.slaveof</code>指向这个节点。</li><li>修改<code>clusterState.myself.flags</code>属性，关闭<code>REDIS_NODE_MASTER</code>标识，<strong>打开<code>REDIS_NODE_SLAVE</code>标识</strong>，标识该节点成为从节点。</li><li>调用复制代码，对主节点复制。</li></ol><p>当节点成为从节点并开始复制时，这个信息会通过消息发送给集群中其他节点。</p><p><strong>故障检测</strong></p><p>集群中每个节点都会定期向其他节点发送PING消息，如果没有在规定时间返回PONG消息，就会被标记位<strong>疑似下线</strong>。集群中各个节点会互相发送消息来交换各个节点的状态，当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态，A会将B的<strong>下线报告添加</strong>到<code>clusterNode.fail_reports</code>链表中。</p><p>链表中每个元素都由clusterNodeFailReport组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span>&#123;</span></span><br><span class="line">    <span class="comment">//报告目标节点已经下线的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">//最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="comment">//程序使用这个时间戳来检查下线报告是否过期</span></span><br><span class="line">    <span class="comment">// (与当前时间相差太久的下线报告会被删除)</span></span><br><span class="line">    <span class="keyword">mstime_t</span> time;</span><br><span class="line">&#125; <span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure><p>在一个集群中，<strong>半数以上</strong>负责处理槽的主节点将某个主节点报告为疑似下线后，这个主节点将被<strong>标记为已下线</strong>。并向集群广播一条关于该主节点FAIL的消息，所有收到消息的节点都会将其标记为已下线。</p><p><strong>故障转移</strong></p><p>当一个从发现主节点下线后，开始故障转移。具体步骤：</p><ol><li>下线的主节点的所有从节点里面，会有一个从节点被选中。</li><li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li><li>新的主节点会撤销对已下线主节点的槽指派，并将这些槽指派给自己。</li><li>新的主节点向集群广播一条PONG消息，让其他节点立即知道新的主节点。</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li></ol><p><strong>选举新的主节点</strong></p><p>集群选举新主节点的具体过程：</p><ol><li>通过集群的配置纪元确定是哪一次选举，它是一个<strong>自增计数器</strong>，初始值为0。</li><li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被加一。</li><li>集群里每个负责处理槽的主节点都有<strong>一次投票的机会</strong>，第一个向主节点要求投票的从节点将获得主节点的投票。</li><li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群<strong>广播</strong>一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到这条消息并且具有投票权的主节点向这个从节点投票。</li><li>如果一个主节点具有投票权(它正在负责处理槽)，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，表示这个主节点支持从节点成为新的主节点。</li><li>每个参与选举的从节点都会接收<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，并根据自己<strong>收到消息的条数</strong>来统计自己获得多少主节点的支持。</li><li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于<strong>N/2+1</strong> 支持票时，这个从节点就会当选为新的主节点。</li><li>配置纪元确定每个具有投票权的主节点只能投一次，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li><li>如果在一个配置纪元里没有从节点得到足够的票，那么集群进入一个新的配置纪元，并<strong>再次进行选举</strong>，直到选出新的主节点为止。</li></ol><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>集群中节点主要通过发送消息来传递信息，主要有5种：</p><ul><li>MEET消息：发送者接收到客户端的<em>CLUSTER MEET</em>消息时，发送者向接收者发送MEET消息，<strong>请求加入</strong>发送者所在集群。</li><li>PING消息：集群每个节点每隔一秒从已知节点<strong>随机选出5个</strong>节点，然后对<strong>最长时间没发</strong>PING消息的节点进行发送。除此之外，如果最后一次收到某节点的PONG消息的时间，<strong>超过</strong>配置的<code>cluster-node-timeout</code>选项的<strong>一半</strong>时，也会发送PING消息。</li><li>PONG消息：应答MEET或PING消息。还可以通过PONG，告诉其他节点，刷新该节点的相关信息。</li><li>FAIL消息：当某个主节点判断另一个主节点<strong>已经进入FAIL状态</strong>时，当前主节点会向集群<strong>广播</strong>一条关于已下线节点的FAIL消息。</li><li>PUBLISH消息：当节点接收到PUBLISH命令时，执行这个命令，并向集群<strong>广播</strong>一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</li></ul><p>一条消息由消息头和消息正文组成。</p><p><strong>消息头</strong></p><p>记录信息发送者的一些信息。比如发送者的当前纪元，发送者名字，发送者的槽指派信息等。接收者可根据发送者的信息来更新发送者的状态。消息头是一个<code>cluster.h/clusterMsg</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//消息的长度(包括这个消息头的长度和消息正文的长度)</span></span><br><span class="line">    uint32_ t totlen;</span><br><span class="line">    <span class="comment">//消息的类型</span></span><br><span class="line">    uint16_ t type;</span><br><span class="line">    <span class="comment">//消息正文包含的节点信息数量</span></span><br><span class="line">    <span class="comment">//只在发送MEET. PING、PONG这三种Gossip协议消息时使用</span></span><br><span class="line">    uint16_ t count;</span><br><span class="line">    <span class="comment">//发送者所处的配置纪元</span></span><br><span class="line">    uint64_ t currentEpoch;</span><br><span class="line">    <span class="comment">//如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span></span><br><span class="line">    <span class="comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元.</span></span><br><span class="line">    uint64_ t configEpoch;</span><br><span class="line">    <span class="comment">//发送者的名字(ID)</span></span><br><span class="line">    <span class="keyword">char</span> sender [REDIS_ CLUSTER_ NAMELEN] ;</span><br><span class="line">    <span class="comment">//发送者目前的槽指派信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots [REDIS_ CLUSTER_ SLOTS/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span></span><br><span class="line">    <span class="comment">//如果发送者是一个主节点，那么这里记录的是REDIS_ NODE_NULL_NAME</span></span><br><span class="line">    <span class="comment">// (一个40字节长，值全为0的字节数组)</span></span><br><span class="line">    <span class="keyword">char</span> slaveof [REDIS_ CLUSTER_ NAMELEN] ;</span><br><span class="line">    <span class="comment">//发送者的端口号</span></span><br><span class="line">    uint16_ t port;</span><br><span class="line">    <span class="comment">//发送者的标识值</span></span><br><span class="line">    uint16_ t flags;</span><br><span class="line">    <span class="comment">//发送者所处集群的状态</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> state;</span><br><span class="line">    <span class="comment">//消息的正文(或者说，内容)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125; clusterMsg;</span><br></pre></td></tr></table></figure><p>其中消息正文是一个<code>cluster.h/clusterMsgData</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span>&#123;</span></span><br><span class="line">    <span class="comment">// MEET、 PING、PONG消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="comment">//每条MEET、PING、pONG消息都包含两个</span></span><br><span class="line">        <span class="comment">//clusterMsgDataGossip结构</span></span><br><span class="line">        clusterMsgDataGossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FAIL消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    clusterMsgDatafail about;</span><br><span class="line">    &#125;fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PUBLISH消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        clusterMsgDataPublish msg;</span><br><span class="line">    &#125;publish;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他消息的正文...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>MEET、PING、PONG消息的实现</strong></p><p>集群中的各个节点通过<strong>Gossip协议</strong>来交换各自关于不同节点的状态信息，Gossip协议由MEET、PING、PONG这三种消息实现，他们的的正文就是上面的ping结构体。</p><p>因为共用消息正文，所以需要消息头的type属性来区分。每次发送这类消息时，发送者都从已知节点中<strong>随机选择两个节点</strong>保存到clusterMsgDataGossip，因此正文包含两个clusterMsgDataGossip结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">struct</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的名字</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> nodename [REDIS_CLUSTER_NAMELEN]; .</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后一次向该节点发送PING消息的时间戳</span></span></span></span><br><span class="line"><span class="function"><span class="params">    uint32_ t ping_sent;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//最后一次从该节点接收PONG消息的时间戳</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> pong_received;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的IP地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的墙口号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint16_t</span> port;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//节点的标识值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint16_t</span> flags;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;clusterMsgDataGossip;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br></pre></td></tr></table></figure><p>消息接收者会根据clusterMsgDataGossip包含的节点，看是否为第一次接触，如果是的话，需要进行一次握手，记录节点信息；如果已经存在于已知节点中，则对相关节点信息更新。</p><p><strong>FAIL消息的实现</strong></p><p>在集群节点较多的情况下，单纯使用Gossip会带来一些<strong>延迟</strong>，FAIL消息需要所有节点立刻知道某个主节点下线了，从而尽快判断<strong>是否需要标记为下线或故障转移</strong>。消息正文是一个<code>cluster.h/clusterMsgDatafail</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录下线节点的名字</span></span><br><span class="line">    <span class="keyword">char</span> nodename[REDIS_CLUSTER_NAMELEN]</span><br><span class="line">&#125;clusterMsgDataFail;</span><br></pre></td></tr></table></figure><p>因为名字都是集群内唯一的，所以可以这么保存。</p><p><strong>PUBLISH消息的实现</strong></p><p>当集群的某个节点发送<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>时，会引发集群中所有节点都向channel发送消息。消息正文是一个<code>cluster.h/clusterMsgDataPublish</code>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint32_ t channel_len;</span><br><span class="line">    uint32_ t message_len;</span><br><span class="line">    <span class="comment">//定义为8字节只是为了对齐其他消息结构</span></span><br><span class="line">    <span class="comment">//实际的长度由保存的内容决定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bulk_data[<span class="number">8</span>] ;</span><br><span class="line">&#125; clusterMsgDataPublish;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bulk_data保存消息的channel和message参数。具体是根据对应参数长度识别的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>复制章节主要讲述主从复制功能，通过复制偏移量判断<strong>是否数据不一致</strong>，然后根据复制积压缓冲区和运行id判断执行<strong>完全重同步还是部分重同步</strong>，从而解决断线重连后的系统资源损耗问题。命令传播的心跳检测<strong>1秒一次</strong>，由从服务器发送，保障网络通常，防止主服务器在不安全的情况下执行写命令。</p><p>哨兵章节主要讲述哨兵的数据结构，命令实现，选举，故障转移等操作。Redis的哨兵集群模式是高可用的解决方案，默认每<strong>10秒一次</strong>向主从服务器发送<strong>INFO</strong>命令更新信息，主服务器下线或故障转移时会<strong>1秒一次</strong>。Sentinel每秒一次与创建命令连接的实例发送PING命令，根据配置的时间内未得到回复就标记为<strong>主观下线</strong>。然后询问其他Sentinel，得到足量下线判断后会标记为客观下线。发现客观下线的哨兵就会发起选举哨兵领头，根据规则（Raft算法），<strong>一半以上</strong>支持则成功担任并负责故障转移工作。根据配置规则向过滤不在线的从服务器，然后按优先级，偏移量，运行id排序选择主服务器并让从服务器都复制它。</p><p>集群章节主要讲述Redis的cluster集群模式下的集群数据结构，实现原理，选举，故障转移等操作。这种集群模式提供了<strong>分布式的数据存储</strong>。每个节点都维护了集群状态，各个节点状态信息还有槽指派信息。集群将<strong>数据分区</strong>，按槽存储，key的<strong>CRC-16</strong>的校验码决定了存放于哪个槽，每个主节点都指派不同的槽。当对某个节点执行key的相关命令时，会先判断<strong>是否归这个槽负责</strong>，如果不是则产生MOVED错误引导客户端指向正确的节点。如果<strong>归这个槽负责并且key在重分片</strong>，就会产生ASK错误，引导客户端指向目标节点。发送ASKING后，才能执行相关读写命令。这种集群模式，<strong>主节点负责读写，从节点复制</strong>，作为一个备份。</p><p>当从节点发现主节点下线，就进行故障转移，通过配置纪元选举出主节点，将原先槽指派给它，并且<strong>广播一条PONG</strong>消息，让其他节点知道。节点之间传递信息依赖消息，有MEET、PING、PONG、FAIL、PUBLISH消息。</p>]]></content>
      
      
      <categories>
          
          <category> 《Redis设计与实现》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现:单机数据库的实现</title>
      <link href="2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>redis3.0 标有注解的源码：<a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p></blockquote><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>从Redis服务端的实现角度介绍，包括db存储，切换，键的存储及过期相关处理。</p><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis把所有库信息都保存在<code>redis.h/redisServer</code>结构的db数组中，数组类型是<code>redis.h/redisDB</code>，dbnum决定着应该创建多少数据库中的db，clients维护着所有连接Redis的客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//客户端状态链表</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器数据库实例如图所示：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042148700.jpg" alt="img"></p><p>当切换库时，其实就是redisClient.db对redisServer.db数组的目标数据库指针的移动。下面展示了从0号库切为1号库的过程。通过<strong>指针的切换</strong>，实现对库的共享：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149516.jpg" alt="img"></p><h3 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h3><p>redis将所有key进行统一管理，按照所属的库划分，放在redisDb的字典中（按照上面画的数据结构，redis每一个库都对应一个redisDb）。redisDb结构的dict字典保存了该数据库中的所有键值对，也称为<strong>键空间</strong>。键空间的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键空间的键就是数据库的键，每个键都是一个字符串对象，键空间的值就是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象（上一章主要是对值的存储结构介绍）。</p><p>下图展示了键空间的存储：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149396.jpg" alt="img"></p><p>当执行一些插入指令时，就是对dict中key的新增；同理，删除键后，dict中的键值对对象都会被删除。</p><p><strong>读写键空间时的维护操作(9.3.6详讲)</strong></p><p>对键的读写时，服务器会做相应的善后操作，比如更新缓存的命中率，更新LRU（最后一次使用）时间，对已过期的键先进行删除操作，修改时对客户端watch的键进行dirty标记，更新dirty键计数器的值，当开启通知功能后，键修改时需要按配置发送相应通知。</p><h3 id="键过期时间相关操作"><a href="#键过期时间相关操作" class="headerlink" title="键过期时间相关操作"></a>键过期时间相关操作</h3><p>通过<code>EXPIRE</code>或<code>PEXPIRE</code>，客户端可以以<strong>秒或毫秒</strong>为精度设置过期时间（Time To Live，TTL）。通过<code>EXPIREAT</code>或<code>PEXPIREAT</code>，客户端可以设置<strong>时间戳</strong>作为过期时间。</p><p>使用<code>TTL</code>或<code>PTTL</code>也可查看某个键的剩余生存时间，还有多久过期：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 498</span><br></pre></td></tr></table></figure><p>Redis是如何保存过期时间的，又是如何删除过期键的将在下面论述。</p><p><strong>设置过期时间</strong></p><p>Redis提供了4个命令设置过期时间：</p><ul><li>EXPIRE<key> <ttl>：将key的生存时间设为ttl秒。</li><li>PEXPIRE<key> <ttl>：将key的生存时间设为ttl毫秒。</li><li>EXPIREAT<key> <timestamp>：将key的过期时间设置为timestamp秒数时间戳。</li><li>PEXPIREAT<key> <timestamp>：将key的过期时间设置为timestamp毫秒数时间戳。</li></ul><p>其实几个命令底层都是经过换算后，用<strong>PEXPIREAT</strong>实现的。</p><p>实现转换关系图：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149255.jpeg" alt="img"></p><p><strong>存储过期时间</strong></p><p>redisDb中有一个expires的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个<strong>long long</strong>类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的Unix时间戳）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>图中键空间和过期的键其实复用了一个键对象，这里方便展示就拆开来，假设我们给键alphabet和book都设置了过期时间：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149780.jpg" alt="img"></p><p><strong>移除过期时间</strong></p><p>PERSIST命令可以<strong>移除一个键的过期时间</strong>，在过期字段中查找给定键，并<strong>解除</strong>键和值在过期字典中的关联。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 498</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><p><strong>计算并返回剩余生存时间</strong></p><p>TTL以秒为单位返回剩余时间，PTTL以毫秒返回键的剩余时间。二者的计算都是通过计算键的过期时间与当前时间之差来实现的。</p><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>如果一个键过期了，那么在什么时候被删除？列举几个常见淘汰策略：</p><ol><li>定时删除：设置键的过期时间时，创建定时器，过期时，以定时器立刻执行键的删除。</li><li>惰性删除：不着急删除过期键，每次获取时都会进行过期校验。</li><li>定期删除：隔一段时间，程序就对数据库检查，删除过期键。</li></ol><p><strong>定时删除</strong></p><p>定时删除策略<strong>对内存友好</strong>，但<strong>对CPU不友好</strong>。过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。Redis定时器需要创建时间事件，时间事件底层由无序链表实现，查找复杂度为O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p><p><strong>惰性删除</strong></p><p>惰性删除<strong>对CPU友好</strong>，但<strong>对内存不友好</strong>。不需要把时间浪费在非相关键的删除上。当键非常多时，会导致内存泄漏，因为只有用到时才会判断，删除。</p><p><strong>定期删除</strong></p><p>定期删除是一种折衷的方式，隔一段时间执行一次，并<strong>限制</strong>删除操作<strong>执行的时长和频率</strong>减少对CPU的占用；定期删除还能<strong>减少庞大的过期键对内存的占用</strong>。如何确定时长和频率是难点，过长或过少，会退变为定时删除和惰性删除。</p><p><strong>Redis的过期键删除策略</strong></p><p>Redis使用了<strong>惰性删除和定期删除</strong>两种策略配合，服务器可以合理地在使用CPU时间和避免内存浪费之间权衡。</p><ul><li><p>惰性删除策略的实现</p><p>该策略由<code>db.c/expireIfNeeded</code>函数实现，如同指令过滤器，在执行读写键指令时都会调用该函数检查键是否过期，如果过期则删除。</p></li><li><p>定期删除策略的实现</p><p>该策略由<code>redis.c/activeExpireCycle</code>函数实现，当服务器周期性调用<code>redis.c/serverCron</code>函数时，<code>activeExpireCycle</code>函数就会被调用，规定时间内，多次遍历服务器的各个数据库，从expires字典中随机检查一部分键的过期时间，并删除过期键。<code>activeExpireCycle</code>函数的主要工作可以拆分为：</p><ol><li>每次运行，都从一定数量的数据库中取出一定数量的<strong>随机键</strong>检查并删除过期键。</li><li>全局遍历记录检查进度，有<strong>记忆</strong>功能，全局变量存储的是几号库。</li><li>当所有数据库都被检查一遍后，<strong>重置</strong>全局变量，进行新一轮检查。</li></ol></li></ul><h3 id="RDB、AOF和复制功能对过期键的处理"><a href="#RDB、AOF和复制功能对过期键的处理" class="headerlink" title="RDB、AOF和复制功能对过期键的处理"></a>RDB、AOF和复制功能对过期键的处理</h3><p><strong>载入RDB文件</strong>：</p><ul><li>若服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键不会对主服务器载入RDB文件产生影响</li><li>若以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，主从服务器在进行数据同步时，从服务器的数据库会被清空，所以过期键不会对从服务器载入RDB文件产生影响</li></ul><p><strong>写入AOF文件</strong>：</p><ul><li>若某个键已过期但未被删除，那么AOF文件不会因这个过期键产生任何影响</li><li>若某个键已过期并被删除后，程序会向AOF文件追加一条DEL命令</li></ul><p><strong>重写AOF文件</strong>：</p><ul><li>与生成RDB文件类似，在重写AOF文件过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中</li></ul><p><strong>复制</strong>：</p><ul><li>主服务器删除一个过期键后，会向所有从服务器发送一个DEL命令，告知从服务器删除该过期键</li><li>从服务器在执行客户端发送的读命令时，即使遇到过期键也不会做什么，而时像处理未过期键一样处理该键，将其值返回。只有在收到主服务器发过来的DEL命令后，从服务器才会删除该过期键。</li></ul><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>Redis发布订阅功能可以让客户端获取数据库中键的变化及命令的执行情况。关注某个键执行了什么命令的通知称为键空间通知。关注某个命令被什么键执行的通知称为事件通知。</p><p>主要就是围绕通知功能，简单看下发送通知及其实现。</p><p><strong>发送通知</strong></p><p>该功能由<code>notify.c/notifyKeyspaceEvent</code>函数实现：</p><p>通过几个入参：要发送的通知类型，事件名称，产生事件的键，产生事件的数据库号。来构造事件通知内容和接收频道名，Redis许多指令的执行函数都会调用这个函数，传递该命令引发的事件相关信息。</p><p><strong>发送通知的实现</strong></p><ol><li>通过服务器配置的值判断，如果给定通知类型不是服务器允许的就直接返回。</li><li>如果是服务器允许发送的，检测是否允许发送键空间通知，允许则构建发送事件并通知。</li><li>检测是否允许发送键事件通知，如果允许则构建并发送通知。</li></ol><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>由于Redis是内存数据库，数据状态都存储于内存，如果不想办法将存储在内存中的数据库状态保存到磁盘里，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p><p>为解决这个问题，Redis提供了持久化的功能，可将内存中的数据库保存到磁盘，防止意外丢失。RDS持久化（默认持久化策略）就是将某一时间点上的状态保存到一个RDB文件里。RDB文件是经过<strong>压缩的二进制文件</strong>，可通过该文件还原成数据库状态。</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个命令可用于生成RDB文件（SAVE和BGSAVE）。他们之间的区别是：SAVE会<strong>阻塞</strong>Redis服务器进程，直到RDB文件创建完毕为止，阻塞期间，服务器不能处理任何命令请求。而BGSAVE会<strong>fork出一个子进程</strong>，由子进程负责创建RDB文件，<strong>父进程继续处理命令请求</strong>。当子进程完成之后，向父进程<strong>发送信号</strong>。</p><p>创建就是执行SAVE/BGSAVE底层调用rdbSave函数的过程，载入就是服务启动时读取RDB文件底层调用rdbLoad函数的过程。</p><p><strong>适用场景</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ul><p><strong>缺陷</strong></p><ul><li>在一定间隔时间做一次备份，所以如果redis挂了，就会<strong>丢失最后一次快照后的所有修改</strong>。</li><li>fork的时候，当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul><p><strong>BGSAVE执行时的服务器状态</strong></p><p>BGSAVE命令执行期间，对SAVE，BGSAVE，BGREWRITEAOF（AOF持久化命令）三个命令的处理方式如下：</p><ul><li>由于SAVE，BGSAVE底层都是调用rdbSave来持久化文件的，而且父子进程同时执行两个rdbSave调用会<strong>产生竞态条件</strong>，所以这两个指令会被服务器拒绝。</li><li>BGREWRITEAOF会被延迟到BGSAVE执行结束后执行。</li></ul><blockquote><p>如果BGREWRITEAOF正在执行，服务器会拒绝BGSAVE命令。由于BGREWRITEAOF和BGSAVE都会产生子进程且有大量的磁盘写入，出于性能考虑不会同时执行。</p></blockquote><p>简单来说，就是BGSAVE执行期间，<strong>拒绝SAVE，BGSAVE</strong>；<strong>延迟执行BGREWRITEAOF</strong>。BGREWRITEAOF执行期间，<strong>拒绝BGSAVE</strong>。</p><p><strong>RDB与AOF共存的载入情况</strong></p><p>RDB文件的载入是在服务器启动时执行，Redis并没有专门提供载入RDB文件的命令。由于AOF文件的更新频率更高，因此开启AOF持久化功能后，启动时<strong>优先加载AOF</strong>还原数据，只有在AOF处于关闭状态，才使用RDB文件恢复数据。</p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>服务器允许用户通过配置文件设置隔一定时间自动执行BGSAVE。可通过save选项设多个保存条件，默认的配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>只要满足任意条件，900s内对数据库进行1次修改或300s内…BGSAVE就会被执行。</p><p>那么，服务器是如何根据save选项来自动执行BGSAVE的？<br>从实现角度考虑，我们需要<strong>记录配置</strong>、<strong>评判依据</strong>和<strong>依据更新驱动</strong>。记录配置由saveparams实现；评判依据是dirty计数器和lastsave属性；依据更新驱动就是serverCron对评判依据的动态更新。<br>save配置都会在redisServer的saveparam数组中体现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>dirty计数器和lastsave属性</strong></p><p>这两个属性由redisServer持有：</p><ul><li>dirty计数器记录距离上次成功执行SAVE或BGSAVE后数据库被修改了几次。</li><li>lastsave是一个UNIX时间戳，记录上次成功执行SAVE或BGSAVE的时间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行保存的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>检查条件是否满足</strong></p><p>Redis的周期性操作函数serverCron每隔100毫秒会执行一次，其中一项工作就是检查save选项设置的保存条件是否满足要求，满足则执行BGSAVE。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150112.jpeg" alt="img"></p><p>REDIS：长度5字节，保存”REDIS”5个字符（为书写方便，其实是5个单独字符），通过这个判断该文件是否为RDB文件。</p><p>db_version：长度4字节，是字符串表示的整数记录RDB的版本号。</p><p>database：包含0个或多个数据库及各数据库中键值对数据。表示那些数据库是有数据的。</p><p>EOF：常量长度1字节，标志RDB文件正文的结束。读取时遇到该值，表示键值对的载入已经结束了。</p><p>check_sum：是一个8字节的无符号整数，保存一个同过前几位变量计算出来的校验和。每次加载都会进行计算校验，通过这个来判断文件是否损坏。</p><p><strong>database部分</strong></p><p>每个非空数据库在RDB文件中都可表示为SELECTDB，db_number，key_value_pairs三部分</p><ul><li>selectdb：1字节，标志位，标志着下一位存储的是数据库号码。</li><li>db_number：是一个数据库号码。</li><li>key_value_pairs：保存了数据库中所有键值对数据，如果有过期时间，则过期时间也会保存。</li></ul><p><strong>key_value_pairs部分</strong></p><p>不带过期时间的键值对在RDB文件由TYPE，key，value组成，带过期时间则含有EXPIRETIME_MS，ms：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150519.png" alt="img"></p><p>EXPIRETIME_MS：标志位，长度为1字节，告知程序下一个读入的是以毫秒为单位的过期时间。<br>ms：是8字节长的带符号整数，记录UNIX时间戳，即过期时间。<br>type：记录value的类型，长度1字节，这个常量其实就是Redis对象类型和底层编码的组装：</p><ul><li>REDIS RDBTYPE_STRING</li><li>REDIS_ RDB_TYPE_LIST</li><li>REDIS_RDB_TYPE_SET</li><li>REDIS_RDB_TYPE_ZSET</li><li>REDIS_RDB_TYPE_HASH</li><li>REDIS_RDB_TYPE_LIST_ ZIPLIST</li><li>REDIS_RDB_TYPE_SET_INTSET</li><li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li><li>REDIS_RDB_TYPE_HASH_ZIPLIST</li></ul><p>服务器会根据TYPE来决定如何读入和解释value的数据。</p><p>key就不用做过多解释~</p><p><strong>value的编码</strong></p><p>根据TYPE的不同，value的存储结构也大不相同。这里不详细展开，只需要知道，对于字符串对象，如果大于20字节，就会用LZF算法压缩。除字符串对象和整数集合，其他存储方式的开头都是节点数量，告诉程序应读入多少节点/键值对。（详细内容可查阅10.3.3节）</p><h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><p>Redis自带RDB文件检查工具redis-check-dump。可以帮助在系统故障后分析快照文件，也就是RDB文件。</p><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。服务器启动时，可通过载入和执行AOF文件中保存的命令来还原服务器关闭前的数据库状态。</p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化可分为命令追加，文件写入，文件同步三个步骤。</p><p><strong>命令追加</strong></p><p>开启AOF持久化后，服务器执行完一个写命令后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的<code>aof_buf</code>缓冲区末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>AOF文件的写入与同步</strong></p><p>Redis服务器进程就是一个<strong>事件循环</strong>，负责接收客户端命令请求及命令回复，时间事件负责执行像<code>serverCron</code>函数这样需要定时运行的函数。服务器每结束一个事件循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否有必要<strong>将aof缓冲区中的内容写入和保存至AOF文件</strong>里。</p><p>这个判断的依据就是根据配置文件的appendfsync值决定：</p><ul><li>always：将aof_buf缓冲区的所有内容<strong>写入并同步</strong>到AOF文件。</li><li>everysec：将aof_buf缓冲区中的所有内容写入到AOF文件，如果此时与上次同步AOF文件的时间<strong>超过一秒</strong>，就再次对AOF文件进行同步，并由一个线程专门负责。</li><li>no：将aof_buf缓冲区中的所有内容写入到AOF文件，但并<strong>不对AOF文件进行同步</strong>，何时同步<strong>由操作系统决定</strong>。</li></ul><p>为什么有写入和同步的区分？写入≠同步</p><p>为提高写效率，操作系统一般将写入数据<strong>暂时保存在内存缓冲区</strong>，等缓冲区<strong>填满或超过</strong>指定时间后才会真正地将<strong>数据同步到磁盘里</strong>。操作系统提供了fsync和fdatasync两个同步函数，可<strong>强制操作系统同步数据</strong>，保证数据安全性。</p><p>也就是说，每一次的事件循环，aof_buf中的指令<strong>都会被写入操作系统的缓冲区</strong>，根据appendfsync配置，当操作系统缓冲区满足一定条件后，才被<strong>真实地写入</strong>磁盘内。</p><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>步骤如下：</p><ol><li>创建一个没有网络连接的伪客户端。（由于Redis命令只能在客户端上下文中执行，并且AOF文件在本地而不是网络）。</li><li>解析AOF文件并取出一条写命令。</li><li>使用伪客户端执行被读出的写命令</li><li>持续执行2和3，直到所有写命令都已经执行完毕</li></ol><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150967.jpg" alt="img"></p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为AOF持久化会将所有的写命令都记录，所以会有冗余情况，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong>瘦身的机制</strong>确保AOF里存的都是必不可少的精华。</p><p>Redis提供AOF文件重写功能，让服务器创建一个新的AOF文件，替代现有的AOF文件，减少冗余命令。</p><p><strong>AOF文件重写的实现</strong></p><p>在新的AOF文件的重写过程中，不会读取旧AOF文件，而是通过<strong>读取数据库状态</strong>来实现的。首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录的多条命令。</p><blockquote><p>注：在重写时会先检查键所包含的元素数量，因为多元素的键在命令转换时可能会导致客户端输入缓冲区溢出。该限制由配置中对应的一个常量控制，默认超过64个就用多条指令记录。</p></blockquote><p><strong>AOF后台重写过程</strong></p><p>AOF重写的过程中会有大量的写入操作，为了避免Redis服务器长时间的阻塞，重写工作将被放到<strong>子进程中进行</strong>。这样的好处是：</p><ul><li>父进程仍然可继续处理请求。</li><li>子进程有自己的数据副本，而非子线程，可以避免一些线程安全性问题的出现。</li></ul><p>子进程在执行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致<strong>当前数据库状态与重写后的AOF文件保存的状态不一致</strong>。为解决这个问题，设置了<strong>AOF重写缓冲区</strong>。</p><p>当重写子进程创建后，Redis服务器执行完写命令就会将其写入AOF缓冲区和AOF重写缓冲区，子进程执行重写期间，服务器进程要执行3个工作：</p><ol><li>执行客户端发来的命令。</li><li>将执行后的写命令追加到AOF缓冲区。</li><li>将执行后的写命令追加到AOF重写缓冲区。</li></ol><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150308.jpg" alt="img"></p><p>当子进程完成重写后，会向父进程<strong>发送一个信号</strong>，父进程接收并调用信号处理函数，将重写缓冲区的所有内容写到新AOF文件中，原子地覆盖现有的AOF文件。因此整个AOF文件重写的过程中，只有<strong>信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是一个<strong>事件驱动程序</strong>，主要有两种：</p><ul><li>文件事件：Redis服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端通信会产生相应文件事件，服务器通过监听这些事件来完成一系列网络通信操作。</li><li>时间事件：Redis服务器有一些需要在给定时间内执行的操作，而时间事件就是对这类定时操作的抽象。</li></ul><p>简单来说，文件事件就是<strong>套接字操作相关的事件</strong>；时间事件就是<strong>定时操作相关事件</strong>。</p><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发的网络事件处理器，就是文件事件处理器。大致是使用I/O多路复用程序<strong>同时监听多个套接字</strong>，根据套接字目前执行的任务为套接字<strong>关联不同的事件处理器</strong>；当被监听的套接字准备好<strong>应答，读取，写入，关闭</strong>等操作时。与之对应的文件事件就会产生，文件事件处理器就开始发挥作用了，调用事先关联好的事件处理器来处理事件。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150098.jpg" alt="img"></p><p>利用多路复用，虽然以单线程的方式运行，但文件事件处理器实现了高性能的网络通信模型，又能很好的与Redis服务器中其他模块对接，保持了设计的<strong>简单性</strong>。</p><p><strong>文件事件处理器的组成</strong></p><p>由套接字，I/O多路复用程序，文件事件分派器，事件处理器组成。</p><p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O多路复用程序总是将所有产生事件的<strong>套接字放入到一个队列</strong>中，以有序，同步，<strong>一次一个套接字</strong>向文件事件分派器传送的姿态来运行。只有当上一个套接字产生事件被事件处理器执行完了，才会继续传送下一个套接字。</p><p>下图展示了多路复用程序使用队列传输套接字：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150230.png" alt="img"></p><p><strong>I/O多路复用的实现</strong></p><p>Redis为所有多路复用的函数库进行包装，每个多路复用函数库在其中都对应一个单独文件：<code>ae_select.c</code>,<code>ae_epoll.c</code>,<code>ae_kqueue.c</code>。为每个多路复用函数都实现了相同的API，所以多路复用程序的底层实现是可以互换的。Redis在多路复用程序源码中用宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的I/O多路复用函数库。</p><p>有关多路复用的知识可以参考：<a href="https://zhuanlan.zhihu.com/p/127170201">https://zhuanlan.zhihu.com/p/127170201</a></p><p><strong>事件的类型</strong></p><p>多路复用程序可监听的套接字事件可分为<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件。</p><ul><li>当套接字变得<strong>可读</strong>时（客户端对套接字执行write，close，accept后），套接字产生AE_READABLE事件。</li><li>当套接字变得<strong>可写</strong>时（客户端对套接字执行read操作后），套接字产生AE_WRITABLE事件。</li></ul><p>I/O多路复用程序允许服务器同时监听者两个事件，如果某个套接字同时产生了两种事件，文件事件分派其会优先处理AE_READABLE，再处理AE_WRITABLE</p><p><strong>文件事件的处理器</strong></p><p>根据客户端的需要，事件处理器分为连接应答处理器，命令请求处理器，命令回复处理器，复制处理器。这里只介绍前三者。</p><ol><li><p>连接应答处理器</p><p><code>networking.c/acceptTcpHandler</code>函数是Redis的连接应答处理器，用于连接服务器监听套接字的客户端进行应答。</p><p>Redis服务器初始化时，程序就将连接应答处理器和服务器监听套接字的<strong>AE_READABLE事件关联</strong>，当客户端调用<code>sys/socket.h/connect</code>函数时连接服务器监听套接字时，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><p>简单来说就是客户端<strong>连接被监听的套接字</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>连接应答处理器就会执行</strong>。</p></li><li><p>命令请求处理器</p><p><code>networking.c/readQueryFromClient</code>函数是Redis命令请求处理器，主要负责从套接字中读入客户端发送的命令请求内容。</p><p>当客户端成功连接到服务器后，服务器会将<strong>AE_READABLE事件</strong>和命令请求处理器关联。当客户端向服务器发送命令请求时，套接字产生AE_READABLE事件，引发命令请求处理器执行，执行相应套接字的读入操作。</p><p>简单来说就是客户端<strong>发送命令请求</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>命令请求处理器就会执行</strong>。</p></li><li><p>命令回复处理器</p><p><code>networking.c/sendReplyToClient</code>函数是Redis的命令回复处理器，负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p><p>当需要回复命令结果时，服务器会将客户端套接字的<strong>AE_WRITEBLE事件</strong>和命令回复处理器关联，当客户端准备好接收回复时就会产生AE_WRITABLE事件，引发命令回复处理器执行。执行结束，服务器会解除命令回复处理器与客户端的套接字AE_WRITABLE事件之间的关联。</p><p>简单来说就是服务器<strong>发送命令回复</strong>时，套接字<strong>产生并触发写事件</strong>，<strong>命令回复处理器就会执行</strong>。</p></li></ol><p><strong>总结</strong></p><p>一次完整的基于文件事件的服务器与客户端交互，相关处理器的处理过程：</p><ol><li>客户端发起连接，产生读事件，触发连接应答处理器执行。创建套接字，客户端状态并将该套接字的读事件与命令请求处理器关联。</li><li>客户端发送命令，产生读事件，触发命令请求处理器。读取执行命令，得到回复并将该套接字的写事件与命令回复处理器关联。</li><li>客户端读取命令回复，产生写事件，触发命令回复处理器。将回复写入套接字，解除写事件与命令回复处理器的关联。</li></ol><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件可分为<strong>定时事件</strong>和<strong>周期性事件</strong>：</p><ul><li>定时事件:只在指定时间到达时执行一次。如xx时间后执行一次。</li><li>周期性事件:每隔一段时间执行一次。如每隔xx秒执行一次。</li></ul><blockquote><p>注：Redis一般只用周期性事件。</p></blockquote><p><strong>时间事件的组成</strong></p><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id：服务器为时间事件创建的全局唯一ID (标识号)。 ID号按<strong>从小到大</strong>的顺序递增，新事件的ID号比旧事件大。</li><li>when：毫秒精度的UNIX时间戳，时间事件的到达(arrive)时间。</li><li>timeProc：时间事件处理器函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p><ul><li>事件处理器返回<code>ae.h/AE_NOMORE</code>, 为定时事件：该事件在达到一次之后被删除，之后不再到达。</li><li>事件处理器返回非<code>AE_NOMORE</code>的整数值，为周期性时间。当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，找到已到达的时间事件，调用相应的事件处理器。新的事件总是插入到链表的表头。</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150489.jpg" alt="img"></p><p>因为事件ID只能增大，所以新插入的id总是最大的。</p><h4 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h4><p>很多情况下，Redis需要定期进行资源检查，状态同步等操作，就需要定期操作，而定期操作都是由serverCron函数负责的，也是时间事件的应用实例。默认每隔100ms执行，具体工作包括：</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。以及清理数据库中的过期键值对。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行AOF或RDB持久化操作。</li><li>如果服务器是主服务器，那么对从服务器进行定期同步。</li><li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul><p>下面简单从几个方面出发，介绍serverCron的本职工作。</p><p><strong>更新服务器时间缓存</strong></p><p>Redis不少功能依赖于系统当前时间，每次获取系统时间都会进行系统调用，为减少系统调用次数，服务器使用了unixtime和mstime作为当前时间的缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">//保存了毫秒级的系统当前UNIC时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于serverCron默认100毫秒更新一次unixtime和mstime，导致其精度不高，只使用于精度要求不高的场景：</p><ul><li>服务器打印日志，更新服务器的LRU时钟，决定执行持久化，计算上限时间等。</li><li>设置过期时间，添加慢查询日志需要高高进度，服务器还是会进行系统调用。</li></ul><p><strong>更新LRU时钟</strong></p><p>每个Redis对象也会有lru属性，记录上一次被命令访问的时间。如果要计算一个键的空转时长，就要通过lrulock记录的时间减去对象的lru属性记录时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">//用于计算键的空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lrulock:<span class="number">22</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//对象最后一个被命令访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>更新服务器每秒执行命令数</strong></p><p>抽样计算函数以100毫秒一次，估算最近一秒钟的处理请求数。每次都会根据4个变量（上次抽样时间、当前时间、上次抽样已执行命令数、当前已执行命令数）来计算调用之间平均每毫秒处理几个命令，乘以1000就是1秒内处理命令的估计值。这个估计值会被放入redisServer的ops_sec_samples数组中。当我们需要知道秒内的指令数时，就会计算这个数组的平均数，因此结果是一个估算值。</p><p><strong>更新服务器内存峰值记录</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stat_peak_memory记录内存峰值，每次serverCron函数执行就会判断是否需要刷新内存峰值，如果当前使用的多就刷新。</p><p><strong>管理客户端资源</strong></p><p>serverCron每次执行都会调用clientsCron函数对客户端进行检查：如果已经超时则关闭；如果输入缓冲区大小超过一定长度则重新创建默认大小的输入缓冲区。</p><p><strong>管理数据库资源</strong></p><p>serverCron每次执行都会调用databaseCron函数，会对服务器的一部分数据库检查，删除过期键；对字典收缩。</p><p><strong>执行被延迟的BGREWRITEAOF</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//AOF延迟标志位，如果为1，则有AOF操作被延迟</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_shceduled;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由<code>aof_rewrite_shceduled</code>标志位决定，如果处于BGSAVE命令执行期间，BGREWRITEAOF会被延迟到BGSAVE执行后执行。</p><p><strong>检查持久化操作的运行状态</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行BGSAVE命令的子进程，没有为-1</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;</span><br><span class="line">    <span class="comment">//执行BGREWRITEAOF命令的子进程，没有为-1</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rdb_child_pid</code>和<code>aof_child_pid</code>只要<strong>一个不为-1</strong>，则检查子进程是否有信号发来。如果有信号到达则进行后续操作，比如新<strong>RDB文件的替换，重写的AOF文件替换</strong>等。</p><p>如果<code>rdb_child_pid</code>和<code>aof_child_pid</code><strong>都为-1</strong>，则进行检查：</p><ul><li>是否有BGREWRITEAOF被延迟，有的话就进行BGREWRITEAOF操作。</li><li>自动保存条件是否满足，满足且未执行其他持久化操作则执行BGSAVE。</li><li>AOF重写条件是否满足，满足且未执行其他持久化操作则开始一次新的BGREWRITEAOF操作。</li></ul><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150971.jpg" alt="img"></p><h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>当服务器同时存在时间事件和文件事件，调度时该如何选择，花费多久？</p><p>事件的调度由<code>ae.c/aeProcessEvents</code>函数负责。对于每一次事件循环，主要过程是：</p><ol><li>拿到最近的时间事件并计算还有多少毫秒。</li><li>创建时间任务结构；阻塞等待文件事件产生，最大阻塞时间<strong>由最近时间事件到达毫秒数决定</strong>。</li><li>先处理已产生的<strong>文件事件</strong>再处理到达的<strong>时间事件</strong>。</li></ol><p>执行原则/设计利弊：</p><ol><li>aeApiPoll函数（redis封装的多路复用函数）的最大阻塞时间由到达时间<strong>最接近当前时间的时间事件</strong>决定，这个方法既可以避免服务器对时间事件进行频繁的轮询(忙等待)，也可以确保aeApiPoll函数<strong>不会阻塞过长时间</strong>。</li><li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。</li><li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器,还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性</li></ol><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>本文第一章提到过Redis服务器的状态结构clients属性是<strong>链表</strong>，记录了所有与服务器相连的客户端结构，对客户端执行批量操作或查找操作，都可以通过clients链表完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clents</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端的属性主要分为通用和特定的，这里主要介绍通用的。简单来说有套接字描述符，标志，输入缓冲区，命令与参数，输出缓冲区，时间等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//标志</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="comment">//单个命令拆分的数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//argv数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    <span class="comment">//固定大小输出缓冲区，默认16K</span></span><br><span class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    <span class="comment">//buf已使用字节数</span></span><br><span class="line">    <span class="keyword">int</span> bufpos;</span><br><span class="line">    <span class="comment">//大小可变输出缓冲区</span></span><br><span class="line">    <span class="built_in">list</span> *reply</span><br><span class="line">    <span class="comment">//创建客户端的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="comment">//与服务器互动的最后时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="comment">//软性限制时间</span></span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    ...</span><br><span class="line">&#125;redis client;</span><br></pre></td></tr></table></figure><p><strong>套接字描述符fd</strong></p><p>根据客户端类型不同：</p><ul><li>fd为-1表示伪客户端。</li><li>fd为大于-1的整数时表示普通客户端。</li></ul><p>伪客户端就是用于处理的命令请求来源于AOF或Lua脚本，不需要套接字连接，也就不需要套接字记录符。普通客户端就是所有来源于网络需要套接字连接的客户端。</p><p><strong>标志flags</strong></p><p>标志flags记录了客户端的角色。有主从标志，Lua伪客户端标志，执行MONITOR标志…标志可以以二进制来拼接：flags:<flag1>|<flag2>|<flag3>…</p><p><strong>输入缓冲区querybuf</strong></p><p>输入缓冲区存储客户端输入的指令，大小根据输入内容动态缩小扩大，最大不可超过1G，否则导致服务器关闭该客户端。</p><p><strong>命令与参数(argv，argc）</strong></p><p>在将客户端输入的命令保存到querybuf后，服务器将对命令进行解析，并将得到的命令参数以及命令参数的个数存放到数组argv和整数argc中，其数据结构是这样的：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150757.jpg" alt="img"></p><blockquote><p>当客户端输入命令后，服务器根据argv[0]的值在命令表中查找（命令不区分大小写）对应命令的函数并给cmd赋值，cmd就是对应的命令函数相关的操作信息。</p><p>命令表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令的redisCommand结构，这个结构保存了命令的实现函数、命令的标志、命令需要的参数个数以及总执行次数和总消耗时长等统计信息。</p></blockquote><p><strong>输出缓冲区（buf，bufpos，reply）</strong></p><p>输出缓冲区有两个，一个大小固定，一个大小可变。大小固定的存储长度小的回复，比如OK，错误返回等。大小可变缓冲区保存长度较大的回复，比如长列表，大集合。</p><p>大小可变缓冲区由reply链表实现，利用链表结构存储若干和字符串对象，使得长度不会受到限制。</p><p>其数据结构如下：</p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150003.png" alt="image-20220104200809219" style="zoom:30%;" /><p><strong>时间（ctime，lastinteraction，obuf_soft_limit_reached_time）</strong></p><ul><li>ctime属性记录了创建客户端的事件</li><li>lastinteraction属性记录了客户端与服务器最后一次进行互动的事件</li><li>obuf_soft_limit_reached_time记录了输出缓冲区第一次到达软性限制的时间</li></ul><blockquote><p>服务器使用两种模式来限制客户端输出缓冲区的大小:</p><ul><li>硬性限制( hard limit):如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li><li>软性限制(softlimit):软性限制比硬性限制小，服务器会根据输出缓冲区大小介于软硬性限制之间的时间决定是否关闭客户端 。</li></ul></blockquote><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><p>由于客户端有不同类型，所以创建和关闭的方式也不相同。</p><p><strong>创建普通客户端</strong></p><p>客户端连接时调用connect函数，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将该新的客户端状态添加到client链表末尾。</p><p><strong>关闭普通客户端</strong></p><p>普通客户端可因其中一个原因关闭：</p><ul><li>客户端进程退出或者被杀死</li><li>客户端向服务器发送了带有不符合协议格式的命令请求</li><li>客户端成为了CLIENT KILL命令的目标</li><li>用户为服务器设置了timeout配置选项且当客户端的空转时间超过timeout时。不过timeout选项有一些例外情况：若客户端是主服务器，从服务器，正在被BLPOP等命令阻塞，或正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li><li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小(默认为1GB)</li><li>输出缓冲区的大小超过了硬性限制所设置的大小</li><li>输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制的时间超过指定时间。</li></ul><p><strong>Lua脚本的伪客户端</strong></p><p>服务器初始化时创建，随服务器结束关闭。</p><p><strong>AOF文件的伪客户端</strong></p><p>载入AOF文件时创建，载入结束关闭。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>简而言之，这章就是在解释客户端<strong>输入Redis指令到返回结果的执行过程</strong>。</p><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>首先是Redis服务器初始化操作，服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p><ol><li>初始化服务器状态。</li><li>载入服务器配置。</li><li>初始化服务器数据结构。</li><li>还原数据库状态。</li><li>执行事件循环。</li></ol><p><strong>初始化服务器状态结构</strong></p><p>主要是对redisServer结构体的初始化，包括设置服务器运行ID，运行频率，设置配置文件路径，设置持久化条件，命令表创建等。</p><p><strong>载入配置选项</strong></p><p>根据用户设定的配置，对redisServer相关变量的值进行修改，比如端口号，数据库数量，RDB的压缩是否开启等等。其他属性还是沿用默认值。</p><p><strong>初始化服务器数据结构</strong></p><p>对除了命令表外的数据结构（包括客户端链表，db数组，订阅信息，Lua脚本执行环境，慢查询日志相关属性等等）进行初始化。</p><blockquote><p>服务器必须先载入用户配置，才能对其他数据结构进行准确初始化。否则，若是先初始化再根据用户配置设定相关值，那么若是用户配置的值和默认值不同，且该配置和数据结构有关，那么服务器就要重新调整和修改已创建的数据结构。这样就会比较麻烦。</p></blockquote><p><strong>还原数据库状态</strong></p><p>载入RDB或AOF文件的数据恢复过程。</p><p><strong>执行事件循环</strong></p><p>至此，服务器可接收客户端请求并发送信息。</p><h3 id="命令执行过程"><a href="#命令执行过程" class="headerlink" title="命令执行过程"></a>命令执行过程</h3><p>以<code>SET key value</code>为例，命令的执行过程是：</p><ol><li>客户端发送命令。</li><li>服务器接收并处理请求，对数据库操作，回复OK。</li><li>服务器将命令回复OK返回给给客户端。</li><li>客户端接收命令并打印结果。</li></ol><p>下面将按照步骤拆解为发送，读取查找，执行预备操作，调用实现函数，执行后续工作，回复，打印操作讲解。</p><p><strong>发送</strong></p><p>客户端接收命令请求时，会将命令根据协议转为固定格式再发送给服务器。</p><p><strong>读取</strong></p><p>当套接字因客户端的写入变得可读时，服务器会先读取协议格式内容并保存到输入缓冲区。命令分析，提取参数及个数，存入argv和argc属性。最后调用命令执行器。</p><p><strong>命令执行器-查找命令的实现</strong></p><p>命令表是一个<strong>字典</strong>，键是命令名字，值是redisCommand结构。几个重要属性如下：</p><ul><li>name：命令名称。</li><li>proc：指向命令实现函数。</li><li>arity：命令参数个数，包括命令名称。</li><li>sflags：命令属性。</li></ul><p>查找命令表的过程就是找到redisCommand，把指针指向它：</p><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150982.jpg" alt="img"></p><p><strong>命令执行器-执行预备操作</strong></p><p>在命令真正执行前需要有预备操作保证命令可以被正确，顺利地执行。这个环节相当于一层过滤，比如检查命令是否正确，参数是否正确，身份验证是否通过，内存是否够用等等。保证配置生效，准确执行。</p><p><strong>命令执行器-调用命令的实现函数</strong></p><p>执行过程就是调用之前找到并指向的执行函数。通过client-&gt;cmd-&gt;proc(client);调用。然后将回复保存在客户端状态的输出缓冲区中，关联该套接字的命令回复处理器。</p><p><strong>命令执行器-执行后续工作</strong></p><p>有一些善后工作还将继续，比如慢查询日志记录，执行时长记录，AOF持久化，主服务器将命令传给从服务器。当这些都处理完后，服务器就继续从文件事件处理器中取出并执行下一个命令请求。</p><p><strong>将命令回复发送给客户端</strong></p><p>当客户端套接字变为可写状态，服务器执行命令回复处理器，将输出缓冲区的回复发送给客户端。</p><p><strong>客户端接收并打印命令回复</strong></p><p>将回复转为人类可读的格式，打印给用户看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库章节主要介绍键值对的宏观存储是怎么实现的和过期策略。通过RedisServer进行组织，用<strong>字典存键值对</strong>，具体数据结构<strong>按照对象的编码存储</strong>。客户端与服务器主要通过<strong>共享指针</strong>的方式来共享库对象。键的过期时间是按照单独的键过期字典存储的，设置过期时间的命令<strong>都会转换为PEXPIREAT</strong>来实现。Redis使用<strong>惰性删除</strong>和<strong>定期删除</strong>作为移除策略。每次对键的读取都会判断是否过期，定期抽查并删除过期键。</p><p>RDB持久化章节主要介绍持久化机制和发生时机，BGSAVE指令对其他指令的<strong>排斥性</strong>，RDB文件结构。RDB文件载入时，主服务器会<strong>检查键是否过期</strong>。RDB的实现分为SAVE和BGSAVE，<strong>SAVE会阻塞</strong>，BGSAVE是通过fork子进程来写RDB文件的方式，来记录Redis的数据库快照。BGSAVE随着serverCron函数的执行，每次都会判断是否有必要执行。</p><p>AOF持久化章节主要介绍持久化机制，时机，重写过程。AOF文件<strong>载入时不会判断键是否过期</strong>，只是执行文件中的命令。AOF开启后，执行一个写命令就会被<strong>追加到aof_buf</strong>中。AOF持久化过程是根据其同步策略配置，一次事件循环，一定会将aof_buf中的命令写到操作系统缓冲区，在根据配置考虑是否需要<strong>强制写入磁盘</strong>。AOF重写是对文件的瘦身计划，为了解决子进程执行AOF文件重写前后数据库状态不一致的问题，AOF重写缓冲区会<strong>记录在这期间对数据库的变更</strong>，子进程结束后<strong>发信号</strong>，主进程接收后会<strong>进入阻塞阶段</strong>，同步重写缓冲区至新的AOF文件。</p><p>事件章节主要介绍文件事件和时间事件。文件时间是<strong>对套接字操作</strong>的事件，时间事件是<strong>对定时操作</strong>相关的事件。文件事件利用I/O多路复用程序<strong>监听多个套接字</strong>，根据相应的<strong>可读/可写事件</strong>来触发并移交给文件事件分派器，分派器会给具体的<strong>事件处理器处理</strong>。然后介绍了时间事件的组成，serverCron的职能，主要负责对资源的检查，更新，判断操作。对于两种事件同时出现情况的处理机制，利用<strong>等待时间事件的空隙</strong>作为文件事件的最大阻塞时间，然后先处理随机的文件事件，再处理时间事件。不浪费CPU资源，提高效率。</p><p>客户端章节主要介绍<strong>redisClient的属性</strong>，包括套接字描述符，输入缓冲区，时间等。然后介绍普通客户端的创建和关闭原因，是通过对应的事件处理器进行的。其他的伪客户端主要是AOF伪客户端按卸磨杀驴的套路，在载入时创建，载入结束后关闭。</p><p>服务器章节主要描述了Redi<strong>s一条指令的执行过</strong>程，从初始化到具体的过程细化，发送命令，读取命令，查找命令字典，执行预备操作，调用实现函数，善后工作，发送回复，客户端打印。</p>]]></content>
      
      
      <categories>
          
          <category> 《Redis设计与实现》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现:数据结构与对象</title>
      <link href="2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>redis3.0 标有注解的源码：<a href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p></blockquote><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>Redis中，涉及可以被修改的字符串值时，都用<strong>简单动态字符串</strong>（simple dynamic string，SDS）来实现。比如包含字符串值的键值对在底层的实现。C字符串（C语言中传统字符串，以空字符串结尾的字符数组）则用于<strong>无须对字符串进行修改</strong>的地方，比如日志打印。</p><p>SDS还被用作缓冲区，比如AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。</p><h3 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//buf已使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//buf未使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf遵循C字符串以空字符串结尾的惯例，保存空字符串的1字节空间不计算在SDS的len属性里面，并为空字符分配<strong>额外1字节</strong>空间，对用户来说是透明的。</p><p>SDS结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182029378.jpg" alt="img"></p><p>图中展示了SDS的数据结构，5字节未使用空间，已使用5字节，buf存储了字符串值，最后一个字节保存了空字符<code>&#39;\0&#39;</code>。这里要注意的是，free和len的计算不涉及空字符。</p><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><ol><li>SDS有<strong>常数级的时间复杂度</strong>获取字符串长度。<br>由于C字符串不会记录自身长度，因此只能遍历，直到遇到结尾的空字符为止,时间复杂度为O(N)。而SDS对于字符串长度的记录都是在其API中执行的，所以时间复杂度为**O(1)**。</li><li>SDS<strong>杜绝缓冲区溢出。</strong><br>由于C字符串未记录自身长度，容易导致缓冲区溢出。在执行字符串拼接时，如果没有足够的空间，并且相邻内存地址被其他字符串占用时，字符串的<strong>数据将溢出</strong>，且容易<strong>意外修改相邻的字符串内容</strong>。相比而言，SDS会将这种情况扼杀在摇篮之中，SDS API先判断<strong>空间是否满足</strong>，如果不满足则将空间<strong>扩展至执行修改所需的大小</strong>。</li><li>SDS拥有的<strong>内存分配策略</strong>可以减少修改字符串造成的内存重分配次数，详见1.3。</li><li>SDS API都是<strong>二进制安全</strong>的。<br>C字符串的字符<strong>必须符合某种编码</strong>，并且中间<strong>不能</strong>有空字符，否则读取时会被误以为是字符串结尾。种种局限使得C字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保Redis对不同使用场景的支持，SDS API都是二进制安全的，也就是所有SDS API都会以<strong>二进制的方式</strong>存取buf中的数据，数据的写入和读出都是一个样的。由于SDS读取时并不是依靠空字符来判断结束的，而是<strong>len属性</strong>，所以是二进制安全的。</li><li><strong>兼容部分C字符串函数</strong>。<br> SDS虽然都是二进制安全的，但也<strong>遵循以空字符结尾</strong>的习惯。SDS API总会在buf数组分配空间时多分配一个字节用于容纳空字符，这是为了保存文本的SDS<strong>重用一部分</strong>&lt;string.h&gt;库函数，避免代码重复。</li></ol><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>由于C字符并<strong>不记录</strong>自身长度，并且需要一个字符空间保存空字符串，因此每次增长或缩短字符串时，就要对其进行一次<strong>内存重分配</strong>操作。增长字符串时要看空间是否够用，否则会有<strong>缓冲区溢出</strong>；缩短字符串要释放不用的空间，否则会有<strong>内存泄漏</strong>。</p><p>Redis经常被用于速度要求严苛，数据被频繁修改的场合，每次修改字符串都要重新分配内存，就会占用很多时间。为避免这个问题，redis采用了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略。</p><p><strong>空间预分配</strong></p><p>空间预分配用于优化SDS字符串<strong>增长操作</strong>。在扩展SDS空间前，SDS API会先检查未使用空间够不够，如果不够，则进行空间预分配。此时，程序<strong>不仅会为SDS分配修改所必须要的空间，还为其分配额外未使用的空间</strong>。 </p><ul><li>修改后的SDS&lt;1MB，程序分配和len属性<strong>同样大小</strong>的未使用空间，此时SDS的len与free大小相等。比如修改后实际存储字符串的空间变为13字节，那么len=13，free=13，buf数组整体的长度=13+13+1（额外1字节保存空字符）。</li><li>修改后SDS&gt;=1MB。程序会分配<strong>1MB</strong>的未使用空间。比如修改后实际存储字符串的空间变为2MB，那么len=2M，free=1MB，buf数组整体的长度=2MB+1MB+1byte。</li></ul><p>通过空间的预分配，将<strong>连续增长N次字符串需要的内存分配次数从一定需要N次变为最多N次</strong>。因而可以减少连续执行字符串增长操作所需的内存重分配的次数。</p><p><strong>惰性空间释放</strong></p><p>惰性空间的释放用于优化SDS字符串<strong>缩短操作</strong>。当SDS API需要缩短保存的字符串时，程序并不立即回收这部分内存，而是使用free属性将字节的数量记录，等待使用。与此同时，SDS提供了相关API，在有需要时，<strong>真正释放</strong>未使用空间，不需要担心惰性空间造成的内存浪费。</p><h3 id="SDS总结"><a href="#SDS总结" class="headerlink" title="SDS总结"></a>SDS总结</h3><p>C字符串与SDS的区别简单来说：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182030627.png" alt="image-20211218194706398" style="zoom:75%;" /><p>SDS相关操作及时间复杂度：</p> <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182030423.png" alt="image-20211218203032217" style="zoom:75%;" /><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>当一个列表键包含了数量比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>节点由前驱后继组成，多个节点组成的链表为双端链表。</p><p>使用<code>adlist.h/list</code>来持有，操作链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>整个链表串起来后，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182105328.png" alt="image-20211218210534199"></p><p>Redis的链表特性可以总结如下：</p><p><strong>双端</strong>：链表节点带有prev和next指针，获取前置和后置节点的复杂度都是O(1)。<br><strong>无环</strong>：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。 带表头指针和表尾指针 带链表长度计数器 。<br><strong>头尾指针</strong>：将程序获取头尾节点的复杂度降为O(1)。<br><strong>长度计数器</strong>：将程序获取表长的复杂度降为O(1)。<br><strong>多态</strong>：链表节点使用void*指针来保存节点值，并且可以通过list结构的<code>dup、free、match</code>为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p><h3 id="链表时间复杂度"><a href="#链表时间复杂度" class="headerlink" title="链表时间复杂度"></a>链表时间复杂度</h3><p>链表相关操作及时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182106389.png" alt="image-20211218210638244" style="zoom:75%;" /> <h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典又称<strong>符号表</strong>，<strong>关联数组</strong>或<strong>映射</strong>，用于保存键值对的抽象数据结构。当一个哈希键包含的键值对比较多时，或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个哈希表节点</strong>，每个哈希表节点保存了字典中的<strong>一个键值对</strong>。</p><p><strong>哈希表</strong></p><p>使用<code>dict.h/dictht</code>结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><p>数组中的每个元素都是指向<code>dict.h/dictht</code>的结构，dictEntry就是一个键值对。</p><p><strong>哈希表节点</strong></p><p>哈希表节点使用dictEntry实现，每个dictEntry都存储着一个键值对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>键值对的值可以是一个指针，或一个<code>uint64_t</code>整数，或一个<code>int64_t</code>整数。next是<strong>指向另一个哈希节点的指针</strong>，可将多个<strong>哈希值相同的键值对连接在一起</strong>，以此来解决冲突。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182112502.png" alt="image-20211218211218390"></p><p>如图，表示的是两个哈希值相同的节点，通过指针连接在一起。</p><p><strong>字典</strong></p><p>Redis中的字典由<code>dict.h/dict</code>实现，由这个数据结构将字典组织在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type和privdata属性是<strong>针对不同类型</strong>的键值对，为丰富键值对的使用场景而设置的。</p><ul><li>type属性是一个指向dictType的结构指针，每个dictType结构保存了一簇用于<strong>操作特定类型键值对的函数</strong>，Redis为用途不同的字典设置不同类型特定函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li><li>ht属性是包含<strong>两个项</strong>的数组，每项都是一个哈希表，ht[0]平时使用，而ht[1]仅在rehash时使用。</li><li>rehashidx记录了rehash的进度，初始为-1。</li></ul><p>下图展示了一个普通状态下（没有进行rehash）的字典：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182135997.png" alt="image-20211218212233398"></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>Redis计算哈希值方法： <code>hash=dict-&gt;type-&gt;hashFunction(key);</code><br>计算索引值的方法：<code>index=hash &amp; dict-&gt;ht[x].sizemask;</code> </p><p>当字典被用作数据库的底层实现或哈希键的底层实现时，Redis使用<strong>MurmurHash2算法</strong>来计算键的哈希值。优点在于即使输入的键是有规律的，算法仍然能给出<strong>很好的随机分布性</strong>，并且计算<strong>速度飞快</strong>。</p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上的键被分配到哈希表的<strong>同个索引</strong>，那么就发生了冲突。Redis使用链地址法来解决冲突，被分配到相同索引的多个节点<strong>使用链表连接</strong>。为了提高速度，每次都是将新节点添加到链表的<strong>表头</strong>位置。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>为了让哈希表的负载因子维持在一个<strong>合理的范围内</strong>，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行响应的扩容或缩容。扩容和缩容通过执行rehash来完成，Redis中<strong>重新散列的步骤</strong>如下：</p><ol><li>为字典ht[1]哈希表<strong>分配空间</strong>，大小取决于要执行的操作与ht[0]<strong>当前键值对的数量</strong>。</li><li>将保存在ht[0]中的所有键值对存放到ht[1]指定的位置</li><li>当ht[0]的所有键值对都迁移完毕后，<strong>释放ht[0]**，并</strong>指向ht[1]**，并在ht[1]上创建一个空的哈希表，为下次rehash准备。</li></ol><p><strong>扩容与缩容场景</strong></p><p>扩容操作场景：</p><ul><li>服务器目前没有在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子&gt;=1</strong>。</li><li>服务器正在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令，并且哈希表的<strong>负载因子&gt;=5</strong>。</li></ul><p>负载因子=哈希表已存储节点数/哈希表大小， 即 <code>load_factor=ht[0].used/ht[0].size</code> </p><blockquote><p>为什么根据**<code>BGSAVE</code><strong>命令或</strong><code>BGREWRITEAOF</code><strong>命令来判断是否扩展？<br>因为执行这些命令时，Redis需要创建当前服务器进程的</strong>子进程<strong>，大多数操作系统采用</strong>写时复制技术**来优化子进程使用效率，此时提高负载因子，可以尽量避免在子进程存在期间对哈希表扩展，避免不必要的内存写入操作，节约内存。</p></blockquote><p>缩容操作场景：</p><p><strong>负载因子&lt;0.1</strong>时，<strong>自动</strong>对哈希表执行收缩操作。</p><h3 id="渐进式rehash的过程"><a href="#渐进式rehash的过程" class="headerlink" title="渐进式rehash的过程"></a>渐进式rehash的过程</h3><p>rehash时会将ht[0]中所有的键值对rehash到ht[1]，如果键值对很多并且一次性操作的话，容易导致服务器在<strong>一段时间内停止服务</strong>。为避免这种情况，Redis采用渐进式rehash，将ht[0]中的键值对分多次，<strong>慢慢地rehash</strong>到ht[1]之中。</p><p>步骤：</p><ol><li>为ht[1]分配空间，让字典同时持有两个哈希表。</li><li>在字典中维持一个<strong>索引计数器变量rehashidx</strong>，将其设置为0，表示rehash正式开始。</li><li>在rehash进行期间，每次对字典进行<strong>添加，删除，查找或更新</strong>操作时，程序除了执行指定的操作外，还会将ht[0]哈希表在rehashidx索引上的所有键值对**rehash到ht[1]**，当rehash工作完成后，将rehashidx++。</li><li>某个时刻，ht[0]中的所有键值对都被rehash至ht[1]，此时设置rehashidx=-1时，表示rehash操作已经完成。</li></ol><p>这种方式的rehash的好处在于采用了分而治之的方式，将rehash键值对所需的<strong>计算工作均摊到对字典的每个操作中</strong>，从而避免集中式rehash带来庞大计算量。</p><p>在rehash的期间，字典<strong>同时使用</strong>ht[0]，ht[1]两个哈希表。对哈希表的操作会在两个表上进行，比如查找键时，<strong>先在ht[0]里面查找</strong>，如果为空，就<strong>继续到ht[1]里查找</strong>。在此期间，新增的键值对<strong>都会被添加到ht[1]**中，ht[0]**不承担任何添加</strong>操作，保证ht[0]中的键值对只能是<strong>越来越少</strong>。</p><h3 id="字典时间复杂度"><a href="#字典时间复杂度" class="headerlink" title="字典时间复杂度"></a>字典时间复杂度</h3><p>字典相关操作及时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112182114711.png" alt="image-20211218211457606" style="zoom:75%;" /> <h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表是一种<strong>有序</strong>的数据结构，通过在每个节点<strong>维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。</p><p>如果一个有序集合中包含的元素数量比较多，又或者有序集合中元素的成员是较长的字符串，Redis就会使用跳跃表来作为有序集合键的底层实现。Redis只有在两个地方用到了跳跃表，一个是实现<strong>有序集合键</strong>，另一个是在<strong>集群节点中</strong>作为内部数据结构。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个数据结构定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    structz zskiplistNode *header,* tail;</span><br><span class="line">    <span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳跃表由zskiplist组织，通过多个跳跃表节点zskiplistNode组成一个跳跃表。值得注意的是，记录level时，表头节点的层高不会记录在内。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201044622.png" alt="image"></p><p><strong>跳跃表节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> strct zskiplistNode&#123;</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistlevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ol><li><p>层–level</p><p>跳跃表的每个节点都会包含多个层，每次创建一个新跳跃表节点时，都会根据<strong>幂次定律</strong>，随机生成一个1~32之间的数作为层的大小。每个层都会包含前进指针和跨度。</p><p>前进指针（forword）用于访问下一个节点。跨度表示<strong>两个节点之间的距离</strong>，指向NULL的所有前进指针的<strong>跨度为0</strong>。跨度用于计算排位，访问某一结点的经过的<strong>跨度之和</strong>就是当前节点的排位。</p><p>注：幂次定律也是80-20法则。最重要的只占一小部分，越大的数出现的概率越小。Redis中对level的随机获取实现是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>后退指针–backward</p><p>用于从表尾向表头方向访问节点，<strong>前进指针可以一次跳过多个节点</strong>，后退指针<strong>只能后退至前一个</strong>节点，因为每个节点只有一个后退指针。</p></li><li><p>分值–score</p><p>分值是一个<strong>double类型的浮点数</strong>，跳跃表中节点都按照分值排序。</p></li><li><p>成员对象–obj</p><p>是一个指针，指向字符串<strong>SDS对象</strong>。一个跳跃表中，<strong>对象必须是唯一的，但分值可以相同</strong>。相同时按对象字典序来排序。</p></li></ol><blockquote><p><strong>思考</strong></p><p>我看代码的时候就有个疑问，书上也没有给出清晰的解释，通过看帖子和自己的理解总结了一下。Redis的level个数为什么要<strong>用幂次定律生成（随机生成节点的层数）</strong>？</p><p>通过幂次定律能保证越高level的结点数量越少 。保证索引等级越高，<strong>参与索引建立的元素越少</strong>，如果每层都有很多level，那么这个索引建立的就没有意义了。那么，为什么不用最均衡的方式，按照节点分数的排序情况均匀建立索引？考虑到下一个插入的元素<strong>具有随机性</strong>，这样设计<strong>不容易出现最坏的情况</strong>。如果每次都以均匀固定的方式建索引，<strong>维护的成本很高</strong>，跳跃表的优点就是维持结构平衡的成本低，完全依靠随机。跳跃表相比二叉树有一个优势就在于<strong>不需要主动rebalance</strong>去维护平衡。</p></blockquote><h3 id="跳跃表的操作"><a href="#跳跃表的操作" class="headerlink" title="跳跃表的操作"></a>跳跃表的操作</h3><p><strong>插入</strong></p><p>初始跳跃表如下图：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201044473.jpg" alt="img" style="zoom:67%;" /><p>插入11.0，随机层数为2。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201045619.jpg" alt="img" style="zoom:67%;" /><p>观察可知，插入操作仅新增节点和指针变化，不需要对整体的平衡进行额外维护操作。</p><p><strong>查找</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201045390.jpg" alt="img" style="zoom:67%;" /><p>跳跃表查找10的过程如上图，由于数字标注的是<strong>查找顺序</strong>，所以不标注跨度以免引起歧义。此时跳跃表查找10，会先从header节点（O1）的最高层（L3）寻找，发现要查找的数小于23.5则返回，继续从下一个有后继的层开始寻找，当发现要查找的数小于11.0时，则从O1的下一层找，此时到O2的L1，发现要查找的数大于7.0，则从L1找，直到查找到相邻节点为止。</p><p><strong>删除</strong></p><p>节点的删除操作比较简单，查找到要删除的节点后，再处理好前后节点的前驱后继就可以啦~</p><p>拓展阅读：<a href="https://zhuanlan.zhihu.com/p/109946103">https://zhuanlan.zhihu.com/p/109946103</a></p><h3 id="跳跃表的时间复杂度"><a href="#跳跃表的时间复杂度" class="headerlink" title="跳跃表的时间复杂度"></a>跳跃表的时间复杂度</h3><p>跳跃表相关操作及时间复杂度：</p> <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201045658.png" alt="image-20211220102700170" style="zoom:75%;" /><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>当一个集合只包含整数元素，并且元素不多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合是Redis中用于保存整数值的集合<strong>抽象数据结构</strong>，可以保证集合<strong>有序不重复</strong>。每个<code>intset.h/intset</code>结构来表示一个整数集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>length属性记录了整数集合包含的元素数量，contents是整数集合的底层实现。contents存储元素的真实类型<strong>取决于encoding</strong>，比如<code>encoding==INT_ENC_INT16</code>时，contents数组中每个向都是int16_t类型的整数。可以为<code>int16_t</code>,<code>int32_t</code>或<code>int64_t</code>。</p><p>下图展示了整数集合的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201102377.png" alt="image-20211220110233149"></p><p><strong>升级</strong></p><p>当我们要将一个新元素添加至集合时，并且新元素的类型<strong>比现有集合类型都长</strong>时，整数集合就要升级。</p><p>步骤：</p><ol><li>根据新元素类型，<strong>扩展</strong>数组空间，并为新元素分配空间。</li><li>将底层数组现有所有元素<strong>都转为新元素相同类型</strong>，并将类型转换后的元素放到正确位置。</li><li>将新元素<strong>添加</strong>到底层数组。</li></ol><p>由于每次向整数集合添加新元素都<strong>可能会引起升级</strong>，而每次升级都需要对底层数组中已有元素进行类型转换，所以添加的**时间复杂度为O(N)**。</p><p><strong>升级的好处</strong></p><p>有两个好处，可以提升整数集合的<strong>灵活性</strong>，也能尽可能地<strong>节约内存</strong>。<br>C语言是静态类型语言，一般数组中的元素类型都相同，使用升级可以<strong>不用担心类型兼容</strong>问题，提升灵活性。元素统一以最大类型存储，而不是都用<code>int64_t</code>，可节约内存。</p><p><strong>降级</strong></p><p>整数集合<strong>不支持降低</strong>，一旦升级就不能降级。</p><h3 id="整数集合的时间复杂度"><a href="#整数集合的时间复杂度" class="headerlink" title="整数集合的时间复杂度"></a>整数集合的时间复杂度</h3><p>整数集合相关操作及时间复杂度：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201106980.png" alt="image-20211220110628831" style="zoom:75%;" /> <h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表是<strong>列表键、哈希键和有序集合键</strong>底层实现之一。当一个列表键只包含少量列表项，且每个列表项要么是小整数，要么是长度比较短的字符串，Redis就使用压缩列表来做列表键的底层实现。哈希键和有序集合键也类似。</p><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>为节约内存而开发的，由一系列<strong>特殊编码</strong>的<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构。</p><p>下图为压缩列表的数据结构:</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201119209.png" alt="image-20211220111940022"></p><p>结构比较简单，属性如下：</p><ul><li>zlbytes：记录整个压缩列表占用<strong>内存字节数</strong>，进行内存重分配或计算zlend时使用。</li><li>zltail：记录压缩列表尾节点<strong>距离压缩列表起始地址</strong>多少字节。</li><li>zllen：节点数量。小于65535时，表示<strong>节点数量</strong>；等于时，需要<strong>遍历</strong>才能计算得出。</li><li>entryx：列表节点。</li><li>zlend：特殊值0xFF用于<strong>标记压缩列表的末端</strong>。</li></ul><h3 id="压缩列表节点的组成"><a href="#压缩列表节点的组成" class="headerlink" title="压缩列表节点的组成"></a>压缩列表节点的组成</h3><p>每个压缩列表节点可以是一个<strong>字节数组</strong>，也可以是一个<strong>整数</strong>。由<code>previous_entry_length，encoding，content</code>组成。</p><p><strong>previous_entry_length</strong></p><p>单位是字节，记录压缩列表<strong>前一个节点的长度</strong>。该属性长度为<strong>1字节或5字节</strong>，前<strong>两位</strong>表示该属性长度为1字节还是5字节。</p><ul><li>前一个节点的长度&lt;254字节时，该属性只有<strong>1字节</strong>，且前一节点的长度就保存在这一个字节。如0x05，表示前一个字节长度为5字节。</li><li>前一个节点的长度&gt;=254字节时，该属性有<strong>5字节</strong>，且该属性的第一字节会被设置成0xFE，表示这是一个5字节的长度，后4字节表示前一个节点的长度。如0xFE00002766，表示前一个字节长度为0x00002766，换算为10进制就是我们熟悉的数字。</li></ul><p><strong>encoding</strong></p><p>encoding记录了节点的content属性所保存<strong>数据类型</strong>和<strong>长度</strong>。<strong>高两位</strong>表示存储的是字节数组还是整数。</p><p><strong>content</strong></p><p>存储节点的值。</p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>当<strong>多个连续</strong>的长度<strong>介于250字节到253字节</strong>之间的节点，插入新的头节点（长度大于等于254字节），后面节点的previous_entry_length就要新增4字节的空间（1字节变成5字节），需要进行<strong>内存重分配</strong>，由于前一个节点的变更，每个节点的previous_entry_length属性<strong>也需要记录之前的长度而发生相应的变更</strong>，所以会出现连锁更新。除了新增节点，删除节点也可能会遇到这种情况。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行<strong>N次空间重分配操作</strong>，每次<strong>重分配的的最坏时间复杂度</strong>为 <img src="https://www.zhihu.com/equation?tex=O(N)" alt="[公式]"> ，所以连锁更新的<strong>最坏时间复杂度为</strong> <img src="https://www.zhihu.com/equation?tex=O(N%5E2)" alt="[公式]"> </p><p>虽然代价很高，但是出现的<strong>几率比较低</strong>，而且只要更新节点的数量不多，就不会对性能产生影响。因此ziplistPush命令的<strong>平均复杂度为</strong> <img src="https://www.zhihu.com/equation?tex=O(N)" alt="[公式]"> 。</p><h3 id="压缩列表的时间复杂度"><a href="#压缩列表的时间复杂度" class="headerlink" title="压缩列表的时间复杂度"></a>压缩列表的时间复杂度</h3><p>压缩列表相关操作及时间复杂度：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201129046.png" alt="image-20211220112937849"> </p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Redis<strong>没有直接使用</strong>前文的数据结构来实现键值对数据库，而是基于这些数据结构构建了一个对象系统，通过对象组织数据结构，包括<strong>字符串对象，列表对象，哈希对象，集合对象</strong>和<strong>有序集合对象这</strong>5种对象。</p><p>使用对象的一个好处是可以针对不同的使用场景，为对象<strong>设置多种不同的数据结构实现</strong>，从而优化对象在不同场景下的使用效率。</p><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p>Redis使用对象来表示数据库的键和值。每个对象都是一个redisObject结构，是一个按照位段存储的结构，节约内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type :<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>其中，type是类型常量，记录对象的类型：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%5Bb%5D+%7B%7Cc%7Cc%7C%7D++%5Chline+%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F&+%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E5%AD%97%5C%5C++%5Chline+REDIS%5C_String++&+%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1+%5C%5C++%5Chline+REDIS%5C_List&+%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1+%5C%5C++%5Chline+REDIS%5C_HASH++&%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1+%5C%5C+++%5Chline+REDIS%5C_SET++&+%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1+%5C%5C+++%5Chline+REDIS%5C_ZSET++&+%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1+%5C%5C++%5Chline+%5Cend%7Barray%7D%5C%5C" alt="[公式]"> </p><p>encoding记录对象使用的编码，即对象底层使用的具体数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936332.jpg" alt="img"></p><p>使用object encoding命令可以查看键的值对象的编码，每个对象都至少使用两种不同编码常量：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936516.jpg" alt="img"></p><blockquote><p>注：Redis中的列表对象在版本3.2之前，列表底层的编码是ziplist和linkedlist实现的，但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</p></blockquote><p>Redis对象采用<strong>encoding属性来设置编码</strong>，从而<strong>决定底层数据结构</strong>，而不是为特定类型的对象关联一种固定编码。这种方式极大地提高了灵活性和效率。</p><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象可以是<strong>int，raw</strong>或<strong>embstr</strong>。 </p><ul><li>如果字符串对象保存的是<strong>整数值</strong>，且这个数值<strong>可用long</strong>表示，底层就会以**<code>REDIS_ENCODING_INT</code>**编码来实现。</li><li> 如果字符串对象是一个字符串值，且这个字符串长度**&gt;32字节<strong>，字符串将使用一个SDS保存，底层编码为</strong><code>REDIS_ENCODING_RAW</code>**。 </li><li>如果字符串对象保存的是字符串，且这个字符串长度**&lt;=32字节<strong>，底层编码就是</strong><code>REDIS_ENCODING_EMBSTR</code>**，使用embstr编码的方式保存字符串。</li></ul><p>下图为raw编码的字符串对象：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936272.jpg" alt="img"></p><p><strong>embstr编码</strong></p><p>专门用于保存短字符串的一种优化编码方式，与raw的效果相同，都使用redisObject和sdshdr结构来表示字符串对象，但是raw会调用两次内存分配函数<strong>分别创建</strong>redisObject和sdshdr结构。embstr编码则通过调用<strong>一次内存分配</strong>函数来分配一块连续空间，空间依次包括redisObject和sdshdr俩结构。</p><p>使用embstr编码保存短字符串的<strong>优点</strong>：</p><ul><li>内存分配次数由两次降为<strong>1次</strong>。</li><li>释放embstr字符串对象只需调用<strong>1次</strong>内存释放函数。</li><li>embstr字符串放在一块连续的内存中，能更好地<strong>利用缓存</strong>带来的优势.</li></ul><p>注：<strong>浮点数</strong>的存储，在Redis底层也会以<strong>字符串的形式</strong>保存。在有需要时，程序会将字符串对象中的字符串值<strong>转为浮点数值</strong>执行运算操作，然后再将结果<strong>转为字符串值</strong>保存。</p><p><strong>编码的转换</strong></p><p><code>int-&gt;raw</code>：对int编码的字符串对象执行后，保存的不再是整数值，而是字符串值时，就会转换成raw编码的字符串。比如整数追加字符串。</p><p><code>embstr-&gt;raw</code>：Redis没有为embstr编写修改程序，所以是<strong>只读的</strong>，当embstr编码的字符串修改后，就变成raw编码的字符串对象。</p><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码是ziplist或linkedlist。</p><p>当列表可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都**&lt;64字节**</li><li>列表对象保存的元素数量**&lt;512个**</li></ul><p>否则使用linkedlist编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用ziplist编码，执行<code>RPUSH elements &quot;a&quot; &quot;b&quot; 1</code>，后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936647.jpg" alt="img"></p><p>使用linkedlist编码，执行<code>RPUSH elements &quot;a&quot; &quot;b&quot; 1</code>，后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936381.jpg" alt="img"></p><blockquote><p>注：SDS对象都<strong>以StringObject代替</strong>。</p></blockquote><blockquote><p><strong>注：Redis中的列表对象在版本3.2之前，列表底层的编码是ziplist和linkedlist实现的，但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</strong></p><p>quicklist的介绍可参考：<a href="https://juejin.cn/post/6844904023418486791">https://juejin.cn/post/6844904023418486791</a></p></blockquote><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或hashtable。</p><ul><li>ziplist的数据结构：每当有新的键值对插入哈希对象时，Redis会先将保存键的压缩列表节点推入表尾，再将保存值的压缩列表节点推入表尾。</li><li>hashtable的数据结构：字典的每个键都是一个字符串对象，保存键；字典的每个值都是字符串对象，保存值</li></ul><p>当哈希对象可以同时满足下两个条件时，使用<strong>ziplist编码</strong>：</p><ul><li>哈希对象保存的所有键值对的值和键<strong>都&lt;64字节</strong></li><li>哈希对象保存的键值对数量**&lt;512个**</li></ul><p>否则使用hashtable编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用<strong>ziplist</strong>编码，执行<code>HSET student name &quot;madongmei&quot; age 25 career &quot;pick up trash&quot;</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936878.jpg" alt="img"></p><p>使用<strong>hashtable</strong>编码，执行<code>HSET student name &quot;madongmei&quot; age 25 career &quot;pick up trash&quot;</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201936135.jpg" alt="img"></p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset或hashtable。</p><p>如果以hashtable编码作为<strong>集合对象</strong>底层实现，那么字典的每个键都是一个<strong>字符串对象</strong>，值都是<strong>null</strong>。</p><p>当集合对象同时满足以下两个条件时，使用intset编码：</p><ul><li>集合对象保存的所有元素<strong>都是整数值</strong></li><li>集合对象保存的元素数量**&lt;=512个**</li></ul><p>否则使用hashtable编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><p>使用<strong>intset</strong>编码，执行<code>SADDnumbers 1 3 5</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937548.jpg" alt="img"></p><p>使用<strong>hashtable</strong>编码，执行<code>SADDnumbers 1 3 5</code>后的数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937885.jpg" alt="img"></p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是ziplist或skiplist。</p><p>使用<strong>ziplist</strong>编码时，每个元素使用<strong>两个紧挨在一起的压缩列表节点</strong>来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937195.jpg" alt="img"></p><p>如果是<strong>skiplist</strong>编码，使用zset结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>dict字典为有序集合创建了一个从<strong>成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：键保存元素，值保存分值。通过字典以<strong>O(1)查找给定成员的分值</strong>。有序集合元素的成员都是<strong>字符串对象</strong>，分值都是<strong>double类型浮点数</strong>。zset的跳跃表和字典通过指针来<strong>共享相同元素</strong>的成员和分值，<strong>不会浪费</strong>额外内存。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937088.jpg" alt="img">当有序集</p><blockquote><p>上图中存在错误，应该是zsl指向跳表结构而不是由ptr指向</p></blockquote><p>合对象同时满足以下两条件时，对象使用ziplist编码：</p><ul><li>有序集合保存的元素数量**&lt;128个**</li><li>有序集合保存的所有元素成员的长度<strong>都&lt;64字节</strong></li></ul><p>否则使用skiplist编码。</p><p>注：两条件的上限值可通过配置文件修改。</p><blockquote><p><strong>思考</strong></p><p>为什么有序集合需要<strong>同时使用跳跃表和字典</strong>来实现？</p><p>如果只使用字典存储，由于是无序的，所以每次在<strong>范围查询时</strong>，需要排序，<strong>时间复杂度为 <img src="https://www.zhihu.com/equation?tex=O(NlogN)" alt="[公式]"> 和额外 <img src="https://www.zhihu.com/equation?tex=O(N)" alt="[公式]"> 的内存空间</strong>，因为要创建一个数组存储排序后的元素。 如果只用跳跃表实现，根据成员<strong>查找分值时</strong>，<strong>复杂度将为 <img src="https://www.zhihu.com/equation?tex=O(logN)" alt="[公式]"></strong> 。综上，为了让有序集合的分值查找和范围查找都尽可能快地执行，Redis选择字典和跳跃表两种数据结构结合的方式。</p></blockquote><h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis中用于操作键的命令可分为两种类型。一种是可对<strong>任何类型执行</strong>的，如del，expire，rename等。另一种命令只能对<strong>特定类型的键执行</strong>，如set，get，hdel，hset，rpush等。如果对特定类型使用其他类型的命令，那么就会报错。</p><p><strong>类型检查的实现</strong></p><p>为了确保只有制定类型的键可以执行某些特定命令，在执行前，Redis会先通过输入键的值对象的<strong>type属性</strong>检查输入键的类型是否正确。</p><p><strong>多态命令的实现</strong></p><p>Redis除了根据值对象判断键是否能够执行特定命令外，还会根据<strong>值对象的编码方式</strong>，选择正确的命令实现代码来执行。比如基于编码的多态，列表对象的编码可能是ziplist或linkedlist，所以需要<strong>多态命令执行</strong>对应编码的API。基于类型的多态是<strong>一个命令可以同时处理多种不同类型的键</strong>。</p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>由于C语言没有内存回收机制，Redis在对象系统中构建了<strong>引用计数器技术</strong>实现内存回收机制。每个对象的引用计数器信息由redisObject的refcount来记录。当对象的引用计数值<strong>为0</strong>时，所占用的内存<strong>会被释放</strong>。</p><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>引用计数器还有共享对象的作用。如果两个不同键的值都一样（必须是整数值的字符串对象），则将数据库键的值指针<strong>指向一个现有的值对象</strong>，然后将被共享对象的引用计数加一。如果不是整数值的对象，则需要耗费大量的时间<strong>验证共享对象和目标对象是否相同</strong>，复杂度较高，消耗CPU时间，所以Redis<strong>不会共享包含字符串的对象</strong>。</p><p>Redis在初始化服务时，会创建很多字符串对象，包含0~9999的整数（和Integer的常量池有点像），当需要时，就能直接复用。</p><p>下图展示了键共享整数100的字符串对象：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/202112201937381.jpg" alt="img"></p><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>redisObject还包含了lru属性，记录对象最后一次被命令程序访问的时间。<code>object idletime</code>命令可打印键的空转时长，就是<strong>当前时间减去lru时间</strong>计算得到的。</p><blockquote><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/140726424">https://zhuanlan.zhihu.com/p/140726424</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 《Redis设计与实现》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka进阶篇：可靠性探究、应用、监控和高级应用</title>
      <link href="2021/11/25/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
      <url>2021/11/25/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8E%A2%E7%A9%B6%E3%80%81%E5%BA%94%E7%94%A8%E3%80%81%E7%9B%91%E6%8E%A7%E5%92%8C%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="可靠性探究"><a href="#可靠性探究" class="headerlink" title="可靠性探究"></a>可靠性探究</h1><h2 id="副本剖析"><a href="#副本剖析" class="headerlink" title="副本剖析"></a>副本剖析</h2><h3 id="失效副本"><a href="#失效副本" class="headerlink" title="失效副本"></a>失效副本</h3><ul><li><p>同步失效或功能失效的副本成为失效副本，失效副本对应的分区成为同步失效分区（under-replicated）</p><ul><li><p>同步失效：根据broker参数 <code>replica.lag.time.max.ms</code> 作为标准，当ISR中的follower副本滞后leader副本的时间超过此时间则判定同步失败</p><blockquote><p>滞后时间 = now - lastCaughtUpTimeMs</p><p>当follower副本将leader副本LEO(LogEndOffset)之前的日志全部同步时，则认为该follower副本己经追赶上leader副本，此时更新该副本的lastCaughtUpTimeMs标识 </p></blockquote></li><li><p>功能失效：副本处于非存活状态，例如副本所在的broker节点被关闭</p></li></ul></li><li><p>如果通过工具增加了副本因子，那么新增加的副本在赶上leader副本之前也都是处于失效状态的。</p></li></ul><h3 id="ISR的伸缩"><a href="#ISR的伸缩" class="headerlink" title="ISR的伸缩"></a>ISR的伸缩</h3><p>Kafka 在启动时会开启定时任务，周期型的检测每个分区是否需要缩减其ISR集合</p><ul><li>ISR的缩减：当ISR中的follower副本滞后leader副本的时间超过<code>replica.lag.time.max.ms</code>则将该副本移出ISR集合</li><li>ISR的扩充：当follower副本的LEO不小于leader副本的HW即判定可进入ISR集合</li></ul><h3 id="LEO与HW"><a href="#LEO与HW" class="headerlink" title="LEO与HW"></a>LEO与HW</h3><p>多副本消息追加过程</p><ul><li>生产者客户端发送消息至leader副本</li><li>消息追加到leader副本的本地日志，并更新日志偏移量</li><li>follower副本向leader副本请求同步数据</li><li>leader副本所在的服务器读取本地日志，并更新对应拉取的follower副本信息</li><li>leader副本所在服务器将拉取结果返回follower副本</li><li>follower副本收到结果，将消息追加到本地日志，并更新日志的偏移量信息</li></ul><p>LEO和HW更新过程</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211125102555.png" alt="image-20211125102555685" style="zoom:80%;" /><ul><li>follower向leader拉取消息时，带有自己的LEO信息（fetch_offset），leader更新HW（取HW和LEO中的最小值），返回follower相应消息，并带有自身的HW</li><li>follower收到新消息后，更新LEO和HW</li></ul><p><strong>在一个分区中，leader会记录所有副本的LEO，而follower只会记录自身LEO</strong></p><h3 id="Leader-Epoch的介入"><a href="#Leader-Epoch的介入" class="headerlink" title="Leader Epoch的介入"></a>Leader Epoch的介入</h3><p>解决在需要截断数据的场景下，LEO/HW不一致导致数据丢失的问题，详细内容可查阅8.1.4节。</p><h3 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="headerlink" title="为什么不支持读写分离"></a>为什么不支持读写分离</h3><ul><li>主写从读的问题：数据一致性问题、延时问题</li><li>kafka通过分区副本机制来解决负载均衡问题</li></ul><h2 id="日志同步机制"><a href="#日志同步机制" class="headerlink" title="日志同步机制"></a>日志同步机制</h2><ul><li>日志同步机制的基本原则<ul><li>如果告知客户端已经成功提交了某条消息，那么即使leader宕机，也要保证新选举出来的leader中能够包含这条消息</li></ul></li><li>kafka通过维护ISR集合，保证leader切换后的数据完整性</li></ul><h1 id="Kafka应用"><a href="#Kafka应用" class="headerlink" title="Kafka应用"></a>Kafka应用</h1><ol><li><p>命令行工具</p><ul><li>kafka-configs.sh：配置管理</li><li>kafka-server-start.sh：启动kafka服务</li><li>kafka-server-stop.sh：关闭kafka服务</li><li>kafka-topics.sh：管理主题</li><li>kafka-preferred-replica-election.sh：优先副本选举</li><li>kafka-reassign-partitions.sh：分区重分配</li><li>kafka-consumer-groups.sh：消费组管理、重置消费位移</li><li>kafka-console-consumer.sh：命令行消费消息</li><li>kafka-console-producer.sh：命令行生产消息</li><li>kafka-consumer-perf-test.sh：测试消费性能</li><li>kafka-dump-log.sh：查看日志内容</li><li>kafka-delete-records.sh：删除消息</li></ul></li><li><p>Kafka Connect</p><ul><li><p>基本概念</p><ul><li>Kafka Connect是一个用于将数据流输入和输出Kafka的框架，可以简单快捷地将数据从Kafka导入或导出</li><li>Source和Sink：Source负责导入数据到Kafka，Sink负责从Kafka导出数据，统称为Connector</li><li>Task和Worker：<ul><li>Connector把一项工作分割成许多Task，然后分发到各个Worker进程去执行</li><li>Task不保存自己的状态信息，而是交给特定kafka topic保存，Connector和Task都是逻辑工作单位，必须安排在进程（Worker）中执行</li></ul></li></ul></li><li><p>独立模式</p><ul><li>通过connect-standalone.sh启动，所有操作都是在一个进程中完成</li><li>需要制定两个配置文件：<ul><li>Worker进程运行相关配置：connect-standalone.properties</li><li>Source或Sink配置：connect-file-source.properties、connect-file-sink.properties</li></ul></li></ul></li><li><p>REST API</p><ul><li>/（GET）：查看Kafka集群版本信息</li><li>/connectors （GET/POST）：查看Connector列表、创建Connector</li><li>/connectors/{name}（GET）：查看指定Connector</li><li>/connectors/{name}/config（GET/PUT）：查看/修改指定Connector配置</li><li>/connectors/{name}/status（GET）：查看指定Connector配置<br>……</li></ul></li><li><p>分布式模式</p><ul><li>运行脚本启动：connect-distributed.sh</li><li>修改Worker配置文件：connect-distributed.properties</li><li>修改Source或Sink配置：同独立模式</li></ul><blockquote><p>以分布式模式启动的连接器并不支持在启动时通过加载连接器配置文件来创建一个连接器，只能通过访问RESTAPI来创建连接器。</p></blockquote></li></ul></li><li><p>Kafka Mirror Maker</p><ul><li>用于在两个集群之间同步数据的工具，原理是从源集群消费消息，然后生产到目标集群</li><li>修改配置文件：consumer.properties，producer.properties</li><li>启动脚本：kafka-mirror-maker.sh</li></ul></li><li><p>Kafka Streams</p><ul><li><p>Kafka Streams是一个用于处理和分析数据的客户端库，它先把存储在Kafka中的数据进行处理和分析，然后将数据结果写到Kafka或发送到外部系统</p></li><li><p>解决问题：</p><ul><li>毫秒级延迟的逐个事件处理</li><li>有状态的处理，包括分布式连接和聚合</li><li>方便的DSL</li><li>使用类似DataFlow的模型对无序数据进行窗口化</li><li>具有快速故障切换的分布式处理和容错能力</li><li>无停机滚动部署</li></ul></li><li><p>使用时需要引入依赖：org.apache.kafka/kafka-streams</p></li></ul></li></ol><h1 id="Kafka监控"><a href="#Kafka监控" class="headerlink" title="Kafka监控"></a>Kafka监控</h1><ol><li>监控数据的来源<ul><li>Kafka自身提供的监控指标（包括broker和主题的指标）都可以通过JMX来获取，需要设置JMX_PORT设置端口并开启JMX功能<br>开启JMX后会在zk的 /brokers/ids/<brokerId> 节点中有jmx_port值</li><li>客户端指标数据可通过ProducerMetrics和ConsumerMetrics获取</li></ul></li><li>消费滞后<ul><li>Kafka中留存的消息与Consumer的消息之间的差值就是消息滞后量（Lag），对每个分区而言，Lag = HW - ConsumerOffset<br>如果分区中有未完成的事务，且isolation.level = “read_committed”，Lag = LSO - ConsumerOffset</li><li>计算Lag<ul><li>通过FindCoordinatorRequest查找消费组对应的GroupCoordinator</li><li>通过AdminClient获取DescribeGroupsRequest，获取当前消费组元数据信息</li><li>通过OffsetFetchRequest请求获取消费位移ConsumerOffset</li><li>通过KafkaConsumer.endOffsets()方法获取HW（LSO）值</li><li>HW与ConsumerOffset相减得到分区Lag</li></ul></li></ul></li><li>监控指标说明<ul><li>通过jconsole查看所有MBean</li></ul></li></ol><h1 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h1><ol><li>过期时间<ul><li>给消息添加timeStamp和超时时间，并在消费时使用拦截器，判断是否超时后进行消费</li></ul></li><li>延时队列<ul><li>到期才能消费</li><li>实现方式<ul><li>1.依然采用给消息添加timeStamp和延时时间，消费者拉取一批消息后，如果有未达到延时时间的消息，就重新写入主题</li><li>2.延时消息先投递到一个指定的主题，并使用自定义服务拉取、判断，满足条件后再投递到消费者真实消费的主题</li></ul></li></ul></li><li>其他功能：<ul><li>死信队列、消息路由、消息轨迹、消息审计等均可以自行设计生产消费结构来实现</li></ul></li><li>消息代理<ul><li>Kafka REST Proxy可以为Kafka集群提供一些列的REST API接口，通过这些接口可以实现发送消息、消费消息、查看集群状态和管理类操作等功能</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 《Kafka核心设计与实践原理》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka进阶篇：深入客户端</title>
      <link href="2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h1><p>消费者客户端可配置<code>partition.assignment.strategy</code>来设置消费者与topic之间的partition分配策略，默认<code>org.apache.kafka.clients.consumer.RangeAssignor</code>，可配置多个策略，逗号分隔。</p><ul><li><p>RangeAssignor：</p><ul><li><p>按照consumer总数和partition总数进行整除获得一个跨度，将partition按跨度进行平均分配，保证尽可能的均匀分配给所有consumer。分配时将consumerGroup内的consumer按名称字典排序，依次分配partition范围。</p><blockquote><p>这里的consumer指的是消费组内订阅了分区所属主题的消费者</p></blockquote></li><li><p>如果不够平均分配，那么字典序靠前的消费者会被多分配一个分区。</p></li></ul></li><li><p>RoundRobinAssignor：</p><ul><li>将group内所有consumer和被订阅的所有topic的partition按字典序排序，通过轮询方式，逐个分配partition</li><li>如果同一个group内的consumer订阅信息是不相同的，可能导致partition分配不均匀。</li></ul></li><li><p>StickyAssignor：</p><ul><li>主要目的：partition分配尽可能均匀，分配partition尽可能与上次保持相同</li><li>比上述两个策略更加优异</li></ul></li><li><p>自定义分配策略</p><ul><li>实现PartitionAssignor接口</li><li>具体内容查阅7.1.4节</li></ul></li></ul><h1 id="消费者协调器和组协调器"><a href="#消费者协调器和组协调器" class="headerlink" title="消费者协调器和组协调器"></a>消费者协调器和组协调器</h1><p>如果消费者客户端中配置了两个分配策略，那么以哪个为准呢?如果有多个消费者，彼此所配置的分配策略并不完全相同，那么以哪个为准?多个消费者之间的分区分配是需要协同的，那么这个协同的过程又是怎样的呢?这一切都是交由<strong>消费者协调器</strong>( ConsumerCoordinator )和<strong>组协调器</strong>(GroupCoordinator)来完成的，它们之间使用一套组协调协议进行交互。</p><h2 id="旧版客户端问题"><a href="#旧版客户端问题" class="headerlink" title="旧版客户端问题"></a>旧版客户端问题</h2><ul><li>旧版消费者客户端使用zk的监听器(Watcher)来实现分区分配。consumer和broker状态发生变化时，相应的节点也会变化，客户端就能够监听到状态。</li><li>依赖zk有两个严重问题：<ul><li>羊群效应：当监听的节点发生变化，大量Watcher通知发送到客户端，导致其他操作延迟，甚至发生死锁</li><li>脑裂问题：再均衡操作时，每个consumer与zk进行通信来监听变化情况，由于zk本身特性，可能导致同一时刻各个consumer获取的状态不一致，从而导致异常</li></ul></li></ul><h2 id="新版客户端再均衡的原理"><a href="#新版客户端再均衡的原理" class="headerlink" title="新版客户端再均衡的原理"></a>新版客户端再均衡的原理</h2><p>新版客户端将全部消费组分成多个子集，每个子集在服务端对应一个GroupCoordinator对其进行管理，而消费者客户端中使用ConsumerCoordinator组件与GroupCoordinator交互。</p><p><strong>触发再均衡操作的情形</strong>有：</p><ul><li>新的consumer加入group</li><li>consumer宕机（长时间没有发送心跳）</li><li>consumer主动退出group（unsubscrible()）</li><li>group对应的GroupCoorinator节点发生了变更</li><li>group内订阅的任一topic或主题的partition数量发生变化</li></ul><p>接下来以一个例子介绍<strong>再均衡</strong>的详细过程，当有<strong>消费者加入消费组</strong>时，消费者、消费组及组协调器之间会经历以下几个 阶段：</p><ul><li><p>第一阶段（FIND_COORDINATOR）</p><ul><li><p>consumer需要确定所属group对应的GroupCoordinator所在的broker，并创建与该broker通信的连接</p></li><li><p>如果已经保存了GroupCoordinator节点信息且连接正常，则进入第二阶段。否则，需要向集群中某个节点（leastLoadedNode）发送FindCoordinatorRequest来查找对应的GroupCoordinator</p><blockquote><p>具体查找 GroupCoordinator的方式是先根据消费组groupid的哈希值计算_consumer_offsets 中的分区编号，然后寻找该分区leader副本所在的broker节点</p></blockquote></li></ul></li><li><p>第二阶段（JOIN_GROUP）</p><ul><li><p>consumer会向GroupCoordinator发送JoinGroupRequest以加入消费组。</p><ul><li>JoinGroupRequest中包含该消费者设置的分配策略。</li><li>若该消费者是第一次加入该消费组，GroupCoordinator受到该请求后会为该消费者生成一个唯一标识<code>member_id</code></li></ul><blockquote><p>如果是原有consumer重新加入group，发送前还要执行一些准备工作：</p><ul><li><p><code>enable.auto.commit</code>为true时，需要向GroupCoordinator提交位移</p></li><li><p>执行再均衡监听器（ConsumerRebalanceListener）的<code>onPartitionsRevoked()</code>方法</p></li><li><p>暂时禁止心跳检测运作</p></li></ul></blockquote></li><li><p>选举消费组的leader</p><ul><li><p>GroupCoordinator需要为消费组内的consumer选举出一个leader。如果消费组内还没有leader，则第一个加入的consumer即为leader。如果原leader退出消费组，则重新选举leader（近乎随机）</p><blockquote><p>在GroupCoordinator中消费者的信息是以HashMap的形式存储的，其中key为消费者的member id，而value是消费者相关的元数据信息。 leaderld表示leader消费者的member id，它的取值为HashMap中的第一个键值对的 key。</p></blockquote></li></ul></li><li><p>选举分区分配策略</p><ul><li>每个consumer都可以设置自己的分区分配策略，而消费组需要从中选出一个来进行整体分区分配。</li><li>这个分区分配策略的选举是由消费组内的消费者投票来决定的。具体选举过程如下：<ul><li>收集各个消费者支持的所有分配策略，组成候选集</li><li>组内的消费者从候选集中找出第一个自身支持的策略，并投上一票（不需要再次与组协调器交互，该步骤在组协调器内部完成）</li><li>计算候选集中个分配策略的票数，票数最高的策略即为当前消费组的分配策略</li></ul></li></ul></li><li><p>在此之后， Kafka 服务端就要发送 JoinGroupResponse 响应给各个消费者，发送给普通消费者和leader消费者的响应中都包含最终选出的分配策略，响应内容并不完全相同。</p><ul><li>发送给普通消费者的 JoinGroupResponse 中的members内容为空，而只有leader消费者的 JoinGroupResponse 中的 members 包含有效数据。 members 为数组类型，其中包含各个成员的订阅信息 。</li></ul></li></ul></li><li><p>第三阶段（SYNC_GROUP）</p><ul><li>leader消费者根据第二阶段中选举出来的策略来实施具体的分区分配，然后通过GroupCoordinator将方案同步给各个consumer。</li><li>各个consumer会向GroupCoordinator发送SyncGroupRequest来同步分配方案。GroupCoordinator在收到该请求后会先进行合法性校验，然后将收到的分配方案发给各个消费者。</li></ul></li><li><p>第四阶段（HEARTBEAT）</p><ul><li>进入此阶段，consumer即处于正常工作状态</li><li>正式消费前，consumer还需要确定拉取消息的起始位置：通过OffsetFetchRequest请求获取消费位移</li><li>consumer通过向GroupCoordinator发送心跳来维持与消费组的从属关系，及对partition的所有权关系。<ul><li>如果一个消费者发生崩溃，并停止读取消息，那么 GroupCoordinator 会等待一小段时间，确认这个消费者死亡之后才会触发再均衡。这个一小段时间由 <code>session.timeout.ms</code> 参数控制</li><li>除了被动退出消费组，还可以使用 LeaveGroupRequest 请求主动退出消费组，比如客户端调用了unsubscrible()方法取消对某些主题的订阅</li></ul></li></ul></li></ul><h1 id="consumer-offsets剖析"><a href="#consumer-offsets剖析" class="headerlink" title="_consumer_offsets剖析"></a>_consumer_offsets剖析</h1><ul><li>一般情况下，集群中第一次有consumer消费消息时，会自动创建主题_consumer_offsets</li><li>它的副本因子还受<code>offsets.topic.replication.factor</code>约束。分区数通过<code>offsets.topic.num.partitions</code>设置（默认50）。</li><li>客户端提交消费位移是使用OffsetCommitRequest实现的</li><li>删除topic时，会将consumer提交的此topic的offset一并删除</li></ul><blockquote><p>OffsetCommitRequest的消息格式和消费位移对应的内容格式可查阅7.3节</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="消息传输保障"><a href="#消息传输保障" class="headerlink" title="消息传输保障"></a>消息传输保障</h2><ul><li>一般消息中间件的消息传输保障有3个层级<ul><li>at most once：至多一次。消息可能丢失，但不会重复</li><li>at least once：至少一次。消息不会丢失，但可能重复</li><li>exactly once：恰好一次。每条消息肯定且仅传输一次</li></ul></li><li>kafka提供的消息传输保障为at least once</li><li>从0.11.0.0版本开始引入幂等和事务特性来实现EOS（exactly once semantics）</li></ul><h2 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h2><p>所谓的幕等，简单地说就是对接口的多次调用所产生的结果和调用一次是一致的。生产者在进行重试的时候有可能会重复写入消息，而使用 Kafka 的幕等性功能之后就可以避免这种情况。</p><ul><li><p>生产者客户端通过设置<code>enable.idempotence</code>=true（默认false）开启幂等性功能</p></li><li><p>开启幂等时，客户端会对用户显式设定的一些参数进行校验</p><ul><li>retries：必须大于0（默认Integer.MAX_VALUE）</li><li>acks：必须为-1（all，默认为1）</li><li>max.in.flight.requests.per.connection：不能大于5（默认5）</li></ul></li><li><p>对于每个PID（producer id），消息发送到的每一个partition都有对应的序列号，从0开始，每发送一条就+1，。broker在内存中为每一对 &lt;PID, partition&gt; 维护一个序列号，收到消息时，对比其序列号(SN_new)和内存中的序列号(SN_old)。</p><blockquote><p>生产者客户端和broker端都为每一对&lt;PID, partition&gt;维护一个序列号，生产者客户端每发送一条消息就将该序列号加一，而broker每接受一条消息就加一。</p><p>每个新的生产者实例在初始化的时候都会被分配一个PID，这个PID对用户而言是完全透明的。</p></blockquote><ul><li>如果SN_new&lt;SN_old+1，说明消息重复写入则丢弃此消息。</li><li>如果SN_new&gt;SN_old+1，可能有消息丢失，对应producer会抛出异常。</li><li>只有SN_new刚好比SN_old大1时，才接受此消息。</li></ul></li><li><p>引入序列号来实现幕等也只是针对每一对&lt;PID，分区&gt;而言的，也就是说Kafka的幂等只能保证<strong>单个生产者会话（session）中单分区的幂等</strong>.</p></li></ul><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>幂等性并不能跨多个分区运作，而事务可以弥补这个缺陷。事务可以保证对多个分区写入操作的原子性。Kafka引入事务协调器（TransactionCoordinator）负责处理事务。</p><p>每一个生产者都会被指派一个特定的 TransactionCoordinator，所有的事务逻辑包括分派 PID 等都是由 TransactionCoordinator 来负责实施的。TransactionCoordinator 会将事务状态持久化到内部主题_transaction_state 中。</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><ul><li>为了实现事务，生产端需要开启幂等，并且将<code>trasactional.id</code>参数设置为非空</li><li>transactionId与PID一一对应，但是transactionId是由用户显式设置，而PID是kafka内部分配。如果使用同一个transactionId开启两个producer，则前一个producer会报错并不再工作。</li><li>KafkaProducer提供了5个事务相关方法：<ul><li><code>initTransactions()</code>：初始化事务（前提是配置了transactionId）</li><li><code>beginTransaction()</code>：开启事务</li><li><code>sendOffsetsToTransaction()</code>：在事务内的位移提交</li><li><code>commitTransaction()</code>：提交事务</li><li><code>abortTransaction()</code>：中止事务</li></ul></li></ul><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><ul><li><p>需要配置enable.auto.commit=false</p></li><li><p>通过配置isolation.level设置事务消息的隔离级别</p><ul><li>read_uncommitted（默认）：可消费到未提交的事务</li><li>read_committed：消费端应用看不到尚未提交的事务内的消息（会缓存在KafkaConsumer内部直到事务提交或中止）</li></ul></li><li><p>KafkaConsumer通过控制消息（ControlBatch）判断事务的提交和中止</p></li></ul><h3 id="事务实现过程"><a href="#事务实现过程" class="headerlink" title="事务实现过程"></a>事务实现过程</h3><p>下面以最复杂的 consume-transform-produce 的流程为例来分析 Kafka 事务的实现原理。</p><blockquote><p><strong>consume-transform-produce 模式</strong></p><p>在这种模式下消费和生产并存: 应用程序从某个主题中消费消息，然后经过一系列转换后写入另一个主题，消费者可能在提交消费位移的过程中出现问题而导致重复消费，也有可能生产者重复生产消息。</p><p>该模式具体代码可查阅7.4.3节。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124213612.png" alt="image-20211124213612752" style="zoom:80%;" /><ul><li><p>1.查找TransactionCoordinator</p><ul><li>与查找组协调器类似，根据 transactionalld 的哈希值计算主题_transaction_state中的分区编号，再查找相应的broker节点</li></ul></li><li><p>2.获取PID</p><ul><li><p>凡是开启了幂等性功能的生产者都必须执行这个操作，而不论是否开启事务</p></li><li><p>通过向TransactionCoordinator发送InitProducerldRequest请求来实现（若未开启事务，则可发往任意broker）</p></li><li><p>当TransactionCoordinator第一次收到该请求时，会把请求中的transactionalId和对应的PID以消息的形式保存到主题_transaction_state中，从而持久化transactionalId和PID的关系。</p><blockquote><p>每个新的生产者实例在初始化的时候都会被分配一个 PID，这个PID对用户而言是完全透明的</p></blockquote></li></ul></li><li><p>3.开启事务</p><ul><li>通过 KafkaProducer的<code>beginTransaction()</code>方法可以开启一个事务</li><li>调用该方法后，生产者本地会标记己经开启了一个新的事务 ，只有在生产者发送第一条消息之后 TransactionCoordinator 才会认为该事务己经开启 </li></ul></li><li><p>4.Consume-Transform-Produce：事务的处理过程</p><ul><li><p>当生产者给一个<strong>新的</strong>分区( TopicPartition) 发送数据前， 它需要先向 TransactionCoordinator 发送 AddPartitionsToTxnRequest请求。这个请求会让 TransactionCoordinator 将&lt;transactionld, TopicPartition&gt;的对应关系存储在主题<code>_transaction_state</code>中。</p></li><li><p>生产者通过 ProduceRequest 请求发送消息(ProducerBatch)到用户自定义主题中</p></li><li><p>消费者通过 KafkaProducer 的sendOffsetsToTransaction()方法在一个事务里提交位移</p><ul><li>该方法会向 TransactionCoordinator 节点发送 AddOffsetsToTxnRequest 请求，收到该请求后，协调器会根据groupId推导出<code>_consumer_offsets</code>中的分区，然后将该分区保存在主题<code>_transaction_state</code>中。（对应图中步骤4.3）</li><li>在处理完 AddOffsetsToTxnRequest 之后，生产者还会发送 TxnOffsetCommitRequest 请求给 GroupCoordinator，从而将本次事务中包含的消费位移信息 offsets 存储到主题<code>_consumer_offsets</code>中。（对应图中步骤4.4）</li></ul></li></ul></li><li><p>5.提交或中止事务</p><ul><li><p>一旦数据被写入成功，我们就可以调用 KafkaProducer 的 <code>commitTransaction()</code>方法或 <code>abortTransaction()</code>方法来结束当前的事务。调用这两种方法后，生产者都会向TransactionCoordinator发送 EndTxnRequest 请求，受到该请求后TransactionCoordinator会执行如下操作：</p><ul><li><p>将 PREPARE COMMIT 或 PREPARE_ABORT 消息写入主题<code>_transaction_state</code></p></li><li><p>通过 WriteTxnMarkersRequest请求将 COMMIT 或 ABORT 信息写入用户所使用的普通主题和<code>_consumer_offsets</code></p><blockquote><p>当分区的leader节点收到这个请求之后，会在相应的分区中写入控制消息( ControlBatch)。控制消息用来标识事务的终结，它和普通的消息一样存储在日志文件中</p></blockquote></li><li><p>将COMPLETE CO孔仙lfIT或COMPLETE ABORT信息写入内部主题<code>_transaction_state</code></p><blockquote><p>表明当前事务已经结束，此时可以删除主题<code>_transaction_state</code> 中所有关于该事务的消息。由于主题<code>_transaction_state</code> 采用的日志清理策略为日志压缩，所以这里的删除只需将相应的消息设置为墓碑消息即可</p></blockquote></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 《Kafka核心设计与实践原理》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka进阶篇：深入服务端</title>
      <link href="2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>2021/11/24/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h1><ul><li>Kafka自定义了一组基于TCP的二进制协议，用于实现各种消息相关操作</li><li>协议基本结构<ul><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124110514.png" alt="img" style="zoom: 50%;" /></li><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124110530.png" alt="img" style="zoom:50%;" /></li><li>不同的api（PRODUCE、FETCH等），RequestBody和ResponseBody结构也不同，其详细描述可查阅6.1节</li></ul></li></ul><h1 id="时间轮（TimingWheel）"><a href="#时间轮（TimingWheel）" class="headerlink" title="时间轮（TimingWheel）"></a>时间轮（TimingWheel）</h1><p>Kafka基于时间轮概念自定义实现了一个用于延时功能的定时器（SystemTitmer）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124111337.png" alt="image-20211124111337413" style="zoom:80%;" /><ul><li>时间轮是一个存储定时任务的环形队列 ，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表( TimerTaskList)。TimerTaskList 是一个环形的双向链表，链表中的每一项表示的都是定时任务项( TimerTaskEntry)，其中封装了真正的定时任务 (TimerTask) 。</li><li>时间轮由多个时间格组成，每个时间格代表基本时间跨度（titkMs），时间轮时间格个数（wheelSIze）是固定的。</li><li>currentTime将时间轮划分为到期部分和未到期部分，当前指向的表示刚好到期，需要处理此时间格内的TimerTaskList中的任务</li></ul><p>wheelSize的扩充有限制，当定时时间较大时，不能直接扩充wheelsize，这不仅会占用很大的内存空间，也会拉低效率。针对不同定时需要，Kafka引入层级时间轮的概念。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124111650.png" alt="image-20211124111650888" style="zoom:80%;" /><ul><li><p>当任务的到期时间超过了当前时间轮的时间范围，会尝试添加到上层时间轮。当延时任务所在的时间轮不能精准实现到期时间时，也会重新提交到层级时间轮，进行降级。</p><blockquote><p><strong>降级示例</strong>：在到期时间为[400ms,800ms)区间内的多个任务(比如 446ms、455ms 和 473ms 的定时任务)都会被放入第三层时间轮的时间格1，时间格1对应的 TimerTaskList 的超时时间为 400ms。 随着时间的流逝，当此 TimerTaskList 到期之时，原本定时为 450ms 的任务还剩下 50ms 的时间，还不能执行这个任务的到期操作。这里就有一个时间轮降级的操作，会将这个剩余时间为 50ms 的定时任务重新提交到层级时间 轮中，此时第一层时间轮的总体时间跨度不够，而第二层足够，所以该任务被放到第二层时间轮到期时间为[40ms,60ms)的时间格中。 再经历40ms之后，此时这个任务又被“察觉”，不过 还剩余 lOms，还是不能立即执行到期操作。所以还要再有一次时间轮的降级，此任务被添加到 第一层时间轮到期时间为[1Oms,11ms)的时间格中，之后再经历 lOms后，此任务真正到期，最终执行相应的到期操作。</p><p><strong>可以类比成时钟来理解。</strong></p></blockquote></li><li><p>Kafka中的定时器只持有第一层时间轮引用，每一层时间轮中有一个引用指向更高一层。</p></li><li><p>Kafka 中的定时器借了JDK中的DelayQueue来协助推进时间轮，具体做法如下：</p><ul><li>每个使用到的TimerTaskList都加入DelayQueue，DelayQueue会根据TimerTaskList对应的超时时间expiration来排序</li><li>Kafka有一个线程ExpiredOperationReaper（过期任务收割机）来获取DelayQueue中到期的任务列表</li><li>获取 DelayQueue中超时的任务列表 TimerTaskList 之后，既可以根据TimerTaskList的expiration来推进时间轮的时间，也可以就获取的TimerTaskList执行相应的操作，对里面的TimerTaskEntry该执行过期操作的就执行过期操作，该降级时间轮的就降级时间轮 。</li></ul></li></ul><blockquote><p> delayqueue的<a href="https://www.cnblogs.com/tong-yuan/p/DelayQueue.html">原理</a></p><p>kafka的时间轮<a href="https://blog.csdn.net/chunlongyu/article/details/52971748">源码解析</a>和<a href="https://zhuanlan.zhihu.com/p/121483218">图解</a></p></blockquote><p><strong>Kafka 中的定时器真可谓“知人善用” ， 用 TimjngWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，两者相辅相成</strong> 。</p><h1 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h1><p>延时操作（延时生产、延时拉取等）需要延时返回响应的结果</p><ul><li>首先它必须有一个超时时间(delayMs)，如果在这个超时时间内没有完成既定的任务，那么就需要强制完成以返回响应结果给客户端 </li><li>其次，延时操作不同于定时操作，定时操作是指在特定时间之后执 行的操作，而延时操作可以在所设定的超时时间之前完成，所以延时操作能够支持外部事件的触发</li></ul><p>Kafka中的延时操作创建后会被加入延时操作管理器（DelayedOperationPurgatory）做专门处理，每个延时操作管理器配别一个定时器（由时间轮实现）。延时操作除了满足时间条件执行，还支持外部事件触发，由一个监听池来监听每个分区的外部事件。</p><h1 id="控制器（KafkaController）"><a href="#控制器（KafkaController）" class="headerlink" title="控制器（KafkaController）"></a>控制器（KafkaController）</h1><p>Kafka集群中有一个broker会被选举为控制器，负责管理整个集群中所有分区和副本的状态。其职责有：</p><ul><li>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本</li><li>当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息</li><li>当使用 kafka-topics.sh 脚本为某个topic增加分区数量时，同样还是由控制器负责分区的重新分配</li></ul><h2 id="控制器的选举及异常恢复"><a href="#控制器的选举及异常恢复" class="headerlink" title="控制器的选举及异常恢复"></a>控制器的选举及异常恢复</h2><p><strong>控制器选举</strong></p><ul><li><p>broker启动时尝试读取zk的/controller节点的brokerid，如果不为-1，则放弃竞选。如果不存在/controller节点或节点数据异常，broker会尝试创建此节点，多个broker只有创建成功的会成为控制器。</p></li><li><p>broker内存会保存当前控制器brokerid：activeControllerId</p></li><li><p>Kafka通过zk的controller_epoch来保证控制器的唯一性，其用于记录控制器发生变更的次数</p><blockquote><p>每个和控制器交互的请求都会携带 controller epoch 这个宇段，如果请求的 controller_epoch 值小于内存中的 controller_epoch 值， 则认为这个请求是向己经过期的控制器所发送的请求，那么这个请求会被认定为无效的请求。 如果请求的 controller epoch 值大于内存中的 controller_epoch 值，那么说明 己经有 新的控制器当选了 </p></blockquote></li></ul><p><strong>异常恢复</strong></p><ul><li>当/controller节点的数据发生变化时，每个broker都会更新自身内存中保存的activeControllerld。如果broker在数据变更前是控制器，在数据变更后自身的brokerid值和新的activeControllerld值不一致，那么就需要“退位” ，关闭相应的资源，如关闭状态机、注销监听器。</li><li>当控制器由于异常下线或其他原因 导致/controller节点被删除时，每个 broker都会进行选举，如果 broker在节点被删除前 是控制器，那么在选举前还需要有 一个“退位”的动作。</li></ul><h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><p>使用kafka-server-stop.sh脚本来优雅地关闭kafka，而不是使用jps加kill -9来关闭</p><ul><li>该脚本会给kafka进程发送一个终止信号（TERM），kafka进程捕获该信号后会执行一个关闭钩子中的内容，其中除了关闭一些必要的资源，还会执行控制关闭（ControlledShutdown）的动作</li><li>broker使用ControlledShutdown的方式关闭时<ul><li>可以让消息完全同步到磁盘上，使服务下次上线时不需要进行日志的恢复操作</li><li>在关闭服务前会对其上的leader副本进行迁移，这样可以减少分区的不可用时间</li></ul></li></ul><h2 id="分区leader的选举"><a href="#分区leader的选举" class="headerlink" title="分区leader的选举"></a>分区leader的选举</h2><p>分区leader副本的选举由控制器负责具体实施。其有四种不同的选举策略，这些策略应用于不同的场景。</p><ul><li><p>OfflinePartitionLeaderElectionStrategy：</p><ul><li><p>当创建分区或原leader副本下线采用，控制器使用该策略选举新的leader：</p><ul><li><p><code>unclean.leader.election.enable</code> 为false时：按照AR集合顺序查找第一个存活的副本，且该副本在ISR集合中。</p></li><li><p><code>unclean.leader.election.enable</code> 为true时：按照AR集合顺序查找第一个存活的副本。</p></li></ul></li><li><p>注意AR顺序在分配时就被指定，只要不发生重分配就保持不变。而分区的ISR集合中副本的顺序可能会改变 </p></li></ul></li><li><p>ReassignPartitionLeaderElectionStrategy：</p><ul><li>当分区重分配时采用，从重分配的AR中找到第一个存活的 replica，且满足在ISR中</li></ul></li><li><p>PrefferredReplicaPartitionLeaderElectionStrategy：</p><ul><li>优先副本选举时采用，直接将优先副本设置为leader</li></ul></li><li><p>ControlledShutdownPartitionLeaderElectionStrategy：</p><ul><li>当某节点被优雅关闭时采用，AR中找到第一个存活replica，且在ISR中，还要确保不在关闭的节点上</li></ul></li></ul><h1 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h1><ul><li><p><code>broker.id</code></p><ul><li>broker启动前必须设定的参数，作为broker的唯一id。</li><li>broker启动时会在zk的/brokers/ids下创建节点，broker的健康状态检查就依赖此节点，broker下线时此节点会自动删除</li><li>在 config/server.properties 或 meta.properties 中配置</li><li>可通过 <code>broker.id.generation.enable</code>(默认true) 和 <code>reserved.broker.max.id</code>(默认1000) 来配合自动生成新的brokerId。自动生成的brokerId会大于maxid的配置。</li></ul></li><li><p><code>bootstrap.servers</code></p><ul><li><p>这个参数用来配置发现kafka集群元数据信息的服务地址（可以不是broker）</p></li><li><p>客户端连接kafka集群的过程</p><p>​    <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211124160610.png" alt="image-20211124160610693" style="zoom:80%;" /></p><ul><li>客户端与bootstrap.servers指定的server连接，发送MetadataRequest请求获取集群的元数据信息</li><li>server收到请求后，返回MetadataResponse，其中包含集群元数据信息</li><li>客户端通过解析元数据信息，与集群各个节点建立连接</li></ul></li></ul></li><li><p>其他服务端参数列表<br>引：<a href="https://www.cnblogs.com/wangjing666/p/10234445.html">kafka brokers配置参数详解</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 《Kafka核心设计与实践原理》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka进阶篇：日志存储</title>
      <link href="2021/11/22/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/"/>
      <url>2021/11/22/kafka/kafka%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%9A%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="文件目录布局"><a href="#文件目录布局" class="headerlink" title="文件目录布局"></a>文件目录布局</h1><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211122210338.png" alt="image-20211122210338721" style="zoom:80%;" /><p>上图所示的是kafka在某一时刻的文件目录布局，每一个根目录都会包含最基本的 4 个检查点文件(xxx-checkpoint)和 meta.prop创ies 文件。当broker配置了多个根目录时，会挑选分区数最少的根目录来创建主题。</p><p>主题、分区、副本、Log和LogSegment之间的关系如下图所示：</p><img src="https://img-blog.csdnimg.cn/20190801152646942.png" alt="img" style="zoom: 75%;" /><ul><li>一个分区副本对应一个日志(Log)，一个日志会分配成多个日志分段(LogSegment)，Log在物理上以文件夹形式存储，而LogSegment对应磁盘上的一个日志文件和两个索引文件及可能的其他文件。</li><li>向Log追加消息时是顺序写入的，只有最后一个LogSegment才能执行写入，称为<strong>activeSegment</strong>，满足一定条件时，需要创建新的activeSegment。</li><li>每个日志及索引的文件名根据基准偏移量(BaseOffset)命名，表示当前LogSegment中第一条消息的offset。</li></ul><h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><h2 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h2><ul><li>Kafka 会将多条消息一起进行压缩，生产者发送的压缩数据在 broker 中也是保持压缩状态进行存储的 ，消费者从服务端获取的也是压缩的消息，消费者在处理消息之前才会解压消息。</li><li>压缩方式通过compression.type来配置：producer、gzip、snappy、lz4、uncmpressed。</li><li>消息压缩时，整个消息集压缩为内层消息，整体作为外层消息的value。外层消息的offset保存了内层消息最后一条记录的offset，而内层消息在压缩时会从0开始分配一个offset，内层消息的offset会在服务端进行转换。</li></ul><h2 id="v2版本日志格式"><a href="#v2版本日志格式" class="headerlink" title="v2版本日志格式"></a>v2版本日志格式</h2><blockquote><p>旧版本的消息格式（日志格式）不在这里展示，有需要可查阅5.2节的内容</p></blockquote><img src="https://img-blog.csdnimg.cn/2019080115325191.png" alt="img" style="zoom: 67%;" /><p>该版本引入了变长整型(Varints)和ZigZag编码来保存数值。如果消息本身没有 key，那么 key length 字段为-1，旧版本的消息用int类型来编码，需要4个字节，而如果使用Varints加ZigZag来编码则只需要1个字节。</p><p><strong>Varints</strong>：</p><ul><li>使用一个或多个字节来序列化整数的一种方法。数值越小，其占用的字节数就越少。</li><li>每个字节都有一个位于最高位的 msb 位( most significant bit)，除最后一个字节的msb为0外，其余msb位都设置为1。除 msb 位外，剩余的 7 位用于存储数据本身，即一个字节可以表示$2^7=128$ 个值。</li><li>Varints中采用的是小端字节序，即最小的字节放在前面。</li><li>举例：<ul><li>数字1用varints来表示-&gt; 0000 0001；</li><li>数字300用varints来表示-&gt;1010 1100 0000 0010；</li></ul></li></ul><p><strong>ZigZag编码</strong>：</p><ul><li>若使用 int64等有符号整数类型表示一个负数，那么哪怕是-1，其编码后的长度始终为4个字节。为了使编码更加高效， Varints 使用了 ZigZag 的编码方式。</li><li>ZigZag编码以一种锯齿形( zig-zags)的方式来回穿梭正负整数， 将带符号整数映射为无符号整数，这样可以使绝对值较小的负数仍然享有较小的Varints编码值。</li><li>比如-1编码为1, 1编码为 2, -2编码为3，2编码为4，-3编码为5，以此类推。</li><li>将原值转换为ZigZag编码的公式为 ( n &lt;&lt; 1 ) ^ ( n &gt;&gt; 31 )  该公式是对sint32类型的原值而言的。</li></ul><h1 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h1><p>Kafka 中的索引文件以**稀疏索引( sparse index)**的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项 。</p><p><em>每当写入一定量(由 broker 端参数 <code>log.index.interval.bytes</code> 指定，默认值为 4096，即 4KB)的消息时，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项</em>。（通过增大或减小 <code>log.index.interval.bytes</code> 的值，可以增加或缩小索引项的密度）</p><p>偏移量索引文件中的偏移量是单调递增的，查询指定偏移量时，使用二分查找法来快速定位偏移量的位置，如果指定的偏移量不在索引文件中，则会返回小于指定偏移量的最大偏移量。查询指定时间戳时，也根据二分查找法来查找不大于该时间戳的最大偏移量，至于要找到对应的物理文件位置还需要根据偏移量索引文件来进行再次定位。</p><p><strong>日志分段文件进行切分的条件</strong>：</p><ul><li>当前日志分段文件的大小超过了 broker 端参数 <code>log.segment.bytes</code> 配置的值</li><li>当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于 <code>log.roll .ms</code> 或 <code>log.roll.hours</code> 参数配置的值。（若都配置了，则ms的优先级高）</li><li>偏移量索引文件或时间戳索引文件的大小达到 broker端参数 <code>log.index.size.max.bytes</code> 配置的值</li><li>追加的消息的偏移量与当前日志分段的偏移量之间的差值大于Integer.MAX_VALUE, 即要追加的消息的偏移量不能转变为相对偏移量</li></ul><blockquote><p><strong>日志分段的大小</strong>：Kafka 在创建索引文件的时候会为其预分配 <code>log.index.size.max.bytes</code> 大小的空间，注意这一点与日志分段文件不同，只有当索引文件进行切分的时候，Kafka 才会把该索引文件裁剪到实际的数据大小 。也就是说与当前活跃的日志分段对应的索引文件的大小固定为<code>log.index.size.max.bytes</code>，而其余日志分段对应的索引文件的大小为实际的占用空间。</p></blockquote><h2 id="偏移量索引（-index）"><a href="#偏移量索引（-index）" class="headerlink" title="偏移量索引（.index）"></a>偏移量索引（.index）</h2><p>偏移量索引文件用来建立消息偏移量(offset)到物理地址之间的映射关系，方便快速定位消息所在的物理文件位置</p><p>每个索引占8个字节，分为两个部分：</p><ul><li>relativeOffset：相对偏移量，表示消息相对于baseOffset的偏移量，当前索引文件的文件名即为baseOffset值</li><li>position：消息在日志分段文件中的物理地址</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211122215526.png" alt="image-20211122215526937" style="zoom:70%;" /><h2 id="时间戳索引（-timeindex）"><a href="#时间戳索引（-timeindex）" class="headerlink" title="时间戳索引（.timeindex）"></a>时间戳索引（.timeindex）</h2><p>时间戳索引文件则根据指定的时间戳( timestamp)来查找对应的偏移量 信息。</p><p>每个索引占12个字节，分为两个部分：</p><ul><li>timestamp：当前日志分段最大的时间戳</li><li>relativeOffset：时间戳对应的消息的相对偏移量</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211122215609.png" alt="image-20211122215609268" style="zoom:70%;" /><h1 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h1><p>Kafka 将消息存储在磁盘中，为了控制磁盘占用空间的不断增加就需要对消息做一定的清理操作。</p><ul><li><p>可以通过broker端参数<code>log.cleanup.policy</code>设置日志清理策略（默认delete）</p></li><li><p>有两种清理策略：</p><ul><li><p>日志删除：按照一定保留策略直接删除不符合条件的日志分段</p><ul><li>设置<code>log.cleanup.policy</code>为delete</li></ul></li><li><p>日志压缩：针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本</p><ul><li>设置<code>log.cleanup.policy</code>为compact，并且将<code>log.leaner.enable</code>设置为true（默认true）</li></ul></li><li><p>可同时使用日志删除和日志压缩两种策略</p></li></ul></li></ul><h2 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a><strong>日志删除</strong></h2><ul><li><p>Kafka的日志管理器中有一个专门的日志删除任务来周期性地检测和删除不符合<strong>保留条件</strong>的日志分段文件，周期通过 broker 端参数 <code>log.retention.check.interval.ms</code>来配置（默认300000，5分钟）</p></li><li><p>日志分段保留策略有3种：</p><ul><li><p>基于时间的保留策略：</p><ul><li><p>通过<code>log.retention.hours</code>、<code>log.retention.minutes</code>和<code>log.retention.ms</code>来配置超时清理阈值</p><blockquote><p>优先级ms&gt;minutes&gt;hours（默认log.retention.hours=168，7天） </p></blockquote></li></ul></li><li><p>基于日志大小的保留策略：</p><ul><li>通过<code>log.retention.bytes</code>配置Log日志总大小阈值（默认-1，无穷大）</li><li>通过<code>log.segment.bytes</code>配置日志分段文件大小阈值（默认1G）</li></ul></li><li><p>基于日志起始偏移量的保留策略：</p><ul><li>某日志分段的<strong>下一个日志分段</strong>的起始偏移量baseOffset是否小于等于logStartOffset，若是则可以删除此日志分段</li><li>logStartOffset 的值可以通过DeleteRecordsRequest请求（比如使用KafkaAdminClient的deleteRecords()方法、使用kafka-delete-records.sh脚本〉、日志的清理和截断等操作进行修改</li></ul></li></ul></li><li><p>删除日志分段时，首先会从Log对象中所维护日志分段的跳表中移出待删除分段，以保证没有线程对其进行读取，然后将对应文件加上.deleted后缀，最后由名为delete-file的延迟任务来删除文件</p><ul><li> Kafka 的每个日志对象中使用了 ConcurrentSkipListMap 来保存各个日志分段，每个日志分段的 baseOffset 作为 key</li><li>删除任务延迟时间通过<code>file.delete.delay.ms</code>配置（默认60000，1分钟）</li></ul></li></ul><h2 id="日志压缩（Log-Compaction）"><a href="#日志压缩（Log-Compaction）" class="headerlink" title="日志压缩（Log Compaction）"></a><strong>日志压缩</strong>（Log Compaction）</h2><ul><li><p>Log Compaction对于有相同key的不同value值，只保留最后一个版本。</p></li><li><p>每个日志目录下都有一个名为“cleaner-offset-checkpoint”的<strong>清理检查点文件</strong>，用来记录每个主题的每个分区中己清理的偏移量。通过清理检查点文件可以将 Log 分成两个部分。通过检查点cleaner checkpoint来划分出 一个己经清理过的clean部分和一个还未清理过的dirty部分。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123103357.png" alt="image-20211123103357404" style="zoom:80%;" /></li><li><p>注意Log Compaction是针对key的，所以在使用时应注意每个消息的key值不为null。每个broker会启动<code>log.cleaner.thread</code>（默认1）个日志清理线程负责执行清理任务， 这些线程会选择<strong>“污浊率”</strong>最高的日志文件进行清理。</p><blockquote><p>污浊率：dirtyRatio = dirtyBytes / ( cleanBytes + dirtyBytes ) </p></blockquote></li><li><p>为了防止日志不必要的频繁清理操作，使用参数<code>log.cleaner.min.cleanable.ratio</code>（默认0.5）来限定可进行清理操作的最小污浊率。 Kafka 中用于保存消费者消费位移的主题<strong>＿consumer_offsets使用的就是Log Compaction策略</strong></p></li><li><p>每个日志清理线程会使用一个名为<strong>“SkimpyOffsetMap”</strong>的对象来构建key与offset的映射关系的哈希表（dirty部分）。日志清理需要遍历两次日志文件，第一次遍历把每个 key 的哈希值和最后出现的offset都保存在 SkimpyOffsetMap 中，第二次遍历会检查每个消息是否符合保留条件，符合就保留下来，否则就会被清理.</p></li><li><p>墓碑消息（tombstone）：</p><ul><li>如果一条消息的key不为null，但是其value为null，那么此消息就是墓碑消息。</li><li>日志清理线程发现墓碑消息时会先进行常规的清理，并保留墓碑消息一段时间。墓碑消息的保留条件是所在的日志分段的最近修改时间 lastModifiedTime大于deleteHorizonMs。deleteHorizonMs为clean部分中最后一个日志分段的最近修改时间减去保留阈值deleteRetionMs（通过 broker 端参数<code>log.cleaner.delete.retention.ms</code>配置，默认86400000，即24小时）</li></ul></li><li><p>Log Compaction执行过后的日志分段的大小会比原先的日志分段的要小，为了防止出现太多的小文件，Kafka 在实际清理过程中并不对单个的日志分段进行单独清理，而是将日志文件 中 offset 从 0 至 firstUncleanableOffset 的所有日志分段进行分组，每个日志分段只属于一组 。</p><ul><li><strong>分组策略</strong>为: 按照日志分段的顺序遍历 ，每组中日志分段的占用空间大小之和不超过 segmentSize(可以通过 broker端参数 <code>log.segment.bytes</code> 设置，默认值为 1GB)，且对应的索引文件占用大小之和不超过 maxindexSize (可以通过 broker端参数 <code>log.index.interval.bytes</code>设置，默认值为 I0MB)。同一个组的多个日志分段清理过后，只会生成一个新的日志分段。</li><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123103848.png" alt="image-20211123103847982" style="zoom:80%;" /></li></ul></li></ul><h1 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h1><h2 id="页缓存（pagecache）"><a href="#页缓存（pagecache）" class="headerlink" title="页缓存（pagecache）"></a>页缓存（pagecache）</h2><ul><li><p>页缓存是操作系统实现的一种主要的磁盘缓存，用来减少对磁盘I/O的操作。具体就是把磁盘中的数据缓存到内存中，把对磁盘的访问变成对内存的访问。</p><ul><li>读取：操作系统会先查看数据所在的页（page）是否在页缓存中，如果存在则直接返回，不存在则向磁盘发起读取请求并将读取的数据存入页缓存，之后再将数据返回。</li><li>写入：查看数据所在的页（page）是否在页缓存中，存在则直接修改页缓存，不存在则在页缓存中添加相应的页再写入。被修改过的页变成了脏页，操作系统会在合适的时间把脏页数据写入磁盘以保持数据一致性。</li></ul></li><li><p>Kafka大量使用了页缓存，这是实现高吞吐的重要因素之一。Kafka提供了同步刷盘及间断性强制刷盘的功能，但并不推荐使用。</p></li></ul><h2 id="磁盘I-O流程"><a href="#磁盘I-O流程" class="headerlink" title="磁盘I/O流程"></a>磁盘I/O流程</h2><p>从编程角度而言，一般I/O场景有以下4种，他们的数据流为：</p><ul><li>用户调用标准C库进行I/O操作：用户程序buffer-&gt;C库标准IObuffer-&gt;文件系统页缓存-&gt;通过具体文件系统到磁盘</li><li>用户调用文件I/O：用户程序buffer-&gt;文件系统页缓存-&gt;通过具体文件系统到磁盘</li><li>用户打开文件时使用O_DIRECT，绕过页缓存直接写磁盘</li><li>用户使用类似dd工具，使用direct参数，绕过系统cache与文件系统直接写磁盘</li></ul><p>最长链路数据流图示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123105825.png" alt="image-20211123105825407" style="zoom:80%;" /><p>IO请求处理：通用块层根据 1/0 请求构造一个或多个 bio 结构并提交给调度层；调度器将 bio 结构进行排序和合并组织成队列且确保读写操作尽可能理想: 将一个或多个进程的读操作合并到一起读，将一个或多个进程的写操作合并到一起写，尽可能变随机为顺序 (因为随机读写比顺序读写要慢)，读必须优先满足，而写也不能等太久</p><blockquote><p>针对不同应用场景，I/O调度策略也会影响I/O读写性能，目前Linux提供4中调度策略：NOOP、CFQ（默认）、DEADLINE、ANTICIPATORY。各调度算法的详细描述可查阅5.5.2节，这里不再赘述。</p><p>此外，若想了解linux内核的磁盘io可参考<a href="https://zhuanlan.zhihu.com/p/96391501">该篇博文</a></p></blockquote><h2 id="零拷贝（Zero-Copy）"><a href="#零拷贝（Zero-Copy）" class="headerlink" title="零拷贝（Zero-Copy）"></a>零拷贝（Zero-Copy）</h2><ul><li><p>零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。 对 Linux 操作系统而言，零拷贝技术依赖于底层的sendfile()方法实现。对应于Java 语言，FileChannal.transferTo()的底层实现就是sendfile()。</p></li><li><p>零拷贝和非零拷贝对比</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211123110541.png" alt="image-20211123110541773" style="zoom: 40%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 《Kafka核心设计与实践原理》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka基础篇：体系架构，生产者，消费者</title>
      <link href="2021/11/16/kafka/kafka%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>2021/11/16/kafka/kafka%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211116220047.png" alt="img" style="zoom: 50%;" /><ul><li>Producer：生产者</li><li>Consumber：消费者</li><li>Broker：服务代理节点（kafka实例）</li></ul><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><ul><li>主题（Topic）：kafka消息以topic为单位进行归类，逻辑概念</li><li>分区（Partition）：<ul><li>Topic-Partition为一对多</li><li>分区在存储层面可看做是一个可追加的日志文件</li><li>消息在追加到分区时会分配一个特定的偏移量（offset）作为在此分区的唯一标示</li><li>kafka通过offset保证消息在分区内的顺序性，但只保证分区有序而不保证主题有序</li><li>Kafka 中的分区可以分布在不同的服务器 (broker)上，也 就是说，一个主题可以横跨多个 broker</li><li>每条消息发送到broker前，会根据分区规则分配到具体的哪个分区</li><li><img src="https://img-blog.csdnimg.cn/20190723125133884.png" alt="img" style="zoom:30%;" /></li></ul></li></ul><h2 id="容灾设计"><a href="#容灾设计" class="headerlink" title="容灾设计"></a>容灾设计</h2><h3 id="多副本机制（Replica）"><a href="#多副本机制（Replica）" class="headerlink" title="多副本机制（Replica）"></a>多副本机制（Replica）</h3><img src="https://img-blog.csdnimg.cn/20190723125246996.png" alt="img" style="zoom:50%;" /><ul><li>一个分区会在多个副本中保存相同的消息</li><li>副本之间是一主多从关系（一个leader副本，若干follower副本，副本数量可通过参数设置）</li><li>leader副本负责读写操作，follower副本只负责同步消息（主动拉取）</li><li>leader副本故障时，从follower副本重新选举新leader</li></ul><h3 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h3><ul><li>分区中所有副本统称为 AR（Assigned Replicas）</li><li>所有与leader副本保持<strong>一定程度的同步</strong>的副本（包括leader）组成 ISR（In-Sync Replicas）</li><li>同步滞后过多的副本组成 OSR（Out-of-Sync Replicas）</li></ul><blockquote><p>“<strong>一定程度的同步</strong>”是指可忍受的滞后范围，这个范围可以通过参数<code>replica.lag.time.max.ms</code>进行配置 </p></blockquote><ul><li>ISR的伸缩：<ul><li>从ISR中移出副本<ul><li>Kafka 的副本管理器会启动一个副本过期检测的定时任务，而这个定时任务会定时检查当前时间与副本的 lastCaughtUpTimeMs 差值是否大于参数 <code>replica.lag.time.max.ms</code> 指定的值，若是则从ISR中移出该副本</li><li>当 follower 副本将 leader 副本 LEO (LogEndOffset) 之前的日志全部同步时，则认为该 follower 副本己经追赶上 leader 副本，此时更新该副本的 lastCaughtUpTimeMs 标识为当前时间</li></ul></li><li>将副本移入ISR<ul><li>随着 follower 副本不断与 leader 副本进行消息同步， follower 副本的 LEO 也会逐渐后移 ， 并最终追赶上 leader 副本，此时该 follower 副本就有资格进入 ISR 集合</li><li>追赶上 leader 副本的 判定准则是此副本的 LEO 是否不小于 leader副本的 HW，<strong>注意这里并不是和 leader副本的 LEO 相比</strong></li></ul></li></ul></li></ul><h3 id="特殊偏移量"><a href="#特殊偏移量" class="headerlink" title="特殊偏移量"></a>特殊偏移量</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211116221144.png" alt="img" style="zoom: 60%;" /><ul><li><p>LEO（Log End Offset）：标识当前分区下一条代写入消息的offset</p></li><li><p>HW（High Watermark）：高水位，标识了一个特定的offset，消费者只能拉渠道这个offset之前的消息（不含HW）</p><ul><li>所有副本都同步了的消息才能被消费，HW的位置取决于所有follower中同步最慢的分区的offset</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20211116221206.png" alt="img" style="zoom:50%;" /></li></ul><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h2><h3 id="消息发送步骤"><a href="#消息发送步骤" class="headerlink" title="消息发送步骤"></a>消息发送步骤</h3><ul><li><p>配置生产者客户端参数及创建相应的生产者实例</p><ul><li>Properties</li><li>KafkaProducer</li></ul></li><li><p>构建待发送的消息：ProducerRecord</p></li><li><p>发送消息：send( )，flush( )</p></li><li><p>关闭生产者实例：close( )</p></li></ul><h3 id="必要参数配置"><a href="#必要参数配置" class="headerlink" title="必要参数配置"></a>必要参数配置</h3><ul><li><p><code>bootstrap.servers</code>：设置kafka集群地址，并非需要所有broker地址，因为生产者会从给定的broker中获取其他broker信息</p></li><li><p><code>key.serializer</code>、<code>value.serializer</code>：转换字节数组到所需对象的序列化器，填写全限类名</p></li></ul><h3 id="发送模式"><a href="#发送模式" class="headerlink" title="发送模式"></a>发送模式</h3><ul><li>发后即忘（fire-and-forget）：只管往kafka发送而不关心消息是否正确到达，不对发送结果进行判断处理；</li><li>同步（sync）：KafkaProducer.send()返回的是一个Future对象，使用Future.get()来阻塞获取任务发送的结果，来对发送结果进行相应的处理；</li><li>异步（async）：向send()返回的Future对象注册一个Callback回调函数，Kafka在返回响应时调用该函数来实现异步的发送确认逻辑。</li></ul><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ul><li><p>实现<code>ProducerInterceptor</code>接口，在消息发送的不同阶段调用</p><ul><li><code>configure()</code>：完成生产者配置时</li><li><code>onSend()</code>：调用send()后，消息序列化和计算分区之前</li><li><code>onAcknowledgement()</code>：消息被应答之前或消息发送失败时</li><li><code>close()</code>：关闭拦截器时执行一些资源的清理工作</li></ul></li><li><p>通过 <code>interceptor.classes</code> 配置指定</p></li></ul><h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><ul><li>实现<code>Serializer</code>接口，此接口有三个方法<ul><li><code>configure()</code>：用来配置当前类</li><li><code>serialize()</code>：用来执行序列化操作</li><li><code>close()</code>：用来关闭当前的序列化器</li></ul></li></ul><blockquote><p>生产者使用的序列化器和消费者使用的反序列化器是需要一一对应的</p></blockquote><h3 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h3><ul><li>在消息发送到kafka前，需要先计算出分区号，这要依赖分区器，默认使用DefaultPartitioner<ul><li>默认分区器采用MurmurHash2算法，会对key进行哈希，最终根据得到的哈希值来计算分区号， 拥有相同 key 的消息会被写入同一个分区 。 如果key为null，那么消息将会以轮询的方式发往主 题内的各个可用分区</li></ul></li><li>自定义分区器：<ul><li>实现<code>Partitioner</code>接口，此接口有两个方法<ul><li>partition()：用来计算分区号</li><li>close()：用来在关闭分区器的时候回收一些资源</li></ul></li><li>通过<code>partitioner.class</code>配置指定</li></ul></li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><img src="https://img-blog.csdnimg.cn/20190723125338632.png" alt="img" style="zoom: 40%;" /><ul><li>主线程KafkaProducer创建消息，通过可能的拦截器、序列化器和分区器之后缓存到消息累加器（RecordAccumulatro）</li><li>消息在RecordAccumulator被包装成ProducerBatch(一个批次的消息，即一个至多个消息)，以便Sender线程可以批量发送。生产者发送消息的速度超过发送到服务器的速度时，会导致生产者的空间不足，<code>send()</code>方法会被阻塞或抛异常<ul><li>RecordAccumulatro缓存的大小通过<code>buffer.memory</code>配置，阻塞时间通过<code>max.block.ms</code>配置</li></ul></li><li>Kafka生产者客户端中，通过ByteBuffer实现消息内存的创建和释放，而RecordAccumulator内部有一个BufferPool用来实现ByteBuffer的复用<ul><li>BufferPool只针对<strong>特定大小</strong>的ByteBuffer进行管理，而其他大小的ByteBuffer不会缓存进BufferPool中，这个特定的大小由 <code>batch.size</code> 参数来指定(默认16384B， 即16KB)</li></ul></li><li>Sender从RecordAccumulator中获取缓存的消息后，将ProducerBatch按Node分组，转换成&lt;Node, List<ProducerBatch>&gt;的形式，Node代表broker节点。也就是说sender只向具体broker节点发送消息，而不关注属于哪个分区，这里是应用逻辑层面到网络层面的转换。<ul><li>在转换成&lt;Node, List<ProducerBatch>&gt;的形式之后， Sender 还会进一步将消息封装成&lt;Node, Request&gt;的形式，这样就可以将 Request 请求发往各个 Node了</li></ul></li><li>Sender将请求发往Kafka前，还会保存到InFlightRequests中，其主要作用是缓存已经发出去但还没收到响应的请求，也是以Node分组。<ul><li>每个连接最大缓存未响应的请求数通过<code>max.in.flight.requests.per.connection</code>配置(默认5)</li></ul></li></ul><blockquote><p>若请求返回异常，则可进行重试，重试次数可自行指定</p></blockquote><h3 id="元数据的更新"><a href="#元数据的更新" class="headerlink" title="元数据的更新"></a>元数据的更新</h3><ul><li>元数据是指 Kafka 集群的元数据，这些元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的 leader 副本分配在哪个节点上， follower副本分配在哪些节点上，哪些副本在 AR、 ISR 等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。</li><li>当客户端中没有需要使用的元数据信息或超过metadata.max.age.ms没有更新元数据时，就会引起元数据更新操作。</li><li>当需要更新元数据时，会先挑选出 leastLoadedNode, 然后 向这个Node发送 MetadataRequest请求来获取具体的元数据信息。这个更新操作是由 Sender 线程发起的， 在创建完 MetadataRequest之后同样会存入 InFlightRequests，之后的步骤就和发送消息时类似。 </li><li>InFlightRequests可以获得leastLoadedNode，即所有Node中负载最小的那一个。选择 leastLoadedNode 发送请求可以使它能够尽快发出，避免因网络拥塞等异常而影响整体的进度。leastLoadedNode一般用于元数据请求、消费者组播协议等交互。</li></ul><h2 id="重要的生产者参数"><a href="#重要的生产者参数" class="headerlink" title="重要的生产者参数"></a>重要的生产者参数</h2><ul><li><p><code>acks</code>：用来指定分区中有多少个副本收到这条消息，才认为生产者写入成功并对请求进行响应（默认”1”）</p><ul><li>“1”：leader写入即成功、“0”：不需要等待服务端响应、”-1”/“all”：ISR所有副本都写入才收到响应</li></ul></li><li><p><code>max.request.size</code>：限制生产者客户端能发送的消息的最大值（默认1048576，即1m）</p></li><li><p><code>retries、retry.backoff.ms</code>：生产者重试次数（默认0）和两次重试之间的间隔（默认100）</p></li><li><p><code>compression.type</code>：消息压缩方式，可配置为”gzip”、”snappy”、”lz4”（默认”none”）</p></li><li><p><code>connections.max.idle.ms</code>：多久后关闭闲置的连接（默认540000，9分钟）</p></li><li><p><code>linger.ms</code>：生产者发送ProducerBatch之前等待更多消息（ProducerRecord）加入的时间（默认为0）</p></li><li><p><code>receive.buffer.bytes</code>：Socket接收消息缓冲区的大小（默认32768，32k）</p></li><li><p><code>send.buffer.bytes</code>：Socket发送消息缓冲区的大小（默认131072，128k）</p></li><li><p><code>request.timeout.ms</code>：Producer等待请求响应的最长时间（默认30000ms），这个值需要比broker参数<code>replica.lag.time.max.ms</code>大(该参数配置ISR中的follower和leader副本间可容忍的滞后范围)</p></li></ul><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费者与消费组"><a href="#消费者与消费组" class="headerlink" title="消费者与消费组"></a>消费者与消费组</h2><ul><li>每个分区只能被一个消费组的一个消费者消费<ul><li>当一个消费组内的消费者数大于分区数时，会有消费者分配不到分区而无法消费任何消息</li></ul></li><li>消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个钱程，也可以是一个进程。</li></ul><h2 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h2><h3 id="消费步骤"><a href="#消费步骤" class="headerlink" title="消费步骤"></a>消费步骤</h3><ul><li>配置消费者客户端参数及创建KafkaConsumer实例</li><li>订阅主题</li><li>拉取消息并消费</li><li>提交消费位移</li><li>关闭实例</li></ul><h3 id="必要的参数配置"><a href="#必要的参数配置" class="headerlink" title="必要的参数配置"></a>必要的参数配置</h3><ul><li><code>bootstrap.servers</code>：集群broker地址清单</li><li><code>group.id</code>：消费组名称</li><li><code>key.deserializer</code>、<code>value.deserializer</code>：反序列化器</li></ul><h3 id="订阅主题和分区"><a href="#订阅主题和分区" class="headerlink" title="订阅主题和分区"></a>订阅主题和分区</h3><ul><li><code>subscribe()</code>：订阅主题，既可以以集合的形式订阅多个主题，也可以以正则表达式的形式订阅特定模式的主题</li><li><code>assign()</code>：订阅指定主题的指定分区<ul><li>如果我们事先并不知道主题中有多少个分区怎，则可通过<code>partitionFor()</code>方法先获取指定主题的元数据信息（包括分区信息）</li></ul></li><li><code>unsubscribe()</code>：取消订阅<ul><li>如果将 <code>subscribe(Collection)</code>或 <code>assign(Collection)</code>中的集合参数设置为空集合 ，那么作用等同于<code>unsubscribe()</code>方法 </li></ul></li></ul><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><ul><li><code>poll()</code>：返回的是所订阅的主题(分区)上的一组消息，可设定timeout参数来控制阻塞时间（返回的是还没有被消费过的消息集）</li><li><code>pause()</code>、<code>resume()</code>：暂停和恢复某分区的消费</li><li><code>seek()</code>：按指定分区的指定offset消费</li><li><code>beginingOffsets()</code>，<code>endOffsetes()</code>，<code>offstesForTimes()</code>：分别获取指定分区开头的位置、指定分区末尾的位置或时间戳大于等于待查询时间的第一条消息对应的位置和时间戳 </li><li><code>seekToBeginning</code>、<code>seekToEnd()</code>：从指定分区的开头、末尾开始消费</li></ul><h3 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h3><p>每次调用<code>poll()</code>方法时，返回的是还没有被消费过的消息集，要做到这一点，就需要记录上一次消费时的消费位移。在旧消费者客户端中，消费位移是存储在 ZooKeeper中的。而在新消费者客户端中，消费位移存储在 Kafka 内部的主题 consumer offsets 中 。 </p><ul><li>提交的offset为 lastConsumedOffset + 1<ul><li>lastConsumedOffset：上一次poll拉取到的分区的最后一条消息的offset</li></ul></li><li>自动提交<ul><li>Kafka 中默认的消费位移的提交方式是自动提交，由消费者客户端参数<code>enable.auto.commit</code>配置，默认值为 true</li><li>该自动提交是定期提交，定期的周期时间由客户端参数<code>auto.commit.interval.ms</code>配置，默认值为5秒。（此参数生效的前提是 <code>enable.auto.commit</code> 参数为 true）</li><li>自动提交位移的方式非常简便，但会导致重复消费和消息丢失的问题</li></ul></li><li>手动提交<ul><li>开启手动提交功能的前提是消费者客户端参数<code>enable.auto.commit</code>配置为 false</li><li>同步提交：<code>commitSync()</code>，会阻塞消费者线程直至位移提交完成</li><li>异步提交：<code>commitAsync()</code>，不会阻塞消费者线程，可能在提交结果未返回之前就开始了新一轮的拉取操作</li></ul></li></ul><h3 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h3><p>再均衡是指分区的所属权从一个消费者转移到另一消费者的行为，它为消费组具备高可用性和伸缩性提供保障，使我们可以既方便又安全地删除消费组内的消费者或往消费组内添加消费者。</p><ul><li><p>在再均衡发生期间，消费组内的消费者是无法读取消息的</p></li><li><p>当 一个分区被重新分配给另一个消费者时， 消费者当前的状态也会丢失。（当一个消费者A还没提交消费位移就发生了再均衡时，该分区分配的另一个消费者B会重新消费该分区已被A消费的消息）</p></li><li><p>在<code>subcribe()</code>时，可以注册一个实现<code>ConsumerRebalanceListener</code>接口的监听器，该接口有两个方法</p><ul><li><p><code>onPartionsRevoked()</code>：该方法会在再均衡开始之前和消费者停止读取消息之后被调用</p></li><li><p><code>onPartitionsAssigned()</code>：该方法会在重新分配分区之后和消费者开始读取消费之前被调用</p></li></ul></li></ul><h3 id="自定义拦截器-1"><a href="#自定义拦截器-1" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><ul><li>实现ConsumerInterceptor接口，该接口有以下方法<ul><li><code>configure()</code>：完成消费者配置时</li><li><code>onConsume()</code>：在poll()方法返回之前调用</li><li><code>onCommit()</code>：在提交完消费位移之后调用</li><li><code>close()</code>：关闭拦截器时执行一些资源的清理工作</li></ul></li></ul><h3 id="自定义反序列化器"><a href="#自定义反序列化器" class="headerlink" title="自定义反序列化器"></a>自定义反序列化器</h3><p>实现<code>Deserializer</code>接口，此接口有三个方法</p><ul><li><code>configure()</code>：用来配置当前类</li><li><code>deserialize()</code>：用来执行反序列化操作</li><li><code>close()</code>：用来关闭当前的反序列化器</li></ul><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><ul><li><p>KafkaProducer是线程安全的，但KafkaConsumer是非线程安全的。KafkaConsumer 中定义了一个<code>acquire()</code>方法可检测当前是否只有一个线程在操作，否则抛出异常.</p></li><li><p>推荐使用单线程消费，而消息处理用多线程，如下图所示.</p><img src="https://img-blog.csdnimg.cn/20190723125353939.png" alt="img" style="zoom:50%;" /></li><li><p>消费者的更多多线程实现可查阅《深入理解kafka：核心设计和实践原理》3.2.10节内容</p></li></ul><h2 id="重要的消费者参数"><a href="#重要的消费者参数" class="headerlink" title="重要的消费者参数"></a>重要的消费者参数</h2><ul><li><code>fetch.min.bytes</code>：一次请求能拉取的最小数据量（默认1b）</li><li><code>fetch.max.bytes</code>：一次请求能拉取的最大数据量（默认52428800b，50m）</li><li><code>fetch.max.wait.ms</code>：与min.bytes有关，指定kafka拉取时的等待时间（默认500ms）</li><li><code>max.partition.fetch.bytes</code>：从每个分区里返回Consumer的最大数据量（默认1048576b，1m）</li><li><code>max.poll.records</code>：一次请求拉取的最大消息数（默认500）</li><li><code>connections.max.idle.ms</code>：多久后关闭闲置连接，默认（540000，9分钟）</li><li><code>receive.buffer.bytes</code>：Socket接收消息缓冲区的大小（默认65536，64k）</li><li><code>send.buffer.bytes</code>：Socket发送消息缓冲区的大小（默认131072，128k）</li><li><code>request.timeout.ms</code>：Consumer等待请求响应的最长时间（默认30000ms）</li><li><code>metadata.max.age.ms</code>：元数据过期时间（默认30000，5分钟）</li><li><code>reconnect.backoff.ms</code>：尝试重新连接指定主机前的等待时间（默认50ms）</li><li><code>retry.backoff.ms</code>：尝试重新发送失败请求到指定主题分区的等待时间（默认100ms）</li><li><code>isolation.level</code>：消费者的事务隔离级别（具体查看进阶篇：事务）</li></ul><h1 id="主题与分区"><a href="#主题与分区" class="headerlink" title="主题与分区"></a>主题与分区</h1><h2 id="主题的管理"><a href="#主题的管理" class="headerlink" title="主题的管理"></a>主题的管理</h2><ul><li><p>创建</p><ul><li>自动创建：broker设置<code>auto.create.topics.enable</code>=true时，生产者发送消息时会自动创建分区数为<code>num.partitions</code>(默认1)，副本因子为<code>default.replication.facto</code>r(默认1)的主题</li><li>通过kafka-topics.sh创建：<code>create</code>指令<ul><li><code>kafka-topics.sh  --zookeeper &lt;zkpath&gt; --create --topic &lt;topic&gt; --partitions &lt;N&gt; --replication-factor &lt;N&gt;</code></li><li>手动分配副本：<code>--replica-assignment</code><ul><li><code>--replica-assignment 2:0:1,1:2:0,0:1:2 partion1 AR：2,0,1 partion2 AR：1:2:0 partion3 AR：0:1:2</code></li><li>设定参数：<code>--config &lt;key=value&gt;</code></li></ul></li></ul></li></ul></li><li><p>分区副本的分配</p><ul><li>使用kafka-topics.sh创建主题内部分配逻辑按机架信息划分两种策略：<ul><li>未指定机架信息分配策略：<code>assignReplicasToBrokersRackUnaware()</code>方法</li><li>指定机架分配策略：<code>assignReplicasToBrokersRackAware()</code>方法</li></ul></li></ul></li></ul><blockquote><p>当创建一个主题时，不管用什么方式，实质上是在zk的/broker/topics节点下创建与该主题对应的子节点并写入分区副本分配方案，并且在/config/topics节点下创建与该主题相关的子节点并写入主题配置信息</p></blockquote><ul><li><p>查看：kafka-topics.sh脚本的 <code>list</code>、<code>describe</code>指令</p></li><li><p>修改：kafka-topics.sh脚本的 <code>alter</code>指令</p></li><li><p>配置管理：kafka-configs.sh脚本</p></li><li><p>删除：kafka-topics.sh脚本的 <code>delete</code>指令</p></li></ul><h2 id="初识KafkaAdminClient"><a href="#初识KafkaAdminClient" class="headerlink" title="初识KafkaAdminClient"></a>初识KafkaAdminClient</h2><ul><li><strong>KafkaAdminClient</strong>：一般情况下 ，我们都习惯使用 kafka-topics.sh脚本来管理主题，但有些时候我们希望将主题管理类的功能集成到公司内部的系统中， 打造集管理、监控、运维、告警为一体的生态平台， 那么就需要以程序调用 API 的方式去实现，KafkaAdminClient提供了这些API。具体的API不在本文中列出，有需要可以自行查阅相关文档。</li><li><strong>主题合法性验证</strong>：普通用户在通过KafkaAdminClient 管理主题时，有可能由于误操作或其他原因而创建了不符合运维规范的主题（比如命名不规范，副本因子数太低等），这些会影响后期的系统运维 。我们可以在broker端设置<code>create.topic.policy.class.name</code>来指定一个类验证主题创建时的合法性，这个类需要实现ClreateTopicPolicy接口。</li></ul><h2 id="分区的管理"><a href="#分区的管理" class="headerlink" title="分区的管理"></a>分区的管理</h2><ul><li><p>优先副本（preferred replica/preferred leader）</p><ul><li><p>优先副本即 AR 集合中的第一个副本，kafka保证了优先副本的均衡分布。<strong>优先副本选举就是对分区leader副本进行选举的时候，尽可能让优先副本成为leader副本，从而保证负载均衡</strong></p><blockquote><p><a href="https://juejin.cn/post/7000552764119973902">优先副本的作用可看这篇博文</a></p></blockquote></li><li><p>kafka-perferred-replica-election.sh可进行优先副本选举操作</p></li></ul></li><li><p>分区重分配</p><ul><li><p>何时需要进行：</p><ul><li><p>需要将某节点上的分区副本迁移至其他节点时(例如宕机迁移失效副本或有计划下线节点迁移副本时）</p><blockquote><p>注意，下线前最好先关闭或重启此broker，保证不是leader节点，减少了节点间流量复制</p></blockquote></li><li><p>需要向新增节点分配原有主题分区副本时</p><blockquote><p>集群中新增节点时，只有新创建的主题分区才有可能分配到新节点上，因此需要把老主体的分区分配到新节点上，否则会造成新节点和原来的节点之间的负载不均衡</p></blockquote></li></ul></li><li><p>如何进行：可使用kafka-reassign-partitions.sh脚本</p></li></ul></li><li><p>复制限流</p><ul><li>数据复制会占用额外的资源，如果重分配的量太大必然会严重影响整体的性能。可以通过对副本间的复制流量加以限制来保证重分配期间整体服务不会受太大的影响，可分别限制follower副本复制速度和leader副本传输速度</li><li>通过kafka-config.sh或 kafka-reassign-partitions.sh配置<ul><li>broker级别：follower/leader.replication.throttled.rate=N</li><li>topic级别：follower/leader.replication.throttled.replicas=N</li></ul></li><li>分区重分配过程中的临时限流策略（在进行相应配置后）<ul><li>原AR会应用leader限流配置</li><li>分区移动的目的地会应用follower限流配置</li><li>重分配所需的数据复制完成后，临时限流策略会被移除</li></ul></li></ul></li><li><p>修改副本因子</p><ul><li>通过kafka-reassign-partitions.sh配置</li></ul></li><li><p>如何选择合适的分区数</p><ul><li>性能测试工具<ul><li>生产者性能测试：kafka-producer-perf-test.sh脚本</li><li>消费者性能测试：kafka-consumer-perf-test.sh脚本</li></ul></li><li>分区数和吞吐量的关系<ul><li>在一定限度内，吞吐量随分区数增加而上升，但由于磁盘、文件系统、I/O调度策略等影响，到一定程度时吞吐量会存在瓶颈或有所下降</li></ul></li><li>考量因素<ul><li>分区数会占用文件描述符，而一个进程所能支配的文件描述符是有限的，这也是通常所说的文件句柄的开销</li><li>如果分区数过多，当集群中某个broker宕机，就会有大量分区需要进行leader角色切换，这个过程会耗费一定的时间，并且在此期间这些分区不可用。分区数越多，kafka的正常启动和关闭耗时也会越长，同时也会增加日志清理的耗时</li><li>建议将分区数设定为broker的倍数</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 《Kafka核心设计与实践原理》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized与锁</title>
      <link href="2021/09/11/synchronized%E4%B8%8E%E9%94%81/"/>
      <url>2021/09/11/synchronized%E4%B8%8E%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。</p><p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。</p><p><strong>注意</strong>：不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的，在<a href="https://www.jianshu.com/p/9932047a89be">这篇博文</a>中提及。</p><blockquote><p>首先需要明确的一点是：<strong>Java多线程的锁都是基于对象的</strong>，Java中的每一个对象都可以作为一个锁。</p><p>还有一点需要注意的是，我们常听到的<strong>类锁</strong>其实也是对象锁。</p><p>Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。</p></blockquote><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>前面我们提到，Java的锁都是基于对象的。首先我们来看看一个对象的“锁”的信息是存放在什么地方的。</p><p>每个Java对象都有对象头。如果是非数组类型，则用2个字宽来存储对象头，如果是数组，则会用3个字宽来存储对象头。在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。对象头的内容如下表：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果是数组）</td></tr></tbody></table><p>我们主要来看看Mark Word的格式：</p><table><thead><tr><th>锁状态</th><th>29 bit 或 61 bit</th><th>1 bit 是否是偏向锁？</th><th>2 bit 锁标志位</th></tr></thead><tbody><tr><td>无锁</td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID、epoch</td><td>1</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>此时这一位不用于标识偏向锁</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>此时这一位不用于标识偏向锁</td><td>10</td></tr><tr><td>GC标记</td><td></td><td>此时这一位不用于标识偏向锁</td><td>11</td></tr></tbody></table><p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><blockquote><p>大白话就是对锁置个变量，如果发现为true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为false，代表存在其他线程竞争资源，那么就会走后面的流程。</p></blockquote><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><p>一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。</p><p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：</p><ul><li>成功，表示之前的线程不存在了，或时还存在但当前执行位置已经不在同步块中， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li><li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li></ul><blockquote><p>CAS: Compare and Swap</p><p>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p></blockquote><p>图中涉及到了lock record指针指向当前堆栈中的最近一个lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。</p><h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol><p>所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseBiasedLocking=<span class="keyword">false</span>。</span><br></pre></td></tr></table></figure><p>下面这个经典的图总结了偏向锁的获得和撤销：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210911190753.png" alt="img" style="zoom:67%;" /><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。</p><h4 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h4><p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。</p><p>然后线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><blockquote><p>自旋：不断尝试去获取锁，一般用循环来实现。</p></blockquote><p>自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p><p>但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p><p><strong>轻量级锁的释放：</strong></p><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><p>一张图说明加锁和释放锁的过程：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210911190825.png" alt="img" style="zoom:67%;" /><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><p>前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Contention List：所有请求锁的线程将被首先放置到该竞争队列</span><br><span class="line">Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</span><br><span class="line">Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</span><br><span class="line">OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</span><br><span class="line">Owner：获得锁的线程称为Owner</span><br><span class="line">!Owner：释放锁的线程</span><br></pre></td></tr></table></figure><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到Contention List的队列的队首，然后调用<code>park</code>函数挂起当前线程。</p><p>当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做<code>Heir presumptive</code>即假定继承人，假定继承人被唤醒后会尝试获得锁，但<code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。</p><p>如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p><h3 id="总结锁的升级流程（重要）"><a href="#总结锁的升级流程（重要）" class="headerlink" title="总结锁的升级流程（重要）"></a>总结锁的升级流程（重要）</h3><p>每一个线程在准备访问同步块时：</p><p>第一步，在当前线程的栈帧中创建用于存储锁记录的空间，我们称为<code>Displaced Mark Word</code>，并把锁的<code>MarkWord</code>复制到这块空间中。</p><p>第二步，检查<code>MarkWord</code>里面是不是放的自己的ThreadId ,如果是，表示当前线程获取了 “偏向锁” 。</p><p>第三步，如果<code>MarkWord</code>中不是自己的<code>ThreadId</code>，则当前线程根据<code>MarkWord</code>里面现有的<code>ThreadId</code>，通知之前线程暂停（在安全点暂停），在暂停线程后，会通过遍历当前jvm的所有线程的方式，检查持有偏向锁的线程状态是否存活：</p><ul><li><p>如果之前线程还存活，且其正在执行同步代码块中的代码，则将锁升级为轻量级锁，唤醒暂停的线程，从安全点继续执行代码。然后继续第四步的流程。</p></li><li><p>如果之前持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：</p><ul><li><p>不允许重偏向，则<strong>撤销偏向锁，将<code>MarkWord</code>设为无锁状态，然后再升级为轻量级锁</strong>。最后唤醒暂停的线程，从安全点继续执行代码（若之前线程还存活），继续第四步的流程。</p></li><li><p>允许重偏向，<strong>将<code>MarkWord</code>设置为匿名偏向锁状态，然后当前线程通过CAS将偏向锁重新指向自己</strong>。最后唤醒暂停的线程，从安全点继续执行代码（若之前线程还存活）。</p><blockquote><p><a href="https://jacobchang.cn/lock-of-synchronized.html">重偏向资料</a></p></blockquote></li></ul></li></ul><p>第四步，当前线程尝试通过CAS修改<code>MarkWord</code>来获取轻量级锁</p><ul><li>若成功，则当前线程获取到了轻量级锁，结束流程。</li><li>若失败，则尝试自旋获取锁。若自旋过程中获得了锁，则结束流程，否则继续下一步。</li></ul><p>第五步，（此时当前线程自旋失败）修改锁标志位，将轻量级锁升级为重量级锁，然后阻塞当前线程，等待之前线程执行完成并唤醒自己（之前线程执行完后，会唤醒所有阻塞的线程）。</p><p>第六步，线程被唤醒后重新和其他被唤醒的线程争夺访问同步块。</p><p>更详细的锁升级流程图如下所示（其中）：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210911182145.jpg" alt="preview"></p><h3 id="各种锁的优缺点对比"><a href="#各种锁的优缺点对比" class="headerlink" title="各种锁的优缺点对比"></a>各种锁的优缺点对比</h3><p>下表来自《Java并发编程的艺术》：</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 锁 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：IO子系统</title>
      <link href="2021/09/09/os/os%EF%BC%9AIO%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/09/09/os/os%EF%BC%9AIO%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O分类"><a href="#I-O分类" class="headerlink" title="I/O分类"></a>I/O分类</h2><p>三种常见的设备<strong>接口类型</strong></p><ul><li><strong>字符设备</strong>：键鼠、串口等</li><li><strong>块设备</strong>：磁盘驱动器、磁带驱动器、光驱等</li><li><strong>网络设备</strong>：以太网、无线、蓝牙等</li></ul><p>设备<strong>访问特征</strong>：</p><ul><li><strong>字符设备</strong>：以字节为单位顺序访问；I/O命令使用get()、put()等，通常使用文件访问接口和语义</li><li><strong>块设备</strong>：均匀的数据块访问；I/O命令使用 原始I/O 或 文件系统接口 或 内存映射文件访问</li><li><strong>网络设备</strong>：格式化报文交换；I/O命令使用send/receive网络报文，通过网络接口支持多种网络协议</li></ul><p>同步与异步I/O：</p><ul><li>阻塞I/O Wait<ul><li>读数据时 进程进入等待状态 直到完成数据读出</li><li>写数据时 进程进入等待状态 直到设备完成数据写入处理</li></ul></li><li>非阻塞I/O Don’t Wait(可能会失败 或者少写)<ul><li>立即从read或write系统调用返回 返回值为成功传输的字节数</li><li>read或write的传输字节数可能为0</li></ul></li><li>异步I/O Tell Me Later<ul><li>读数据时 使用指针标记好用户缓冲区 立即返回 稍后内核将填充缓冲区并通知用户</li><li>写数据时 使用指针标记好用户缓冲区 立即返回 稍后内核将处理数据并通知用户</li></ul></li></ul><blockquote><p>IO请求的流程：</p><ol><li>用户发起 I/O请求</li><li>请求会发送到内核中的设备驱动</li><li>设备驱动将其转换为对硬件的控制</li><li>硬件控制完成之后 会产生中断 由内核的中断处理例程进行响应</li><li>回到设备驱动进行相应处理，最后回到用户态</li></ol><p>I/O请求的流程图可看下方I/O结构章节中的I/O请求生命周期</p></blockquote><h2 id="I-O结构"><a href="#I-O结构" class="headerlink" title="I/O结构"></a>I/O结构</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909151459.png" alt="Device_Connects_CPU" style="zoom:50%;" /><ul><li><p>设备控制器</p><ul><li>CPU和I/O设备间的接口</li><li>向CPU提供特殊指令和寄存器</li></ul></li><li><p>I/O地址</p><ul><li><p>CPU用来控制I/O硬件</p></li><li><p>内存地址或端口号：基于I/O指令或内存映射I/O</p><ul><li><p>I/O指令</p><ul><li>通过I/O端口号访问设备寄存器</li><li>特殊的CPU指令：out 0x21,AL</li></ul></li><li><p>内存映射I/O</p><ul><li>设备的寄存器/存储被映射到内存物理地址空间中</li><li>通过内存load/store指令完成I/O操作</li><li>MMU设置映射，硬件跳线或程序在启动时设置地址</li></ul></li></ul></li></ul></li><li><p>CPU与设备的通信方式</p><ul><li>轮询(CPU直接访问I/O端口或者是映射到的内存地址，不用中断控制器)</li><li>设备中断</li><li>DMA(将数据直接放到内存)</li></ul></li></ul><h3 id="内核I-O结构"><a href="#内核I-O结构" class="headerlink" title="内核I/O结构"></a>内核I/O结构</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909152232.png" alt="Kernel_I_O_Subsystem" style="zoom: 45%;" /><h3 id="I-O请求生命周期"><a href="#I-O请求生命周期" class="headerlink" title="I/O请求生命周期"></a>I/O请求生命周期</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909152251.png" alt="Life_cycle_of_I_O_Request" style="zoom:50%;" /><h2 id="I-O数据传输"><a href="#I-O数据传输" class="headerlink" title="I/O数据传输"></a>I/O数据传输</h2><ul><li>程序控制I/O(PIO Programmed I/O)<ul><li>通过CPU的 in/out 或者 load/store 传输所有数据</li><li>硬件简单 编程容易</li><li>消耗的CPU时间和数据量成正比</li><li>适用于简单的、小型的设备I/O</li></ul></li><li>直接内存访问(DMA)<ul><li>设备控制器可直接访问系统总线</li><li>控制器直接与内存互相传输数据</li><li>设备传输数据不影响CPU</li><li>需要CPU参与设置</li><li>适用于高吞吐量I/O</li></ul></li></ul><blockquote><p>DMA传输数据的操作：</p><ul><li>首先，CPU通过设置其寄存器来对DMA控制器进行编程，以使其知道在何处传输（下图中的步骤1）。<br><strong>它还向磁盘控制器发出命令，告诉它从磁盘读取数据到其内部缓冲区</strong>中并验证校验和。</li><li>当有效数据位于磁盘控制器的缓冲区中时，DMA可以开始。 <strong>DMA控制器通过通过总线向磁盘控制器</strong>发出读取请求来启动传输（步骤2）。该读取请求看起来与任何其他读取请求一样，并且磁盘控制器不知道（或不在乎）它是来自CPU还是来自DMA控制器。通常，<strong>要写入的内存地址在总线的地址线上，因此，当磁盘控制器从其内部缓冲区中获取下一个Word时，它就知道将其写入哪里。</strong>写入存储到存储器是另一个标准的总线周期（步骤3）。</li><li>写入完成后，磁盘控制器也会通过总线将确认信号发送到DMA控制器（步骤4）。然后，DMA控制器增加要使用的内存地址，并减少字节数。如果字节计数仍大于0，则重复步骤2至4，直到计数达到0。</li><li>那时，DMA控制器中断CPU，以通知传输现在已完成。操作系统启动时，不必将磁盘块复制到内存；它已经在那里。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909155807.png" alt="image-20210909155807745"></p></blockquote><p>有时操作系统需要了解设备的状态（例如I/O操作完成的时间、I/O操作期间遇到的错误等），那么如何获悉这些状态呢？</p><p>有两种方式：<strong>轮询</strong>和<strong>设备中断</strong></p><p><strong>轮询</strong>：</p><p>I/O设备在特定的状态寄存器中放置状态和错误信息，操作系统定期检测这些状态寄存器。</p><p>特点：</p><ul><li>简单</li><li>I/O操作频繁或不可预测时，开销大(因为I/O频繁)和延时长(因为不可预测)</li></ul><p><strong>设备中断</strong>：</p><p>设备中断处理例程</p><ol><li>CPU在 I/O 之前设置任务参数</li><li>CPU发出 I/O请求后 继续执行其他任务</li><li>I/O设备处理 I/O请求</li><li>I/O设备处理完成时 触发CPU中断请求</li><li>CPU接受中断 分发到相应中断处理例程</li></ol><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909160949.png" alt="Device_Interrupts" style="zoom: 33%;" /><p>特点：</p><ul><li>处理不可预测时间效果好(CPU会在每两条指令执行间隔去检查是否有中断请求)</li><li>开销相对较高(CPU中断频率太高)</li></ul><blockquote><p>轮询和设备中断方式各有优缺点，因此一些设备可能结合了轮询和设备中断。例如高带宽网络设备，它<strong>在第一个传入数据包到达前采用中断，之后轮询后面的数据包直到硬件缓存为空</strong>。</p></blockquote><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>磁盘I/O传输时间主要由寻道时间、旋转延时和数据传送时间组成，其中寻道时间所消耗的时间最长。因此，我们主要针对磁盘调度（磁盘访问请求顺序）进行优化，从而减少寻道时间。</p><p>接下来介绍一些常见的磁盘调度算法。</p><h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><p>按顺序处理请求，<strong>根据进程请求访问磁盘的先后顺序进行调度</strong>。</p><ul><li>公平对待所有进程</li><li>在有很多进程的情况下，接近随机调度的性能</li></ul><h3 id="最短服务时间优先-SSTF"><a href="#最短服务时间优先-SSTF" class="headerlink" title="最短服务时间优先(SSTF)"></a>最短服务时间优先(SSTF)</h3><p>选择从磁臂当前位置需要<strong>移动最少距离</strong>的I/O请求。</p><ul><li>可以保证每次寻道时间最短，但是不能保证总的寻道时间最短</li></ul><h3 id="扫描算法-SCAN"><a href="#扫描算法-SCAN" class="headerlink" title="扫描算法(SCAN)"></a>扫描算法(SCAN)</h3><p>磁臂在一个方向上移动，访问所有未完成的请求，<strong>只有移动到该方向的最外侧磁道或最内侧磁道才可以反向移动</strong>（即便在磁头移动的方向上已经没有请求，仍然必须移动到最内/外侧的磁道）。由于磁头移动的方式很像电梯，因此也被称为电梯算法(elevator algorithm)</p><ul><li>各个位置磁道的响应频率不平均（C-SCAN算法改进了这个缺点）</li></ul><h3 id="循环扫描算法-C-SCAN"><a href="#循环扫描算法-C-SCAN" class="headerlink" title="循环扫描算法(C-SCAN)"></a>循环扫描算法(C-SCAN)</h3><p>与SCAN相比，规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至最靠边缘的的磁道上（即另一端）而途中不处理任何请求</strong>。</p><ul><li><p>相比于SCAN算法，对于各个位置磁道响应频率比较平均，但平均寻道时间增加了</p></li><li><p>此外，就算磁盘边缘没有I/O请求的磁道也要走到头，浪费了时间。（ C-LOOK算法改进了这个缺点）</p></li></ul><h3 id="LOOK算法和C-LOOK算法"><a href="#LOOK算法和C-LOOK算法" class="headerlink" title="LOOK算法和C-LOOK算法"></a>LOOK算法和C-LOOK算法</h3><p>釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最边缘的被请求的磁道即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。</p><p><strong>注意，若无特别说明，也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度。</strong></p><h3 id="N步扫描-N-Step-SCAN-算法"><a href="#N步扫描-N-Step-SCAN-算法" class="headerlink" title="N步扫描(N-Step-SCAN)算法"></a>N步扫描(N-Step-SCAN)算法</h3><p>用于解决<strong>磁头粘着</strong>问题。</p><blockquote><p>磁头粘着(Arm Stickiness)现象：SSTF SCAN CSCAN等算法中，可能出现的磁头停留在某处不动的情况（例如进程反复请求对某一磁道的I/O操作可能会导致该现象）</p></blockquote><ul><li>将磁盘请求队列分成长度为N的子队列</li><li>子队列间：按FIFO算法依次处理所有子队列</li><li>子队列内：用扫描算法处理每个队列</li></ul><h3 id="双队列扫描算法-FSCAN"><a href="#双队列扫描算法-FSCAN" class="headerlink" title="双队列扫描算法(FSCAN)"></a>双队列扫描算法(FSCAN)</h3><p>FSCAN算法是N步扫描算法的简化，只将磁盘请求队列分成两个子队列，这样可以减少平均等待时间</p><ul><li>把磁盘I/O请求分成两个队列</li><li>交替使用扫描算法处理一个队列</li><li>新生成的磁盘I/O请求放入另一队列中 所有的新请求都将被推迟到下一次扫描时处理</li></ul><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><blockquote><p><strong>缓存</strong>：数据传输双方访问速度差异很大时，引入的速度匹配中间层</p></blockquote><p>磁盘缓存是磁盘扇区在内存中的缓存区</p><ul><li>磁盘缓存的调度算法很<strong>类似虚拟存储</strong>调度算法</li><li>磁盘的访问<strong>频率远低于</strong>虚拟存储中的内存访问频率</li><li>通常磁盘缓存调度算法会比虚拟存储<strong>复杂</strong></li></ul><h4 id="单缓存与双缓存"><a href="#单缓存与双缓存" class="headerlink" title="单缓存与双缓存"></a>单缓存与双缓存</h4><p>单缓存(Single Buffer Cache)</p><ul><li>读和写不能同时进行，速度受限</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909191000.png" alt="Single_Buffer_Cache" style="zoom:50%;" /><p>双缓存(Double Buffer Cache)</p><ul><li>读和写可同时进行</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210909191014.png" alt="Double_Buffer_Cache" style="zoom:50%;" /><h4 id="访问频率置换算法-Frequency-based-Replacement"><a href="#访问频率置换算法-Frequency-based-Replacement" class="headerlink" title="访问频率置换算法(Frequency-based Replacement)"></a>访问频率置换算法(Frequency-based Replacement)</h4><ul><li>解决的问题<ul><li>在一段密集磁盘访问后 ，被密集访问的缓存块的引用计数迅速增大，从而使LFU算法的引用计数变化无法反映当前的引用情况（我的理解是，这些之前被密集访问的缓存块之后可能不在被访问，但因其计数很大，这些缓存块几乎永远不会被替换，从而产生问题）</li></ul></li><li>算法思路<ul><li>考虑磁盘访问的密集特征，对密集引用不计数</li><li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li></ul></li></ul><p><strong>具体实现</strong>：</p><p>把LRU算法中的特殊栈分成三部分，并在每个缓存块增加一个引用计数。</p><p><img src="https://yuerer.com/images/Frequency_based_Replacement.png" alt="Frequency_based_Replacement"></p><p>缓存未满时：</p><ul><li>栈中缓存块被访问时移到栈顶。如果该块在新区域，引用计数不变，否则引用计数加1<ul><li>在新区域中引用计数不变的目的是避免密集访问对引用计数的不利影响</li><li>在中间区域和旧区域中引用计数加1是为了使用LFU算法</li></ul></li><li>未缓存数据块读入后放在栈顶，引用计数为1</li><li>中间区域的定义是为了有一个过渡期，避免新读入的缓存块在第一次出新区域时（此时其计数较少，但之后可能被频繁访问）马上被置换 </li></ul><p>缓存已满时：</p><ul><li>在旧区域中引用计数最小的缓存块被置换</li></ul><p>至此，操作系统课程结束，完结撒花🎉！(^-^)</p>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab8：文件系统</title>
      <link href="2021/09/08/os/lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/09/08/os/lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>设备驱动程序、文件系统、虚拟文件系统。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab7</code> 源代码，<code>lab8</code> 主要做了如下改动：</p><ul><li><p><code>proc.h</code> 扩展 <code>struct proc_struct</code> 成员属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span>                <span class="comment">// 当前进程的文件集信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前进程所在工作目录的 inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开文件表</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 共享此 files_struct 的进程个数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 用于互斥访问 files_struct</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;<span class="comment">// 文件状态 (无效、初始态、打开态、关闭态)</span></span><br><span class="line">    <span class="keyword">bool</span> readable;<span class="comment">// 可读</span></span><br><span class="line">    <span class="keyword">bool</span> writable;<span class="comment">// 可写</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">// 对应的文件描述符</span></span><br><span class="line">    <span class="keyword">off_t</span> pos;<span class="comment">// 目前的访问位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span><span class="comment">// 对应的 inode</span></span><br><span class="line">    <span class="keyword">int</span> open_count;<span class="comment">// 此文件打开的次数 (此实验中，该字段似乎没什么用。然而，对于 Linux 系统而言，该字段是具有意义的：父子进程共享文件描述符，它们会对应至相同的文件表项，该表项的 open_count 取值会增加)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在 Linux 系统中，每个打开的文件对应三种数据结构：文件描述符表、打开文件表、<code>inode</code> 表，其中前一者为进程级数据结构，后两者为系统级数据结构。<a href="https://blog.csdn.net/ai2000ai/article/details/79738422">https://blog.csdn.net/ai2000ai/article/details/79738422</a></p><p>在 <code>ucore</code> 中，每个打开的文件仅对应两种数据结构：打开文件表 (包含文件描述符表的信息)、<code>inode</code> 表，其中前者为进程级数据结构，后者为系统级数据结构。</p></blockquote></li><li><p><code>iobuf.[ch]</code> 提供数据读写的内核缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     </span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   </span><br><span class="line">    <span class="keyword">size_t</span> io_len;     </span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>dev.h</code> 规范设备抽象 (只要设备实现此结构所需内容，该系统便可应用此设备，用于屏蔽底层设备的不同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得一说的是，借助于上述内容，我们可以实现如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>inode.h</code> 规范 VFS 层级的 <code>inode</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="comment">// inode 对应的实际类型所存放的信息 (若是设备，则存放设备信息；若是特定 FS，则存放其详细的 inode 信息)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="comment">// inode 对应的实际类型 (特定设备、特定文件系统)</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="comment">// 此 inode 的引用计数</span></span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="comment">// 打开此 inode 的文件个数</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="comment">// inode 对应的抽象文件系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="comment">// 抽象 inode 的操作集</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VFS 层级，针对 inode 操作的众多定义，具体实现基于实际的文件系统</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>vfs.h</code> 规范 VFS 层级的 <code>fs</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="comment">// 具体文件系统的信息 (此实验仅涉及 sfs)。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;                                      </span><br><span class="line">    <span class="comment">// fs 对应的实际文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     </span><br><span class="line">    <span class="comment">// 针对 fs 的四大操作</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   </span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              </span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);          </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>vfs.h</code> 提供 VFS 层级的，针对文件、路径等内容的众多操作，它们进一步会调用 <code>inode_op-&gt;xxx</code> 完成具体功能。</p></blockquote></li><li><p><code>sysfile.[ch]</code> 提供关于文件系统调用的内核级封装</p><p>这部分提供的系统调用会进一步调用 VFS 层级的函数，从而实现相关功能。</p></li><li><p><code>vfsdev.c</code> 提供 <code>vfs_dev_t</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ucore 将设备也视为一种文件，因此也将其集成至 VFS。</span></span><br><span class="line"><span class="comment">// VFS 将设备表示为 vfs_dev_t，并将其串接为一个链表，以方便后续操作。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 设备名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="comment">// 设备对应的 inode 信息 (十分重要，借助于它，ucore 才能统一设备与文件系统的操作)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="comment">// 设备所挂载的文件系统</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="comment">// 设备是否可挂载</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="comment">// 链接只用</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>sfs.h</code> 提供简易文件系统 SFS 的各种数据结构</p><p>下图为 SFS 的物理布局：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210908161934.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sfs superblock 内容的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">// 唯一标记 sfs </span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">// sfs 的总块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">// sfs 尚未使用的块数</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">// sfs 简介信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 的 硬盘inode 内容的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">// 文件大小 (字节单位)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">// 文件类型 (文件、目录、链接)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">// 硬链接数目</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">// 文件内容所占块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">// 块索引的直接索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">// 块索引的一级索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 目录文件内部一项的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">// 文件/目录的索引节点所占数据块索引值</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">// 文件/目录的名称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述均为数据在硬盘中的组织形式，下述则是数据在内存中的组织形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 的 内存inode 内容的具体结构 (之所以区分硬盘和内存，一则额外信息需要保存，二则方便某些操作)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">// 硬盘 inode 的具体信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">// inode 号</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">// 此 inode 是否被修改</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">// 此 inode 待回收数，若其值为 0，需将其写回硬盘</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">// 用于互斥访问 sfs_disk_inode</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">// 链接之用</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sfs 文件系统的具体结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">// superblock 信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">// 所挂载的设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">// freemap 表示的空闲块信息</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">// superblock/freemap 是否被修改</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">// 用于从硬盘获取非对齐块信息，以此作为缓冲，并复制给其他缓冲区</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">// 用于互斥访问 fs</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">// 用于互斥访问 io </span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">// sfs 所管部分 inode 的链表组织形式</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">// sfs 所管部分 inode 的 hash 表组织形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sfs_inode.c</code> 提供 SFS 关于 <code>inode</code> 操作的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 目录节点的操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 文件节点的操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="练习零"><a href="#练习零" class="headerlink" title="练习零"></a>练习零</h2><p>该练习用于了解 <code>ucore</code> 文件系统的实现机制与运行流程。</p><h3 id="文件系统的实现机制"><a href="#文件系统的实现机制" class="headerlink" title="文件系统的实现机制"></a>文件系统的实现机制</h3><p><code>ucore</code> 文件系统的实现机制详见 <code>fs_init()</code> ，我们对其进行简要分析：</p><ul><li><p><code>vfs_init()</code> 初始化 VFS</p><p>VFS 主要记录两大数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list;   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录的 inode 信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">bootfs_node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> bootfs_sem;</span><br></pre></td></tr></table></figure><p>因此，初始化上述变量即是 <code>vfs_init()</code> 的工作。</p></li><li><p><code>dev_init()</code> 初始化相关设备</p><p>此处设备指代 <code>stdin</code>、<code>stdout</code>、<code>disk0</code>，在此仅以 <code>stdin</code> 的初始化进行说明。</p><p><code>stdin</code> 初始化工作主要在于构建 <code>vfs_dev_t</code>，完成相关初始化，并将其加入至 <code>vdev_list</code>。</p><p><code>vfs_dev_t</code> 的详细信息具体如下 (可以看到：各字段均已填充完毕)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname; --&gt; <span class="string">&quot;stdin&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span>--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span>--&gt; <span class="literal">NULL</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;--&gt; <span class="literal">false</span> (设备不同，选项不同。对于 disk0，其选择即为 <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;--&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class">    <span class="title">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;--&gt; inode_type_device_info</span><br><span class="line">    <span class="keyword">int</span> ref_count;--&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">int</span> open_count;--&gt; <span class="number">0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>--&gt; <span class="literal">NULL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>--&gt; 在dev.c中声明的dev_node_ops (重申一次，这些操作具体由 struct device 所定义的四个函数实现)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;--&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;--&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);--&gt; stdin_open</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);--&gt; stdin_close</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);--&gt; stdin_io</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);--&gt; stdin_ioctl</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sfs_init()</code> 初始化 sfs</p><p><code>sfs_init()</code> 的工作在于：挂载 sfs 至 <code>disk0</code>，并使用 <code>disk0</code> 硬盘信息初始化 <code>fs</code>。(把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统).</p><p><code>fs</code> 的详细信息具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disk0 所指代的 vfs_dev_t-&gt;fs = 下述 struct fs</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="comment">// 具体文件系统的信息 (此实验仅涉及 sfs)。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;         --&gt; 下述的 <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span>                             </span></span><br><span class="line"><span class="class">    // <span class="title">fs</span> 对应的实际文件系统类型</span></span><br><span class="line"><span class="class">    <span class="title">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                --&gt; fs_type_sfs_info                     </span><br><span class="line">    <span class="comment">// 针对 fs 的四大操作</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);      --&gt; sfs_sync (此四者为 sfs 的具体实现)          </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   --&gt; sfs_get_root</span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              --&gt; sfs_unmount</span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);          --&gt; sfs_cleanup</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>             --&gt; disk0 硬盘所存的 superblock</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>          --&gt; disk0 所指代的 <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>             --&gt; 新建 freemap，并使用 disk0 硬盘所存信息进行初始化</span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                   --&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                   --&gt; 新建的缓冲区  </span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                 --&gt; 初始化若干信号量</span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             </span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          </span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;            --&gt; 初始化链表            </span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;            --&gt; 初始化 hash 表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注：第二个内核线程 <code>init</code> 的主体实现 <code>init_main()</code> 会设置 <code>disk0</code> 的根目录 <code>inode</code> 为<code>bootfs_node</code>。</p></blockquote></li></ul><p>至此，<code>ucore</code> 文件系统已然实现。</p><h3 id="文件系统的运行流程"><a href="#文件系统的运行流程" class="headerlink" title="文件系统的运行流程"></a>文件系统的运行流程</h3><p>使用若干文件操作说明 <code>ucore</code> 文件系统的运行流程：</p><ul><li><p><code>SYS_open</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_open 陷入中断，经获取 path/open_flags 参数后，调用 sysfile_open() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_open() 进一步调用 file_open()，它首先从当前进程的文件集中分配 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，并调用 <span class="title">vfs_open</span>() 进行处理。</span></span><br><span class="line"><span class="class">3. <span class="title">vfs_open</span>() 进一步调用 <span class="title">vfs_lookup</span>() 去寻找 <span class="title">path</span> 对应文件的 <span class="title">inode</span>。</span></span><br><span class="line"><span class="class">1. <span class="title">vfs_lookup</span>() 借助于 <span class="title">get_device</span>() 获取 <span class="title">path</span> 最初目录的 <span class="title">inode</span> (对于路径 &quot;<span class="title">device</span>:</span>xxx<span class="string">&quot; 而言，即是 device 对应的 inode，它可通过遍历 vdev_list 找到；对于路径 &quot;</span>/xxx<span class="string">&quot; 而言，即是 / 对应的 inode，它可通过访问 bootfs_node 得到；对于路径 &quot;</span>xxx<span class="string">&quot;，即是工作目录对应的 inode`，它可通过访问 pwd 得到)。</span></span><br><span class="line"><span class="string">2. 随后，借助于 vop_lookup() 寻找该目录下对应文件的 inode (该目录的 inode 已知，则可直接调用其具体的 inode_ops)。</span></span><br><span class="line"><span class="string">4. 如果没有找到对应文件的 inode，而 open_flags 允许新建，则新建一个 inode (该目录是已知的，则其通过 inode_ops 调用的新建流程会自动设置,新建 inode 的 inode_ops 为该文件系统所允许的 inode_ops)，并完成相应的初始化工作。</span></span><br><span class="line"><span class="string">5. 使用上述得到的 inode 以及 open_flags 填充 struct file。</span></span><br><span class="line"><span class="string">6. 返回 file-&gt;fd 给用户进程。</span></span><br></pre></td></tr></table></figure></li><li><p><code>SYS_close</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_close 陷入中断，经获取 fd 参数后，调用 sysfile_close() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_close() 进一步调用 file_close()，它首先从当前进程的文件集中获取此 fd 对应的 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，并调用 <span class="title">fd_array_close</span>() 进行处理。</span></span><br><span class="line"><span class="class">3. <span class="title">fd_array_close</span>() 将 <span class="title">file</span>-&gt;</span>open_count 减一，如果此时为 <span class="number">0</span>，则调用 fd_array_free() 进行清理。</span><br><span class="line"><span class="number">4.</span> fd_array_free() 进一步调用 vfs_close()，它会依据 node-&gt;ref_count/open_count 是否为 <span class="number">0</span>，进一步调用 vop_close()/vop_reclaim() 完成善后工作 (由于 inode 已知，同样可直接调用特定文件系统的 inode_ops )。</span><br></pre></td></tr></table></figure></li><li><p><code>SYS_read</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_read 陷入中断，经获取 fd/base/len 参数后，调用 sysfile_read() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_read() 执行若干预处理操作 (判断是否存在该 fd、分配内核缓冲区)，使用 file_read() 进行读取。</span><br><span class="line"><span class="number">3.</span> file_read() 找到该 fd 对应的 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，经过权限是否允许的判断后，使用 <span class="title">vop_read</span>() 读取相关内容至内核缓冲区。</span></span><br><span class="line"><span class="class">4. <span class="title">vop_read</span>() 会基于 <span class="title">file</span>-&gt;</span> pos 找到相应的物理块，并进一步调用设备的 dev_node_ops 完成读取操作。</span><br><span class="line"><span class="number">5.</span> 层层返回，将内核缓冲区的数据拷贝至用户空间 (可能由于待读取的数据很多，它会多次重复执行 <span class="number">3</span>/<span class="number">4</span>/<span class="number">5</span>)。</span><br></pre></td></tr></table></figure></li><li><p><code>SYS_write</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 系统调用 SYS_write 陷入中断，经获取 fd/base/len 参数后，调用 sysfile_write() 进行处理。</span><br><span class="line"><span class="number">2.</span> sysfile_write() 执行若干预处理操作 (判断是否存在该 fd、分配内核缓冲区、)。</span><br><span class="line"><span class="number">3.</span> 随后，sysfile_write() 拷贝用户空间数据至内核缓冲区，并使用 file_write() 进行写入。</span><br><span class="line"><span class="number">4.</span> file_write() 找到该 fd 对应的 <span class="class"><span class="keyword">struct</span> <span class="title">file</span>，经过权限是否允许的判断后，使用 <span class="title">vop_write</span>() 将内核缓冲区内容写入至相关设备。</span></span><br><span class="line"><span class="class">5. <span class="title">vop_write</span>() 会基于 <span class="title">file</span>-&gt;</span> pos 找到相应的物理块，并进一步调用设备的 dev_node_ops 完成写入操作。</span><br><span class="line"><span class="comment">// 可能由于待写入的数据很多，它会多次重复执行 3/4/5。</span></span><br></pre></td></tr></table></figure></li></ul><p>以用户态写文件函数write的整个执行过程为例，器流程图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210908184539.png" alt="image-20210908184539558"></p><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于实现文件读写的核心函数 <code>sfs_io_nolock()</code>。</p><blockquote><p>用户程序读文件需要使用系统调用。在用户程序执行<code>read</code>操作时会调用<code>sys_read</code>系统调用。根据ucore的中断机制实现，系统调用将通过<code>trap_dispatch</code>分发给<code>syscall</code>，随后分发给读的系统调用<code>sys_read</code>内核函数。</p><p><code>sys_read</code>内核函数需要进一步调用<code>sysfile_read</code>内核函数，进入到文件系统抽象层处理流程完成进一步的读文件操作。<code>sysfile_read</code>函数调用<code>file_read</code>函数，<code>file_read</code>函数调用<code>vop_read</code>函数接口进入到文件系统实例的读操作接口。</p><p><code>vop_read</code>函数实际上是对<code>sfs_read</code>的包装。sfs_read函数调用sfs_io函数。它有三个参数，node是对应文件的inode，iob是缓存，write表示是读还是写的布尔值（ 0表示读，1表示写） ，这里是0。函数先找到inode对应sfs和sin，<strong>然后调用sfs_io_nolock函数进行读取文件操作</strong>，最后调用iobuf_skip函数调整iobuf的指针。</p></blockquote><p><code>sfs_io_nolock</code>函数主要用来将磁盘中的一段数据读入到内存中或者将内存中的一段数据写入磁盘，其补充完整后的实现如下所示（ 完整代码见源代码 ，这里只展示补充的部分）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 未修改处</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="comment">// 判断 endpos 和 offset 是否在同一块中?</span></span><br><span class="line">        <span class="comment">// 若为同一块 则 size 为 endpos - offset。</span></span><br><span class="line">        <span class="comment">// 若不为同一块 则 size 为 SFS_BLKSIZE - blkoff(偏移) 为 第一块要读的大小。</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno++; nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间对齐的情况。</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno++, nblks--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 末尾最后一块没对齐的情况。</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问答</strong></p><p>如何实现 UNIX 的 PIPE 机制？</p><p>简单来说，PIPE 用于两个进程通信，前者输出放至管道，后者输入取自管道，输入输出并不同步。那么，我么可以新建一个临时文件，再分别让这两个进程打开，各自构建出一个 <code>struct file</code>，即文件描述符。两个进程应当对应不同的 <code>struct file</code>，但是对应相同的 <code>struct inode</code> (其对应的实际数据应当直接存放于内核之中)。</p><p>另外，对于每个进程而言，其 <code>fd_array[0,1,2]</code> 分别指代输入、输出、错误输出。因此，应当修改前者的输出 <code>fd_array[1]</code> 和后者的输入 <code>fd_array[0]</code> 为上述的 <code>struct file</code>。</p></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现程序加载的核心函数 <code>load_icode()</code>。</p><p><code>load_icode()</code> 实现具体见源代码 (可类比 lab7 实现此函数)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">  <span class="comment">// create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf;</span><br><span class="line">  <span class="comment">// 使用 load_icode_read 获取elf文件头 （read raw data content in file and resolve elfhdr）</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; ++i) &#123;</span><br><span class="line">      <span class="comment">// 使用 load_icode_read 获取每个程序头部表信息（read raw data content in file and resolve proghdr based on info in elfhdr）</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * i)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">      <span class="comment">// call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line"><span class="comment">// call pgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 从磁盘上复制相应的内容到内存</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// all mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相比于 lab7 实现，该实现需要妥善放置 argc 和 kargv 至用户栈，因此需要一番计算，使得其尽量减少不必要存储消耗，且能保证 kargv[i] 能顺利索引到相应的字符串。</span></span><br><span class="line">    <span class="comment">// 先算出所有参数加起来的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> total_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        total_len += strnlen(kargv[i], EXEC_MAX_ARG_LEN) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户栈顶 减去所有参数加起来的长度 再 4字节对齐 找到 真正存放字符串参数的栈的位置</span></span><br><span class="line">    <span class="keyword">char</span> *arg_str = (USTACKTOP - total_len) &amp; <span class="number">0xfffffffc</span>;</span><br><span class="line">    <span class="comment">// 放字符串参数的栈的位置的下面 是存放指向字符串参数的指针</span></span><br><span class="line">    <span class="keyword">int32_t</span> *arg_ptr = (<span class="keyword">int32_t</span> *)arg_str - argc;</span><br><span class="line">    <span class="comment">// 指向字符串参数的指针下面 是参数的个数</span></span><br><span class="line">    <span class="keyword">int32_t</span> *stacktop = arg_ptr - <span class="number">1</span>;</span><br><span class="line">    *stacktop = argc;</span><br><span class="line">  <span class="comment">// 将参数字符串拷贝到用户栈中对应位置，并设置相应的指针指向拷贝过来的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> arg_len = strnlen(kargv[i], EXEC_MAX_ARG_LEN);</span><br><span class="line">        <span class="built_in">strncpy</span>(arg_str, kargv[i], arg_len);</span><br><span class="line">        *arg_ptr = arg_str;</span><br><span class="line">        arg_str += arg_len + <span class="number">1</span>;</span><br><span class="line">        ++arg_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;       <span class="comment">// 设置对应的栈指针</span></span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：文件系统</title>
      <link href="2021/09/07/os/os%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/09/07/os/os%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h2><h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p><strong>文件系统</strong>：操作系统中管理<strong>持久性数据</strong>的子系统，提供数据<strong>存储</strong>和<strong>访问</strong>功能</p><ul><li>组织、检索、读写访问功能</li><li>大多数计算机系统都有文件系统</li><li>Google也是一个文件系统</li></ul><p><strong>文件</strong>：具有符号名，由字节序列构成的数据项集合。</p><ul><li>文件系统的基本数据单位</li><li>文件名是文件的表示符号</li></ul><p><strong>文件系统的功能</strong></p><ul><li><p>分配文件磁盘空间</p></li><li><ul><li>管理文件块（位置和顺序）</li><li>管理空闲空间（位置）</li><li>分配算法（策略）</li></ul></li><li><p>管理文件集合：</p></li><li><ul><li>定位：通过文件名定位文件并读取其内容</li><li>命名：对文件命名</li><li>文件系统结构：文件的组织方式</li></ul></li><li><p>数据可靠和安全</p></li><li><ul><li>可靠：持久保存文件，避免错误和崩溃</li><li>安全：多层次保护数据安全，减少攻击危害</li></ul></li></ul><p><strong>文件的属性</strong>包括：名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等</p><p><strong>文件头</strong>：文件系统元数据中的文件信息</p><ul><li>文件属性</li><li>文件存储位置和顺序</li></ul><h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><ul><li><p>磁盘文件系统：文件存储在数据存储设备上，如磁盘</p></li><li><ul><li>例如FAT，NTFS，ext2/3，ISO9660</li><li>不同文件系统的安全要求不同，按照所需选取对应协议即可。</li></ul></li><li><p>数据库文件系统：</p></li><li><ul><li>文件特征是可被寻址（辨识）的</li><li>例如WinFS</li></ul></li><li><p>日志文件系统：</p></li><li><ul><li>记录文件系统的修改/事件</li></ul></li><li><p>网络/分布式文件系统</p></li><li><ul><li>例如：NFS，SMB，AFS，GFS</li></ul></li><li><p>特殊文件系统，如管道</p></li><li><p>虚拟文件系统</p></li></ul><p><strong>关于网络/分布式文件系统</strong></p><p>文件可以通过网络被共享</p><ul><li>文件位于远程服务器，客户端</li><li>客户端远程挂载服务器文件系统</li><li>标准系统文件访问被转换成远程访问</li><li>标准文件共享协议：NFS（UNIX），CIFS（Win）</li></ul><p>分布式文件系统的挑战：</p><ul><li>客户端和客户端上的用户辨识很复杂</li><li>比如NFS是不安全的</li><li>一致性问题</li><li>错误处理模式</li></ul><h2 id="文件组织和存储"><a href="#文件组织和存储" class="headerlink" title="文件组织和存储"></a>文件组织和存储</h2><h3 id="目录、别名和虚拟文件系统"><a href="#目录、别名和虚拟文件系统" class="headerlink" title="目录、别名和虚拟文件系统"></a>目录、别名和虚拟文件系统</h3><p>文件以目录的方式组织起来</p><ul><li>目录是一类特殊文件<ul><li>目录的内容是文件索引表&lt;文件名, 指向文件的指针&gt;</li></ul></li><li>目录和文件的树型结构<ul><li>早期的文件系统是扁平的(只有一层目录)</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203054.png" alt="Hierarchical_File_System" style="zoom:50%;" /><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>操作系统应该只允许内核修改目录以确保映射的完整性，应用程序通过系统调用访问目录。</p><p><strong>典型目录操作</strong>：搜索、创建、删除、列出、重命名、遍历</p><h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><ul><li>文件名的线性列表 包含了指向数据块的指针<ul><li>编程简单</li><li>执行搜索耗时</li></ul></li><li>哈希表<ul><li>减少目录搜索时间</li><li>可能会产生冲突（两个文件名的哈希值相同）</li><li>固定大小</li></ul></li></ul><h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><p>两个或多个文件名关联同一个文件</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203223.png" alt="Alias" style="zoom:50%;" /><ul><li>硬链接<ul><li>多个文件项指向一个文件(只在删除最后一个指向这个文件的文件名时，才真正删除该文件的实体)</li></ul></li><li>软链接<ul><li>通过快捷方式指向其他文件</li><li>通过存储真实文件的逻辑名称来实现</li></ul></li></ul><h4 id="文件目录中的循环"><a href="#文件目录中的循环" class="headerlink" title="文件目录中的循环"></a>文件目录中的循环</h4><p>父目录指向子目录，子目录又指回父目录，无限循环</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203500.png" alt="Directory_Loop" style="zoom:50%;" /><ul><li>解决循环的办法<ul><li>只允许到文件的链接 不允许在子目录里的链接</li><li>增加链接时 用循环检测算法确定是否合理(银行家算法 开销大)</li></ul></li><li>实际上是限制路径可遍历文件目录的长度</li></ul><h4 id="名字解析-路径遍历"><a href="#名字解析-路径遍历" class="headerlink" title="名字解析(路径遍历)"></a>名字解析(路径遍历)</h4><p>名字解析是指将逻辑名字转换成物理资源(文件)</p><ul><li>遍历文件名录直到找到目标文件</li></ul><p>当解析 <code>&quot;/bin/ls&quot;</code>时</p><ul><li>读取根目录的文件头(在磁盘固定位置)</li><li>读取根目录的数据块 搜索 <code>bin</code> 项</li><li>读取 <code>bin</code> 的文件头</li><li>读取 <code>bin</code> 的数据块 搜索 <code>ls</code> 项</li><li>读取 <code>ls</code> 的文件头</li></ul><p>当前工作目录(PWD)</p><ul><li>每个进程都会指向一个文件目录用于解析文件名(可以提高效率)</li><li>允许用户指定相对路径来代替绝对路径 如 <code>PWD=&quot;/bin”</code> 能够解析 <code>“ls”</code></li></ul><h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><p>文件系统需要先挂载才能被访问（未挂载的文件系统需要挂载在挂载点上）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907203853.png" alt="Mounting_File_Systems" style="zoom:50%;" /><h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><ul><li>目的<ul><li>对所有不同文件系统的抽象</li></ul></li><li>功能<ul><li>提供相同的文件和文件系统接口</li><li>管理所有文件和文件系统关联的数据结构</li><li>高效查询例程 遍历文件系统</li><li>与特定文件系统模块的交互</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907204741.png" alt="File_system_implementation" style="zoom:50%;" /><p>文件系统基本数据结构包括（各中文件系统都应该有）：</p><ul><li><strong>文件卷控制块</strong>：每个文件系统一个，包括文件系统的详细信息如块、块大小、空余快、计数、指针等，如Unix中的superblock</li><li><strong>文件控制块</strong>：每个文件一个，包括文件的详细信息如访问权限、拥有者、大小、数据块位置等，如Unix中的vnode</li><li><strong>目录项</strong>：每个目录项对应一个子目录或文件，将目录项数据结构以及树形布局编码成数据结构，指向文件控制块、父目录、子目录。</li></ul><p>这些数据持久存入外存，当需要加载时进入内存，加载的时机分别为：</p><ul><li>卷控制模块：当文件系统挂载时进入内存</li><li>文件控制块：当文件被访问时进入内存</li><li>目录节点：在遍历一个文件路径时进入内存</li></ul><p><strong>文件系统的存储视图：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907205525.png" alt="File_system_storage" style="zoom:50%;" /><h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><p>背景：大多数文件都很小，一些文件非常大</p><ul><li>需要对小文件提供很好的支持，块空间不能太大</li><li>必须支持大文件，大文件访问必须高效</li></ul><p>如何表示分配给一个文件数据块的位置和顺序就成为一个问题。</p><p><strong>分配方式主要有如下几种</strong>：</p><ul><li>连续分配</li><li>链式分配</li><li>索引分配</li></ul><p>以下我们从存储效率和读写性能等方面来评定这些分配方式。</p><p><strong>连续分配</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907213822.png" alt="Continuous_Allocation" style="zoom:50%;" /><ul><li>文件头指定起始块和长度</li><li>分配策略包括最先匹配、最佳匹配</li><li>优点：文件读取表现好，访问高效（随机访问）。</li><li>缺点：碎片；文件增长时会出现问题</li></ul><p><strong>链式分配</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907213838.png" alt="Linked_Allocation" style="zoom:50%;" /><ul><li>文件以数据块链表方式存储</li><li>文件头包含了到第一块和最后一块的指针</li><li>优点：创建、增大、缩小很方便，没有碎片</li><li>缺点：不支持随机访问，访问效率低；可靠性差（破坏了一个链，后面的数据就会丢失）</li></ul><p><strong>索引分配</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214116.png" alt="Indexed_Allocation" style="zoom:50%;" /><ul><li>为每个文件创建一个索引数据块，其中存放指向文件数据块的指针列表</li><li>文件头包含了索引数据块指针</li><li>优点：直接访问，创建、增大、缩小很方便，没有碎片</li><li>缺点：对于小文件来说，有多余开销；多索引块才能实现大文件索引（一个索引快可能放不下所有索引）</li></ul><p>大文件可以使用链式索引或者多级索引实现。</p><p><strong>链式索引块</strong>(IB + IB + …)</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214257.png" alt="Link_Index_Allocation" style="zoom:50%;" /><p><strong>多级索引块</strong>(IB * IB * …)</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214306.png" alt="Multilevel_Index_Allocation" style="zoom:50%;" /><p><strong>UFS多级索引分配(UFS Unix File System)</strong></p><p>将各种分配方法融合到一起</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907214349.png" alt="Unix_file_system" style="zoom:50%;" /><ul><li>文件头包含13个指针<ul><li>10个指针指向数据块</li><li>第1个指针指向索引块</li><li>第12个指针指向二级索引快</li><li>第13个指针指向三级索引快</li></ul></li><li>效果<ul><li>提高了文件大小限制阈值</li><li>动态分配数据块 文件扩展很容易</li><li>小文件开销小</li><li>只为大文件分配间接索引块 大文件在访问数据块时需要大量查询</li></ul></li></ul><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>采用什么数据结构来表示空闲空间？</p><p>可以使用<strong>位图</strong>：用一个01向量来表示整个存储空间的数据块占用情况。0表示空闲，1表示已经分配</p><p>其使用简单，但是会产生一个很大的向量</p><ul><li>维护起来工作量很大</li><li>假定空闲空间在磁盘中均匀分布，则找到空闲块之前平均扫描n/r个数据块（n为磁盘上数据块的总数，r为空闲块的数目）</li></ul><p>类似空间分配、页式存储等的思路，这里可以使用链表串联空闲空间。另外可以结合索引结构，实现索引链表，节省空间且容易查找。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220009.jpg" alt="img" style="zoom: 80%;" /><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>通常磁盘通过分区来最大限度减小寻道时间</p><ul><li>分区是一组柱面的集合</li><li>每个分区都可以视为逻辑上独立的磁盘</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220141.png" alt="Disk_partitioning" style="zoom:40%;" /><p>一个拥有完整文件系统实例的外存空间通常常驻在磁盘的单个分区上。</p><ul><li>可以将一个磁盘分为多个逻辑分区。</li><li>也可以将多个磁盘组成一个逻辑分区</li></ul><p>使用多个磁盘的好处：</p><ul><li>通过并行改善吞吐量</li><li>通过冗余改善可靠性和可用性</li></ul><p>冗余磁盘阵列（RAID）</p><ul><li>多种磁盘管理技术</li><li>RAID分类：RAID-0，RAID-1，RAID-5等</li><li>实现：可以通过操作系统内核的文件卷管理实现，也可以通过RAID硬件控制器</li></ul><p>RAID-0：磁盘条带化</p><ul><li>把数据块分成多个子块，存储在独立的磁盘中</li><li>通过独立磁盘上<strong>并行</strong>数据块访问提供<strong>更大的磁盘带宽</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220448.png" alt="RAID_0" style="zoom: 40%;" /><p>RAID-1：磁盘镜像</p><ul><li>向两个磁盘写入，从任意一个读取</li><li><strong>可靠性</strong>成倍增长，读取性能线性增加</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220536.png" alt="RAID_1" style="zoom:50%;" /><p>RAID-4：带校验的磁盘条带化</p><ul><li>数据块级的磁盘条带化+专用奇偶校验磁盘<ul><li>奇偶校验规则可阅读<a href="https://blog.csdn.net/weixin_30657541/article/details/98186875">这篇博文</a></li></ul></li><li>允许从任意一个故障磁盘中恢复，增大可靠性</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220640.png" alt="RAID_4" style="zoom:40%;" /><p>RAID-5：带分布式校验的磁盘条带化</p><p>减小对校验和所在磁盘的读写压力</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220722.png" alt="RAID_5" style="zoom: 40%;" /><p>RAID-3：如上的RAID-0,4,5基于数据块，也可以有基于位的条带化/校验结构。</p><p>RAID-6：增加一个奇偶校验块，容许更多的出错。</p><p><strong>RAID嵌套</strong></p><ul><li>RAID 0 + 1(条带化提高性能 再做一个磁盘镜像 可靠性提高)</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220826.png" alt="RAID_0+1" style="zoom:50%;" /><ul><li>RAID 1 + 0(先做磁盘镜像 再做条带化)</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907220848.png" alt="RAID_1+0" style="zoom:50%;" /><h2 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>操作系统在打开文件表（进程独有的和系统级的）中维护的打开文件状态和信息</p><ul><li>文件指针<ul><li>最近一次读写位置</li><li>每个进程分别维护自己的打开文件指针</li></ul></li><li>文件打开计数<ul><li>当前打开文件的次数</li><li>最后一个进程关闭文件时 将其从打开文件表中移除</li></ul></li><li>文件的磁盘位置<ul><li>缓存数据访问信息</li></ul></li><li>访问权限<ul><li>每个进程的文件访问模式信息（<a href="https://blog.csdn.net/ai2000ai/article/details/79738422">其中各个数据结构之间的关系</a>）</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907200026.png" alt="image-20210907200026247" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907200103.png" alt="image-20210907200103570" style="zoom:80%;" /><h4 id="文件的用户视图和系统视图"><a href="#文件的用户视图和系统视图" class="headerlink" title="文件的用户视图和系统视图"></a>文件的用户视图和系统视图</h4><ul><li>文件的用户视图<ul><li>持久的数据结构</li></ul></li><li>系统访问接口<ul><li>字节序列的集合(Unix)</li><li>系统不关心存储在磁盘上的数据结构</li></ul></li><li>操作系统的文件视图<ul><li>数据块的集合</li><li>数据块是逻辑存储单元 而扇区是物理存储单元</li><li>块大小和扇区大小通常是不同的 通常是几个扇区构成一个数据块</li></ul></li></ul><h4 id="用户视图到系统视图的转换"><a href="#用户视图到系统视图的转换" class="headerlink" title="用户视图到系统视图的转换"></a>用户视图到系统视图的转换</h4><p>文件系统中的基本操作单位是数据块 <code>getc()和putc()</code>即使每次只访问1字节的数据 也需要缓存目标数据4096字节</p><ul><li>进程读文件<ul><li>获取字节所在的数据块(数据块是逻辑存储单位)</li><li>返回数据块内对应部分</li></ul></li><li>进程写文件<ul><li>获取数据块</li><li>修改数据块中对应部分</li><li>写回数据块</li></ul></li></ul><h4 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h4><p>操作系统需要了解进程如何访问文件</p><ul><li>顺序访问<ul><li>按字节依次读取</li><li>大多数文件访问都是顺序访问</li></ul></li><li>随机访问<ul><li>从中间读写</li><li>不常用 但很重要</li><li>虚拟内存中把内存页存储在文件</li></ul></li><li>索引访问<ul><li>依据数据特征进行索引</li><li>通常操作系统不完整提供索引访问</li><li>可以在索引内容的磁盘访问之上建立数据库来提供完整索引访问</li></ul></li></ul><h4 id="文件内部结构"><a href="#文件内部结构" class="headerlink" title="文件内部结构"></a>文件内部结构</h4><ul><li>无结构<ul><li>单词、字节序列</li></ul></li><li>简单记录结构<ul><li>分列</li><li>固定长度</li><li>可变长度</li></ul></li><li>复杂结构<ul><li>格式化的文档(PDF Word)</li><li>可执行文件</li></ul></li></ul><h4 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h4><p>多用户系统中的文件共享是很有必要的</p><ul><li>访问控制<ul><li>每个用户能够获得哪些文件的哪些访问权限</li><li>访问模式 读 写 执行 删除 列表</li></ul></li><li>文件访问控制列表(ACL)<ul><li>&lt;文件实体, 权限&gt;</li></ul></li><li>Unix模式<ul><li>&lt;用户|组|所有人, 读|写|可执行&gt;</li><li>用户标识ID<ul><li>识别用户 表明每个用户所允许的权限及保护模式</li></ul></li><li>组标识ID<ul><li>允许用户组成组 并指定了组访问权限</li></ul></li></ul></li></ul><h5 id="语义一致性"><a href="#语义一致性" class="headerlink" title="语义一致性"></a>语义一致性</h5><p>规定多进程如何同时访问共享文件</p><ul><li>与同步算法相似</li><li>因磁盘I/O和网络延迟而设计简单</li><li>Unix文件系统(UFS)语义(相当于把一致性问题丢回给用户自己处理)<ul><li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li><li>共享文件指针允许多用户同时读取和写入文件</li></ul></li><li>会话语义<ul><li>写入内容只有当文件关闭时可见(一次就要写完整 效率低)</li></ul></li><li>读写锁<ul><li>一些操作系统和文件系统提供该功能(又是将一致性问题抛给用户)</li></ul></li></ul><h3 id="文件缓存和打开文件管理"><a href="#文件缓存和打开文件管理" class="headerlink" title="文件缓存和打开文件管理"></a>文件缓存和打开文件管理</h3><p>多种磁盘缓存位置：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907211502.png" alt="Disk_cache" style="zoom:50%;" /><p>两种数据块缓存方式</p><ul><li>数据块缓存</li><li>页缓存： 统一缓存数据块和内存页</li></ul><h4 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h4><ul><li>数据块按需进入内存<ul><li>提供read()操作</li><li>预读 预先读取后面的数据块</li></ul></li><li>数据块使用后被缓存<ul><li>假设数据将会再次用到</li><li>写操作可能被缓存和延迟写入</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907212157.png" alt="Data_Block_cache" style="zoom:50%;" /><h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><ul><li>虚拟页式存储<ul><li>在虚拟地址空间中虚拟页面可映射到本地外存文件中</li></ul></li><li>文件数据块的页缓存<ul><li>在虚拟内存中文件数据块被映射成页</li><li>文件的读/写操作被转换成对内存的访问</li><li>可能导致缺页或被设置为脏页</li><li>会带来问题 页面置换算法需要协调虚拟存储和页缓存间的页面数</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907212211.png" alt="Page_cache" style="zoom:50%;" /><h4 id="文件系统中打开文件的数据结构"><a href="#文件系统中打开文件的数据结构" class="headerlink" title="文件系统中打开文件的数据结构"></a>文件系统中打开文件的数据结构</h4><ul><li>文件描述符<ul><li>每个被打开的文件都有一个文件描述符</li><li>文件状态信息<ul><li>目录项 当前文件指针 文件操作设置</li></ul></li></ul></li><li>打开文件表<ul><li>每个进程都有一个打开文件表</li><li>一个系统级的打开文件表</li><li>有文件被打开时 文件卷就不能被卸载</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907212238.png" alt="Open_file_table" style="zoom:50%;" /><h5 id="打开文件锁"><a href="#打开文件锁" class="headerlink" title="打开文件锁"></a>打开文件锁</h5><p>一些文件系统提供文件锁 用于协调多进程的文件访问</p><ul><li>强制<ul><li>根据锁保持情况和访问需求确定是否拒绝访问</li></ul></li><li>劝告<ul><li>进程可以查找锁的状态来决定怎么做</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：死锁和进程通信</title>
      <link href="2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>2021/09/07/os/os%EF%BC%9A%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h3><p>死锁是由于竞争资源或者通信关系，两个或更多线程在执行中出现的，永远相互等待只能由其他进程引发的事件 的状态。</p><p><strong>我们使用进程和资源的关系来对死锁进行描述</strong>。系统中存在各种类型的资源（CPU执行时间、内存空间、I/O设备等），每类资源都可能有多个实例。</p><p>进程访问资源时，有如下流程：</p><ul><li>请求/获取：申请空闲资源</li><li>使用/占用：进程占用资源</li><li>释放：资源状态由占用变成空闲</li></ul><p>而资源可以分为如下两类：</p><ul><li><strong>可重用资源</strong>（Reusable）：资源不能删除，互斥，可重用，比如处理器、I/O通道，主副存、文件、数据库、信号量等等，在各占<strong>一部分</strong>资源时会出现死锁</li><li><strong>消耗资源</strong>（Consumable）：资源创建和销毁，在I/O缓冲区的中断、信号、消息等，相互等待通信时可能死锁。</li></ul><p>进程和资源之间的分配和占用可以用<strong>资源分配图</strong>表示，这是一个有向图，其中资源和进程间的分配和占用关系如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907103630.png" alt="Resource_allocation_mapping" style="zoom: 40%;" /><p><strong>出现死锁的必要条件</strong>：</p><ul><li>互斥<ul><li>任何时刻只能有一个进程使用一个资源实例</li></ul></li><li>持有并等待<ul><li>进程保持至少一个资源 并正在等待获取其他进程持有的资源</li></ul></li><li>非抢占<ul><li>资源只能在进程使用后自愿释放</li></ul></li><li>循环等待</li></ul><p>死锁和非死锁的资源分配图示例：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907103850.png" alt="Resource_allocation_mapping_Deadlock" style="zoom:50%;" /><blockquote><p>如上两个图中的情况的不同在于，图右的产生循环的资源都不止一个实例。</p></blockquote><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><ul><li><strong>死锁预防</strong>（prevention）：限制并发进程对资源的请求，使得系统在任何时刻都<strong>不满足死锁的必要条件</strong>（四个）。</li><li><strong>死锁避免</strong>（avoidance）：在分配资源前判断，只允许不会出现死锁的进程请求资源。</li><li><strong>死锁检测和恢复</strong>：在检测到运行系统进入死锁状态后，进行恢复。</li></ul><p>目前大多数操作系统都是由应用程序来解决死锁问题。</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件，即消除死锁的必要条件。</p><p>消除四个必要条件的做法：</p><ul><li>互斥：允许资源同时使用。比如在线编辑文档</li><li>持有并等待：进程请求资源时，要求它不持有其他任何资源。即要求所有进程在开始执行时，一次性地申请在整个运行过程中所需的全部资源（资源利用效率会变低）</li><li>非抢占：如果进程请求不能立即分配的资源，则释放占有资源，再分配时只对拥有所有所需资源的进程进行分配操作。</li><li>循环等待：对资源排序，要求进程按顺序请求资源</li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>利用额外的先验信息，在分配资源时进行动态检查，若分配后系统可能发生死锁，则不予分配，否则予以分配。</p><h5 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h5><ul><li>如果系统能按某种顺序为每个进程依次分配其所需的资源，直至所有进程都能运行完成，称此时系统处于安全状态</li><li>这种进程的顺序，如P4,P1,…,Pn, 称为安全序列</li><li>若不存在这样一个安全序列称此时系统处于不安全状态</li><li>如果不按安全序列分配资源，则系统可能会由安全状态进入不安全状态。</li></ul><blockquote><p>注意：不安全状态≠死锁</p><ul><li>处于不安全状态的系统不一定会发生死锁（具体原因可看<a href="https://blog.csdn.net/qq_34666857/article/details/104122776">这篇博文</a>）</li><li>处于安全状态的系统一定不会发生死锁</li></ul><p>如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907110717.png" alt="image-20210907110701819"></p></blockquote><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>银行家算法就是一种基于资源安全状态判断的死锁避免算法，借鉴银行贷款的策略实现。</p><ul><li>申请资源的线程在第一次申请资源的时候需声明所需最大资源数，在满足所有资源要求并执行完成后，及时释放资源归还操作系统</li><li>若线程申请的资源数量不超过操作系统拥有的最大值时，操作系统尽量满足申请资源的线程的需求</li></ul><p>实现银行家算法时需要的数据结构如下（n 为线程数量，m 为资源类型数量）：</p><ul><li>总需求矩阵Max：各个线程对应每种资源的最大需求量（n x m 矩阵）</li><li>总剩余向量Available：各个资源的剩余量（长度为 m 的向量）</li><li>已分配矩阵Allocation：各个线程对应每种资源的已有量（n x m 矩阵）</li><li>未来需要矩阵Need：各个线程对应每种资源的需求差量（n x m 矩阵）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Need[i,j] = Max[i,j] - Allocation[i,j]</span><br></pre></td></tr></table></figure><p>银行家算法<strong>安全状态判断</strong>：</p><ol><li><p>初始化长度为 m 的Work向量和 长度为 n 的Finish向量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work = Available <span class="comment">// 当前资源剩余空闲量</span></span><br><span class="line">Finish[i] = <span class="literal">false</span> <span class="keyword">for</span> i : <span class="number">1</span>, <span class="number">2</span>, ..., n <span class="comment">// 线程i有没有完成</span></span><br></pre></td></tr></table></figure></li><li><p>寻找线程Ti，其满足以下条件:</p><ul><li>Finish[i] = false</li><li>Need[i] &lt;= Work</li></ul><p>没有找到满足条件的线程，则跳转到步骤4</p></li><li><p>找到线程Ti，则进行以下操作：</p><ul><li>Work = Work + Allocation[i]</li><li>Finish[i] = true</li><li>回到 步骤1</li></ul></li><li><p>检查所有线程是否满足 Finish[i] == true</p><ul><li>若都等于，则系统处于安全状态</li></ul></li></ol><p>知道了如何进行安全状态判断后，就有了整体的算法执行流程，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">初始化: Requesti 线程Ti的资源请求向量</span><br><span class="line">       Requesti[j] 线程Ti请求资源Rj的实例数量</span><br><span class="line">循环:</span><br><span class="line">1.如果 Requesti ≤ Need[i], 转到步骤2。否则, 拒绝资源申请, 因为线程已经超过了其最大要求</span><br><span class="line">2.如果 Requesti ≤ Available, 转到步骤3。否则, Ti 必须等待, 因为资源不可用</span><br><span class="line">3.通过安全状态判断来确定是否分配资源给Ti: 生成一个需要判断状态是否安全的资源分配环境</span><br><span class="line">- Available &#x3D; Available - Requesti;</span><br><span class="line">- Allocation[i] &#x3D; Allocation[i] + Requesti;</span><br><span class="line">- Need[i]&#x3D; Need[i] – Requesti;</span><br><span class="line">4.调用安全状态判断方法，</span><br><span class="line">- 若安全 则分配资源给Ti</span><br><span class="line">- 若不安全 则拒绝Ti的资源请求</span><br></pre></td></tr></table></figure><h4 id="死锁检测-Deadlock-Detection"><a href="#死锁检测-Deadlock-Detection" class="headerlink" title="死锁检测(Deadlock Detection)"></a>死锁检测(Deadlock Detection)</h4><p>死锁检测方法和银行家算法的系统安全状态判断是类似的。其执行流程如下：</p><ol><li>初始化 Work 和 Finish:<ul><li>Work = Available // work为当前资源剩余量</li><li>Allocation[i] &gt; 0时 Finish[i] = false 否则为 true // 线程是否完成</li></ul></li><li>寻找线程Ti满足:<ul><li>Finish[i] = false // 线程没有结束 且 此线程需要的资源量小于剩余资源量</li><li>Requesti &lt;= Work</li><li>若没有找到 则跳到步骤4</li></ul></li><li>将找到的线程拥有的资源释放回当前空闲资源<ul><li>Work = Work + Allocation[i]</li><li>Finish[i] = true</li><li>跳到步骤2</li></ul></li><li>检查所有线程的 Finish 若有一个为 false 则系统处于死锁状态</li></ol><p>算法的时间复杂度为O(n^2 x m)，若让操作系统检测系统是否处于死锁状态，开销比较大，因此实际场景操作系统不管死锁。</p><h4 id="死锁恢复-Deadlock-Recovery"><a href="#死锁恢复-Deadlock-Recovery" class="headerlink" title="死锁恢复(Deadlock Recovery)"></a>死锁恢复(Deadlock Recovery)</h4><ul><li><p>选择哪个进程去终止?</p><ul><li>终止所有死锁的进程</li><li>一次只终止一个进程直到死锁消除</li><li>终止进程的顺序应该是<ul><li>进程的优先级(选最低的)</li><li>进程已运行时间以及还需运行时间(运行时间越长越考虑留下 因为已经利用资源算了很长时间了)</li><li>进程已占用资源</li><li>进程完成需要的资源</li><li>终止进程数目(越少越好)</li><li>进程是交互还是批处理(让交互的继续执行)</li></ul></li></ul></li><li><p>怎么样终止进程? 资源抢占</p><ul><li>选择被抢占进程(成本最小的)</li><li>进程回退 返回到一些安全状态 重启进程到安全状态</li><li>可能出现饥饿 同一进程可能一直被选作抢占者</li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间进行通信和同步的机制。</p><h3 id="进程通信概念"><a href="#进程通信概念" class="headerlink" title="进程通信概念"></a>进程通信概念</h3><p>Inter-Processing Communication，后面我们都将进程通信简称为IPC。</p><p>IPC提供2个基本操作，发送（send）和接收（receive）。</p><p>进程通信流程</p><ol><li>在通信进程间建立通信链路</li><li>通过send/receive交换消息</li></ol><p>进程链路特征</p><ul><li>物理（如共享内存、硬件总线）</li><li>逻辑（如逻辑属性）</li></ul><h4 id="直接通信和间接通信"><a href="#直接通信和间接通信" class="headerlink" title="直接通信和间接通信"></a>直接通信和间接通信</h4><p>IPC可分为直接通信和间接通信：</p><p><strong>间接通信</strong>(通过系统维护的消息队列)，生命周期可以不同(两个进程不需要同时存在)</p><ul><li>每个消息队列都有一个唯一的标识</li><li>只有共享了相同消息队列的进程 才能够通信</li><li>通信链路属性<ul><li>只有共享了相同消息队列的进程 才建立连接</li><li>连接可以为单向也能为双向</li><li>消息队列可以与多个进程相关联</li></ul></li><li>间接通信流程<ol><li>创建一个新的消息队列</li><li>通过消息队列发送和接受消息(只关心消息队列是谁)</li><li>销毁消息队列</li></ol></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907164147.png" alt="Indirect_communication" style="zoom:50%;" /><p><strong>直接通信</strong>（两个进程必须同时存在才能进行通讯）</p><ul><li>进程必须正确命名对方</li><li>通信链路的属性<ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链路存在</li><li>链路可以为单向 但通常为双向</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907164211.png" alt="Direct_communication" style="zoom:50%;" /><h4 id="阻塞与非阻塞通信"><a href="#阻塞与非阻塞通信" class="headerlink" title="阻塞与非阻塞通信"></a>阻塞与非阻塞通信</h4><p>进程通信可划分为阻塞(同步)通信与非阻塞(异步)通信</p><p><strong>阻塞通信</strong></p><ul><li>阻塞发送<ul><li>发送者在发送消息后进入等待 直到接受者成功收到</li></ul></li><li>阻塞接受<ul><li>接受者在请求接受消息后进入等待 直到成功收到消息</li></ul></li></ul><p><strong>非阻塞通信</strong></p><ul><li>非阻塞发送<ul><li>发送者在消息发送后 可立即进行其他操作</li><li>没有消息发送时 接受者在请求接受消息后 接受不到任何消息(可以做别的事)</li></ul></li></ul><h4 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h4><p>进程发送的消息在链路上可能有三种缓冲方式</p><ul><li>0 容量<ul><li>发送方必须等待接收方(必须有接收方)</li></ul></li><li>有限容量<ul><li>通信链路缓冲队列满时 发送方必须等待</li></ul></li><li>无限容量<ul><li>发送方不需要等待</li></ul></li></ul><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>进程间的软件中断通知和处理机制(SIGKILL SIGSTOP SIGCONT)</p><ul><li>信号的接收处理<ul><li>捕获(Catch)：执行进程指定的信号处理函数</li><li>忽略(Ignore) ：执行操作系统指定的缺省处理(例如进程终止、进程挂起)</li><li>屏蔽(Mask) ：禁止进程接受和处理信号(可能是暂时的 当处理同样类型的信号)</li></ul></li><li>不足<ul><li>传送的信息量小，只有一个信号类型</li></ul></li></ul><h4 id="信号的实现"><a href="#信号的实现" class="headerlink" title="信号的实现"></a>信号的实现</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907165121.png" alt="Signal_implementation" style="zoom:50%;" /><h4 id="信号的使用示例"><a href="#信号的使用示例" class="headerlink" title="信号的使用示例"></a>信号的使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigproc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">signal(SIGINT, sigproc);   <span class="comment">// 为了兼容</span></span><br><span class="line"><span class="built_in">printf</span>(“you have pressed ctrl-c - disabled \n”);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitproc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="built_in">printf</span>(“ctrl-\\ pressed to quit\n”);   <span class="comment">/* this is “ctrl” &amp; “\” */</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    signal(SIGINT, sigproc);  <span class="comment">// signal 是注册信号的系统调用，摁下 ctrl+\ 时会发送SIGQUIT信号，</span></span><br><span class="line">  <span class="comment">// 摁下 ctrl+c 时会发送SIGINT信号</span></span><br><span class="line">    signal(SIGQUIT, quitproc);</span><br><span class="line"><span class="built_in">printf</span>(“ctrl-c disabled use ctrl-\\ to quit\n”);</span><br><span class="line"><span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe)"></a>管道(Pipe)</h3><p>进程间基于内存文件的通信机制，进程不知道也不关心另一端</p><ul><li>子进程从父进程继承文件描述符</li><li>缺省文件描述符 0 stdin, 1 stdout, 2 stderr</li></ul><h4 id="管道相关系统调用"><a href="#管道相关系统调用" class="headerlink" title="管道相关系统调用"></a>管道相关系统调用</h4><ul><li>读管道 read()，scanf() 是基于它实现的</li><li>写管道 write()，printf() 是基于它实现的</li><li>创建管道 pipe(rgfd)<ul><li>rgfd是2个文件描述符组成的数组</li><li>rgfd[0] 是读文件描述符</li><li>rgfd[1] 是写文件描述符</li></ul></li></ul><h4 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170054.png" alt="Pipe" style="zoom:50%;" /><ol><li>创建管道</li><li>为ls创建一个进程，设置其 stdout 为管道写端</li><li>为more创建一个进程，设置其 stdin 为管道读端</li></ol><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p><ul><li>每个消息(Message)是一个字节序列</li><li>相同标识的消息组成按先进先出顺序组成一个消息队列(Message Queues)</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170301.png" alt="Message_Queues" style="zoom:50%;" /><h4 id="消息队列的系统调用"><a href="#消息队列的系统调用" class="headerlink" title="消息队列的系统调用"></a>消息队列的系统调用</h4><ul><li>msgget()<ul><li>获取消息队列标识</li></ul></li><li>msgsnd()<ul><li>发送消息</li></ul></li><li>msgrcv()<ul><li>接收消息</li></ul></li><li>msgctl()<ul><li>消息队列控制</li><li>因为消息队列独立于创建它的进程 需要有系统调用完成消息队列的创建和销毁</li></ul></li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p><ul><li>进程<ul><li>每个进程都有私有内存地址空间</li><li>每个进程的内存地址空间需明确设置共享内存段</li></ul></li><li>线程<ul><li>同一进程中的线程总是共享相同的内存地址空间</li></ul></li><li>优点<ul><li>快速 方便地共享数据</li></ul></li><li>不足<ul><li>必须用额外的同步机制来协调数据访问</li></ul></li></ul><h4 id="共享内存的实现"><a href="#共享内存的实现" class="headerlink" title="共享内存的实现"></a>共享内存的实现</h4><p>通过页表项映射到同一物理页帧</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210907170400.png" alt="Share_memory_implement" style="zoom:50%;" /><ul><li>优点：速度最快<ul><li>没有系统调用干预 没有数据复制</li></ul></li><li>缺点：不提供同步</li></ul><h4 id="共享内存的系统调用"><a href="#共享内存的系统调用" class="headerlink" title="共享内存的系统调用"></a>共享内存的系统调用</h4><p>为了保证数据的完整性 需要信号量等机制协调共享内存的访问冲突</p><ul><li>shmget()<ul><li>创建共享段</li></ul></li><li>shmat()<ul><li>把共享段映射到进程地址空间</li></ul></li><li>shmdt()<ul><li>取消共享段到进程地址空间的映射</li></ul></li><li>shmctl()<ul><li>共享段的控制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab7:同步互斥</title>
      <link href="2021/09/06/os/lab7-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
      <url>2021/09/06/os/lab7-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>临界区、信号量、条件变量、管程。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab6</code> 源代码，<code>lab7</code> 主要做了如下改动：</p><ul><li><code>sched.[ch]</code> 增加定时器机制，用以实现 <code>do_sleep()</code> 功能</li><li><code>wait.[ch]</code> 实现基于链表形式的等待队列</li><li><code>sem.[ch]</code> 实现信号量机制</li><li><code>monitor.[ch]</code> 实现基于管程的条件变量机制</li></ul><h2 id="练习零"><a href="#练习零" class="headerlink" title="练习零"></a>练习零</h2><p>该练习用于了解定时器机制的实现流程。</p><p>为实现此机制，首先需要使用相关数据结构以表示定时器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示定时器结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;       <span class="comment">// 定时器的到期时间 (实际实现中，各定时器按到期时间，由近至远串接至 timer_list。为简化定时更新操作，该字段含义变更为：当前定时器距离前一个定时器的时间间隔)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   <span class="comment">// 该定时器所对应的进程</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;    <span class="comment">// 链接至 timer_list</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器链表首部，用以串接各定时任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br></pre></td></tr></table></figure><p>各字段含义已经明确，<code>add_timer()/del_timer()</code> 的实现就比较简单，唯一需要注意的是：正确更新相关 <code>timer_t</code> 的 <code>expires</code> 字段。</p><p>接下来，便是如何动态感知定时器是否到期，从而唤醒相关进程？</p><p>对于操作系统而言，它借助于时钟中断以感知时间变化，因此当时钟中断发生时，它会调用特定函数 (<code>ucore</code> 中的 <code>run_time_list()</code> ) 以动态查询定时器链表中的定时器是否到期，若到期则执行相关唤醒操作，最后，动态更新当前进程的时间片信息，从而判断是否需要切换调度。</p><blockquote><p>简单提一下，用户进程如何使用定时器？</p><p>简单流程：用户调用 <code>sleep(time)</code> –&gt; 中断触发 <code>sys_sleep()</code> –&gt; 间接调用 <code>do_sleep(time)</code> –&gt; <code>add_timer()</code>。</p></blockquote><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解信号量机制的实现流程。</p><blockquote><p>为实现互斥方法，总共存在三种方案：基于软件设计、基于硬件中断、基于硬件提供的原子操作。</p><p>在 <code>ucore</code> 中，使用最简单的 “基于硬件中断” 实现信号量机制。</p></blockquote><p>先行给出信号量机制实现的形式化描述 (信号量实现基本与此相同)：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210906162405.png" alt="img" style="zoom: 50%;" /><p>对于信号量而言，它使用如下数据结构进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 共享资源的数目</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue; <span class="comment">// 欲共享该资源的等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head; <span class="comment">// 链首</span></span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列中的元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> <span class="comment">// 所涉的进程</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags;  <span class="comment">// 该进程放置于等待队列中的原因 (例如：信号量的P操作、定时)</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue;<span class="comment">// 所在的等待队列</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link;<span class="comment">// 链接至等待队列 wait_queue</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br></pre></td></tr></table></figure><p>信号量对应的 <code>P()/V()</code> 操作，具体见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P 操作</span></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">// 如果仍存在资源可访问，则直接访问即可。</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表明已不存在资源可访问，则将当前进程放置于等待队列内部。</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度其他进程运行。</span></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程再次运行，则表明其已获取资源。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前进程从等待队列中移除</span></span><br><span class="line">local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"><span class="comment">// 判断 唤醒该进程的原因 和 当时让该进程等待的原因是否一致， 若不一致则返回 wait-&gt;wakeup_flags （造成等待的原因）</span></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V 操作</span></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="comment">// local_intr_save 表示关中断，local_intr_restore 表示开中断。</span></span><br><span class="line">    <span class="comment">// 中断关闭，保证只有当前进程可以运行，从而保证这部分操作的原子性。</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">// 如果等待队列内部不存在等待进程，则资源数量加一，否则选择一个等待进程调度即可。</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然信号量形式化与具体实现并不相同，但是两者是等价的。</p><p>两者的主要差别在于：在形式化中，<code>sem</code> 大于等于零时，表示共享资源的剩余数目，小于零时，表示正在等待资源的进程的数量；在具体实现中，<code>value</code> 仅表示共享资源的剩余数目，等待进程用等待队列来管理 (此时，因为共享资源的剩余数目只可能大于等于零，而不可能小于零，所以 <code>value</code>大于等于零)。</p></blockquote><blockquote><p><strong>问答</strong></p><p>如何为用户态进程提供信号量机制？</p><p>肯定需要使用系统调用。</p><p>当用户态进程使用创建信号量的系统调用时，OS 内部创建 <code>semaphore_t</code> 结构体，但是返回给用户态进程的标识则是另一个 (可能的情况，在 PCB （pcb 保存在内核空间）内部维护信号量数组，返回的是信号量在此数组的下标)。</p><p>当用户态进程使用 <code>up/down</code> 的系统调用时，OS 从当前进程的 PCB 找到相应的 <code>semaphore_t</code> 结构体，然后执行相关操作即可。</p></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解基于管程的条件变量机制的实现流程。</p><blockquote><p>信号量可以实现互斥访问，也可实现进程间同步。因为基于信号量的进程间同步比较麻烦，而且容易出错误，因此出现了 <strong>条件变量</strong> (注意：条件变量仍是以信号量为基础)。</p><p>信号量和条件变量均是偏底层、用于互斥访问和进程间同步的方法，使用起来也是比较麻烦的。为进一步简化使用，更高层级的抽象形式 <strong>管程</strong> 便出现了。</p></blockquote><p>简而言之，<strong>管程</strong> 是一个黑盒，程序员往里扔的函数，它可确保在同一时刻，只有一个函数在执行 (亦因如此，确保其内部共享数据的互斥访问)。</p><blockquote><p>管程的实现方式分为多种，其主要区别在于：假定线程 A 因等待某条件而处于等待队列，线程 B 满足该条件后，线程 B 具有哪种行为？</p><ul><li><code>Mesa Semantics</code>：线程 B 执行 <code>cond_signal</code> ，因而线程 A 从等待队列移除，并放置于就绪队列，然后线程 B 继续执行。（java中使用这种）</li><li><code>Hanson Semantics</code>：线程 B 执行完成并退出的同时，执行 <code>cond_signal</code>，因而线程 A 从等待队列移除，并放置于就绪队列。</li><li><code>Hoare Semantics</code>：线程 B 执行 <code>cond_signal</code>，因而线程 A 从等待队列移除，并放置于就绪队列，然后立即阻塞线程 B，并等待线程 A 被执行。</li></ul><p>对于这三种方式，实际实现基于前两种 (因为可以减少一次上下文切换)，书本介绍基于后一种。（其中<code>Mesa Semantics</code>和<code>Hanson Semantics</code>类似，但<strong>前者是B线程先通知A线程，然后继续执行直到退出；而后者是B线程先退出，然后再通知A线程</strong>）</p><p>在 <code>ucore</code> 中，管程即是基于后一种实现的，由于需要保证 <code>cond_signal</code> 执行的同时，阻塞当前线程，因此其实现有些麻烦。</p><p>另外，管程属于更高层级的抽象形式，往往适用于 Java 等高级语言实现，这里实现一种基于 C 语言的、简化版的管程。</p></blockquote><p>管程基于信号量和条件变量而实现，信号量的实现前面已经谈及，在此给出<strong>条件变量实现</strong>的形式化描述 (条件变量实现基本与此大不相同)：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210906213516.png" alt="img" style="zoom:50%;" /><blockquote><p>根据此图，简单说明 <code>Mesa Semantics</code> 实现所存在的小缺陷。</p><p>线程 B 执行 <code>cond_signal</code> 后，它只是将线程 A 放置于就绪队列，此时即便调度至线程 A，由于其需要再次获取 <code>lock</code>，而此时 <code>lock</code> 仍归线程 B 所有，因此线程 A 仍无法运行，只能等待线程 B 执行完成并释放 <code>lock</code>，然后才能执行线程 A (如果调度线程 A 前调度了其他进程进入管程，有可能使得线程 A 的条件再次无法满足。因此，当线程 A 执行时，其需要循环判断条件是否满足)。</p></blockquote><p>对于管程而言，它使用如下数据结构进行表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 借助于信号量，间接使用等待队列 (最初设置信号量为 0)。</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 在此条件变量上等待的进程数量</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 所属的管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 互斥访问管程内部的数据结构，初始化为 1。</span></span><br><span class="line">    <span class="comment">// next_count 指代由于发出 cond_signal 而睡眠的进程数量，next 只是用于构建一个发出 cond_signal 而睡眠的进程的等待队列。此二者是实现 Hoare Semantics 的关键。</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;      </span><br><span class="line">    <span class="keyword">int</span> next_count;         </span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 管程内部的条件变量列表</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure><p>首先给出初始化过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始值 next_count 自然为 0。</span></span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// mutex 置 1，表示当前管程尚无进程访问，next 只是用于构建等待队列，因此置 0。</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); </span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 为条件变量分配空间，并依据字段含义进行初始化。</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123;</span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是条件变量的 <code>cond_wait()/cond_signal()</code>（Hoare Semantics），具体见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_signal</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前条件变量上并不存在等待进程，则直接返回，否则执行如下操作。</span></span><br><span class="line">   <span class="keyword">if</span> (cvp-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">monitor_t</span>* mon = cvp-&gt;owner;</span><br><span class="line">       mon-&gt;next_count++;</span><br><span class="line">       <span class="comment">// 唤醒当前条件变量所示等待队列上的一个。</span></span><br><span class="line">       up(&amp;(cvp-&gt;sem));</span><br><span class="line">       <span class="comment">// 将当前进程添加至 next 所示的等待队列上、使 next_count 加一，并选择调度其他进程。</span></span><br><span class="line">       down(&amp;(mon-&gt;next));</span><br><span class="line">       <span class="comment">// 再次执行时，当前进程唤醒，因而需要使next_count 减一。 </span></span><br><span class="line">       mon-&gt;next_count--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_wait</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前条件变量上等待进程数加一。</span></span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="keyword">monitor_t</span>* mon = cvp-&gt;owner;</span><br><span class="line">    <span class="comment">// 如果 next 所示的等待队列上存在进程，则唤醒其中的一个，否则唤醒管程等待队列上的一个。</span></span><br><span class="line">    <span class="keyword">if</span> (mon-&gt;next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        up(&amp;(mon-&gt;next));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        up(&amp;(mon-&gt;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前进程添加至等待队列，并选择调度其他进程。</span></span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    <span class="comment">// 再次执行时，表明条件已经满足，当前条件变量上等待进程数减一。</span></span><br><span class="line">    cvp-&gt;count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，当编写管程内部函数时，其格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------the real body of function--------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>似乎，高级语言内部实现管程是比较简单的。</p><p>对于一个普通的类而言，隐式添加成员变量 <code>mutex</code>、在各方法前后隐式添加获取和释放 <code>mutex</code> 的代码、向 <code>cond_wait()</code> 传递 <code>mutex</code> 即可(条件变量的设置和使用需要由用户编写，因为这部分涉及具体逻辑)。</p></blockquote><p>鉴于条件变量的两个操作难于理解，在此以一个例子进行说明。</p><p>所涉线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程 A:线程 B:</span><br><span class="line">......</span><br><span class="line">cond_wait();cond_signal();</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>执行流程(可参考下方的流程图，请注意图中一些变量名和函数名和代码中不同，但概念一样)：</p><ol><li>线程 A 获取 <code>mutex</code>，从而开始执行。后续因等待某条件发生，因而执行 <code>cond_wait()</code>。</li><li><code>cond_wait()</code> 执行后，将线程 A 添加至该条件变量对应的等待队列中，并调度其他线程执行 (因为目前 next 所示的等待队列为空，因而执行 <code>up(&amp;(mon-&gt;mutex))</code>，从而释放 <code>mutex</code>)。</li><li>线程 B 获取 <code>mutex</code>，从而开始执行。后续满足某条件，因而执行 <code>cond_signal()</code>。</li><li><code>cond_signal()</code> 执行后，唤醒该条件变量对应的等待队列上的一个线程，将当前线程添加至 <code>next</code> 所示的等待队列上，并调度其他线程执行。</li><li>线程 A 继续执行其函数体，后续因为 <code>next_count &gt; 0</code> 唤醒 <code>next</code> 所示等待队列上的一个线程，然后完成执行。</li><li>线程 B 继续执行其函数体，后续因为 <code>next_count = 0</code>，释放 <code>mutex</code>，然后完成执行。</li></ol><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210906213731.png" alt="lab7_monitor" style="zoom:50%;" /><p>针对上述流程，需要留意几点：</p><ol><li>线程 A 再次获取执行权限时，其并没有获取锁 <code>mutex</code>，而是继续使用线程 B 所获取的锁 <code>mutex</code>。因为线程 B 已经睡眠，因此这里不会发生互斥访问 。</li><li>线程 A 退出时，它所做的操作是唤醒线程 B，而非释放锁。释放锁的操作由最初获取锁的线程 B 自己释放。</li></ol><blockquote><p>综合说明 <code>Hoare Semantics</code> 实现中保证互斥访问的机制：</p><ol><li>线程间如果不存在条件变量的羁绊，则其依靠 <code>mutex</code> 实现互斥访问。</li><li>线程间如果存在条件变量的羁绊，执行 <code>cond_signal()</code> 的线程与执行 <code>cond_wait()</code> 的线程共享前者的锁，但是由于 <code>cond_signal()</code> 执行会阻塞一个、唤醒一个，故仍然保证互斥访问。</li></ol></blockquote><p>用管程解决哲学家就餐问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">check_sync.c:</span><br><span class="line"><span class="comment">// 测试编号为i的哲学家是否能获得刀叉 如果能获得 则将状态改为正在吃 并且 尝试唤醒 因为wait操作睡眠的进程</span></span><br><span class="line"><span class="comment">// cond_signal 还会阻塞自己 等被唤醒的进程唤醒自己</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拿刀叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));    <span class="comment">// P操作进入临界区</span></span><br><span class="line">    state_condvar[i] = HUNGRY; <span class="comment">// 饥饿状态 准备进食</span></span><br><span class="line">    phi_test_condvar(i); <span class="comment">// 测试当前是否能获得刀叉 </span></span><br><span class="line">    <span class="keyword">while</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">        cond_wait(&amp;mtp-&gt;cv[i]); <span class="comment">// 若不能拿 则阻塞自己 等其它进程唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放刀叉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex)); <span class="comment">// P操作进入临界区</span></span><br><span class="line">    state_condvar[i] = THINKING; <span class="comment">// 思考状态</span></span><br><span class="line">    phi_test_condvar(LEFT); <span class="comment">// 试试左右两边能否获得刀叉</span></span><br><span class="line">    phi_test_condvar(RIGHT);</span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>) <span class="comment">// 有哲学家睡在 signal操作 则将其唤醒</span></span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex)); <span class="comment">// 离开临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体函数，创建若干线程模拟哲学家就餐问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_condvar</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123; <span class="comment">/* arg is the No. of philosopher 0~N-1*/</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_condvar\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* iterate*/</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is thinking\n&quot;</span>,iter,i); <span class="comment">/* thinking*/</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_condvar(i); </span><br><span class="line">        <span class="comment">/* need two forks, maybe blocked */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is eating\n&quot;</span>,iter,i); <span class="comment">/* eating*/</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_condvar(i); </span><br><span class="line">        <span class="comment">/* return two forks back*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_condvar quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：信号量</title>
      <link href="2021/09/04/os/os%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>2021/09/04/os/os%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="信号量概念"><a href="#信号量概念" class="headerlink" title="信号量概念"></a>信号量概念</h2><p>信号量（Semaphore）是另一种临界区的保护机制，它是操作系统提供的一种协调共享资源访问的方法。<strong>它将资源纳入全局考虑，从操作系统的层面对资源进行宏观的调配</strong>。</p><p>这个机制由Dijkstra在20世纪60年代提出，是早期操作系统的主要同步机制。</p><p>信号量是一种抽象的数据结构：</p><ul><li>由一个整型变量(sem)和两个原子操作组成</li><li>P() sem - 1 若 sem &lt; 0 进入等待 否则继续</li><li>V() sem + 1 若 sem &lt;= 0 唤醒一个等待进程</li></ul><p>信号量中的整数sem就是这个<strong>系统资源剩余量</strong>。具体的实现接口P()和V()，分别是荷兰语中<strong>增加prolagg</strong>和<strong>减少verhoog</strong>的缩写。</p><p>信号量的具体实现伪代码（其中sem是剩余资源）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> sem;</span><br><span class="line">WaitQueue q;  <span class="comment">// 等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">sem--;</span><br><span class="line"><span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">Add thread t to q;</span><br><span class="line">block(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">sem++;</span><br><span class="line"><span class="keyword">if</span> (sem &lt;= <span class="number">0</span>) &#123; <span class="comment">// 说明队列中有线程在等待</span></span><br><span class="line">Remove a thread t from q;</span><br><span class="line">Wakeup(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号量的特性：</strong></p><ul><li><p><code>sem</code>是由操作系统全局保护的整数变量</p><ul><li>信号量的相关操作是<strong>原子操作</strong></li><li><code>sem</code>初始化完成后，只能通过<code>P()</code>和<code>V()</code>操作更改</li><li><code>P()</code>可能阻塞，<code>V()</code>不会阻塞</li></ul></li><li><p>通常假定信号量是“公平的”：</p></li><li><ul><li>线程不会无限地阻塞在<code>P()</code>操作</li><li>假定信号量等待按先进先出</li></ul></li></ul><h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>信号量可分为<strong>二进制信号量</strong>（资源数目为0或1）和<strong>资源信号量</strong>（资源数目为任何非负值），基于其一可以实现另一个（两者等价）。</p><p>信号量可以用于实现临界区的<strong>互斥访问</strong>和线程间的<strong>条件同步</strong>。</p><p><strong>用信号量实现临界区的互斥访问</strong>，示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mutex-&gt;P();</span><br><span class="line">Critical Section;</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure><p>必须成对使用P()操作和V()操作，不能颠倒、重复或遗漏</p><p><strong>此外，利用P和V配对的性质，可以将P和V分开，从而实现条件同步</strong>，示例如下：</p><p><strong>同步目标</strong>是线程B执行完X部分的代码后，线程A才能执行N部分的代码。</p><p>实现方式如下图所示：线程A中，如果调用P，那么信号量将变为-1，进入<strong>等待状态</strong>（这是信号量设计中很精髓的FIFO）。线程B调用V之后，信号量变为0，这时A重新开始运行，从而就实现了两个线程的同步。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904201438.jpg" alt="img" style="zoom: 67%;" /><p><strong>生产者-消费者问题</strong>：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904201514.png" alt="Producer-consumer_problem" style="zoom:50%;" /><ul><li>任何时候只能有一个线程操作缓冲区（互斥访问）</li><li>缓冲区空时，消费者必须等待生产者（条件同步）</li><li>缓冲区满时，生产者必须等待消费者（条件同步）</li></ul><p>用信号量描述在这个问题当中的约束（缓冲区大小为n）：</p><ul><li>二进制信号量mutex用于互斥访问缓冲区，初始化为1</li><li>资源信号量fullBuffers表示当前占满的缓冲区数量，用于限制读出，初始化为0</li><li>资源信号量emptyBuffers表示当前为空的缓冲区数量，用于限制写入，初始化为n</li></ul><p>伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&#123;</span></span><br><span class="line">mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">fullBuffers = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">emptyBuffers = <span class="keyword">new</span> Semaphore(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其生产、消费两个过程相互对称，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">emptyBuffers-&gt;P();<span class="comment">//条件同步</span></span><br><span class="line">mutex-&gt;P();    <span class="comment">//互斥访问</span></span><br><span class="line">Add c to buffer; <span class="comment">//核心操作</span></span><br><span class="line">mutex-&gt;V();    <span class="comment">//互斥访问</span></span><br><span class="line">fullBuffers-&gt;V();<span class="comment">//条件同步</span></span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::Withdraw(c)&#123;</span><br><span class="line">fullBuffers-&gt;P();<span class="comment">//条件同步</span></span><br><span class="line">mutex-&gt;P();    <span class="comment">//互斥访问</span></span><br><span class="line">Add c to buffer; <span class="comment">//核心操作</span></span><br><span class="line">mutex-&gt;V();    <span class="comment">//互斥访问</span></span><br><span class="line">emptyBuffers-&gt;V();<span class="comment">//条件同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用信号量的困难在于：</p><ul><li>读/开发都比较困难</li><li>容易出错</li><li>不能系统性地解决死锁问题</li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是一种更为现代的实现<strong>互斥访问</strong>的方法。与临界区相比，管程有更好的封装，如果设计得当，则处理各种问题时，使用将极为便捷。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904205047.png" alt="Synchronization_method_monitor" style="zoom: 50%;" /><h3 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h3><ul><li>一个锁<ul><li>控制管程代码的互斥访问</li></ul></li><li>0或者多个条件变量(0个条件变量 则和 信号量差不多)<ul><li>管理共享数据的并发访问</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904204647.png" alt="Monitor" style="zoom:50%;" /><h4 id="条件变量-Condition-Variable"><a href="#条件变量-Condition-Variable" class="headerlink" title="条件变量(Condition Variable)"></a><strong>条件变量(Condition Variable)</strong></h4><p><strong>管程内的等待机制</strong></p><ul><li>进入管程的线程因资源被占用而进入等待状态</li><li>每个条件变量表示一种等待原因 对应一个等待队列</li><li>Wait()操作<ul><li>将自己阻塞在等待队列中</li><li>唤醒一个等待者或释放管程的互斥访问</li></ul></li><li>Signal()操作<ul><li>将等待队列中的一个线程唤醒</li><li>如果等待队列为空 则等同于空操作</li></ul></li></ul><p><strong>条件变量实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Class Condition &#123;</span><br><span class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>; <span class="comment">// 等待线程数</span></span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">    numWaiting++; <span class="comment">// 有线程处于等待状态</span></span><br><span class="line">    Add <span class="keyword">this</span> thread t  to q;</span><br><span class="line">    release(lock); <span class="comment">// 释放管程的访问权</span></span><br><span class="line">    schedule(); <span class="comment">//need mutex</span></span><br><span class="line">    require(lock); <span class="comment">// 请求管程访问权</span></span><br><span class="line">&#125;</span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果等待队列为空 则为空操作</span></span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t); <span class="comment">//need mutex</span></span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与信号量的一个最为重要的不同在于，使用条件变量时，如果进入等待状态，还能暂时放弃管程的互斥访问等待事件出现时恢复，从而并行进行其他操作，而不是简单地像对临界区那样“固守”。<br>这一点是使用了条件变量的好处，可以看到中途释放了lock。</p></blockquote><h3 id="用管程解决生产者-消费者问题"><a href="#用管程解决生产者-消费者问题" class="headerlink" title="用管程解决生产者-消费者问题"></a>用管程解决生产者-消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 管程入口的锁</span></span><br><span class="line">  Lock lock;</span><br><span class="line">    <span class="comment">// 缓冲区里的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 用信号量解决的时候 不能把检查条件放在申请互斥操作的后面 是因为会产生死锁 因为都申请了互斥操作了 别的线程           * 不可读不可写 当前线程只能一直在那等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 而用管程不同 它可以放弃管程的互斥访问权限 调度到其他线程去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BoundedBuffer::Deposit(c) &#123;</span><br><span class="line">     <span class="comment">// 管程进入申请</span></span><br><span class="line">  lock-&gt;Acquire();</span><br><span class="line">  <span class="comment">// 判断缓冲区是否已经满了,满了就等待条件满足时再继续执行</span></span><br><span class="line">    <span class="keyword">while</span> (count == n)</span><br><span class="line">        notFull.Wait(&amp;lock);</span><br><span class="line"> </span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.Signal();</span><br><span class="line">  <span class="comment">// 管程释放</span></span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c) &#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)    </span><br><span class="line">        notEmpty.Wait(&amp;lock);</span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    count--;</span><br><span class="line">  <span class="comment">// 将等待线程中的其中一个唤醒</span></span><br><span class="line">    notFull.Signal();</span><br><span class="line">    </span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过良好的设计封装，可以降低使用过程的使用难度。具体使用情景下，Deposit和Remove都只需要简单的对外接口，但有着有效的互斥访问机制。</p><h3 id="管程分类"><a href="#管程分类" class="headerlink" title="管程分类"></a>管程分类</h3><p>管程中的条件变量按照不同的释放处理方式分为两种：</p><ul><li>Hansen管程(当前正在执行的线程更优先)<ul><li>用于真实OS或Java中</li></ul></li><li>Hoare管程<ul><li>多见于教材</li></ul></li></ul><h4 id="Hansen管程"><a href="#Hansen管程" class="headerlink" title="Hansen管程"></a>Hansen管程</h4><p>当前正在执行的线程优先级更高，因此线程连续执行，所以其效率更高</p><ul><li>条件变量释放仅是一个提示，需要重新检查条件 （用 while）</li></ul><p>因为另一个线程中释放了条件变量后还是在继续往下执行，有可能在这段期间条件变量发生变化，所以仍然需要检查条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hansen_style::Deposit()&#123;</span><br><span class="line">  lock-&gt;acquire();</span><br><span class="line">  <span class="keyword">while</span> (count == n) &#123; <span class="comment">// 这里是 while</span></span><br><span class="line">       notFull.wait(&amp;lock); </span><br><span class="line">  &#125;</span><br><span class="line">  Add thing;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">  lock-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904205923.png" alt="Hansen_monitor" style="zoom:50%;" /><h4 id="Hoare管程"><a href="#Hoare管程" class="headerlink" title="Hoare管程"></a>Hoare管程</h4><p>等待条件变量的优先级更高</p><ul><li>条件变量释放同时表示放弃管程访问</li><li>释放后条件变量的状态可用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Hoare_style::Deposit()&#123;</span><br><span class="line">  lock-&gt;acquire();</span><br><span class="line">  <span class="keyword">if</span> (count == n) &#123; <span class="comment">// 这里是 if</span></span><br><span class="line">       notFull.wait(&amp;lock); </span><br><span class="line">  &#125;</span><br><span class="line">  Add thing;</span><br><span class="line">  count++;</span><br><span class="line">  notEmpty.signal();</span><br><span class="line">  lock-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904205933.png" alt="Hoare_monitor" style="zoom:50%;" /><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>5个哲学家围绕一张圆桌坐</p><ul><li>桌子放5支叉子</li><li>每两个哲学家之间放一支</li><li>哲学家动作包含思考和就餐<ul><li>进餐时需同时拿到左右两边两把叉子</li><li>思考时将两支叉子放回原处</li></ul></li><li>要求不出现有人永远拿不到叉子的情况</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904211005.png" alt="Dining_philosophers_problem" style="zoom:50%;" /><h4 id="信号量解决哲学家就餐问题"><a href="#信号量解决哲学家就餐问题" class="headerlink" title="信号量解决哲学家就餐问题"></a>信号量解决哲学家就餐问题</h4><p>方案1</p><ul><li>会发生死锁!</li><li>当五个哲学家同时拿起左边的叉子 所有人都在等待别人放下右边的叉子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 5支叉子的信号量初值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 哲学家编号：0 － 4</span></span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(fork[i]); <span class="comment">// 拿左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 拿右边的叉子</span></span><br><span class="line">        eat();</span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案2</p><ul><li>互斥访问正确</li><li>每次只能有一个哲学家进餐 性能差</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为1</span></span><br><span class="line">semaphore mutex; <span class="comment">// 互斥信号量，初值1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 哲学家编号：0 － 4</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span> </span>&#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex); <span class="comment">// 进入临界区 只有一个哲学家能就餐</span></span><br><span class="line"></span><br><span class="line">        P(fork[i]); <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        eat();</span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        V(mutex); <span class="comment">// 退出临界区</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方案3</p><ul><li>根据编号不同 采取不同动作 避免都拿到一部分资源构造环路的情况</li><li>没有死锁 并允许多人(最多两人)同时就餐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">// 哲学家编号：0 － 4</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span> </span>&#123;</span><br><span class="line">        think();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// 偶数 先拿左 后拿右 奇数 先拿右 后拿左</span></span><br><span class="line">            P(fork[i]); <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">            P(fork[i]); <span class="comment">// 去拿左边的叉子 </span></span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>共享资源的两类使用者</p><ul><li>读者 只读取数据 不修改</li><li>写者 读取和修改数据</li><li>读读允许<ul><li>同一时刻允许有多个读者同时读</li></ul></li><li>读写互斥<ul><li>没有写者时 读者才能读</li><li>没有读者时 写者才能写</li></ul></li><li>写写互斥<ul><li>没有其他写者时 写者才能写</li></ul></li></ul><h4 id="读者写者问题的优先策略"><a href="#读者写者问题的优先策略" class="headerlink" title="读者写者问题的优先策略"></a>读者写者问题的优先策略</h4><ul><li>读者优先策略<ul><li>只要有读者正在读状态 后来的读者都能直接进入</li><li>若读者持续不断进入 则写者就处于饥饿</li></ul></li><li>写者优先策略<ul><li>只要有写者就绪 写者应尽快执行写操作</li><li>若写者持续不断就绪 则读者就处于饥饿</li></ul></li></ul><h4 id="信号量解决读者写者问题"><a href="#信号量解决读者写者问题" class="headerlink" title="信号量解决读者写者问题"></a>信号量解决读者写者问题</h4><p><strong>此方案 读者优先</strong>（<a href="https://blog.csdn.net/mch2869253130/article/details/84320971">用信号量解决读者写者问题的写者优先方案</a>）</p><ul><li>信号量WriteMutex<ul><li>控制读写操作互斥</li><li>初始化为 1</li></ul></li><li>读者计数Rcount<ul><li>正在进行读操作的读者数目</li><li>初始化为 0</li></ul></li><li>信号量CountMutex(对 Rcount 进行保护)<ul><li>控制对读者计数的互斥修改</li><li>初始化为 1</li></ul></li></ul><p>Write线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(WriteMutex); <span class="comment">// 读写互斥</span></span><br><span class="line">    write();</span><br><span class="line">V(WriteMutex);</span><br></pre></td></tr></table></figure><p>Reader线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P(CountMutex); <span class="comment">// 保护 Rcount</span></span><br><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">    P(WriteMutex); </span><br><span class="line">    <span class="comment">// 只在第一个读者 开启读写互斥 </span></span><br><span class="line">++Rcount; <span class="comment">// 加一读者</span></span><br><span class="line">V(CountMutex);</span><br><span class="line">read();</span><br><span class="line">P(CountMutex);</span><br><span class="line">--Rcount;</span><br><span class="line"><span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">    V(WriteMutex); </span><br><span class="line">    <span class="comment">// 没有读者了 让写者有机会访问临界区去写</span></span><br><span class="line">V(CountMutex);</span><br></pre></td></tr></table></figure><h4 id="管程解决读者写者问题"><a href="#管程解决读者写者问题" class="headerlink" title="管程解决读者写者问题"></a>管程解决读者写者问题</h4><p><strong>此方案 写者优先</strong></p><p>管程的状态变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AR = <span class="number">0</span>; <span class="comment">// 当前读的读者</span></span><br><span class="line">AW = <span class="number">0</span>; <span class="comment">// 当前写的写者</span></span><br><span class="line">WR = <span class="number">0</span>; <span class="comment">// 等待读的读者</span></span><br><span class="line">WW = <span class="number">0</span>; <span class="comment">// 等待写的写者</span></span><br><span class="line">Lock lock;</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br></pre></td></tr></table></figure><p>读者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Database::Read() &#123;</span><br><span class="line">    <span class="comment">// Wait until no writers;</span></span><br><span class="line">    StartRead(); </span><br><span class="line">    read database;</span><br><span class="line">    <span class="comment">// check out – wake up waiting writers; </span></span><br><span class="line">    DoneRead();</span><br><span class="line">&#125;</span><br><span class="line">Database::StartRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">  <span class="comment">// 只要有写者就等 说明写者优先</span></span><br><span class="line">    <span class="keyword">while</span> ((AW+WW) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.wait(&amp;lock);</span><br><span class="line">        WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line">Database::DoneRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AR--;</span><br><span class="line">   <span class="comment">// 当前没有读者且有等待写的写者 则唤醒 写者</span></span><br><span class="line">    <span class="keyword">if</span> (AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Database::Write() &#123;</span><br><span class="line">    <span class="comment">// Wait until no readers/writers;</span></span><br><span class="line">    StartWrite(); </span><br><span class="line">    write database;</span><br><span class="line">    <span class="comment">// check out-wake up waiting readers/writers; </span></span><br><span class="line">    DoneWrite(); </span><br><span class="line">&#125;</span><br><span class="line">Database::StartWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">  <span class="comment">// 只要有正在写的写者或者正在读的读者 就等(不等 等待读的读者 说明写者优先)</span></span><br><span class="line">    <span class="keyword">while</span> ((AW+AR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.wait(&amp;lock);</span><br><span class="line">        WW--;</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line">Database::DoneWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AW--;</span><br><span class="line">    <span class="keyword">if</span> (WW &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 优先唤醒等待写的写者</span></span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有等待写的写者 才唤醒等待读的读者</span></span><br><span class="line">        okToRead.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：同步互斥</title>
      <link href="2021/09/03/os/os%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/"/>
      <url>2021/09/03/os/os%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="背景、问题和基本概念"><a href="#背景、问题和基本概念" class="headerlink" title="背景、问题和基本概念"></a>背景、问题和基本概念</h2><p>对于独立程序</p><ul><li><p>不和其他程序共享资源</p></li><li><p>输入状态决定结果，具有确定性</p></li><li><p>可重现起始条件</p><blockquote><p>在计算机科学中，<strong>再现性</strong>是指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果</p></blockquote></li><li><p>调度顺序不重要</p></li></ul><p>但对于并发进程来说，多个进程间有资源共享，可能会因为不同顺序出现相互的干扰。从而</p><ul><li>产生不确定性</li><li>不可重现</li><li>未定义行为，程序错误是间歇性发生的</li></ul><p>实际上我们又希望使用多进程并发执行，提升效率、实现协同、模块化设计等，所以我们需要使用一些方式来克服并发设计的坏处（例如，使用一些原子操作）。</p><blockquote><p>原子操作（Atomic Operation）指一次不存在任何中断或者失败的操作，要么操作完成，要么没有执行，不会出现半途而废、部分执行的情况。</p></blockquote><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>进程的交互关系，根据相互感知程度的不同分为如下三种：</p><table><thead><tr><th>相互感知的程度</th><th>交互关系</th><th>进程间的影响</th></tr></thead><tbody><tr><td>相互不感知</td><td>独立</td><td>一个进程的操作对于其他进程的结果没有影响</td></tr><tr><td>间接感知（双方都与第三方方交互，如共享资源 ）</td><td>通过共享进行协作</td><td>一个进程的结果依赖于共享资源的状态</td></tr><tr><td>直接感知（双方直接交互，如通信）</td><td>通过通信进行协作</td><td>一个进程的结果依赖于从其他进程获得的信息</td></tr></tbody></table><p>同步问题的解决方案主要基于<strong>间接感知</strong>的部分，其中主要会有如下三种状态：</p><ul><li>互斥（mutual exclusion）：一个进程占用资源，其他进程无法使用</li><li>死锁（deadlock）：多个进程各占用部分资源，形成循环等待</li><li>饥饿（starvation）：其他进程轮流占用资源，一个进程一直得不到资源</li></ul><p>其中最为基本的状态称为互斥，这即是一个良好的原子操作的思路。</p><p>我们将互斥资源存放的位置称为<strong>临界区</strong>，其上资源同时只允许一个进程的访问，临界区附近的代码结构通常如下：</p><ul><li>进入区（entry section）：检查是否可以进入临界区的一段代码，如果可以进入，则设定“正在进入临界区”标志</li><li>临界区（critical section）：进程中访问临界资源的一段需要互斥执行的代码</li><li>退出区（exit section）：清除“正在访问临界区”标志</li><li>剩余区（remainder section）：跟同步互斥无关的代码</li></ul><p>临界区的访问规则如下：</p><ul><li>空闲则入：没有进程在临界区时，任何进程可以进入</li><li>忙则等待：有进程在临界区时，其他进程均不能进入临界区</li><li>有限等待：等待进入临界区的进程不能无限等待</li><li>让权等待(可选)：不需要访问临界区的进程，应当释放CPU</li></ul><p>在具体实现过程当中，我们必须满足前三条规则。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h3><p>禁止硬件中断响应，因而对一个正在运行的不会发生上下文切换，且没有并发。</p><ul><li>硬件将中断处理延迟到中断使能之后</li><li>现代计算机体系结构都提供指令来实现禁用中断</li></ul><p>缺点：</p><ol><li>禁用中断之后，进程无法停止</li></ol><ul><li>整个系统都会为此停下来</li><li>可能导致其他进程处于饥饿状态</li></ul><ol start="2"><li>临界区可能很长，无法确定中断响应时间</li></ol><p>所以应该谨慎使用。</p><h3 id="软件方法"><a href="#软件方法" class="headerlink" title="软件方法"></a>软件方法</h3><p>设置一些全局的共享变量，来标识两个线程对互斥资源的占用情况，从而实现同步。</p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>共享变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn; <span class="comment">// 表示该谁进入临界区</span></span><br><span class="line">boolean flag[]; <span class="comment">// 表示进程申请进入临界区</span></span><br></pre></td></tr></table></figure><p>进程i 进入区代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"> <span class="comment">//这里相当于谦让，让另一个进程优先获得权限</span></span><br><span class="line">turn = j;</span><br><span class="line"><span class="keyword">while</span> (flag[j] &amp;&amp; turn == j)</span><br></pre></td></tr></table></figure><p>退出区代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag[i] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当进程 j 没有申请进入临界区 则 flag[j] = false;  turn = j;</p><p>那么进程 i 可以直接进入临界区</p><p>当进程 j 也申请进入临界区 则 flag[j] = true; turn 有 两种情况 当 进程 i 先写 turn = j; 进程 j 后写 turn = i; 时 turn = i;</p><p>那么进程 i 可以进入临界区 进程 j 不可以进入临界区</p><p>也就是说先写turn这个标志的能进入临界区，后写的要等待</p></blockquote><p>Peterson算法完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> ( flag[j] &amp;&amp; turn == j);</span><br><span class="line">    </span><br><span class="line">            CRITICAL SECTION</span><br><span class="line"></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            REMAINDER SECTION</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="Dekkers算法"><a href="#Dekkers算法" class="headerlink" title="Dekkers算法"></a>Dekkers算法</h4><p>Dekkers算法是Peterson算法的扩展。对比 Peterson算法，其优点是可以很方便扩展到多个线程（即Eisenberg and McGuire’s Algorithm）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> flag[j] == <span class="literal">true</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> turn != i &#123;</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> turn != i;</span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        CRITICAL SECTION</span><br><span class="line"></span><br><span class="line">    turn = j;</span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">        EMAINDER SECTION</span><br><span class="line">   &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>进程 i 申请进入临界区 flag[i] = true;<br>当进程 j 也申请进入临界区 则 flag[j] = true;<br>这时再判断 turn 这个共享变量 允许哪个进程进入临界区<br>若不允许 则将进程 flag[i] = false; 并一直等待 直到允许</p></blockquote><h4 id="N线程的软件方法-Eisenberg-和-McGuire"><a href="#N线程的软件方法-Eisenberg-和-McGuire" class="headerlink" title="N线程的软件方法(Eisenberg 和 McGuire)"></a>N线程的软件方法(Eisenberg 和 McGuire)</h4><p>将线程排成环 若要进入临界区 则将 线程的 flag 标志 填写好 再去看 turn 标志</p><ul><li>线程Ti要等待从 turn 到 i-1的线程 都退出临界区后才能访问临界区</li><li>线程Ti退出时 将turn改成下一个请求线程</li></ul><blockquote><p><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=1217">https://piazza.com/class/i5j09fnsl7k5x0?cid=1217</a> 详细解释</p></blockquote><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210904123218.png" alt="Eisenberg_McGuire" style="zoom:50%;" /><h4 id="基于软件同步方法的缺点"><a href="#基于软件同步方法的缺点" class="headerlink" title="基于软件同步方法的缺点"></a>基于软件同步方法的缺点</h4><ul><li>复杂<ul><li>需要两个进程间共享变量</li></ul></li><li>需要忙等待<ul><li>浪费CPU时间 (需要频繁查询共享变量的状态)</li></ul></li></ul><h3 id="更高级的抽象方法"><a href="#更高级的抽象方法" class="headerlink" title="更高级的抽象方法"></a>更高级的抽象方法</h3><blockquote><p>现代CPU体系结构提供的一些特殊原子操作指令</p><p><strong>测试和置位指令(TS Test-and-Set)</strong></p><ul><li>从内存单元中读取值</li><li>测试该值是否为1(真或假)</li><li>内存单元值设置为1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *target)</span></span>&#123;</span><br><span class="line">    boolean rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>交换指令(Exchange)</strong></p><p>交换内存中的两个值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span> <span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>将上述的想法抽象成一个二进制的数据结构（锁定/解锁），称为锁（lock）。<br>它有两个主要API：</p><ul><li>Lock::Acquire() 申请锁</li><li>Lock::Release() 释放锁</li></ul><p>将相关的互斥操作封装好之后，使用锁来控制临界区访问就会变得非常简单。</p><p><strong>TS指令实现自旋锁(Spinlock)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 通过TS指令 读出 value的值 然后写入1</span></span><br><span class="line"><span class="comment">    若value为0 说明锁被释放 TS指令读出0 并写入 1 进入临界区</span></span><br><span class="line"><span class="comment">    若value为1 说明锁为忙状态 TS指令读出1 并写入 1 状态并没有改变 但是陷入循环 一直等待</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">   <span class="keyword">while</span> (test-<span class="keyword">and</span>-<span class="built_in">set</span>(value))</span><br><span class="line">      ; <span class="comment">//spin</span></span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但上述的自旋等待锁存在忙等待</strong>的问题，我们可以在锁的数据结构中加入等待队列，避免CPU自旋。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">   WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        若锁处于忙状态则将当前进程加入等待队列并执行调度程序</span></span><br><span class="line"><span class="comment">        使得其他进程可以占用CPU继续执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">while</span> (test-<span class="keyword">and</span>-<span class="built_in">set</span>(value)) &#123;</span><br><span class="line">      add <span class="keyword">this</span> TCB to wait <span class="built_in">queue</span> q;</span><br><span class="line">      schedule();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">   value = <span class="number">0</span>;</span><br><span class="line">   remove one thread t from q;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将等待进程放到就绪队列里去 相当于唤醒等待进程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   wakeup(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原子操作指令锁特征</strong></p><ul><li><p>优点</p><ul><li>适用于单处理机或者共享内存的多处理机中任意数量的进程同步(禁用中断只适用于单处理机, 多处理机的情况下 禁止单个处理机的中断, 其他处理机仍然能够响应中断)</li><li>简单且容易证明</li><li>支持多临界区</li></ul></li><li><p>缺点：</p><ul><li>忙等待消耗处理器时间</li><li>可能会导致饥饿</li><li>可能会导致死锁：高优先级拥有CPU，低优先级拥有独占资源</li></ul></li></ul><h3 id="常用三种同步实现方法总结"><a href="#常用三种同步实现方法总结" class="headerlink" title="常用三种同步实现方法总结"></a>常用三种同步实现方法总结</h3><ul><li>禁用中断(仅限于单处理机)</li><li>软件方法(共享变量 复杂)</li><li>原子操作指令(单处理机或多处理机均可)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab6:调度器</title>
      <link href="2021/09/02/os/lab6-%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
      <url>2021/09/02/os/lab6-%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>进程调度算法。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab5</code> 源代码，<code>lab6</code> 主要做了如下改动：</p><ul><li><p><code>proc.h</code> 扩展 <code>struct proc_struct</code> 成员属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span>                       <span class="comment">// 该进程所在的 run_queue</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_link;                      <span class="comment">// 以链表形式链接各就绪进程</span></span><br><span class="line">    <span class="keyword">int</span> time_slice;                             <span class="comment">// 该进程所占用的 CPU 时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> lab6_run_pool;            <span class="comment">// FOR LAB6 ONLY: 以优先队列形式链接各就绪进程</span></span><br><span class="line">    <span class="comment">// 当前进程的 stride 和优先级属性。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_stride;                       <span class="comment">// FOR LAB6 ONLY: 该进程对应的 stride 属性 (此二者用于 stride 调度算法)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_priority;                     <span class="comment">// FOR LAB6 ONLY: 该进程对应的 priority 属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>alloc_proc()</code> 实现中，增加这些属性的初始化工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">skew_heap_init(&amp;(proc-&gt;lab6_run_pool));</span><br><span class="line">proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">proc-&gt;lab6_priority = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>schedule.[ch]</code> 增加调度器框架信息</p><p><code>ucore</code> 调度器框架使用 <code>struct sched_class</code> 加以表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 调度器名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 初始化调度器</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">// 进程入队</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// 进程出队</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// 选择待运行的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// 时钟触发的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ucore</code> 调度器具体使用 <code>struct run_queue</code> 进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_list;<span class="comment">// 进程集合的链表形式    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_num;<span class="comment">// 进程集合总数</span></span><br><span class="line">    <span class="keyword">int</span> max_time_slice;<span class="comment">// 进程运行的最大时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> *lab6_run_pool;<span class="comment">// For LAB6 ONLY: 进程集合的优先队列形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>trap.c</code> 更新时钟中断的处理程序</p><p>每当发生时钟中断，调用 <code>ucore</code> 调度器的 <code>proc_tick()</code> 函数，从而使得调度器能够动态感知时间变化，并更新相关进程的某些调度属性信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        sched_class_proc_tick(current);</span><br></pre></td></tr></table></figure></li><li><p><code>default_sched.[ch]</code> 实现 Round-Robin 调度算法</p></li><li><p><code>sched.c</code> 更新 <code>wakeup_proc()</code> 操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// proc 若未处于 RUNNABLE 状态，则置为此状态。</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 若当前进程并非 proc，则将 proc 入队 (出现情况：当前进程创建子进程，子进程的 do_fork 最后一步会调用此函数，从而将其入队管理)。</span></span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>skew_heap.h</code> 提供斜堆的具体实现</p></li></ul><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解 Round-Robin 调度算法的具体实现。</p><p>Round-Robin 调度算法比较简单，直接查看其源代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 RR，只需初始化进程集合，并重置相关属性即可 (max_time_slice 属性由调用者自主设置)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 放置当前进程于进程集合尾部。</span></span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="comment">// 如果其所剩时间片为 0，或不符合条件，则重置之。</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新其他属性。</span></span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，进程集合中删除此进程，并初始化此进程的 run_link 即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择进程集合首部元素作为待运行的进程即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次发生时钟中断，更新当前进程可用的时间片，如果可用时间片为 0，则设置 need_resched 以调度其他进程 (该字段在 trap() 的 if(!in_kernel) 内起作用)。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将默认的处理器调度算法设为RR</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;RR_scheduler&quot;</span>,</span><br><span class="line">    .init = RR_init,</span><br><span class="line">    .enqueue = RR_enqueue,</span><br><span class="line">    .dequeue = RR_dequeue,</span><br><span class="line">    .pick_next = RR_pick_next,</span><br><span class="line">    .proc_tick = RR_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>结合具体算法描述<strong>ucore调度执行过程</strong>：</p><ul><li>正如前文中所提及到的那样，在ucore中调用调度器的主体函数（不包括init，proc_tick）的代码仅存在在wakeup_proc和schedule，前者的作用在于将某一个指定进程放入可执行进程队列中，后者在于将当前执行的进程放入可执行队列中，然后将队列中选择的下一个执行的进程取出执行；</li><li>当需要将某一个进程加入就绪进程队列中，则需要将这个进程的能够使用的时间片进行初始化，然后将其插入到使用链表组织的队列的对尾；这就是具体的Round-Robin enqueue函数的实现；</li><li>当需要将某一个进程从就绪队列中取出的时候，只需要将其直接删除即可；</li><li>当需要取出执行的下一个进程的时候，只需要将就绪队列的队头取出即可；</li><li>每当出现一个时钟中断，则会将当前执行的进程的剩余可执行时间减1，一旦减到了0，则将其标记为可以被调度的，这样在ISR中的后续部分就会调用schedule函数将这个进程切换出去；</li></ul><p>简要说明如何设计实现<strong>多级反馈队列调度算法</strong>：</p><ul><li><p>在proc_struct中添加总共N个多级反馈队列的入口，每个队列都有着各自的优先级，编号越大的队列优先级约低，并且优先级越低的队列上时间片的长度越大，为其上一个优先级队列的两倍；并且在PCB中记录当前进程所处的队列的优先级；</p></li><li><p>处理调度算法初始化的时候需要同时对N个队列进行初始化；</p></li><li><p>在处理将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低1级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去；</p></li><li><p>在同一个优先级的队列内使用时间片轮转算法；</p></li><li><p>在选择下一个执行的进程的时候，有限考虑高优先级的队列中是否存在任务，如果不存在才转而寻找较低优先级的队列；（有可能导致饥饿）</p></li><li><p>从就绪进程集合中删除某一个进程就只需要在对应队列中删除即可；</p></li><li><p>处理时间中断的函数不需要改变；</p></li><li><p>至此完成了多级反馈队列调度算法的具体设计；</p></li></ul></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现 Stride 调度算法。</p><p>首先简单介绍 Stride 调度算法的基本思想：Stride 调用算法仍是基于时间片以调度进程，但是它每次选择进展最慢 (表征进程的 <code>struct proc_struct</code> 结构中，<code>stride</code> 表示当前进程的进展度，<code>BIG_STRIDE / priority</code> 表征当前进程被调度后的进展增加值) 的进程加以调度。</p><blockquote><p>stride相关资料：<a href="http://web.eecs.umich.edu/~mosharaf/Readings/Stride.pdf">http://web.eecs.umich.edu/~mosharaf/Readings/Stride.pdf</a></p></blockquote><p>接下来，给出 Stride 调度算法的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BIG_STRIDE 取值具有一定原因，它可以保证即使 stride 取值溢出，仍可正确实现两个进程的 stride 比较操作，原理请看下方问答。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE    (((uint32_t)-1) / 2) <span class="comment">// 即 0X7FFFFFFF</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个进程的 stride 比较操作，用于构建斜堆。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">proc_stride_comp_f</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Stride，只需初始化进程集合，并重置相关属性即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list)); <span class="comment">// 是否初始化进程集合的链表形式都可，因为不会用到。</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队，插入当前进程至斜堆，并更新相关属性。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;  </span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     <span class="comment">// 如果尚未初始化 priority，则默认取值为 1。</span></span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          proc-&gt;lab6_priority = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">           proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     proc-&gt;rq = rq;</span><br><span class="line">     rq-&gt;proc_num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队，斜堆删除特定进程。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     rq-&gt;proc_num--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择 stride 最小的进程作为待运行的进程（斜堆的顶就是 stride 值最小的进程），并更新其 stride 取值。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">stride_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool != <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span>* <span class="title">proc</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">          proc-&gt;lab6_stride += (BIG_STRIDE / proc-&gt;lab6_priority);</span><br><span class="line">          <span class="keyword">return</span> proc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 RR 所取操作相同。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stride_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;time_slice --;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认调度策略为 stride</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">     .name = <span class="string">&quot;stride_scheduler&quot;</span>,</span><br><span class="line">     .init = stride_init,</span><br><span class="line">     .enqueue = stride_enqueue,</span><br><span class="line">     .dequeue = stride_dequeue,</span><br><span class="line">     .pick_next = stride_pick_next,</span><br><span class="line">     .proc_tick = stride_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如何证明STRIDE_MAX – STRIDE_MIN &lt;= PASS_MAX？</p><ul><li>假如该命题不成立，则可以知道就绪队列在上一次找出用于执行的进程的时候，假如选择的进程是P，那么存在另外一个就绪的进程P’，并且有P’的stride比P严格地小（因为步进值最大为PASS_MAX，若该命题不成立，那么上一次调度时被选择执行并增加stride的进程一定不是stride最小的进程）。这也就说明上一次调度出了问题，这和stride算法的设计是相违背的；因此通过反证法证明了上述命题的成立；</li></ul><p>在 ucore 中，目前Stride是采用无符号的32位整数表示。则BigStride应该取多少，才能保证比较的正确性？</p><ul><li><p>开始有A=B,最大步进值S</p></li><li><p>B+S不溢出，则需A&lt;B+S，即0&lt;S,即S&lt;2^31</p></li><li><p>B+S溢出代表B+S &gt;= 2^32</p><p>溢出后B’ = B+S-2^32</p><p>此时为使 A-B’ &lt; 0,需要 A &gt;= B’+2^31</p><p>即A &gt;= B+S-2^32+2^31=B+S-2^31</p><p>又由A=B，有0&gt;=S-2^31，即S&lt;=2^31</p></li><li><p>综合有S&lt;2^31，即S&lt;=0x7FFFFFFF</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：处理机调度</title>
      <link href="2021/09/01/os/os%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
      <url>2021/09/01/os/os%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="处理器调度概念"><a href="#处理器调度概念" class="headerlink" title="处理器调度概念"></a>处理器调度概念</h1><h2 id="调度的技术背景"><a href="#调度的技术背景" class="headerlink" title="调度的技术背景"></a>调度的技术背景</h2><p>在此前我们已经介绍了进程和线程机制， 它们可以使得CPU能够更加有效地展现并发处理的能力。</p><p>对于资源基本管理单位的进程来说，CPU资源的当前占用者切换是基本的并发思路。</p><p>但有如下两个问题：</p><ol><li>如何从就绪队列中选出下一个运行（占用CPU）的<strong>进程</strong></li><li>从多个CPU中选出就绪进程中当前准备使用的的<strong>CPU</strong></li></ol><p>这两个选择任务就交由调度算法来实现。</p><h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>调度程序除了解决上述提到的进程线程选择之外，还需进行<strong>调度时机</strong>的选择</p><p>当前系统为<strong>非抢占系统</strong>时，内核在如下两种情况下运行调度程序：</p><ul><li>进程从运行状态切换到等待状态(等待某个事件)</li><li>进程被终结了</li></ul><p>当前系统为<strong>抢占系统</strong>时，内核在如下情况下运行调度程序：</p><ul><li>中断请求被服务例程响应完成时<ul><li>进程从 运行状态 切换到 就绪状态</li></ul></li><li>当前进程被抢占<ul><li>进程时间片用完</li><li>某进程从 等待状态 切换到 就绪状态 (它的优先级更高，因此会发生抢占)</li></ul></li></ul><h1 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h1><h2 id="评定调度算法好坏的指标"><a href="#评定调度算法好坏的指标" class="headerlink" title="评定调度算法好坏的指标"></a>评定调度算法好坏的指标</h2><p>从运行效率来说：</p><ul><li><strong>CPU使用率</strong>：CPU处于忙状态的时间百分比</li><li><strong>吞吐量</strong>：单位时间内完成的进程数量</li></ul><p>从用户使用来说：</p><ul><li><strong>周转时间</strong>：进程从初始化到完成（包括等待）的时间</li><li><strong>等待时间</strong>：进程在就绪队列中等待的时间</li><li><strong>响应时间</strong>：从提交请求到产生响应所花费的总时间</li></ul><p>调度算法的要求：希望“更快”的服务<br>对于“更快”我们有两个层面的描述：</p><ul><li>传输文件时，我们希望高带宽，对应调度算法的<strong>高吞吐量</strong></li><li>玩游戏时，我们希望实时响应，对应调度算法的<strong>低响应延迟</strong></li></ul><p>这两个因素是独立的。我们的设计也分别基于这两个方向。</p><h2 id="调度策略的低时延目标"><a href="#调度策略的低时延目标" class="headerlink" title="调度策略的低时延目标"></a>调度策略的低时延目标</h2><p>减少响应时间：及时处理用户的输入请求，尽快将输出反馈给用户</p><p>减少平均响应时间的波动：可预测性和稳定性比高差异低平均更好</p><p>低延迟调度改善了用户的交互体验</p><h2 id="调度策略的吞吐量目标"><a href="#调度策略的吞吐量目标" class="headerlink" title="调度策略的吞吐量目标"></a>调度策略的吞吐量目标</h2><p>增加吞吐量：减少开销并实现系统资源高效利用</p><p>减少等待时间：减少每个进程的等待时间</p><p>要点：</p><ul><li>操作系统需要保证吞吐量不受用户交互影响</li><li>吞吐量是操作系统的计算带宽</li></ul><h2 id="调度的公平性目标"><a href="#调度的公平性目标" class="headerlink" title="调度的公平性目标"></a>调度的公平性目标</h2><p>除上述两条对于单用户的使用设计目标外，对于多用户的使用公平性。</p><ol><li>保证每个进程占用相同的CPU时间</li><li>保证每个进程的等待时间相同（因此，一个用户使用多个进程，其等待时间也相应增加）</li></ol><p>公平性通常会牺牲一定程度的时延。</p><h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="就绪队列优先级"><a href="#就绪队列优先级" class="headerlink" title="就绪队列优先级"></a>就绪队列优先级</h2><h3 id="先来先服务算法-FCFS，First-Come-First-Served"><a href="#先来先服务算法-FCFS，First-Come-First-Served" class="headerlink" title="先来先服务算法(FCFS，First Come, First Served)"></a>先来先服务算法(FCFS，First Come, First Served)</h3><p>依据进程进入就绪队列的先后顺序排列</p><ul><li>进程进入等待或结束状态时，就绪队列中下一个进程占用CPU</li></ul><p><strong>先来先服务算法的特征</strong>：</p><ul><li>优点<ul><li>简单</li></ul></li><li>缺点<ul><li>平均等待时间波动较大 (短进程排在长进程后面，如下图所示)</li><li>I/O资源和CPU资源的利用率较低 (CPU密集型的进程导致I/O闲置时，I/O密集型进程仍然需要等待)</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210901205431.png" alt="FCFS_TAT" style="zoom:50%;" /><blockquote><p>P1，P2，P3的到达的时间都是时刻0</p></blockquote><h3 id="短进程优先算法-SPN，Shortest-Process-Next"><a href="#短进程优先算法-SPN，Shortest-Process-Next" class="headerlink" title="短进程优先算法(SPN，Shortest Process Next)"></a>短进程优先算法(SPN，Shortest Process Next)</h3><p>选择就绪队列中<strong>预期的执行时间最短</strong>的进程占用CPU进入运行状态（就绪队列按照预期的执行时间来排序。）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902111244.png" alt="SPN" style="zoom:40%;" /><blockquote><p>当有一个新的进程进入就绪队列，且它的预期执行时间比当前正在执行的进程所剩的执行时间还短，允许其抢占，则为 SRT: Shortest Remaining Time (短剩余时间优先)</p></blockquote><p><strong>短进程优先算法的特征:</strong></p><ul><li>可能导致饥饿<ul><li>连续的短进程流会使长进程无法获得CPU资源</li></ul></li><li>如何预测进程的执行时间<ul><li>可以询问用户，用户可能不知道；也有可能给出过于乐观的估计，比如用户觉得自己的工作能很快做完（“欺骗”），但发现卡死了，这时候可以手动中止这个运行时间较长的程序。</li><li>用过去预测未来。利用过去的情况来预测某个进程的执行时间。 $\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n$​ ， $\tau_i$为第$i$次的估计值</li></ul></li></ul><h3 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h3><p>是短进程优先算法的改进，防止预估时间较长的进程长时间被抢占出现饥饿现象</p><p>选择就绪队列中响应比R值最高的进程，响应比R定义为：$R = \frac {w + s} {s}$ （其中w为等待时间，s为预估执行时间）</p><p><strong>这个算法关注了等待时间，防止了长进程频繁被抢占和无限期推迟。</strong></p><h2 id="时间控制"><a href="#时间控制" class="headerlink" title="时间控制"></a>时间控制</h2><p>以上是从进程排列来考虑的调度算法，我们也可以从时间资源分配入手。</p><h3 id="时间片轮转算法-RR，Round-Robin"><a href="#时间片轮转算法-RR，Round-Robin" class="headerlink" title="时间片轮转算法(RR，Round Robin)"></a>时间片轮转算法(RR，Round Robin)</h3><ul><li>将时间片 q 作为分配处理机资源的基本时间单位</li><li>时间片结束时，按 FCFS(先来先服务)算法切换到下一个就绪进程</li><li>每个进程分到了 1 / n(进程总数) 的时间</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902111332.png" alt="RR" style="zoom:50%;" /><blockquote><p>基于FCFS给出的进程队列，操作系统给队头交替分配相应的处理器资源。如果执行完退出，没有执行完回到队尾</p></blockquote><p><strong>时间片轮转算法特征:</strong></p><p>有额外的上下文切换开销 (正常情况下是在 进程进入等待状态或结束状态时 才切换进程)</p><ul><li>当时间片太大时<ul><li>等待时间过长</li><li>极限情况退化成 FCFS(先来先服务)</li></ul></li><li>当时间片太小时<ul><li>反应迅速，但产生大量的上下文切换</li><li>大量上下文切换开销影响系统的吞吐量(单位时间内 运行的总进程数)</li></ul></li><li>时间片长度选择目标<ul><li>通常为 10ms左右 为一个时间片</li><li>维持上下文开销处于 1% 以内</li></ul></li></ul><h3 id="多级队列调度算法-MQ，Multilevel-Queues"><a href="#多级队列调度算法-MQ，Multilevel-Queues" class="headerlink" title="多级队列调度算法(MQ，Multilevel Queues)"></a>多级队列调度算法(MQ，Multilevel Queues)</h3><ul><li>就绪队列被划分为多个独立的子序列 (例如可以分为前台和后台)</li><li>每个队列拥有自己的调度策略</li><li>队列间调度<ul><li>固定优先级<ul><li>先处理前台 后处理后台</li><li>可能导致饥饿</li></ul></li><li>时间片轮转<ul><li>每个队列都得到一个确定的能够调度其进程的CPU总时间</li><li>80% CPU时间用于前台 20% CPU时间用于后台</li></ul></li></ul></li></ul><h3 id="多级反馈队列算法-MLFQ，Multilevel-Feedback-Queues"><a href="#多级反馈队列算法-MLFQ，Multilevel-Feedback-Queues" class="headerlink" title="多级反馈队列算法(MLFQ，Multilevel Feedback Queues)"></a>多级反馈队列算法(MLFQ，Multilevel Feedback Queues)</h3><p><strong>进程可在不同队列间移动</strong>的多级队列算法。</p><p>首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程；对于同一个队列中的各个进程，按照FCFS分配时间片调度。</p><ul><li>时间片大小随优先级级别增加（级别增加，优先级降低）而增加</li><li>进程在当前时间片没有完成，则降到下一优先级（会被分配更大的时间片）</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902111954.png" alt="MLFQ" style="zoom:50%;" /><p><strong>多级反馈队列算法特征：</strong></p><ul><li>CPU密集型进程的优先级会下降的很快</li><li>I/O密集型进程保留在高优先级</li></ul><h3 id="公平共享调度算法-FSS，Fair-Share-Scheduling"><a href="#公平共享调度算法-FSS，Fair-Share-Scheduling" class="headerlink" title="公平共享调度算法(FSS，Fair Share Scheduling)"></a>公平共享调度算法(FSS，Fair Share Scheduling)</h3><p>FSS 控制用户对系统资源的访问</p><ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源</li></ul><p>未使用的资源按比例分配，没有达到资源使用率目标的组获得更高优先级</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902112301.png" alt="FSS" style="zoom:50%;" /><h3 id="传统调度算法总结"><a href="#传统调度算法总结" class="headerlink" title="传统调度算法总结"></a>传统调度算法总结</h3><blockquote><p>若采用某个调度算法时，每个进程都有机会被调度，则该调度算法是公平的</p></blockquote><ul><li>先来先服务算法(FCFS)<ul><li>不公平 平均等待时间变动大</li></ul></li><li>短进程优先算法(SPN)<ul><li>平均周转时间最小</li><li>需要精确的预测执行时间</li><li>不公平，可能导致饥饿</li></ul></li><li>最高响应比优先算法(HRRN)<ul><li>基于 SPN调度(关注等待时间)</li><li>不可抢占</li></ul></li><li>时间片轮转算法(RR)<ul><li>公平 平均等待时间较差 交互比较好</li></ul></li><li>多级反馈队列算法(MLFQ)<ul><li>多种算法的集合(在实际系统中所使用)</li></ul></li><li>公平共享调度(FSS)<ul><li>公平</li></ul></li></ul><h1 id="实时调度和多处理器调度"><a href="#实时调度和多处理器调度" class="headerlink" title="实时调度和多处理器调度"></a>实时调度和多处理器调度</h1><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时操作系统不仅要求功能正确，还要约定的时间得以保证。</p><p>时间约束的<strong>及时性</strong>和<strong>可预测性</strong>比速度、平均性能更重要。</p><p>要保证时间能极大概率满足一个具体要求。</p><p>几个概念：</p><ul><li>实时任务：对时限有要求的任务</li></ul><p><img src="https://pic3.zhimg.com/80/v2-d09496ae911d7a8f99f11e1ca83a2112_720w.jpg" alt="img"></p><ul><li><p>周期实时任务：一系列相似的规律重复的实时任务。由周期、最大执行时间、使用率等决定。波动越小，使用率就可以越高。</p></li><li><p>硬实时和软实时：硬实时必须要满足时限，可以保证系统的确定性，否则会导致严重后果；而软实时只需尽量满足，无法达成时可以降低要求。</p></li><li><p>可调度性：一个操作系统可以满足任务的时限要求。</p></li><li><ul><li>需要确定实时任务的执行顺序</li><li>进行动态或静态的优先级调度</li></ul></li></ul><p>这里给出两个理论上可调度的实时调度算法，不要求掌握。</p><ul><li>速率单调调度算法RM：通过周期安排优先级，周期越短越早安排。</li><li>最早截止时间优先算法EDF：截止时间越早优先级越高。</li></ul><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多个处理器组成一个多处理器系统，处理器之间共享负载。</p><p><strong>对称处理器调度：</strong></p><ul><li>各处理器都有自己的调度机制</li><li>访问共享资源时再进行同步</li></ul><p><strong>对称多处理器进程分配：</strong></p><ul><li><strong>静态进程分配</strong><ul><li>进程从开始到结束都被分配到一个固定的处理机上执行</li><li>每个处理机有自己的就绪队列</li><li>调度开销小</li><li>各处理机可能忙闲不均</li></ul></li><li><strong>动态进程分配</strong><ul><li>进程在执行中可分配到任意空闲处理机上执行</li><li>所有处理机共享一个就绪队列</li><li>调度开销大</li><li>各处理机的负载是均衡的</li></ul></li></ul><h2 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h2><p>优先级置是我们不希望发生的一种调度状态。在该种状态下，一个高优先级任务间接被一个低优先级任务所抢先。</p><blockquote><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/maimang1001/article/details/7343045">说说优先级倒置（Priority inversion）blog.csdn.net</a></p></blockquote><p>这往往出现在一个高优先级任务<strong>等待访问</strong>一个被低优先级任务正在使用的<strong>临界资源</strong>时。并且此时，该低优先级任务被一个次高优先级的任务所抢先，从而<strong>无法及时地释放该临界资源</strong>。从而阻塞了高优先级任务。如下图。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902114018.png" alt="priority_inversion" style="zoom:50%;" /><blockquote><p>注：临界资源指一次只能被一个进程占用的资源，这些资源是互斥体。</p></blockquote><p><strong>如何解决优先级反置?</strong></p><p>为了保证这个互斥体资源不被次高级进程抢走，常见地，我们有如下两种策略：</p><ul><li>优先级继承(Priority Inheritance)</li><li>优先级天花板协议(Priority Ceiling Protocol)</li></ul><p><strong>优先级继承(Priority Inheritance)</strong></p><p>占用资源的低优先级进程，继承申请资源的高优先级进程的优先级。</p><p>以下图为例，T1为优先级最高的进程，T3为最低。t4之后为什么让T3先执行，就是使用了优先级继承的策略，将T3的优先级提高到和T1一样，从而让已经占有临界区资源的进程先运行。从图中可以看出，如果t4之后资源s被次高级的T2所抢占，那么T1和T3还需要等很长时间。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210902114320.png" alt="priority_inheritance" style="zoom:60%;" /><blockquote><p>注意，只有在占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级。如上图中的t3到t4之间发生的。</p></blockquote><h5 id="优先级天花板协议-Priority-Ceiling-Protocol"><a href="#优先级天花板协议-Priority-Ceiling-Protocol" class="headerlink" title="优先级天花板协议(Priority Ceiling Protocol)"></a>优先级天花板协议(Priority Ceiling Protocol)</h5><p>占用资源进程的优先级，和所有可能申请该资源的进程的最高优先级相同。</p><ul><li>不管是否发生等待，都提升占用资源进程的优先级</li><li>从而当任务执行临界区时就不会被阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab5:用户进程管理</title>
      <link href="2021/09/01/os/lab5-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2021/09/01/os/lab5-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>进程、虚拟存储、中断机制、系统调用。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab4</code> 源代码，<code>lab5</code> 主要做了如下改动：</p><ul><li><p><code>memlayout.h</code> 增加用户空间的图形表示和宏定义</p><p>宏定义 <code>USERTOP/USERBASE</code> 等指明用户虚拟地址空间范围，图形表示显示哪些用户空间属于合法空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                          Permissions</span></span><br><span class="line"><span class="comment"> *                                                              kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     4G ------------------&gt; +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |         Empty Memory (*)        |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+ 0xFB000000</span></span><br><span class="line"><span class="comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span></span><br><span class="line"><span class="comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span></span><br><span class="line"><span class="comment"> *                            |           User stack            |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                            |       User Program &amp; Heap       |</span></span><br><span class="line"><span class="comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *                            |  - - - - - - - - - - - - - - -  |</span></span><br><span class="line"><span class="comment"> *                            |    User STAB Data (optional)    |</span></span><br><span class="line"><span class="comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure></li><li><p><code>pmm.[ch]</code> 添加若干与页表项、页面相关的拷贝函数</p></li><li><p><code>vmm.[ch]</code> 添加若干与 <code>mm/vma/pgdir</code> 相关的函数</p><p>值得注意的是： <code>struct mm_struct</code> 属性内容发生变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> </span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  </span><br><span class="line">    <span class="keyword">int</span> map_count;                 </span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 </span><br><span class="line">    <span class="keyword">int</span> mm_count;                  <span class="comment">// 共享此 mm 的进程数量</span></span><br><span class="line">    <span class="keyword">lock_t</span> mm_lock;                <span class="comment">// 互斥锁, dup_map() 实现时使用，</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>proc.h</code> 扩展 <code>proc_struct</code> 数据结构</p><p><code>proc_struct</code> 的扩展点具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    ... <span class="comment">// 同以往结构的属性</span></span><br><span class="line">    <span class="keyword">int</span> exit_code;                              <span class="comment">// 当前进程的退出码，供父进程使用。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wait_state;                        <span class="comment">// 当前进程的等待状态，供子进程退出时调用。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">cptr</span>, *<span class="title">yptr</span>, *<span class="title">optr</span>;</span>     </span><br><span class="line">    <span class="comment">// 若干指针存放与其他进程间的关系(孩子进程指针(总是指向最新的子进程)、更年轻的(或称为前一个)兄弟进程指针、更年长的(或称为后一个)兄弟进程指针(后面两个指针构建兄弟进程的双向链表))</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>proc.c</code> 增加若干与 <code>SYSCALL</code> 相关的实现函数</p></li></ul><blockquote><p>在 <code>ucore</code> 中，进程与线程采用同一套管理机制，它们间的区别可能仅在于：进程之间不共享地址空间，而线程间共享某进程的地址空间 (通过共享 <code>mm</code> 结构即可)，因此两个术语基本可以混用。</p></blockquote><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>该练习用于了解 <code>do_exec()</code> 的具体实现。</p><p>在 lab4 中，我们已经知道：如何创建一个内核线程，并通过调度使得其正常执行。那么我们首先看一下 lab5 中所涉的内核线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc_init() -&gt; 构建 idleproc 和 initproc</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 此句构建 initproc，其执行 initmain 函数。</span></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="comment">// initmain() -&gt; 构建 user_mainproc</span></span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nr_free_pages_store = nr_free_pages();</span><br><span class="line">    <span class="keyword">size_t</span> kernel_allocated_store = kallocated();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(user_main, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 此句构建 user_mainproc，属于第三个内核线程，它是 initproc 的子线程。</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create user_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (do_wait(<span class="number">0</span>, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123; <span class="comment">// 等待 user_mainproc 结束，并回收其剩余资源(此为后话)。</span></span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="comment">// user_main</span></span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">user_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(<span class="built_in">exit</span>); <span class="comment">// 实际执行 sys_exec 系统调用，使用 do_exec() 重新配置当前进程的内存空间，并执行 exit 程序。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;user_main execve failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>接下来，我们主要看看 <code>do_exec()</code> 的实现细节 (<code>do_exec</code> 等价于实际系统中的 <code>exec()</code> )：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空原有 mm。</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先切换页目录表，以防访问到不该访问的，使得访问异常。</span></span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="comment">// mm 共享数减一，如此此时为 0，则需要删除此 mm，具体包括 vma集合、页目录表和页表、实际物理空间、mm 结构。</span></span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// load_icode 用来加载并解析一个处于内存中的ELF执行文件格式的应用程序，其主要工作包括：创建 mm、填充 mm 各属性、填充与代码段，数据段，栈相关的物理页、重新设置 tf，使得能够正确返回至用户空间，并开始执行相关代码。具体涉及 ELF 文件格式，可不细理。</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, size)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">&quot;already exit: %e.\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// load_icode 涉及重置 tf 部分：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line"><span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"><span class="comment">// 更新 cs 等段寄存器值为用户态段。那么当执行中断返回时，系统便可基于此判断是否存在特权级切换，从而正确弹栈。</span></span><br><span class="line">tf-&gt;tf_cs = USER_CS;</span><br><span class="line">tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF;</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题回答</strong></p><p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程 序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态） 到具体执行应用程序第一条指令的整个经过。</p><ul><li>分析在创建了用户态进程并且加载了应用程序之后，其占用CPU执行到具体执行应用程序的整个经过：<ul><li>在经过调度器占用了CPU的资源之后，用户态进程调用了exec系统调用，从而转入到了系统调用的处理例程；</li><li>在经过了正常的中断处理例程之后，最终控制权转移到了syscall.c中的syscall函数，然后根据系统调用号转移给了sys_exec函数，在该函数中调用了上文中提及的do_execve函数来完成指定应用程序的加载；</li><li>在do_execve中进行了若干设置，包括推出当前进程的页表，换用kernel的PDT之后，使用load_icode函数，完成了对整个用户线程内存空间的初始化，包括堆栈的设置以及将ELF可执行文件的加载，之后通过current-&gt;tf指针修改了当前系统调用的trapframe，使得最终中断返回的时候能够切换到用户态，并且同时可以正确地将控制权转移到应用程序的入口处；</li><li>在完成了do_exec函数之后，进行正常的中断返回的流程，由于中断处理例程的栈上面的eip已经被修改成了应用程序的入口处，而cs上的CPL是用户态，因此iret进行中断返回的时候会将堆栈切换到用户的栈，并且完成特权级的切换，并且跳转到要求的应用程序的入口处；</li><li>接下来开始具体执行应用程序的第一条指令；</li></ul></li></ul></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解 <code>do_fork()-&gt;copy_mm()</code> 的具体实现。</p><p>为了了解需要完成编码的函数的作用，不烦首先分析父进程调用fork系统调用生成子进程的过程：</p><ul><li>父进程调用fork系统调用，进入正常的中断处理机制，最终交由syscall函数进行处理；</li><li>在syscall函数中，根据系统调用好，交由sys_fork函数处理；</li><li>该函数进一步调用了do_fork函数，这个函数是主要的创建子进程、并且将父进程的内存空间复制给子进程的逻辑所在；</li><li>在do_fork函数中，调用copy_mm进行内存空间的复制，在该函数中，进一步调用了dup_mmap，在这个函数中，遍历了父进程的所有合法虚拟内存空间，并且将这些空间的内容复制到子进程的内存空间中去，具体进行内存复制的函数就是我们在本次练习中需要完善的copy_range；</li><li>在copy_range函数中，对需要复制的内存空间按照页为单位从父进程的内存空间复制到子进程的内存空间中去；</li></ul><p><strong>copy_range函数的具体执行流程如下</strong>：</p><ul><li><p>遍历父进程指定的某一段内存空间中的每一个虚拟页，如果这个虚拟页是存在的话，为子进程对应的同一个地址（但是页目录表是不一样的，因此不是一个内存空间）也申请分配一个物理页，然后将前者中的所有内容复制到后者中去，然后为子进程的这个物理页和对应的虚拟地址（事实上是线性地址）建立映射关系；而在本练习中需要完成的内容就是内存的复制和映射的建立，具体流程如下：</p><ul><li>找到父进程指定的某一物理页对应的内核虚拟地址；</li><li>找到需要拷贝过去的子进程的对应物理页对应的内核虚拟地址；</li><li>将前者的内容拷贝到后者中去；</li><li>为子进程当前分配这一物理页映射上对应的在子进程虚拟地址空间里的一个虚拟页；</li></ul></li><li><p>具体使用代码实现的结果如下所示：</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *src_kvaddr = page2kva(page); <span class="comment">// 找到父进程需要复制的物理页在内核地址空间中的虚拟地址，这是由于这个函数执行的时候使用的时内核的地址空间</span></span><br><span class="line"><span class="keyword">char</span> *dst_kvaddr = page2kva(npage); <span class="comment">// 找到子进程需要被填充的物理页的内核虚拟地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE); <span class="comment">// 将父进程的物理页的内容复制到子进程中去</span></span><br><span class="line">page_insert(to, npage, start, perm); <span class="comment">// 建立子进程的物理页与虚拟页的映射关系</span></span><br></pre></td></tr></table></figure><p>至此完成了本联系中所有需要的编码任务，从而正确地实现了操作系统的fork系统调用的功能;</p><h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>该练习用于理解各系统调用的实现机理。</p><p>首先看用户空间的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="comment">// 获取相关参数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实施中断，并将相关参数传给相关寄存器，它们会进一步放置于 tf 内部。</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">&quot;int %1;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;d&quot;</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;c&quot;</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;b&quot;</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;D&quot;</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;S&quot;</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下为用户程序可调用的各种函数，它们统一使用 syscall 实现其功能。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_exit, error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_fork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_wait</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> *store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_wait, pid, store);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_yield);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_kill, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_getpid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_putc, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_pgdir</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_pgdir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，硬件得到 <code>T_SYSCALL</code> 中断号，并调用相关中断处理程序进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    syscall();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>接下来，看看内核程序 <code>syscall()</code> 的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error_code = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> do_exit(error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uintptr_t</span> <span class="built_in">stack</span> = tf-&gt;tf_esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(<span class="number">0</span>, <span class="built_in">stack</span>, tf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_wait</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> *store = (<span class="keyword">int</span> *)arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> do_wait(pid, store);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_exec</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = (<span class="keyword">const</span> <span class="keyword">char</span> *)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">size_t</span> len = (<span class="keyword">size_t</span>)arg[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)arg[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">size_t</span> size = (<span class="keyword">size_t</span>)arg[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> do_execve(name, len, binary, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_yield</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> do_kill(pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> current-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_putc</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)arg[<span class="number">0</span>];</span><br><span class="line">    cputchar(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sys_pgdir</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>&#123;</span><br><span class="line">    print_pgdir();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述函数为 SYS_xx 的具体实现，它们会获取相关参数，并调用相关 do_xxx 进行处理，最后返回。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>= &#123;</span><br><span class="line">    [SYS_exit]              sys_exit,</span><br><span class="line">    [SYS_fork]              sys_fork,</span><br><span class="line">    [SYS_wait]              sys_wait,</span><br><span class="line">    [SYS_exec]              sys_exec,</span><br><span class="line">    [SYS_yield]             sys_yield,</span><br><span class="line">    [SYS_kill]              sys_kill,</span><br><span class="line">    [SYS_getpid]            sys_getpid,</span><br><span class="line">    [SYS_putc]              sys_putc,</span><br><span class="line">    [SYS_pgdir]             sys_pgdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 tf 中获取相关参数，放置于 arg[] 内部，并调用相应的 SYS_xxx 进行处理。</span></span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述 <code>sys_xxx</code>，简要做如下分析：</p><ul><li><p><code>do_fork(0, stack, tf)</code></p><p>第一个参数为 0，表明其会完全复制当前进程的地址空间，第二三参数，表明其会完全复制当前进程的用户栈及中断帧。如此实现，含义与实际 <code>fork()</code> 相同。</p><p>由于之前早已说明 <code>do_fork()</code> 的实现细节，在此不再赘述。</p></li><li><p><code>do_execve(name, len, binary, size)</code></p><p>练习一已经说明其含义，在此不再赘述。</p></li><li><p><code>do_exit(error_code)</code></p><p><code>do_exit()</code> 用于回收该进程的内存资源，并设置 <code>PROC_ZOMBIE</code> 状态以等待父进程处理。如果当前进程存在子进程，需要将它们置为 <code>initproc</code> 的子进程。</p></li><li><p><code>do_wait(pid, store)</code></p><p><code>do_wait()</code> 用于等待子进程处于 <code>PROC_ZOMBIE</code> 状态，并回收其剩余资源 (指代内核栈、PCB)。</p><blockquote><p>某进程资源的回收工作具体分为两步：**<code>do_exit()</code> 自主回收内存资源，<code>do_wait()</code> 由父进程回收内核资源**。之所以如此实现，原因在于：进程回收内核资源，则其必定在使用内核栈，而内核资源包括内核栈，因此存在一个矛盾。另外，父进程可通过回收资源过程，获取其子进程的运行结果，然后动态施行相关操作。</p></blockquote></li><li><p><code>do_yield()</code></p><p><code>do_yield()</code> 用于释放 CPU，并让其调度处理其他进程。</p></li><li><p><code>do_kill(pid)</code></p><p><code>do_kill()</code> 用于设置特定进程的 <code>flags |= PF_EXITING;</code>。</p></li><li><p><code>sys_getpid/sys_putc/sys_pgdir</code></p><p>此三者都比较简单，没什么可说的。</p></li></ul><p>需要注意：<code>do_yield()</code> 和 <code>do_kill()</code> 功能实现的部分代码在相应的<code>do_xxx</code>函数内部，部分代码位于 <code>trap()</code> 内部，<code>trap()</code> 内部的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如此保存旧 tf，保证实现中断嵌套。</span></span><br><span class="line">        struct trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">    </span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    </span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">            <span class="comment">// do_kill 发挥作用就比较慢，当特定进程再次进入中断后，才会让它触动回收。</span></span><br><span class="line">            <span class="comment">// 进程进入中断的方式主要存在两种：1. 系统调用 2. 时钟中断。</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// do_yield 设置字段后，中断返回前即会重新调度。</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">                schedule();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                            RUNNING----------------+</span><br><span class="line">                                               A |                  |</span><br><span class="line">                                               | |                  |</span><br><span class="line">                                            proc_run()            <span class="built_in">exit</span>()  </span><br><span class="line">                                               | |                  |</span><br><span class="line">                                               | V                  V</span><br><span class="line">--alloc_page()--&gt; UNINIT --wakeup_proc()--&gt; RUNNABLE --<span class="built_in">exit</span>()--&gt; ZOMBIE</span><br><span class="line">                                               A                    A</span><br><span class="line">                                               |                    |</span><br><span class="line">                                           子进程<span class="built_in">exit</span>()            <span class="built_in">exit</span>()</span><br><span class="line">                                               |                    |</span><br><span class="line">                                               |                    |</span><br><span class="line">                                            SLEEPING----------------+</span><br></pre></td></tr></table></figure></blockquote><h2 id="扩展练习一"><a href="#扩展练习一" class="headerlink" title="扩展练习一"></a>扩展练习一</h2><p>该练习用于实现 <code>Copy on Write(COW)</code> 机制。</p><p><code>COW</code> 机制实现比较复杂，并没有实现。在此简要说明其思想。</p><p>当执行 <code>do_fork(0, stack, tf) -&gt; copy_mm()</code> 时，复制 <code>vma</code> 集合、页目录表等内容，共享当前进程的物理页，并设置相关条目为只读 (而非原先的复制物理页)。</p><p>当新旧进程需要写共享物理页时，触发中断，执行 <code>do_pgfault()</code>。如果该页面为只读，且其共享数大于 1，则表明存在新旧进程在共享物理页，因此复制该物理页给当前进程，并设置相关条目为读写。</p><h2 id="如何创建用户线程？"><a href="#如何创建用户线程？" class="headerlink" title="如何创建用户线程？"></a>如何创建用户线程？</h2><p>借助于 <code>do_fork()/do_execve()</code>，我们成功创建用户进程 (也可称作该进程对应的主线程)，它所对应的栈直接位于虚拟地址空间中的栈区。</p><blockquote><p>用户进程的栈大小默认为 8M。当栈所占实际空间小于 8M 时，它会因缺页中断而动态增长；当栈所占实际空间大于 8M 时，便会触发 <em>栈溢出</em>。</p></blockquote><p>对于用户线程而言，它们需要共享用户进程资源 (例如：地址空间、打开的文件列表)，而独占栈空间、寄存器组等资源。</p><p>经过上面的实现，共享进程资源比较简单，无非就是设置相关指针以指向相同结构体；独占寄存器组也比较简单，使用 <code>proc.context</code> 保存即可；唯一难点在于：如何独占栈空间的同时，实现共享该进程的地址空间？</p><p>Linux 系统的解决方案是这样的：创建用户线程之时，在当前地址空间的堆区直接分配栈空间，以此作为该线程的栈。</p><blockquote><p>用户线程的栈大小默认为 16K，最大为 2M。</p><p>注：Linux 的解决方案中，线程栈空间直接分配，它不会动态增长。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab4:内核线程管理</title>
      <link href="2021/08/31/os/lab4-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>2021/08/31/os/lab4-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>线程、状态转换。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab3</code> 源代码，<code>lab4</code> 主要是添加代码 <code>process/*</code> 以实现进程/线程管理功能。</p><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于认识进程/线程控制块 PCB。</p><p>在 <code>ucore</code> 中，<code>struct proc_struct</code> 用于描述进程/线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>                      <span class="comment">// 进程状态(创建、就绪、运行、阻塞、终止)</span></span><br><span class="line">    <span class="keyword">int</span> pid;                                    <span class="comment">// 进程 ID，唯一标识此进程。</span></span><br><span class="line">    <span class="keyword">int</span> runs;                                   <span class="comment">// 进程已运行时间(尚未用到)。</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;                           <span class="comment">// 进程的内核栈(每个进程/线程均有一个，用以当发生中断时保存相关信息)。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched;                 <span class="comment">// 该进程是否需要被重新调度。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>                 <span class="comment">// 进程的父进程。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>                       <span class="comment">// 进程对应的 mm。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>                     <span class="comment">// 进程对应的上下文信息(用于进程间切换以保存进程状态)。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>                       <span class="comment">// 进程当前中断对应的 tf。</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                              <span class="comment">// PDT 所在地址。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                             <span class="comment">// 进程标识信息(尚未用到)。</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];               <span class="comment">// 进程名称</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;                      </span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                     <span class="comment">// PCB 相互链接对应的链表和 hash 表。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程状态的具体信息</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 创建</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 阻塞</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 终止</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context 还应保存各种段寄存器信息，但是此次 lab 为内核线程管理，这些寄存器取值固定，因此没有列出。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>鉴于对于 PCB 的上述理解，我们应当在 <code>alloc_proc()</code> 中，如此初始化新建的 PCB：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 尚未分配进程所需的其他资源，进程状态当然处于 &quot;新建&quot;。</span></span><br><span class="line">    proc-&gt;state = PROC_UNINIT;</span><br><span class="line">    proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">    proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;proc-&gt;context, <span class="number">0</span> , <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">    proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 本 lab 所涉内核线程，其对应 PDT 均为 boot_cr3。</span></span><br><span class="line">    proc-&gt;cr3 = boot_cr3;</span><br><span class="line">    proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;(proc-&gt;name), <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    <span class="comment">// 对于其余信息，默认初始化为空即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于实现 <code>do_fork()</code> 以为新建进程/线程分配资源 (其含义等价于实际系统中的 <code>fork()</code>)。</p><p>对于进程/线程而言，其所需资源包括 (就目前 lab 而言)：PCB、内核栈、内存资源。</p><p>在 <code>do_fork()</code> 函数内部，一一分配这些资源即可。具体源代码如下示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 PCB。</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指明当前进程为新建进程的父进程。</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内核栈</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 mm (具体指代该进程对应程序的 vma 集、与物理页面对应的 PDT)。</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置中断栈帧内容以及新建进程的 context，容许进程切换的顺利进行。</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置原子操作（通过关中断的方式），添加此 PCB 至进程集合。</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">// 关中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        nr_process++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置此进程状态为 *就绪*。</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>该练习用于详细了解 <code>ucore</code> 内部如何创建并执行内核线程（其中包括进程，在这里指等同于内核线程，切换的实现）。</p><p><code>do_fork()</code> 函数完成后，新建进程的各种资源已经分配完成，此时我们简单看看 PCB 的部分内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct trapframe *tf 属性的部分信息，其设置与 kernel_thread()/copy_thread() 相关。</span></span><br><span class="line">tf.tf_cs = KERNEL_CS;                            <span class="comment">// 各种段寄存器设置，表明其为内核进程。</span></span><br><span class="line">tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;               <span class="comment">// ebx/edx 取值为新建进程运行的函数和相关参数，之所以设置此两寄存器，规定而已。</span></span><br><span class="line">tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;       <span class="comment">// 中断返回后的执行入口。</span></span><br><span class="line">tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">tf.tf_esp = esp;</span><br><span class="line">tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct context context 属性的部分信息，其设置与 copy_thread() 相关。</span></span><br><span class="line">context.eip = (<span class="keyword">uintptr_t</span>)forkret;               <span class="comment">// 上下文切换的执行入口。</span></span><br><span class="line">context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);            <span class="comment">// 上下文切换的栈寄存器取值，其指向该进程内核栈的栈顶，其中存放 tf。</span></span><br></pre></td></tr></table></figure><p>在uCore执行完proc_init函数后，就创建好了两个内核线程：idleproc和initproc，这时uCore当前的执行现场就是idleproc，等到执行到init函数的最后一个函数cpu_idle之前，uCore的所有初始化工作就结束了，<strong>idleproc将通过执行cpu_idle函数让出CPU，给其它内核线程执行</strong>，具体过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，判断当前内核线程idleproc的need_resched是否不为0，回顾前面“创建第一个内核线程idleproc”中的描述，proc_init函数在初 //始化idleproc中，就把idleproc-&gt;need_resched置为1了，所以会马上调用schedule函数找其他处于“就绪”态的进程执行。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cpu_idle(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">            ……</span><br></pre></td></tr></table></figure><p>uCore在实验四中只实现了一个最简单的FIFO调度器，其核心就是<code>schedule</code>函数。它的执行逻辑很简单：</p><p>1．设置当前内核线程<code>current-&gt;need_resched</code>为0； </p><p>2．在proc_list队列中查找下一个处于“就绪”态的线程或进程next； </p><p>3．<strong>找到这样的进程后，就调用<code>proc_run</code>函数，保存当前进程current的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。</strong></p><p>接下来，我们看看，<strong>切换进程时具体执行的 <code>proc_run()</code> 函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前进程换为 要切换到的进程</span></span><br><span class="line">          current = proc;</span><br><span class="line">          <span class="comment">// 设置任务状态段tss中的特权级0下的 esp0 指针为 next 内核线程 的内核栈的栈顶</span></span><br><span class="line">            <span class="comment">// 两者均为内核进程，而 tss-&gt;esp0 指代 CPL =0 时的内核栈顶，因此需要切换此值。</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            <span class="comment">// 重新加载 cr3 寄存器(页目录表基址) 进行进程间的页表切换</span></span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 调用 switch_to 进行上下文的保存与切换</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>在本实验的执行过程中，创建且运行了几个内核线程？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个内核线程 一个为 idle_proc 为 第 0 个内核线程 完成内核中的初始化 然后调度执行其他进程或线程</span><br><span class="line">另一个为 init_proc 本次实验的内核线程 只用来打印字符串</span><br></pre></td></tr></table></figure><ul><li>语句local_intr_save(intr_flag);….local_intr_restore(intr_flag);在这里有何作用?请说明理由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭中断 避免进程切换的中途 再被中断(其他进程再进行调度)</span><br></pre></td></tr></table></figure></blockquote><p>进一步，<strong>追看 <code>switch_to()</code> 的具体实现</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">switch_to:                      </span><br><span class="line">    # 保存原有进程的 context 信息。</span><br><span class="line">  # 调用 switch_to 后栈的情况  |     To    esp + 8 |</span><br><span class="line">    #                          |   From   esp + 4  |</span><br><span class="line">    #                          |  Ret Addr &lt;- esp  |</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from</span><br><span class="line">    # 指代将 switch_to 的返回地址 pop 作为原先进程的 context.eip </span><br><span class="line">    popl 0(%eax)                </span><br><span class="line">    movl %esp, 4(%eax)          </span><br><span class="line">    movl %ebx, 8(%eax)          </span><br><span class="line">    movl %ecx, 12(%eax)        </span><br><span class="line">    movl %edx, 16(%eax)         </span><br><span class="line">    movl %esi, 20(%eax)      </span><br><span class="line">    movl %edi, 24(%eax)        </span><br><span class="line">    movl %ebp, 28(%eax)     </span><br><span class="line"></span><br><span class="line">    # 恢复新进程的 context 信息。</span><br><span class="line">    movl 4(%esp), %eax          # eax points to to</span><br><span class="line"></span><br><span class="line">    movl 28(%eax), %ebp        </span><br><span class="line">    movl 24(%eax), %edi         </span><br><span class="line">    movl 20(%eax), %esi        </span><br><span class="line">    movl 16(%eax), %edx         </span><br><span class="line">    movl 12(%eax), %ecx         </span><br><span class="line">    movl 8(%eax), %ebx          </span><br><span class="line">    movl 4(%eax), %esp          </span><br><span class="line"></span><br><span class="line">    # 设置函数的返回地址为 to 所指代的 eip (具体指代 forkret)，那么 switch_to 返回后，便会执行 forkret 函数。</span><br><span class="line">    pushl 0(%eax)              </span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>由上述汇编代码可知，<code>switch_to</code> 函数返回后会执行<code>forkret</code>函数，而forkret会调用位于kern/trap/trapentry.S中的forkrets函数执行</p><p>进一步，<strong>追看 <code>forkret() -&gt; forkrets()</code> 的具体实现</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__trapret: </span><br><span class="line">    # restore registers from stack (从栈中弹出所有通用寄存器的值)</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %gs, %fs, %ds and %es</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"># get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    # 跳转到kernel_thread_entry （此时esp指向了current-&gt;tf.tf_eip，而如果此时执行的是initproc，则current-&gt;    </span><br><span class="line">    # tf.tf_eip&#x3D;kernel_thread_entry）</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # 把esp指向当前进程的中断帧</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    # 此部分为中断处理的后半部分，弹出栈顶的一系列元素，返回执行中断前的指令，具体指代 tf.eip 所指。</span><br><span class="line">    # 对于新进程而言，其指代 kernel_thread_entry (它会调用 fn 和 arg，开始真正执行新进程的指令)。</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure><p>至此，完成分析 “进程切换” 的完整步骤。</p><blockquote><p>虽然本 lab 仅涉及内核线程的切换，但是其进程切换方式是比较特殊的：借助于中断实现。该种实现方式允许特权级切换，从而可以构建用户进程，从而为 lab5 打下基础。</p></blockquote><p><strong><code>kernel_thread_entry</code>是entry.S中实现的汇编函数</strong>，它做的事情很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread_entry: # void kernel_thread(void)</span><br><span class="line">pushl %edx # push arg</span><br><span class="line">call *%ebx # call fn (fn就是进程的主体函数)</span><br><span class="line">pushl %eax # save the return value of fn(arg)</span><br><span class="line">call do_exit # call do_exit to terminate current thread</span><br></pre></td></tr></table></figure><p>从上可以看出，kernel_thread_entry函数主要为内核线程的主体fn函数做了一个准备开始和结束运行的“壳”，并把函数fn的参数arg（保存在edx寄存器中）压栈，然后调用fn函数，把函数返回值eax寄存器内容压栈，调用do_exit函数退出线程执行。</p>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：进程和线程（六）</title>
      <link href="2021/08/27/os/os%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/08/27/os/os%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程</p><p>这里特别注意<strong>程序和进程之间的关系</strong>：</p><ul><li>程序=文件（静态的可执行文件）</li><li>进程=程序+执行过程</li><li>进程是程序的超集，还包括数据和进程控制块。</li></ul><p><strong>程序和进程之间的区别</strong>：</p><ul><li>同一个程序的<strong>多次执行</strong>过程对应为不同进程</li><li>进程是动态的，程序是静态的</li><li>进程是暂时的，程序是永久的</li></ul><p><strong>进程的特征</strong>：</p><ul><li>动态性：动态创建、结束</li><li>并发性：可以独立调度并占用处理器运行</li><li>独立性：不同的进程的工作互不影响</li><li>制约性：因访问共享数据、资源或进程间同步产生制约关系</li></ul><p>共享和独立需要有一定限度，进程之间不仅需要去耦合，但不能忘记相互协作的初衷</p><p>执行进程需要内存和CPU共同工作：</p><ul><li>内存负责保存代码和数据</li><li>CPU负责执行指令</li></ul><h3 id="进程控制块-PCB-Process-Control-Block"><a href="#进程控制块-PCB-Process-Control-Block" class="headerlink" title="进程控制块 (PCB Process Control Block)"></a>进程控制块 (PCB Process Control Block)</h3><p>操作系统管理控制进程运行所用的信息集合 (操作系统用 PCB 来描述进程的基本情况以及运行变化的过程)</p><ul><li>PCB 是进程存在的唯一标识（每个进程都在操作系统中有一个对应的 PCB）</li></ul><p><strong>进程控制块存些什么?</strong></p><ul><li>进程标识信息 (PID)</li><li>处理机现场保存 (调度之前需要 保存上下文 保存其他寄存器 以便下次调度回来的时候使用)</li><li>进程控制信息 (调度优先级)<ul><li>调度和状态信息 (调度进程和处理机使用情况)</li><li>进程间通信信息</li><li>存储管理信息 (指向进程映像存储空间数据结构 占用的存储空间用完以后还给操作系统)</li><li>进程所用资源 (进程使用的系统资源 打开文件)</li><li>有关数据结构连接信息 (与PCB相关的进程队列 不同的状态处于不同的进程队列)</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827211736.png" alt="PCB_Context" style="zoom: 50%;" /><p>**进程控制块的组织 (数据结构实现)**：</p><ul><li><p>链表：各种状态形成不同的链表，多个状态对应多个不同的链表</p></li><li><p>索引表：同一个状态的进程归入一个索引表（由索引指向）</p></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827211955.png" alt="PCB_Data_Structure" style="zoom: 67%;" /><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>进程创建 操作系统分配给进程所需要的资源 构建 PCB<ul><li>系统初始化时</li><li>用户请求创建一个新进程</li><li>正在运行的进程执行了创建进程的系统调用</li></ul></li><li>进程执行<ul><li>进程创建完后 会放入就绪队列 等待 CPU调度</li><li>内核选择一个就绪的进程 让它占用处理机并执行</li></ul></li><li>进程等待(阻塞) 进程等待是进程本身发起的 不是外部让它去等待的<ul><li>请求并等待的系统服务 无法马上完成</li><li>启动某个操作 无法马上完成</li><li>需要的数据没有到达</li></ul></li><li>进程抢占<ul><li>高优先级进程就绪</li><li>进程执行时间片用完</li></ul></li><li>进程唤醒 进程唤醒是由别的进程或操作系统唤醒 不是自己唤醒自己<ul><li>被阻塞的进程需要的资源可被满足</li><li>被阻塞的进程等待的事件到达</li></ul></li><li>进程结束 将进程所占用的资源还给操作系统<ul><li>正常退出</li><li>错误退出</li><li>致命错误(强制性的)</li><li>被其他进程所杀(强制性的)</li></ul></li></ul><h3 id="三状态进程模型"><a href="#三状态进程模型" class="headerlink" title="三状态进程模型"></a>三状态进程模型</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827212135.png" alt="process_state" style="zoom: 50%;" /><ul><li>当程序被创建完成之后，一切就绪准备运行时，变为<strong>就绪状态</strong></li><li>处于就绪状态的进程被进程调度程序选中后，就分配到处理器上来运行，进入<strong>运行状态</strong>。</li><li>处于运行状态的进程在其运行过程中，由于分配给它的时间片用完，让出处理器，返回<strong>就绪状态</strong>。</li><li>当进程请求某资源且必须等待时，进入<strong>等待状态</strong>。</li><li>进程要等待某时间到来时，它从阻塞状态变到<strong>就绪状态</strong>。</li><li>当进程表示它已经完成或者因出错，进程由运行过程<strong>退出</strong>。</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li>进程 1 执行 sleep() 进入 内核 内核调用函数设置定时器</li><li>进行调度 保存现场(到 PCB 中) 切换到 进程 2</li><li>进程 2 开始执行 若此时定时器时间到了 定时器产生 中断</li><li>中断服务例程 让 进程 2 暂停下来 并保护 进程 2 的现场 恢复 进程 1 的现场</li><li>让 进程 1 继续执行 进程 1 执行结束 再回到 操作系统</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827212331.png" alt="process_switching" style="zoom: 50%;" /><h3 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h3><p>在上述的三状态模型的基础上，我们引入外存，增加一系列挂起状态，包括就绪挂起和等待挂起，从而进一步缓解内存的空间压力。</p><p>将优先级较低的的进程挂起，是通用的策略。</p><p>几个典型的状态变迁如下：</p><ul><li><strong>等待到等待挂起</strong>：没有进程出于就绪态，或就绪过程需要挤占更多内存</li><li><strong>就绪到就绪挂起</strong>：高优先级等待进程遇到低优先级就绪进程，认为前者将更快就绪，所以后者就绪挂起</li><li><strong>运行到就绪挂起</strong>：高优先级等待挂起因事件出现而进入就绪挂起。（我的理解是一种特殊的插队机制）</li><li><strong>等待挂起到就绪挂起</strong>：当有等待挂起进程因相关事件出现而发生转换</li><li><strong>就绪挂起到就绪</strong>：没有就绪进程或挂起就绪进程优先级高于就绪进程</li><li><strong>等待挂起到等待</strong>：当一个进程释放足够内存，并有高优先级等待挂起进程</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827212503.png" alt="process_suspend" style="zoom: 50%;" /><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><p>由操作系统来维护一组队列 表示系统中所有进程的当前状态</p><ul><li>不同队列表示不同状态</li><li>根据进程状态不同 进程PCB 加入相应队列</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827212553.png" alt="process_state_queue" style="zoom: 50%;" /><h2 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程(Thread)"></a>线程(Thread)</h2><h3 id="背景和需求"><a href="#背景和需求" class="headerlink" title="背景和需求"></a>背景和需求</h3><p>如果要实现可同步进行且相互通信的三个流程，用进程就不行了。</p><p>进程可以实现并行化，但是</p><ul><li>进程间相对隔离的性质和这个目标相悖</li><li>使用进程的开销过大，需要各自开辟一块相类似的进程控制块</li></ul><p>所以我们引入在同一个进程当中并行设计的<strong>线程</strong>机制。</p><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p><strong>线程是什么</strong>：</p><ul><li>进程的一部分</li><li>描述指令流执行状态，是进程中指令执行流的最小单元</li><li>是CPU调度的基本单位。</li><li>线程之间可以并发执行，其之间共享相同的地址空间。</li></ul><p><strong>线程的优缺点</strong>：</p><p>线程 = 进程 - 共享资源 = 执行流</p><ul><li>线程的优点<ul><li>一个进程中可以有多个线程</li><li>各个线程之间可并发执行</li><li>各个线程之间可以共享地址空间和文件等资源</li></ul></li><li>线程的缺点<ul><li>一个线程崩溃 会导致其所属进程的所有线程崩溃</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827213432.png" alt="process_thread_relationship" style="zoom:50%;" /><p><strong>线程与进程的区别：</strong></p><ul><li>进程是资源分配单位，线程是CPU调度单位</li><li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源 (寄存器 栈)</li><li>线程能减少并发执行的时间和空间开销<ul><li>线程的创建和结束时间比进程短，且同一进程内的线程切换时间比进程短</li><li>同一进程的 各线程间共享内存和文件资源，可不通过内核进行直接通信(省执行时间)</li></ul></li></ul><h3 id="线程实现的三种方式"><a href="#线程实现的三种方式" class="headerlink" title="线程实现的三种方式"></a>线程实现的三种方式</h3><ul><li>用户线程(在用户空间实现)</li><li>内核线程(在内核中实现)</li><li>轻权进程(LightWeight Process 在内核中实现 支持用户线程 结合了用户线程和内核线程的优点)</li></ul><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827213800.png" alt="user_thread" style="zoom:50%;" /><p>用户线程的<strong>特征</strong>：</p><ul><li><strong>不依赖操作系统内核</strong>：内核不了解用户线程的存在；可用于不支持线程的OS</li><li><strong>在用户空间实现线程机制</strong>：每个进程由私有的线程控制块（TCB）列表，TCB由线程库函数维护</li><li>同一进程内的用户线程<strong>切换速度快</strong>：无需OS内核特权级转换等等开销</li><li>允许每个进程拥有<strong>自己的线程调度算法</strong>：程序员可以根据实际情况设计更适合程序的调度</li></ul><p>当然也有<strong>缺点</strong>：</p><ul><li>线程发起系统调用而阻塞时，则整个进程进入等待。</li><li>由于不和内核作用，所以不支持基于线程的处理器抢占。</li><li>只能按进程分配CPU时间：多个线程的进程中，每个线程所能分到的时间片较少</li></ul><p>上述的缺点都是由于用户态的设计不与内核作用的结果，一方面不依赖内核，但一方面也不能实现最好的优化。</p><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827213927.png" alt="kernel_thread" style="zoom:50%;" /><p>由于上述缺点，所以如果在内核当中实现线程将会更加合适。在内核中直接用PCB链接TCB并进行操作，就可以让处理器更加了解当前工作的线程机制。从而克服上述的问题。</p><p>内核线程的<strong>特征</strong>：</p><ul><li>由内核来维护 PCB 和 TCB</li><li>线程执行系统调用而被阻塞 不影响 其他线程</li><li>线程的创建 终止 切换 开销大(因为要通过系统调用在内核中走一趟)</li><li>以线程为单位进行 CPU时间分配(多线程的进程可获得更多的CPU时间)</li></ul><h4 id="轻权进程-LightWeight-Process"><a href="#轻权进程-LightWeight-Process" class="headerlink" title="轻权进程(LightWeight Process)"></a>轻权进程(LightWeight Process)</h4><p>Solaris提出的轻权进程能进一步解决内核线程开销大的问题，一个进程可有一个或多个轻权进程，每个轻权进程由一个单独的内核线程来支持。但后续由于过于复杂，轻权进程的实际表现并不理想。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827214241.png" alt="lightWeight_process" style="zoom:50%;" /><blockquote><ul><li>永久绑定线程 可看作是 内核支持的线程</li><li>未绑定的轻权进程 可由用户态来给出一些策略 提高应用的效率;未绑定的轻权进程 就像用户线程实现的多线程 可以自己决定调度算法之类的</li><li>但同时 永久绑定线程 又是 内核原生就支持的线程 所以轻权进程 是融合了 内核线程和用户线程的优点</li></ul></blockquote><h4 id="内核线程和用户线程和轻权进程的对应关系"><a href="#内核线程和用户线程和轻权进程的对应关系" class="headerlink" title="内核线程和用户线程和轻权进程的对应关系"></a>内核线程和用户线程和轻权进程的对应关系</h4><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827214753.png" alt="thread_relationship" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一对一 可看作是 多进程多线程操作系统</span><br><span class="line">多对一 可看作是 多进程单线程操作系统(用户态实现多线程)</span><br><span class="line">多对多 轻权进程</span><br><span class="line">实际上最广泛使用 一对一 多进程多线程操作系统</span><br></pre></td></tr></table></figure><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程切换-上下文切换"><a href="#进程切换-上下文切换" class="headerlink" title="进程切换 (上下文切换)"></a>进程切换 (上下文切换)</h3><p>暂停当前运行进程，从运行状态变为其他状态；调度另一个进程从就绪状态变成运行状态。</p><p>重要的上下文信息包括：</p><ul><li>寄存器</li><li>CPU状态</li><li>内存地址空间</li></ul><p>进程切换的要求：</p><ul><li>切换前，保存进程上下文</li><li>切换后，恢复进程上下文</li><li>要求快速切换</li></ul><p>切换的模式图如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827215318.png" alt="context_switch" style="zoom:50%;" /><p>内核为每个进程维护了对应的进程控制块，内核将相同状态的进程的PCB放置在同一队列。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827215345.png" alt="PCB_queue" style="zoom:60%;" /><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ul><li>Windows进程创建Api CreateProcess()</li><li>Unix进程创建系统调用 fork/exec<ul><li>fork() 把一个进程复制成两个进程 父子进程的PID不同</li><li>exec() 用新程序来重写当前进程 PID 不变</li></ul></li></ul><h4 id="进程复制-fork"><a href="#进程复制-fork" class="headerlink" title="进程复制 fork"></a>进程复制 fork</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork()；<span class="comment">// 创建子进程</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">// 子进程在这里继续</span></span><br><span class="line">    exec(“program”, argc, argv0, argv1, …);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fork() 创建一个继承的子进程<ul><li>复制父进程的所有变量和内存</li><li>复制父进程的所有 CPU 寄存器(一个寄存器例外 是用来识别父进程和子进程的)</li></ul></li><li>fork() 的返回值<ul><li>子进程的 fork() 返回值 为 0</li><li>父进程的 fork() 返回值为 子进程标识符</li><li>子进程可使用 getpid() 获取 PID</li></ul></li></ul><p>fork执行过程对于子进程而言，是在调用时刻对父进程地址空间的一次复制。fork得到的子进程和父进程只有上述的返回值不同。利用这个特点就可以进行多进程操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> childPID;</span><br><span class="line">s_1;</span><br><span class="line"></span><br><span class="line">childPID = fork();</span><br><span class="line"><span class="keyword">if</span> (childPID == <span class="number">0</span>)</span><br><span class="line">&lt;子进程执行&gt;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">&lt;父进程执行&gt;</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line">s_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个创建的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LOOP; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*fork another process */</span></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123; <span class="comment">// if error occurred</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123; <span class="comment">//child process</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;i=%d, pid=%d, parent pid=%d\n&quot;</span>, I, getpid(), getppid());</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码开始运行之后，每一个现存的进程都会进行fork复制。如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827215624.png" alt="fork_loop" style="zoom:50%;" /><h3 id="进程加载与执行-exec"><a href="#进程加载与执行-exec" class="headerlink" title="进程加载与执行 exec"></a>进程加载与执行 exec</h3><p>执行系统调用exec()时，进行程序加载操作。</p><ul><li>exec()，允许程序加载一个完全不同的程序，并从main开始执行（和操作系统启动时的思路类似）</li><li>运行进程加载时指定启动参数。（argc，argv）</li><li>exec调用成功时，还是相同的进程，但是运行了不同的程序。</li><li>代码段、堆栈和堆都完全重写。</li></ul><p>在99%的情况下，我们在调用fork()之后，我们都会使用系统调用exec()，<strong>加载</strong>新程序取代当前运行进程。<br>因而</p><ul><li>在fork操作中内存复制是没有作用的</li><li>子进程将可能关闭打开的文件和链接</li></ul><p>因而在创建进程时，可以不再创建一个同样的内存映像，将fork和exec结合起来，成为轻量级fork，接口为vfork()。现在vfork使用Copy on write技术实现。</p><h3 id="进程等待与退出"><a href="#进程等待与退出" class="headerlink" title="进程等待与退出"></a>进程等待与退出</h3><p><strong>进程等待：</strong></p><p>wait() 系统调用用于<strong>父进程等待子进程的结束</strong></p><ul><li>子进程结束时通过 exit() 向父进程返回一个值</li><li>父进程通过 wait() 接受并处理返回值</li></ul><p><strong>wait()系统调用的功能：</strong></p><ul><li><p>当父进程先 wait() 子进程后 exit() 时</p><ul><li>父进程进入等待状态，等待子进程的返回结果</li><li>当某子进程调用 exit() 时 唤醒父进程，将 exit() 返回值作为 父进程 wait() 的返回值</li></ul></li><li><p>当子进程先 exit() 父进程后 wait() 时</p><ul><li>说明有僵尸子进程等待 ，wait() 立即返回其中一个值</li></ul></li><li><p>当 无子进程存活 而 父进程 wait() 时</p><ul><li>wait() 立即返回</li></ul></li></ul><p><strong>进程退出：</strong></p><p>进程结束执行时 调用 exit() 完成进程资源回收</p><ul><li>exit() 系统调用的功能<ul><li>将调用参数作为进程的 结果(返回值)</li><li>关闭所有打开的文件等占用资源</li><li>释放内存</li><li>释放大部分进程相关的内核数据结构</li><li>检查父进程是否还存活<ul><li>存活 保留结果的值 直到父进程需要它 进入 僵尸(zombie/defunct)状态</li><li>非存活 释放所有的数据结构和结果</li></ul></li><li>清理所有等待的僵尸进程</li></ul></li></ul><p>因此，进程终止是最终的垃圾收集(资源回收)</p><h3 id="进程控制与进程状态关系"><a href="#进程控制与进程状态关系" class="headerlink" title="进程控制与进程状态关系"></a>进程控制与进程状态关系</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210827220349.png" alt="process_control_with_process_state" style="zoom:60%;" /><h3 id="其他进程控制系统调用"><a href="#其他进程控制系统调用" class="headerlink" title="其他进程控制系统调用"></a>其他进程控制系统调用</h3><ul><li>优先级控制<ul><li>nice() 指定进程的初始优先级</li><li>Unix系统中 进程优先级会随着执行时间而衰减</li></ul></li><li>进程调试支持<ul><li>ptrace() 允许一个进程控制另一个进程的执行</li><li>设置断点和查看寄存器等</li></ul></li><li>定时<ul><li>sleep() 可以让进程在定时器的等待队列中等待指定的时间</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>os_lab3:虚拟内存管理</title>
      <link href="2021/08/26/os/lab3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/08/26/os/lab3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>虚拟存储、页面置换算法、中断机制。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab2</code> 源代码，<code>lab3</code> 主要是添加部分代码以实现虚拟存储功能，仅见的改动点在于页描述结构 <code>page</code> 和 <code>alloc_pages</code> 函数的具体实现，两者源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        </span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          </span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         </span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link;     <span class="comment">// 链接属于同一程序的物理页面</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;            <span class="comment">// 指明此物理页面对应的虚拟地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct Page * <span class="title">alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         local_intr_save(intr_flag);</span><br><span class="line">         &#123;</span><br><span class="line">              page = pmm_manager-&gt;alloc_pages(n);</span><br><span class="line">         &#125;</span><br><span class="line">         local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果因空闲页不够而导致的内存分配失败，且此时已经开启 swap，则其会基于相关替换算法而自动换出某些页面，以满足分配要求(此处要求 n &gt; 1，表明只要请求页面大于 1，分配失败时不会尝试进行页面替换)。</span></span><br><span class="line">         <span class="keyword">if</span> (page != <span class="literal">NULL</span> || n &gt; <span class="number">1</span> || swap_init_ok == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">check_mm_struct</span>;</span></span><br><span class="line">         </span><br><span class="line">         swap_out(check_mm_struct, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于了解页面替换算法 FIFO 的具体实现。</p><p>对于虚拟内存管理而言，另外涉及两大数据结构：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210826105223.png" alt="image-20210826105223591"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// 指向管理此 vma 的 mm</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">// vma 的起始虚拟地址(包含)      </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">// vma 的终止虚拟地址(不包含)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">// vma 权限标志信息(可读、可写、可执行)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">// 用于将属于同一程序的 vma 链接起来</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 指向某程序的 vma 集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 当前访问的 vma</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">// 该程序对应的页目录表</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">// 指明某程序的 vma 总数</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">// swap manager(主要指代页面替换算法的具体实现) 的隐私信息。ucore 之中，使用 pra_list_head 进行填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为实现 FIFO，我们需要使用 <code>list_entry_t pra_list_head</code> 所指链表来有序 (对于 FIFO 而言，指代页面被分配的时间) 保存某程序所分配的物理页面集 (集内页面使用 <code>Page.pra_page_link</code> 进行链接)。</p><p>当分配某程序物理页面后，需要将刚分配的页面放置于链表尾部以显式更新 <code>pra_list_head</code> 链表；当需要选择待替换物理页面时，直接选择链首页面即可。</p><blockquote><p>被替换的物理页面会被存放至 swap 分区内部 (此称为交换技术)。因为此时 PTE 表项无效，因此 <code>ucore</code> 使用此存放该页面所在位置的起始扇区编号。</p><p>因为 <code>ucore</code> 将物理页面线性映射至 swap 对应扇区，因此其交换技术的实现十分简单。而实际系统之中，这种映射实现是比较复杂的。</p></blockquote><p>基于 FIFO 实现思想及上述数据结构，很容易写出相关代码，故不再赘述。</p><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>此练习用于了解并实现缺页中断的异常处理程序。</p><p>缺页中断的异常处理程序的具体调用流程如下：<code>__alltraps</code> –&gt; <code>trap</code> –&gt; <code>trap_dispatch</code> –&gt; <code>pgfault_handler</code> –&gt;<code>do_pgfault</code>。这里直接基于 <code>do_pgfault</code> 的实现，说明如何处理缺页中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm 指代当前运行程序的虚拟内存管理结构，error_code 指代硬件设置的异常码，addr 指代引发缺页中断的虚拟地址。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">// 判断 addr 是否属于当前运行程序的合法地址。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">// 如果该地址不合法，则直接返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 详细判断硬件设置的 error_code (其第 0 位指代中断是否由页面不存在而引起，第 1 位指代中断是否由写操作引起，第 2 位指代当前是否处于用户模式)，对于因权限不满足的情况，直接返回。</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下情形才能继续运行：1. 写某已存在的地址；2. 写未存在的地址，并且此地址可写；3. 读未存在的地址，并且此地址可读。</span></span><br><span class="line">    <span class="comment">// 对于情形 1，基本没有涉及，主要关注后两种情形。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 vma 对应的访问权限</span></span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实验指导书所示练习填写代码处</span></span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取该虚拟地址对应的 pte 表项，若获取失败(可能因为空间不足，而分配页表失败)，则直接返回。</span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果其值为空，则只能直接分配页面(对于实际系统而言，直接分配肯定是不行的，因为当前页面可能存在数据)。</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 同样可能因为分配页面而失败，</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表明其存在于 swap 分区内部，需要进行获取(如果 swap manager 尚未初始化成功，则直接返回)。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            <span class="comment">// 获取 swap 内容至所分配的 page。</span></span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构建页表映射，触发 FIFO 更新，设置 page 对应的 pra_vaddr。</span></span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);                        </span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展练习一"><a href="#扩展练习一" class="headerlink" title="扩展练习一"></a>扩展练习一</h2><p>该练习用于了解并实现 <code>extended clock</code> 页面替换算法。</p><p>基于硬件实现以及现有数据结构，该算法比较容易实现。</p><p>首先设置一个指针<code>ptr</code>，其指向<code>list_entry_t pra_list_head</code> 所示链表的首个元素；当分配某程序物理页面后，需要将其放置于 <code>list_entry_t pra_list_head</code> 所示链表的尾部；程序访问过程中，硬件会自动设置 PTE 表项中的相关标志位 (所示页面是否发生修改，所示页面是否访问)；当需要选择待替换物理页面时，遍历链表，并动态更新 <code>ptr</code> 指针以及相应页面对应页表项的标志位，如果某页面对应的标志位为 00 (即，自上次至此，尚未被访问，也尚未被修改)，则选择此页面进行替换。</p>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：页面置换算法（五）</title>
      <link href="2021/08/24/os/os%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>2021/08/24/os/os%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="页面置换算法概念"><a href="#页面置换算法概念" class="headerlink" title="页面置换算法概念"></a>页面置换算法概念</h1><blockquote><p>本节强烈建议看视频：课程第九讲。其中给出了大量的动画示例，有助于理解。</p></blockquote><p>处理缺页异常（需要调入新页面而内存已满）时，用于选择被置换的物理页面的算法。</p><p>设计<strong>目标</strong>：减少调入调出次数，寻找未来不再访问或短期内不访问的页面调出</p><p>在给出页面置换的结构之前，我们有一类特例，即不被替换的页面：<br><strong>页面锁定</strong>（frame locking）</p><ul><li>操作系统的关键部分，描述必须常驻的逻辑页面，这部分页面对响应速度有要求</li><li>利用页表中的锁定标志位来实现</li></ul><p>评价方法：页面轨迹统计，模拟页面置换行为，记录缺页次数</p><p>页面置换算法分类：</p><ul><li><p>局部页面置换算法（选择范围仅限当前进程占用的物理页面）</p></li><li><ul><li>最优算法：全知全能，量身定制</li><li>先进先出算法：先调入的页先调出</li><li>最近最久未使用算法：一个统计方法，实现较麻烦</li><li>时钟算法，最不常用算法</li></ul></li><li><p>全局置换算法（选择防卫是所有可换出的物理页面）</p></li><li><ul><li>工作集算法</li><li>缺页率算法</li></ul></li></ul><h1 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h1><h2 id="最优置换算法（OPT）"><a href="#最优置换算法（OPT）" class="headerlink" title="最优置换算法（OPT）"></a>最优置换算法（OPT）</h2><p>置换在未来最长时间不访问的页面。</p><p>缺页时计算内存中<strong>每个</strong>逻辑页面的下一次访问时间。全知全能，缺页次数最少，是理想情况。</p><ul><li>实际系统中无法实现</li><li>无法预制每个页面在下次访问前的等待时间</li><li>但具有理论意义：用于评定置换算法的性能</li></ul><h2 id="先进先出算法（FIFO）"><a href="#先进先出算法（FIFO）" class="headerlink" title="先进先出算法（FIFO）"></a>先进先出算法（FIFO）</h2><p>由于上述以未来情况为依据的算法不可实现，所以我们要使用如下的基于过去情况的算法。</p><p>选择在内存中驻留时间最长的页面进行置换，即FIFO算法。</p><p>具体实现过程通过维护一个记录所有位于内存中的逻辑页面队列（双向链表）实现。</p><ul><li>实现简单</li><li>性能较差，调出的页面可能是经常访问的</li><li>Belady现象：进程分配物理页面数增加时，缺页并不一定减少，例子可看之后的章节-Belady现象</li><li>很少单独使用</li></ul><h2 id="最近最久未使用算法（LRU）"><a href="#最近最久未使用算法（LRU）" class="headerlink" title="最近最久未使用算法（LRU）"></a>最近最久未使用算法（LRU）</h2><p>Least Recently Used（LRU），选择最长时间没有被引用的页面进行置换。局部性原理表明，如某些页面长时间未被访问，则它们在将来可能会长时间不会访问。</p><p>缺页时，计算内存中每个逻辑页面的上一次访问时间，排序找最远。</p><p>LRU是最优置换算法的一种近似，但由于算法复杂度过大，仍然在实际情况中无法实施。</p><p>实际实现可以使用页面链表或者活动页面栈来构建优先队列，从而降低复杂度：</p><ul><li>队头：最久未使用的</li><li>队尾：刚刚使用过的</li></ul><p>当然维护队列维护队列所带来的复杂度也是不可小视的。</p><h2 id="时钟算法（Clock）"><a href="#时钟算法（Clock）" class="headerlink" title="时钟算法（Clock）"></a>时钟算法（Clock）</h2><p>前面两种算法各有优劣，FIFO考虑得太过简单，导致性能较差，而LRU的核心问题在于统计得过于仔细，所以难以实施。</p><p>所以考虑对页面访问的情况进行大致统计。</p><ul><li>在页表项中增加访问位，描述页面在过去一段时间中的访问情况。形成环形链表。</li><li>缺页时，从指针处开始顺序查找<strong>未被访问</strong>（LRU因素）的<strong>第一个</strong>（FIFO因素）页面进行置换。</li><li>有环、有指针，所以形象地称为时钟算法。它是LRU和FIFO的折中。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824210700.jpg" alt="img" style="zoom:67%;" /><p>算法描述如下：</p><ul><li>页面装入内存时，访问位初始化为0；</li><li>访问页面时，被访问页面的访问位置1；</li><li>缺页时，从指针处开始顺序扫描，如果访问位为0则置换该页，如果访问位为1则修改为0并移动指针到下一个页面，直到找到可置换页面。</li></ul><p>一个示例如下：</p><p><img src="https://pic1.zhimg.com/80/v2-336f133d21e88157dba1a5b419e359c0_720w.jpg" alt="img"></p><h2 id="改进的clock算法"><a href="#改进的clock算法" class="headerlink" title="改进的clock算法"></a>改进的clock算法</h2><p><strong>时钟置换算法缺点</strong>：</p><p>之前的时钟置换算法如果要置换的页是被修改过的，那么就会先要将修改过的页写到外存，然后才将要换入的页读入内存，这样消耗时间过长。</p><p>减少修改页的缺页处理开销 (如果要置换的页被修改了 则不置换此页 同时操作系统定期将修改过的页写到外存)</p><p><strong>改进算法</strong>：</p><ul><li>在页面中加入修改位 并在访问时 进行相应修改</li><li>缺页时 修改页面标志位 以跳过有修改的页面</li></ul><p>按照下面的状态转移表在指针扫过时对使用位和修改位进行修改，后续改动的页面的写出会被合并且延时，而不用在每一次修改并换出时都向外存写出。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824211854.jpg" alt="img" style="zoom:50%;" /><h2 id="最不常用算法（LFU）"><a href="#最不常用算法（LFU）" class="headerlink" title="最不常用算法（LFU）"></a>最不常用算法（LFU）</h2><p><strong>算法实现：</strong></p><ul><li>每个页面设置一个访问计数</li><li>访问页数 访问计数 + 1</li><li>缺页时 置换 计数最小的页面</li></ul><p><strong>算法特征：</strong></p><ul><li>算法开销大</li><li>开始时频繁使用 以后不使用的页面难换出 (因为页面在里面待的越久 访问计数越大)<ul><li>解决方法 较大的计数定期右移</li></ul></li></ul><p><strong>LRU 和 LFU 的区别：</strong></p><ul><li>LRU 关注多久未使用，时间越短越好 (维护栈)</li><li>LFU 关注次数，次数越多越好 (稍微简单些)</li></ul><h2 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h2><ul><li>Belady现象：在采用FIFO算法时，有时会出现分配的物理页数增加，缺页率反而提高的异常现象。</li><li>Belady现象的原因：FIFO算法的置换特征与进程访问内+存的动态特征是矛盾的。与置换算法的目标是不一致的（即替换较少使用的页面）。因此，被它置换出去的页面并不一定是进程不会访问的。为什么FIFO算法会产生Belady现象，而LRU算法不会产生Belady现象：</li><li>例子：比如对于1,2,3,4,1,2,5,1,2,3,4,5这个序列，<ul><li>如果FIFO队列长为3，缺页次数为9，</li><li>如果FIFO队列长为4，缺页次数为10</li></ul></li></ul><blockquote><p>解答：因为LRU算法符合栈算法的特点，而FIFO算法不符合栈算法的特点。栈算法的特点是给与的物理页帧越多，所产生的缺页中断的次数就越少。</p><p>思考：Clock algorithm 和 Enhanced Clock algorithm 是否会产生Belady现象？</p><p>会</p></blockquote><h2 id="几种算法的对比"><a href="#几种算法的对比" class="headerlink" title="几种算法的对比"></a>几种算法的对比</h2><p>LRU、FIFO和Clock的比较：</p><ul><li><p>LRU算法和FIFO算法本质上都是先进先出的思路。只不过LRU针对页面最近访问的时间来进行排序。所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序（有一个页面最近访问的时间变了）；而FIFO是针对页面进入内存的时间来进行排序，这个时间是固定不变的。所以页面之间的先后顺序是固定的。如果一个页面在进入内存后没有被访问。那么它最近访问的时间就是它进入内存的时间。换句话说，如果内存当中所有的页面都未曾访问过，那么LRU算法就退化为FIFO算法。</p></li><li><p>LRU算法性能比较好，但系统的开销比较大；FIFO算法系统的开销比较小，但有可能会发生Belady现象。</p><p>因此，折中的办法就是Clock算法，在每一次页面访问时，它不必动态的区调整页面在链表中的顺序，而仅仅是做一个标记，然后等到发生缺页中断的时候，再把它移动到链表尾端。对于内存中那些未被访问的页面，Clock算法的表现和LRU一样好；而对于那些曾经被访问过的页面，它不能像LRU算法那样，记住它们准确的位置。6.3 全局页面置换算法</p></li></ul><h1 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很多时候，很少量的页面数限制成为算法的瓶颈，比如这个例子：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824213507.jpg" alt="img" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824213516.jpg" alt="img" style="zoom:80%;" /><p>增加一个物理页面之后，整个置换过程中缺页数量都大大减小。</p><p>因而我们思考，可以通过进程之间的物理页面数目的均衡，来改善不同进程的置换算法的表现。</p><h3 id="全局置换算法要解决的问题"><a href="#全局置换算法要解决的问题" class="headerlink" title="全局置换算法要解决的问题"></a><strong>全局置换算法要解决的问题</strong></h3><ul><li>进程在不同阶段的内存需求是变化的。</li><li>分配给进程的内存也需要在不同阶段也不同。</li><li>全局置换算法需要确定分配给进程的物理页面数</li></ul><h3 id="CPU利用率和并发进程数的关系"><a href="#CPU利用率和并发进程数的关系" class="headerlink" title="CPU利用率和并发进程数的关系"></a><strong>CPU利用率和并发进程数的关系</strong></h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824220001.png" alt="CPU_process" style="zoom:67%;" /><p> CPU利用率 与 并发进程数存在相互促进和制约的关系</p><ul><li>进程数少时，提高并发进程数可提高CPU利用率</li><li>并发进程导致内存访问增加</li><li>并发进程的内存访问会降低访存局部性特征 (两个进程所做的事情不相干 局部性原理不适用)</li><li>局部性特征下降会导致缺页率上升和CPU利用率下降</li></ul><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>一个进程当前正在使用的逻辑页面的集合 可表示为二元函数 W(t, Δ)</p><ul><li>t 是当前的执行时刻</li><li>Δ 为工作集窗口(Working-set window) 一个定长的页面访问时间窗口</li><li>W(t, Δ) 为在当前时刻t前的 Δ 时间窗口中所有访问页面所组成的集合</li><li>| W(t, Δ) | 为工作集大小 页面数量</li></ul><h3 id="工作集的变化"><a href="#工作集的变化" class="headerlink" title="工作集的变化"></a>工作集的变化</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824214025.png" alt="Working_set" style="zoom:67%;" /><ul><li>进程开始执行后 随着访问新页面逐步建立较稳定的工作集</li><li>当内存访问的局部性区域的位置大致稳定时(只访问那几个页面 没有大的改变时) 工作集大小也大致稳定</li><li>局部性区域的位置改变时(进程前一项事情做完 去做下一项事情时) 工作集快速扩张和快速收缩过渡到下一个稳定值</li></ul><h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>在当前时刻 进程实际驻留在内存当中的页面集合</p><ul><li>工作集和常驻集的关系<ul><li>工作集是进程运行过程中固有的性质 (进程在一段时间访问的页面集合)</li><li>常驻集 取决于 系统分配给进程的物理页面数 和 页面置换算法 (实际在内存中的页)</li></ul></li><li>缺页率和常驻集的关系<ul><li>常驻集 包含 工作集时 缺页较少 (进程访问的页都在内存里)</li><li>工作集发送剧烈过渡时 缺页较多</li><li>进程常驻集大小达到一定数目后 缺页率不会明显下降 (内存够进程功能使用了 再去加内存 反而效率下降)</li></ul></li></ul><h2 id="工作集置换算法"><a href="#工作集置换算法" class="headerlink" title="工作集置换算法"></a>工作集置换算法</h2><p>换出不在工作集中的页面 (并不一定是在缺页时才做 因此开销大)</p><p>具体实现：窗口大小 τ，则 当前时刻前τ个内存访问的页引用是工作集</p><ul><li>访存链表 维护窗口内的访存页面链表</li><li>访存时 换出不在工作集的页面 (开销大)</li><li>缺页时 换入页面</li></ul><blockquote><p>工作集置换算法和LRU相似，但是是在访存时将不在工作集内的页面换出。在缺页时直接补入。</p></blockquote><h2 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h2><p>缺页率 (Page fault rate) = 缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数 （一般使用后者）</p><ul><li>影响缺页率因素<ul><li>页面置换算法 (只有这个能自己控制)</li><li>分配给进程的物理页面数</li><li>页面大小</li><li>程序的编写方法 (局部性特征)</li></ul></li></ul><p><strong>缺页率算法实现</strong></p><p>通过调节常驻集的大小 使每个进程的缺页率保持在一个合理的范围</p><ul><li>若进程缺页率过高 则增加常驻集以分配更多物理页面数</li><li>若进程缺页率过低，则会降低并发度，使CPU利用率下降。因此要减少常驻集，将一些页面置换到外存</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824214517.png" alt="PFF_process" style="zoom:67%;" /><ul><li>访存时 设置引用位标记</li><li>缺页时 计算从上次缺页时间 t_last 到现在 t_current 的时间间隔<ul><li>如果 t_current - t_last &gt; T 缺页率低，则置换 所有在[t_last, t_current]中没有被引用的页 使其用在更有意义的地方(CPU并发率提高)</li><li>如果 t_current - t_last &lt;= T 缺页率高 则增加缺失页到常驻集中</li></ul></li></ul><h1 id="抖动和负载控制"><a href="#抖动和负载控制" class="headerlink" title="抖动和负载控制"></a>抖动和负载控制</h1><h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>抖动的产生是因为随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。<br>抖动问题(Thrashing)：</p><ul><li>进程物理页面太少 不能包含工作集</li><li>造成大量缺页 频繁置换</li><li>进程运行速度变慢</li></ul><p>因此操作系统需在 并发水平 和 缺页率之间达到一个平衡，需要选择一个适当的<strong>进程数目</strong>和<strong>进程所需要的物理页面数</strong>（即进行负载控制）。</p><h2 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h2><p>通过调节并发进程数 (MPL Multiprogramming level) 来进行系统负载控制</p><ul><li>我们希望平均缺页间隔时间（MTBF）大于等于缺页异常处理时间（PFST）（若小于，则cpu处于满负荷）。因此下图中两条虚线夹着的范围就是平衡点所在范围。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824214855.png" alt="thrashing" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os:虚拟存储概念（四）</title>
      <link href="2021/08/24/os/os%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/"/>
      <url>2021/08/24/os/os%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="虚存的需求背景"><a href="#虚存的需求背景" class="headerlink" title="虚存的需求背景"></a>虚存的需求背景</h2><p>实际的存储受限于成本等原因，为了物尽其用，往往设计为层次结构，大容量存储往往性能较差，性能较好的存储往往设计的很小。</p><p>但借助软硬件的协同，将读写较快的内存作为读写较慢的磁盘的缓存来使用，如果处理得当，相当于提高了存储的综合性能。</p><h2 id="覆盖技术和交换技术"><a href="#覆盖技术和交换技术" class="headerlink" title="覆盖技术和交换技术"></a>覆盖技术和交换技术</h2><p>目前已经有一些解决内存不够的思路，比如之前提到的段式存储中的共用策略（覆盖），连续存储中的交换策略。</p><p>这一类时间换空间的方法，都是比较真诚的资本家想法，在于充分的增加内存的时间占用率，让每一块区域尽可能都不闲下来。</p><p><strong>覆盖</strong>技术：</p><ul><li>必要部分：常驻</li><li>可选部分：用到时装入</li><li>不会同时使用的几个模块：相互覆盖，共用存储</li></ul><p>这样就减小了单个程序运行的内存开销，可以在较小的内存上运行较大的程序。</p><p>但这种方式，不能自动完成，需要程序员自行指定调用关系，机器才会进行覆盖。这增加了编程的难度。</p><p><strong>交换</strong>技术着眼于不同进程的调度，区别相对繁忙和闲置的进程，并换入换出。通常我们使用电脑时看到的临时文件.swp就是被换到外存的部分（当然不一定是整个进程）。</p><p>交换技术的问题</p><ul><li><strong>交换时机</strong>：何时需要交换？只当内存空间不够或者有不够的可能时换出</li><li><strong>交换区大小</strong>：存放用户进程的所有内存映像的拷贝</li><li><strong>程序换入时的重定位</strong>：换回时需要放回在原处吗？使用动态链接</li></ul><p>对比：</p><table><thead><tr><th></th><th>覆盖</th><th>交换</th></tr></thead><tbody><tr><td>操作单位</td><td>模块</td><td>进程</td></tr><tr><td>模块间逻辑结构</td><td>需要给出</td><td>不需给出</td></tr><tr><td>工作环境</td><td>程序内部模块</td><td>内存进程间</td></tr></tbody></table><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>在介绍虚拟内存之前，我们先要给出其一个重要的理论前提，即局部性原理，说白了就是好好利用缓存，一鼓作气干尽可能多的事，可以降低不必要的时间消耗。</p><p>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。这种局部性可以从如下三个层面上来看：</p><ul><li>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问与下次访问都集中在一个较短时期内；</li><li>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几条数据都集中在一个较小的区域内；</li><li>分支局部性：一条跳转指令的两次执行，很可能跳转到相同的内存位置</li></ul><p>基于上述的思考，虚拟存储技术是能够实现的，且能获得令人满意的结果。</p><p>比如要遍历一个二维数组int <code>a[1024][1024]</code></p><p>有如下两种编写方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">a[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">a[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由于后一次将临近的数据先行访问完，从而造成的缺页中断比前者少一个量级。</p><h2 id="虚存的目标"><a href="#虚存的目标" class="headerlink" title="虚存的目标"></a>虚存的目标</h2><p>虚拟存储就结合了覆盖和交换两种方法的优劣势：</p><ul><li>在程序内部（单<strong>进程</strong>）实现内存与外存的交换，从而获得更多的空闲内存空间。</li><li>这个过程由操作系统<strong>自动</strong>完成，不需程序员设定。</li></ul><p>决定哪些内容何时换入换出的算法就是下一节要重点讲述的<strong>置换算法</strong>。</p><h2 id="虚存的概念"><a href="#虚存的概念" class="headerlink" title="虚存的概念"></a>虚存的概念</h2><p>虚拟存储就是将一部分硬盘当成虚拟内存使用，实现时将不常用的部分内存块暂存到外存。</p><p><strong>原理</strong>：</p><ul><li>加载程序时，只将<strong>当前</strong>指令执行<strong>需要</strong>的部分页面或段装入内存</li><li>执行过程中，需要的指令或者数据不在内存中（称为<strong>缺页</strong>或<strong>缺段</strong>）时，处理器通知操作系统将相应的页或段调入内存中</li><li>操作系统将内存中暂时不用的页面或段保存到外存</li></ul><p>这样，除却交换过程的开销，整体上就显得内存变大了。</p><p><strong>特点</strong>：</p><ul><li>不连续性：物理内存和虚拟地址空间使用非连续</li><li>内存扩容：提供给用户的虚存大于实际物理内存</li><li>部分交换：只对部分虚拟地址空间进行调入调出</li></ul><p><strong>实现</strong></p><ul><li><p>方式：</p></li><li><ul><li>虚拟页式存储</li><li>虚拟段式存储</li></ul></li><li><p>具体的实现包括：</p></li><li><ul><li>硬件的地址转换机制</li><li>操作系统的进程监控</li><li>操作系统的置换算法</li></ul></li></ul><h2 id="虚拟页式存储"><a href="#虚拟页式存储" class="headerlink" title="虚拟页式存储"></a>虚拟页式存储</h2><p>在之前的页式存储（非连续）的基础上，增加请求调页和页面置换的机制。</p><p>思路：</p><ul><li>只装必要的部分即可运行</li><li>需要的代码或数据不在内存，发送缺页异常</li><li>处理异常，从外存调入必要页面</li></ul><p>原理框图也比较直接，在之前的页式存储的结构上加入缺页异常的处理即可。<br>处理方法就是将“不在内存”这个标志位（即<strong>驻留位</strong>）变成“在内存”。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824145732.jpg" alt="img" style="zoom:80%;" /><p>其他的标志位还有：</p><ul><li>修改位：表示在内存中的该页是否已经修改过（置换时是否需要写回）</li><li>访问位：给页面置换算法提供统计支持</li><li>保护位：表示该页的允许访问方式（只读、可读写、可执行等）</li></ul><p>x86页表结构：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824145830.jpg" alt="img" style="zoom:80%;" /><h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p>发现要找的内存页不在内存当中，就会引发缺页异常。却也异常处理流程如下图：</p><ul><li>执行命令时CPU给出需要的逻辑地址，查找页表；</li><li>发现缺页，产生缺页异常；</li><li>操作系统启用缺页异常例程，查找页面在外存中的位置；</li><li>从物理内存中找空闲页帧并将页面换入空闲处；</li><li>将对应页表项修改为有效；</li><li>重新执行导致异常的指令。</li></ul><p>可以看到这是最顺利的情况，如果换入时发现没有空闲页帧的话则需要额外几步：</p><ul><li>根据页面置换算法选择要被换出的页帧；</li><li>判断该页帧是否被修改过，如果被修改过则写回外存，否则直接作废；</li><li>将其对应的页表项改为无效；</li><li>然后将需要的页帧换入空出来的区域，后续与最开始的流程一致。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824145913.jpg" alt="img" style="zoom:80%;" /><p>虚拟页式存储管理的性能可以用<strong>有效存储访问时间</strong>（Effective memory access time，EAT）来评定，</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210824150259.jpg" alt="img" style="zoom:67%;" /><p>可见为了使引入虚拟页式存储的时间尽可能小，必须要保证缺页率 相当低。</p>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab2:物理内存管理</title>
      <link href="2021/08/23/os/lab2-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/08/23/os/lab2-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>分段机制、分页机制、物理内存管理机制、伙伴系统、slub 分配算法。</p><h2 id="改动点"><a href="#改动点" class="headerlink" title="改动点"></a>改动点</h2><p>相比于 <code>lab1</code> 源代码，<code>lab2</code> 主要做了如下改动：</p><ul><li><p><code>bootasm.S</code> 增加内存探测功能</p><p>借助于 BIOS 提供的 <code>int 0x15</code> 中断功能，探测当前机器的内存布局，并将其结果放置于 <code>0x8000</code> 处。</p><p>该结果以 <em>地址范围描述符</em> 结构体形式进行存放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_map;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> addr; <span class="comment">// 基址</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> size; <span class="comment">// 大小</span></span><br><span class="line"><span class="keyword">long</span> type; <span class="comment">// 类型</span></span><br><span class="line">&#125; <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>kernel.ld</code> 重新设置入口点和加载位置</p><p>在 <code>lab1</code> 中，ucore 入口点直接为 <code>init.c</code>；而在 <code>lab2</code> 中，ucore 入口点为 <code>entry.S</code>，随后跳转至 <code>init.c</code>，原因在于：需要在 <code>entry.S</code> 中完成开启分页机制、加载基本页表等工作。</p><p>值得注意的是：虽然 <code>kernel.ld</code> 中加载位置为 <code>0xC0100000</code> ，但是 <code>bootmian.c</code> 却将其实际加载至 <code>0x100000</code>，从而形成一种不对等映射。</p></li><li><p>增加 <code>entry.S</code> 文件</p></li><li><p>修改 <code>pmm_init()</code> 函数</p><p>该函数为实现物理内存管理的关键函数，所有练习均基于此进行展开，其中主要完成如下工作：初始化物理内存管理器 <code>pmm_manager</code>、内核空间虚拟地址与物理地址的映射、有关页目录表和页表的各种操作。</p></li></ul><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于了解 <code>default_pmm.c</code> 代码所做的工作 (默认的物理内存管理：基于 First-Fit 的连续物理内存分配算法)。</p><p>对于物理内存管理而言，主要涉及两大数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该结构用于管理空闲物理内存。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// 双向链表头部节点，该链表存放所有空闲内存块。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// 该链表所含的空闲页总数(内存块可能包含多个空闲页)。</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构用于描述某页信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// 指代当前页被映射至多少个虚拟页。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 指代当前页的状态信息。PG_reserved 表示当前页是否为保留页，PG_property 指代当前页是否空闲，仅内存块的第一个页设置此字段，内存块的其余页均设置为 0。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// 指代空闲内存块所包含的空闲页个数，仅空闲内存块的第一个空闲页设置此字段，其余空闲页均设置为 0。</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// 双向链表节点。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>熟悉此两大数据结构各字段含义和 First-Fit 思想，很容易理解 <code>default_pmm.c</code> 所做的工作，在此不再赘述。</p><p>值得一说的是：<code>ucore</code> 如何初始化 <code>free_area_t</code>？</p><p>初始化工作具体分为两部分：</p><ul><li><p><code>init_pmm_manager()</code></p><p>初始化物理内存管理器为 <code>default_pmm_manager</code>，并调用该管理器的 <code>init()</code> 以初始化 <code>free_list</code> 和 <code>nr_free</code> 。</p></li><li><p><code>page_init()</code></p><p>基于内存探测结果，将空闲物理块放置于 <code>free_list</code> 中，以供管理器进行管理。</p><p>鉴于此函数比较重要，在此简单列举其实现源代码 (已忽略部分无关代码)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 之前放置内存探测结构的位置便是 0x8000 + KERNBASE，如今获取它。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (struct e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="comment">// maxpa 用于存放最大可用物理内存地址(注：ucore 设置可用物理空间最大为 KMEMSIZE，因此 maxpa 不可能超过此值，下面代码有设置)。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="comment">// 如果内存块类型为 E820_ARM 表明，其可供 OS 使用。</span></span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE) &#123;</span><br><span class="line">                maxpa = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kernel.ld 中 .bss 数据段的结尾，基本也属于 OS 代码部分的结尾。</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所含页数，设置页描述数组 pages 的起始位置。</span></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line">    pages = (struct Page *)ROUNDUP((<span class="keyword">void</span> *)end, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 0~maxpa 部分的物理页，设为保留页。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页描述数组的结尾位置。</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> freemem = PADDR((<span class="keyword">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(struct Page) * npage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 page table 结尾 ~ maxpa 空间放置于空闲链表内(目前仅涉及内核空间，后续 ucore 实验可能涉及用户空间)。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem) &#123;</span><br><span class="line">                begin = freemem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE) &#123;</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * QEMU 的物理内存探测结果布局：</span></span><br><span class="line"><span class="comment">    * e820map:</span></span><br><span class="line"><span class="comment">    * memory: 0009fc00, [00000000, 0009fbff], type = 1.</span></span><br><span class="line"><span class="comment">    * memory: 00000400, [0009fc00, 0009ffff], type = 2.</span></span><br><span class="line"><span class="comment">    * memory: 00010000, [000f0000, 000fffff], type = 2.</span></span><br><span class="line"><span class="comment">    * memory: 07ee0000, [00100000, 07fdffff], type = 1.</span></span><br><span class="line"><span class="comment">    * memory: 00020000, [07fe0000, 07ffffff], type = 2.</span></span><br><span class="line"><span class="comment">    * memory: 00040000, [fffc0000, ffffffff], type = 2.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 注：type 取值为 1，表示 OS 可用空间；type 取值为其他值，则 OS 不可用，仅供某些设备可用(具体不谈，知道即可)。</span></span><br><span class="line"><span class="comment">    * 按照上述代码以及探测结果可知，最大可用空间为 [0~07fdffff]，近似等于 [0~128M]。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * entry.S 中，设置基本页表 KERNBASE + (0 ~ 4M) ~ (0 ~ 4M) 的映射关系。</span></span><br><span class="line"><span class="comment">    * 根据最开始的汇编代码可知：0~1M 已经供给 BIOS 和 BootLoader 使用，OS 使用的是 1~4M 空间。</span></span><br><span class="line"><span class="comment">    * 这里就存在一个问题，重新设置页表前，OS 真的不会超过 4M 吗，即所需页面不会超过 3 * 1024 / 4 = 768？</span></span><br><span class="line"><span class="comment">    * 简单分析一下：</span></span><br><span class="line"><span class="comment">    *     运行代码查看 end 取值，可以发现其值为 0xc011bf28，刨去 BIOS 和 BootLoader 所占空间，可知：OS 代码、数据部分所占 27 个页面。</span></span><br><span class="line"><span class="comment">    *     page table 所需页面计算：128M的可用空间 =&gt; 分成128 * 1024 / 4 (32768) 页面 =&gt; 由于每个页面大致容纳 4K/20=200 个 page 信息，因此总共需要约 32768/200（163） 个页面。</span></span><br><span class="line"><span class="comment">    *     总共 27+163=190 个页面，由此可知，OS 是不会超过 4M 的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如何修改kern/mm/default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数可查看lab_answer/lab2_result中的代码和注释，这里就不再赘述。</p><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>该练习用于了解页目录表、页表的使用，以及虚拟地址的转换流程。</p><p>对于 <code>ucore</code> 而言，如此划分 32 位的线性地址 (其中宏 <code>PDX/PTX/PGOFF/PPN</code> 分别用于获取线性地址的相应部分)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |     Index      |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \----------- PPN(la) -----------/</span></span><br></pre></td></tr></table></figure><p>对于页目录表或者页表而言，其均 4KB 对齐，且表项均为 <code>int</code> 整数 (因为 4KB 对齐，那么页表或页的物理地址的低 12 位一定为 0，那么表项可使用这低 12 位存放权限信息，例如，当前页表或页可读、可写、是否存在)。</p><blockquote><p><strong>注</strong>：页目录项（Pag Directory Entry）和页表项（Page Table Entry）中每一个组成部分的含义可参考<a href="https://wiki.osdev.org/Paging">该资料</a>。</p></blockquote><p><code>get_pte()</code> 函数的具体实现，详见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> * <span class="title">get_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于宏 PDX 及页目录表基址 pgdir，获取线性地址 la 所对应的页目录表条目。</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = pgdir + PDX(la);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断当前条目是否存在对应页表。</span></span><br><span class="line">    <span class="keyword">if</span> ( !(*pdep &amp; PTE_P))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 尝试分配一个物理页，以此作为页表。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> =</span> alloc_page();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配失败或者无需新建，则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!create || page == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要使用此页表，设置引用数。基于 page2pa 获取该页对应的物理地址(页描述数组起始地址与 page 地址的差，表明其间存在多少个页描述结构，一个页描述结构对应 4KB 空间，那么很容易计算当前页所对应的物理地址)。</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空该页信息(pa 为物理地址，需要将其转换为虚拟地址，因为分段机制采用的是扁平模式，因此虚拟地址等价于线性地址。对于目前的内核而言，线性地址与物理地址间相差 0xC000000，因此很容易实现地址转换)。</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立页表与页目录间的对应关系，并设置相应权限。</span></span><br><span class="line">        *pdep = pa | PTE_P | PTE_W | PTE_U ;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回 la 对应的具体页表条目(因为页目录条目对应的是物理地址，同样需要将其转换为虚拟地址)。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">pte_t</span> *)(KADDR(PDE_ADDR(*pdep))) + PTX(la);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：函数参数、指针操作，所涉及的地址均为虚拟地址，而非实际物理地址。</p><h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>该练习用于了解页目录表、页表的使用，以及虚拟地址的转换流程。</p><p><code>page_remove_pte()</code> 函数的具体实现，详见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">page_remove_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep) &#123;</span><br><span class="line"><span class="comment">// 判断当前页目录条目是否存在相应的页表，如果不存在则无需移除。</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// 获取相应页表对应的页描述结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">        <span class="comment">// 解除映射关系，自然需要引用数减一，如果引用数归零，则释放此页面。</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(page);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置页目录条目，并清除 tlb 中有关此线性地址 la 的无效信息。</span></span><br><span class="line">        *ptep = <span class="number">0</span>;</span><br><span class="line">        tlb_invalidate(pgdir, la);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="地址映射的若干阶段"><a href="#地址映射的若干阶段" class="headerlink" title="地址映射的若干阶段"></a>地址映射的若干阶段</h2><p>段页式管理总体框架图：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210823211355.png" alt="image-20210823211355112" style="zoom:120%;" /><p>在 <code>lab2</code> 中，最为复杂的，莫过于与分段机制和分页机制相关的若干地址映射阶段，在此简要介绍其实现过程。</p><ul><li><p>第一阶段</p><p><code>bootasm.S</code> 中开启分段机制，其所涉段表定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br></pre></td></tr></table></figure><p>地址映射关系为：虚拟地址 == 线性地址 == 物理地址。</p></li><li><p>第二阶段</p><p><code>bootmain.c</code> 中加载 OS，由于编译的加载位置与实际的加载位置并不相同，因此存在一个隐性的地址映射关系 (实际并不存在)：虚拟地址 - 0xC0000000== 线性地址 == 物理地址。</p></li><li><p>第三阶段</p><p><code>entry.S</code> 中开启分页机制，其所涉页表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.globl __boot_pgdir</span><br><span class="line">    # 映射虚拟地址 0 ~ 4M 至物理地址 0 ~ 4M(临时条目，跳转至 kern_init 前即会删除)。</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    # 空白填充虚拟地址 4M ~ 0xC0000000 之间的页目录表项</span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) </span><br><span class="line">    # 映射虚拟地址 0xC0000000 + (0 ~ 4M) 至物理地址 0 ~ 4M。</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir)</span><br></pre></td></tr></table></figure><p>地址映射关系为：虚拟地址 == 线性地址 == 物理地址 + 0xC0000000 (仅限 0 ~ 4M)。</p><p>涉及到的汇编命令可参考<a href="http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html%E5%92%8Chttp://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html和http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html</a></p></li><li><p>第四阶段</p><p><code>pmm_init() -&gt; boot_map_segment()</code> 中重新设置页目录表和页表，从而得到如下地址映射关系：虚拟地址== 线性地址 == 物理地址 + 0xC0000000 (0~0x38000000，目前 <code>ucore</code> 所能访问的全部地址空间)。</p></li></ul><h2 id="linux-内核-内存管理-slub算法"><a href="#linux-内核-内存管理-slub算法" class="headerlink" title="linux 内核 内存管理 slub算法"></a>linux 内核 内存管理 slub算法</h2><p>核管理页面使用了2个算法：伙伴算法和slub算法，伙伴算法以页为单位管理内存，但在大多数情况下，程序需要的并不是一整页，而是几个、几十个字节的小内存。于是需要另外一套系统来完成对小内存的管理，这就是slub系统。slub系统运行在伙伴系统之上，为内核提供小内存管理的功能。</p><p>详细内容可查看<a href="https://blog.csdn.net/lukuen/article/details/6935068">这篇博文</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：非连续内存分配（三）</title>
      <link href="2021/08/20/os/os%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>2021/08/20/os/os%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="非连续内存分配的背景与需求"><a href="#非连续内存分配的背景与需求" class="headerlink" title="非连续内存分配的背景与需求"></a>非连续内存分配的背景与需求</h2><p>之前已经讲到操作系统的连续内存分配，但比如在WFA（worst-fit allocation，先拆最大块方法）中，随着分配的进行，较大的内存申请很可能将不再能一次满足。所以我们思考有没有一种方法将较为离散的内存块组织起来，组织成逻辑上的相对大块的内存。借用段式存储管理中的这张图，我们将这个过程示意如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816205535.jpg" alt="img" style="zoom:67%;" /><p>另外，连续内存的申请和释放都伴随着一些麻烦，同时还不免地产生内外碎片。</p><p>非连续分配的提出就是为了<strong>提高内存的利用率和管理的灵活性</strong>。</p><ul><li>允许程序使用非连续的物理地址空间</li><li>允许共享代码和数据</li><li>支持动态加载和动态链接</li></ul><p>非连续分配的实现过程中需要解决的问题： <strong>实现虚拟地址和物理地址的转换</strong></p><ul><li>软件实现：利用类似外排序的思路，灵活地组织处在<strong>不同区域</strong>的内存，但是开销大；</li><li>硬件实现：每执行一条指令都需要做转换，那么直接使用硬件做映射是比较好的。</li></ul><p>非连续分配硬件辅助机制：如何选择非连续分配中的内存分块大小（拆多大？如何组织？）</p><ul><li>段式存储管理（segmentation）</li><li>页式存储管理（paging）</li></ul><blockquote><p>访问不在当前段的地址的错误就叫<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/wpgraceii/p/10622582.html">段错误</a>（segmentation fault），这在初学算法题时十分常见。当一个程序找不到某个地址时，它会认为你所需要的地址在其他段上，而不是说它不存在。</p></blockquote><h2 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h2><h3 id="段式存储管理概念"><a href="#段式存储管理概念" class="headerlink" title="段式存储管理概念"></a>段式存储管理概念</h3><p>段表示访问方式和存储数据等属性相同的一段地址空间，对应一个连续的内存“块”，由若干个“段”组成进程逻辑地址空间。</p><p>进程的地址空间由多个功能不同的段构成：主代码段，子模块代码段、公用库代码段、stack、heap、初始化数据段、符号表等。</p><p>将各个功能区隔离开之后，段式存储就实现了更细粒度的灵活的分离与共享。段式存储在做内存保护方面有优势。</p><blockquote><p>各个部分内部连续，但之间相对去耦合，从而实现（这里是相对底层的）复用。这和高级语言编程中加入函数和模块的考量是一致的。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816210242.png" alt="image-20210816210242325" style="zoom:40%;" /><h3 id="段式存储的访问"><a href="#段式存储的访问" class="headerlink" title="段式存储的访问"></a>段式存储的访问</h3><p>利用基址+长度这种描述方法访问段的地址。思路如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816210631.png" alt="image-20210816210631419" style="zoom:50%;" /><p>段的地址可以用一个二元数来表示，其中一个是<strong>基址</strong>，原理上基址加指定的偏移，就可以完成重定位，即可找到段的地址。 二元数的另一个元素是<strong>长度</strong>，在重定位之前就要验证段长度是否会溢出（这又是经典的segfault了qwq）。</p><h2 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h2><p>页式存储和段式存储是两种不同粒度的管理策略，但是其总体思路是一致的，认识如下量方面即可：</p><ul><li>单元划分的标准</li><li>单元访问方式</li></ul><h3 id="页式存储的基本单元"><a href="#页式存储的基本单元" class="headerlink" title="页式存储的基本单元"></a>页式存储的基本单元</h3><p>将分块进行较小的划分之后，由于数量增多，我们希望这种效率提高，基于二进制的位运算是符合这种目标的。 我们将<strong>2的n次方的内存片段</strong>作为页式存储的单元，如512、4k、8k。4k是很常见大小。</p><ul><li>物理地址空间中的单元叫做物理页面，一般地，称为页帧（page frame），简称<strong>帧（frame）</strong>。</li><li>逻辑地址空间中的单元称为逻辑页面，一般地，称为页面，简称<strong>页（page）</strong>。</li><li>帧和页的大小必须相同。</li></ul><h3 id="页式存储的地址转换"><a href="#页式存储的地址转换" class="headerlink" title="页式存储的地址转换"></a>页式存储的地址转换</h3><p>首先看物理内存中的单元：帧</p><p>物理内存被划分为2的n次方大小的帧，其内存物理地址仍然可以用二元组（f,o）表示，f为帧号（占s位），o为偏移。 则物理地址为： $f*2^s+o$ </p><p><strong>例题</strong>：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816211714.jpg" alt="img" style="zoom:67%;" /><p>页和帧有一定的对应关系，在两个对应的页和帧中，页内偏移和帧内偏移一致，但通常页号大小和帧号大小不同。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816211735.jpg" alt="img" style="zoom:67%;" /><p>构建的逻辑地址合乎人的使用习惯，页号是连续的。而物理地址空间中的帧号并不是连续的。</p><p><strong>注意：并不是所有的页都有对应的帧。</strong></p><p>在这种情况下，在比较大的内存空间中，需要做的仅仅是简单映射：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816211909.png" alt="image-20210816211909363" style="zoom: 40%;" /><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><h3 id="基本要点"><a href="#基本要点" class="headerlink" title="基本要点"></a>基本要点</h3><ul><li>每个进程都有一个页表，每一个页面都有一个页表项。</li><li>页表是按照逻辑页密排的，所以页号并不需要存入页表项。</li><li>页表项中<strong>只储存物理帧号</strong>以及一些标志位。</li><li>页表中的内容随着进程的运行状态而动态变化。为了表征这些变化所以引入标志位，比如存在位、修改位、引用位等（这些后续会讲到）。</li></ul><p>例子：假定一个16位系统，物理内存32KB，页大小1k，则 - 有32页。0<del>9存储页内数据，A</del>F存储页号。</p><ul><li>页表有32项。</li><li>物理帧号的地址位数一般少于逻辑地址，因为并不是进程的每一个页面都要调入内存，所以物理帧号的位数小于页号位数。</li></ul><p>解决页式存储管理的问题：</p><ul><li>需要访问两次：使用缓存（快表）</li><li>页表可能非常大：间接访问（多级页表）</li></ul><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>快表（TLB，translation look-aside buffer）就是将最近使用过的页表存入CPU，使用caching的方式加快页表的查询对应。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816212138.jpg" alt="img" style="zoom:80%;" /><ul><li>如果TLB命中，则物理页号将会<strong>快速</strong>且<strong>并行</strong>地获取。</li><li>未命中时查询页表，随后更新TLB。</li></ul><p>如果命中率高，那么TLB对于页表查询开销的改善作用是非常有效的。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>将线性页表转换为树形结构，即可构建多级页表，可以减小每一级的长度。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816212207.jpg" alt="img" style="zoom:80%;" /><p>如果逻辑地址空间全满的话，对于存储空间来说，其实并没有非常显著的提升，但是实际使用过程中，会有很多空的分支，这样就可以节省一部分空间。</p><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>另一种减小页表大小的方法。</p><p>由于多级页表是树形结构，对于大地址空间（虚拟地址），多级页表仍会变得非常繁琐。 而且因为每个进程都有独立的页表，所以页表的大小会随着进程的增加而增加。</p><p>为了解决这些问题，我们可以<strong>不让页表和逻辑地址空间的大小相对应，而是让页表与物理地址空间的大小相对应</strong>。这就是<strong>页寄存器</strong>和<strong>反置页表</strong>的思路。</p><p>在这种情况下，如果页面本身相对于页表项很大的话，页表的内存开销就不足为惧了。</p><p>具体的实现方法是，让每一个物理帧都和一个页寄存器相关联。页寄存器包含如下的标志位：</p><ul><li>使用位（residence bit）：此帧是否被进程占用</li><li>占用页号（occupier）：对应的页号p</li><li>保护位（protection bits）</li></ul><p>这种方法的好处在于：</p><ul><li>大大减省页表占用内存</li><li>页表大小与逻辑地址空间相比往往很小</li></ul><p>缺点在于其反转了逻辑，要能够依据帧号找页号（建立联系），同时在用页号查找时就相对困难。</p><ul><li>对逻辑地址进行哈希，随后就可以在页寄存器反向建立的查找表（通过哈希的方法建立）中进行小范围查找。</li><li>这里还可以引入快表。尽管快表功耗大</li><li>如果有冲突需要遍历冲突项。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816212919.png" alt="image-20210816212919724" style="zoom:40%;" /><p>反置页表是在页寄存器的基础上引入PID（进程标识）一同哈希，随后与反置页表中指定哈希值处对应验证，如果不一样就说明有冲突，继续遍历冲突项。如果PID和虚拟基址都相同，则找到了对应的页表。多余的开销来自于hash冲突。总体仍然是一个很好的思路。</p><h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><p>段式存储在做内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。</p><p>提出段页式因而是很自然的，通过这样的结合设计，既可以使用页式结构便利高效的内存利用，也可以使用段式的功能隔离、保护与共享。</p><p>段页式存储管理中的内存共享：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816212717.png" alt="image-20210816212717208" style="zoom: 50%;" /><h2 id="课后题知识点整理"><a href="#课后题知识点整理" class="headerlink" title="课后题知识点整理"></a>课后题知识点整理</h2><p>可有效应对大地址空间可采用的页表手段是(多级页表和反置页表)</p><p>描述段管理机制正确的是：</p><ul><li><ul><li>段的大小可以不一致</li><li>段可以有重叠(是因为共享的需求？)</li><li>段可以有特权级</li><li>段与段之间是可以不连续的</li></ul></li></ul><p>描述页管理机制正确的是：</p><ul><li><ul><li>页表在内存中</li><li>页可以是只读的</li><li>页可以有特权级（*）</li></ul></li></ul><p>页表项标志位包括：</p><ul><li><ul><li>存在位(resident bit)</li><li>修改位(dirty bit)</li><li>引用位(clock/reference bit)</li><li>只读位(read only OR read/write bit)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：连续内存分配（二）</title>
      <link href="2021/08/20/os/os%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>2021/08/20/os/os%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="连续物理内存分配综述"><a href="#连续物理内存分配综述" class="headerlink" title="连续物理内存分配综述"></a>连续物理内存分配综述</h1><p><strong>基本要求</strong>：一个进程需要一块存储时分配，完成工作后收回<br><strong>基本结构</strong>：首先分为物理存储和逻辑存储。</p><p><strong>物理存储</strong>可以从计算机体系结构的三个重要模块入手：CPU、内存和IO</p><p>我们可以将各个部分以存储为逻辑，做层次化的区分：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816163246.jpg" alt="img" style="zoom:50%;" /><p>大体的调用关系如下，首先要考虑最为快速的缓存，其存取速度与CPU主频相同。缓存的使用是我们所不能意识到的，因为其依靠硬件实现。但内存和外存是我们需要在操作系统当中操作的。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816163256.jpg" alt="img" style="zoom:50%;" /><p><strong>逻辑地址空间</strong>：物理地址如果交由计算机或许是可以方便使用的，但是对于人来说，并不容易记忆理解和使用。我们希望我们各个进程使用的存储都相对性地低耦合，有一个比较清晰的逻辑结构。把线性的物理地址编号转换为抽象的逻辑内存结构的计算机硬件是MMU（Memory Management Unit）</p><p><strong>内存管理的核心目的</strong>：抽象（逻辑地址空间）、保护（独立地址空间）、共享（访问相同内存）、虚拟化（更大的地址空间）</p><p><strong>实现方法</strong>：重定位（relocation）、分段（segmentation）、分页（paging）、虚拟存储（virtual memory）</p><h1 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h1><h2 id="地址空间的定义"><a href="#地址空间的定义" class="headerlink" title="地址空间的定义"></a>地址空间的定义</h2><p>物理空间地址：硬件支持的地址空间，起始地址为0，直到MAXsys<br>逻辑地址空间：在CPU运行的进程看到的地址，起始地址同样为0，直到MAXprog</p><h2 id="逻辑地址的生成"><a href="#逻辑地址的生成" class="headerlink" title="逻辑地址的生成"></a>逻辑地址的生成</h2><p><strong>主要步骤</strong>：编译、汇编、链接、重定位</p><h3 id="地址生成的时机和限制"><a href="#地址生成的时机和限制" class="headerlink" title="地址生成的时机和限制"></a>地址生成的时机和限制</h3><ul><li>如果<strong>起始地址已知</strong>，则地址在<strong>编译时生成</strong>，起始地址改变必须重新编译</li><li>编译时<strong>起始位置未知</strong>，编译器需要生成可重定位的代码，<strong>加载时生成</strong>绝对地址</li><li>也可以在<strong>执行时生成</strong>地址，执行时代码可移动，需地址转换硬件支持</li></ul><p>不同的系统里，这几种方法均有采用</p><h3 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h3><p>ALU（算术逻辑单元）所需要的地址是逻辑地址，但向内存中取用时，需要的是物理地址。</p><p>CPU中依靠MMU进行一次逻辑到物理地址的转换。虽然这是硬件完成的，但是操作系统提供两者之间的关系的描述（这是页表的功劳）</p><p>而后还要进行地址检查，防止超过段长度。加上段基址完成重定位即可。</p><h1 id="连续内存分配算法"><a href="#连续内存分配算法" class="headerlink" title="连续内存分配算法"></a>连续内存分配算法</h1><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><ul><li>连续内存分配：给进程分配一块不小于指定大小的连续物理内存区域。</li><li>内存碎片：不能被利用的空闲内存</li><li>外部碎片：分配单元之间的未被利用内存</li><li>内部碎片：分配单元内部的未被使用内存，取决于分配单元大小是否要取整</li></ul><h2 id="动态分配策略"><a href="#动态分配策略" class="headerlink" title="动态分配策略"></a>动态分配策略</h2><p><strong>最先分配策略</strong>：（first-fit）</p><ul><li>空闲分区列表按地址大小排序，直接选用第一个够用的分区。</li><li><strong>优点</strong>：简单，且高地址处会有大块的分区</li><li><strong>缺点</strong>：是会产生外碎片，且分配大块时需要搜索较长时间</li></ul><p><strong>最优分配策略</strong>（best-fit）：</p><ul><li><strong>申请</strong>：空闲分区列表从小到大排序，搜索一个比它大但最小的分区，分区利用率最高</li><li><strong>释放</strong>：释放时要在空闲分区中查找相邻空闲分区，较慢</li><li><strong>外碎片</strong>：避免大分区拆分，减小外碎片大小，简单，但同时外碎片难以利用</li></ul><p><strong>最差分配策略</strong>：</p><ul><li>与最优策略对应，空闲分区由大到小排。找一个能容纳它的最大空闲分区（即从头开始搜索时找到的第一个大于它的空闲分区）</li><li><strong>优点</strong>：中等大小分配较多时效果较好，避免出现太多的小碎片</li><li><strong>缺点</strong>：释放空间较慢；大分区被破坏掉，而后难以分配较大的空间</li></ul><h2 id="碎片整理算法"><a href="#碎片整理算法" class="headerlink" title="碎片整理算法"></a>碎片整理算法</h2><p>通过调整进程占用的分区位置来减少或者避免分区碎片</p><p><strong>紧凑</strong>：</p><ul><li><strong>定义</strong>：通过<strong>移动</strong>分配给进程的内存分区，以合并外部碎片</li><li><strong>条件</strong>：所有的应用可以动态重定位</li><li><strong>问题</strong>：进程等待时移动。开销</li></ul><p><strong>分区对换</strong>：</p><ul><li><strong>定义</strong>：通过抢占并回收处于等待状态进程的分区，从而增大可用内存空间。</li><li>类似windows的虚拟内存机制，相等于将一部分外存用作内存，.swp文件就来源于分区对换（swapping）</li><li>早期多进程实现方式</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816165458.jpg" alt="img" style="zoom:50%;" /><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p>伙伴系统（buddy system）就是采用二分的思路进行占用率相对较高的分配。</p><p><strong>分配时</strong>：</p><ul><li>所有可分配的空闲分区大小都为2的幂</li><li>如果整个可分配分区的大小为$2^k$，且需要分配的分区大小$2^{k-1} \leq s \leq 2^k$​，那么就将这个分区整个分配。如果不够继续二分，递归至超过50%利用率。</li></ul><p><strong>释放时</strong>：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816170551.jpg" alt="img" style="zoom:80%;" /><p>合并时注意，两段内存可以合并的条件是，它们两个对应的节点在二叉树中的父节点相同。(即合并条件的最后一条)</p><p><strong>分配释放示例如下</strong>：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210816170647.jpg" alt="img" style="zoom:80%;" /><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><ul><li>在启动页机制的情况下，在CPU运行的用户进程访问的地址空间是(逻辑地址空间)</li><li>在使能分页机制的情况下，不会产生外碎片</li><li>操作系统中可采用的内存管理方式包括重定位(relocation)、分段(segmentation)、分页(paging)、段页式（segmentation+paging）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os_lab1:系统软件启动过程</title>
      <link href="2021/08/20/os/lab1-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>2021/08/20/os/lab1-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程主页：<a href="https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title">https://www.xuetangx.com/course/THU08091000267/5883104?channel=i.area.learn_title</a><br>实验指导书：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a><br>github：<a href="https://github.com/chyyuu/ucore_os_lab">https://github.com/chyyuu/ucore_os_lab</a> (master 分支)</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><code>make/gdb</code> 使用、磁盘 <code>MBR</code> 格式规范、BIOS 执行流程、bootloader 执行流程、<code>ELF</code> 文件格式、函数调用底层过程、中断处理流程。</p><h2 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h2><p>此练习用于了解编译 <code>ucore</code> 源代码为镜像文件 <code>ucore.img</code> 的整体流程。</p><blockquote><p>因为我不是很懂 <code>Makefile</code>，因此我会尽可能地避免介绍 <code>Makefile</code> 内部相关指令含义。</p></blockquote><p>在命令行目录 <code>labcodes_answer/lab1_result</code> 中，依次输入命令 <code>make clean,make &quot;V=&quot;</code>，即可得到详细的编译过程 (已删除若干冗余输出结果)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译 .c 得到 .o 文件。着重说明几个重要参数：-ggdb 用于生成 gdb 调试信息、-nostdinc 不使用标准头文件、-Ixxx 使用指定位置 xxx 处的头文件。</span></span><br><span class="line">+ cc kern/init/init.c</span><br><span class="line">gcc -Ikern/init/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">gcc -Ikern/libs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/<span class="built_in">trap</span>/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line">...</span><br><span class="line">gcc -Ilibs/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line">+ ld bin/kernel</span><br><span class="line"><span class="comment"># 链接上述 .o 文件得到 kernel 可执行文件。着重说明几个重要参数：-m elf_i386 仿真 elf_i386 机器的链接器功能、-nostdlib 不使用标准库、-T xxx 使用特定链接脚本 xxx (其中主要指定各段的起始地址，设定代码段应当位于 0x100000 处) 进行链接。</span></span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/<span class="built_in">trap</span>/trap.o obj/kern/<span class="built_in">trap</span>/vectors.o obj/kern/<span class="built_in">trap</span>/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br><span class="line"><span class="comment"># 编译 .S 或 .c 得到 .o。</span></span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">gcc -Iboot/ -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line"><span class="comment"># 编译得到 sign 可执行文件，其用于判断并规格化主引导扇区(如果满足容量限制的话)。</span></span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line"><span class="comment"># 链接 bootblock.o 和 bootasm 得到 bootblock 可执行文件。着重说明几个重要参数：-m elf_i386 仿真 elf_i386 机器的链接器功能、-nostdlib 不使用标准库、-N 指定代码段和数据段可读写、-e 指定入口点、-Ttext 指定代码段的起始地址</span></span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line"><span class="comment"># 此两句输出结果表明，bootblock.out 所占容量为 500 bytes，并以此为基础，成功构建规格化的主引导扇区 (就是将 512 字节的最后两个字节设为 0x55AA，此两个字节的存在表明当前扇区为规格化的主引导扇区)。</span></span><br><span class="line"><span class="string">&#x27;obj/bootblock.out&#x27;</span> size: 500 bytes</span><br><span class="line">build 512 bytes boot sector: <span class="string">&#x27;bin/bootblock&#x27;</span> success!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建空的 ucore.img 镜像文件，并将 bootblock 和 kernel 放置其中。</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">10000+0 records <span class="keyword">in</span></span><br><span class="line">10000+0 records out</span><br><span class="line">5120000 bytes (5.1 MB, 4.9 MiB) copied, 0.0307689 s, 166 MB/s</span><br><span class="line"><span class="comment"># 放置 bootblock 至 ucore.img 的第一个扇区</span></span><br><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes copied, 0.000149858 s, 3.4 MB/s</span><br><span class="line"><span class="comment"># 放置 kernel 至 ucore.img 的第二个扇区。</span></span><br><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br><span class="line">146+1 records <span class="keyword">in</span></span><br><span class="line">146+1 records out</span><br><span class="line">74868 bytes (75 kB, 73 KiB) copied, 0.000415369 s, 180 MB/s</span><br></pre></td></tr></table></figure><blockquote><p>可详见 <code>os_kernel_lab/labcodes_answer/lab1_result/tools/sign.c</code> 以查看其功能。</p><p><code>ucore</code> 源代码中的 <code>bootblock</code> 也是常说的 <code>bootloader</code>。</p><p><code>ucore</code> 的 <code>MBR</code> 十分简单，含 <code>bootloader</code> 而不含磁盘分区表信息。</p></blockquote><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p>此练习用于了解计算机启动至 <code>bootblock</code> 开始执行期间的指令执行顺序。</p><blockquote><p>对于 intel 以往机器而言，地址线 20 位 (物理寻址空间 2^20 = 1M)，而寄存器仅 16 位。为实现访问全部的地址空间，另设若干段寄存器 (例如 CS 表示代码段寄存器)，其中存放段基址。此时实际物理地址 = (段基址 &lt;&lt; 4 + IP)。鉴于此种地址访问方式直接访问物理地址，因此其称为 <strong>实模式</strong>。</p><p>为兼容以往机器，intel x86 机器启动后，首先进入 <strong>实模式</strong>，并寻址第一条指令 <code>CS:IP = 0xf000:0xfff0 =&gt; 0xffff0</code> 以执行 BIOS 指令。</p></blockquote><p>为了解此执行顺序，需要进行单步调试。</p><p>首先查看 <code>labcodes/lab1/Makefile</code> 中的 <code>debug</code> 部分指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(QEMU) 执行 QEMU 模拟器、-S 启动 QEMU 而不启动 CPU，等待 monitor (其用于与 QEMU 通信，以执行暂停、运行模拟器等工作) 输入 &#x27;c&#x27; 后才启动 CPU 以进行模拟、-s 等待 gdb 远程连接、-D 指定日志存放位置、-monitor 重定向 monitor 至 stdio、 -hda 指定硬盘镜像文件</span></span><br><span class="line">$(V)$(TERMINAL) -e <span class="string">&quot;<span class="subst">$(QEMU)</span> -S -s -d in_asm -D <span class="subst">$(BINDIR)</span>/q.log -monitor stdio -hda $&lt; -serial null&quot;</span></span><br><span class="line">$(V)sleep 2</span><br><span class="line"><span class="comment"># 启动 gdb 调试，并使用 lab1init 进行初始化。</span></span><br><span class="line">$(V)$(TERMINAL) -e <span class="string">&quot;gdb -q -x tools/gdbinit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据上述的 debug 部分指令可知，此时仅启动 QEMU 而尚未启动 CPU，因此其位于 BIOS 尚未执行的状态。</span></span><br></pre></td></tr></table></figure><p>其中 <code>gdbinit</code> 内容如下 (相较于源代码，此部分已经修改)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 kernel 的调试信息(暂时没用)</span></span><br><span class="line">file bin/kernel</span><br><span class="line"><span class="comment"># 设置当前所模拟机器的指令架构</span></span><br><span class="line"><span class="built_in">set</span> architecture i8086</span><br><span class="line"><span class="comment"># 远程连接 QEMU</span></span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb无法正确获取当前qemu执行的汇编指令，通过如下配置可以在每次gdb命令行前强制反汇编当前的指令</span></span><br><span class="line">define hook-stop</span><br><span class="line">x/i <span class="variable">$pc</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在命令行目录 <code>labcodes/lab1</code> 中，输入命令 <code>make debug</code>，开始进行调试。</p><p>查看 CS：IP 取值及此处指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CS:IP 取值与上述相同。</span></span><br><span class="line">(gdb) p/x <span class="variable">$cs</span></span><br><span class="line"><span class="variable">$2</span> = 0xf000</span><br><span class="line">(gdb) p/x <span class="variable">$eip</span></span><br><span class="line"><span class="variable">$3</span> = 0xfff0</span><br><span class="line"><span class="comment"># 此处指令为一跳转指令，用于跳转至实际的 BIOS 指令 (如此设计，仍是兼容以往机器的缘故)。</span></span><br><span class="line">(gdb) x /i 0xffff0</span><br><span class="line">   0xffff0:     ljmp   <span class="variable">$0x3630</span>,<span class="variable">$0xf000e05b</span></span><br><span class="line"><span class="comment"># 大佬解释说，$0x3630 为 QEMU 版本问题，可以忽略。</span></span><br><span class="line"><span class="comment"># ljmp $0xf000e05b =&gt; 设置 CS:IP=0xf000:0xe05b，并跳转至此位置执行 BIOS 代码。</span></span><br></pre></td></tr></table></figure><blockquote><p>简要叙述 BIOS 功能：</p><ul><li>提供基本的输入输出功能 (例如，机器启动进入 BIOS 界面后，允许输入键盘信息并输出信息至显示屏)。</li><li>硬件自检 (检查与机器启动密切相关的硬件是否正常，如果不正常则直接启动失败，否则才允许继续启动)</li><li>加载 <code>bootloader</code> (BIOS 允许从指定磁盘启动，那么它便会加载指定磁盘的 0 号扇区，即 <code>MBR</code> ，至 <code>0x0:0x7C00</code> 处，并设置 <code>CS:IP</code> 为此值，从而执行 <code>bootloader</code> 指令)。</li></ul></blockquote><p>输入如下指令，以设置断点并运行机器至断点指令处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure><p>查看断点处指令，可得 (其与 <code>bootasm.S</code> 文件中 <code>start</code> 处指令相同，即执行的是此处指令，相关原因可见上述的 <code>make &quot;V=&quot;</code> 输出结果)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p&#x2F;x $pc</span><br><span class="line">$4 &#x3D; 0x7c00</span><br><span class="line">(gdb) x &#x2F;5i $pc</span><br><span class="line">&#x3D;&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br><span class="line">   0x7c02:      xor    %eax,%eax</span><br><span class="line">   0x7c04:      mov    %eax,%ds</span><br><span class="line">   0x7c06:      mov    %eax,%es</span><br></pre></td></tr></table></figure><h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p>此练习用于了解 <code>bootasm.S</code> 代码所做的工作。</p><p><code>bootasm.S</code> 是 <code>bootloader</code> 的一部分，其主要完成三件事：1. 开启 A20；2. 初始化 GDT 表；3. 开启保护模式。</p><blockquote><p>对于 intel x86 机器而言，其地址线 32 位 (物理寻址空间 2^32 = 4G)，普通寄存器 32 位，段寄存器仍为 16 位 (兼容以往机器)。为访问全部的地址空间且基于分段提供保护功能，段寄存器此时存放 GPT 索引表位置及相关保护位，其中 GPT 表项存放段初始位置 (32 位)、段长、访问权限等信息，此时实际物理地址 = (段索引表示的段初始位置 + IP)。鉴于此种地址访问方式间接访问物理地址，因此其称为 <strong>保护模式</strong>。(在我看来，分段机制基本没用，不如使用分页机制，而且现今 intel 采用扁平模式已经略过分段机制了)</p></blockquote><p><code>bootasm.S</code> 的具体实现，详见源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;asm.h&gt;</span><br><span class="line"></span><br><span class="line"># 注：Intel x86 中的段选择器，也称为段选择子。</span><br><span class="line"># 段选择子仍存在一定规则，高 13 位表示其在 gdt 中的索引位，低 3 位为保护信息。</span><br><span class="line">.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,             0x1                     # protected mode enable flag</span><br><span class="line"></span><br><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line"># bootloader 所做的第一件事：使能 A20 地址线，如此便可访问 4G 物理地址空间 (仍是兼容以往机器的缘故)。</span><br><span class="line"># 使能 A20 地址线比较复杂，涉及较多底层硬件，简单来说：禁中断、等待 Input Buffer 为空、输入写命令、等待 Input Buffer 为空、输入置位命令。</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    # 禁中断</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">    # Enable A20:</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al     # 从64端口读取数据              # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al    # 读到的数据是2则input buffer 为空</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line"># 至此，完成使能 A20 操作。</span><br><span class="line">    </span><br><span class="line">    # 加载 gdtdesc 所表示的值至 gdtr 寄存器。 </span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    # cr0 控制寄存器的部分作用在于控制处理器的工作模式，通过设置相关位，以开启保护模式。</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # 跳转至 protcseg，执行相关指令 (因为目前基于分段机制，因此汇编码需要设置段选择子和段内偏移，注意：实模式和保护模式的段寄存器含义不同)。</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # 设置 cs 以外的段寄存器取值为 $PROT_MODE_DSEG，即均设置为数据段选择子的取值。</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # 如此设置各个段寄存器的值后 (这些值应当都不会再发生变化了)，编译器中的逻辑地址 &#x3D;&gt; 隐式转换为同等的线性地址 &#x3D;&gt; 再做它处。</span><br><span class="line"></span><br><span class="line">    # 设置栈顶指针 esp 和 栈顶指针所示栈帧底部的指针 ebp (esp 指向栈空间底部，此时并不存在栈帧，因此 ebp 没有含义，将其设为 0，以此作为到达栈底的条件判断)，并调用 bootmain 函数 (因此栈空间为 0 ~ start&#x2F;0x7c00)。</span><br><span class="line">    # 注意：栈空间的使用是不会覆盖即将执行的其他指令的，原因有二：1. 上述已执行了众多指令，这部分指令空间是可以被直接覆盖的；2. bootmain 中函数调用所需的栈空间并不多，并且加载完 OS 后，便会跳转至 0x100000 处执行。</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    # 调用此函数，其为 bootloader 的另一部分，主要完成加载 OS 工作。</span><br><span class="line">    call bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn&#39;t), loop.</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                          # force 4 byte alignment</span><br><span class="line"># 对于 gdt 中的段描述符而言，其含有 64 位，不同部位表示特定的含义，此处使用定义于 &lt;asm.h&gt; 中的宏填充表项 </span><br><span class="line"># 对于 gdt 的段描述符组织结构而言，第一项应当为空，其余随便，在此处第二三项分别与代码段和数据段相关。</span><br><span class="line">gdt:</span><br><span class="line">    # 全 0。</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    # 代码段具有读、执行权限，段基址 &#x3D; 0，段界限 &#x3D; 4G，即扁平化处理，以隐藏分段机制。</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    # 数据段具有读、写执行权限，段基址 &#x3D; 0，段界限 &#x3D; 4G，即扁平化处理，以隐藏分段机制。</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br><span class="line"># 对于 gptr 寄存器而言，其高 32 位为 gdt 所在地址 (对应 .long gdt)，低 16 位为段界限 (对应 .word 0x17)</span><br><span class="line">gdtdesc:</span><br><span class="line">    # 根据 gdt 具体结构可知，其含有 3 个段，因此段界限为 3 * 8 - 1 &#x3D; 23 &#x3D; 0x17</span><br><span class="line">    .word 0x17                                      # sizeof(gdt) - 1</span><br><span class="line">    .long gdt                                       # address gdt</span><br></pre></td></tr></table></figure><blockquote><p>对于现有的操作系统而言，<code>Bootloader</code> 的实现代码往往很多，MBR 内部根本无法容纳全部的 <code>Bootloader</code>。因此，其实现往往是这样的：MBR 内部的 <code>Bootloader</code> 代码用于定位、加载、运行另外一处位置的代码，而该部分代码为 Boot Loader 的实际实现代码。该部分代码通常包含一些通用的文件系统驱动程序，从而保证可以加载 OS。</p></blockquote><h2 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h2><p>此练习用于了解 <code>bootmain.c</code> 代码所做的工作。</p><p><code>bootmain.c</code> 是 <code>bootloader</code> 的另一部分，其主要完成 OS 的加载。</p><p><code>bootmain.c</code> 的具体实现，详见源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定扇区大小、ELFHDR 加载位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE        512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR          ((struct elfhdr *)0x10000)      <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前磁盘尚未准备好，则一直循环等待。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处采用最常见的磁盘读取方式(等待磁盘准备好、发送读命令、等待磁盘准备好，读取数据)。</span></span><br><span class="line"><span class="comment">//等待磁盘直到其不忙；</span></span><br><span class="line"><span class="comment">//往0x1F2到0X1F6中设置读取扇区需要的参数，包括读取扇区的数量以及LBA参数；</span></span><br><span class="line"><span class="comment">//往0x1F7端口发送读命令0X20；</span></span><br><span class="line"><span class="comment">//等待磁盘完成读取操作；</span></span><br><span class="line"><span class="comment">//从数据端口0X1F0读取出数据到指定内存中；</span></span><br><span class="line"><span class="comment">//注：如何直接操纵磁盘以读取扇区，属于硬件相关，简单了解即可。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">waitdisk(); <span class="comment">// 等待磁盘到不忙为止</span></span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);             <span class="comment">// 往0X1F2地址中写入要读取的扇区数，由于此处需要读一个扇区，因此参数为1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>); <span class="comment">// 输入LBA参数的0...7位；</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>); <span class="comment">// 输入LBA参数的8-15位；</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>); <span class="comment">// 输入LBA参数的16-23位；</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>); <span class="comment">// 输入LBA参数的24-27位（对应到0-3位），第四位为0表示从主盘读取，其余位被强制置为1；</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// 向磁盘发出读命令0x20</span></span><br><span class="line"></span><br><span class="line">    waitdisk(); <span class="comment">// 等待磁盘直到不忙</span></span><br><span class="line"></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>); <span class="comment">// 从数据端口0x1F0读取数据至dst，除以4是因为此处是以4个字节为单位的，这个从指令是以l(long)结尾这点可以推测出来；  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是对readsect函数的进一步封装（从 kernel offset 偏移处读取 count 字节至 va 处）。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 磁盘数据以扇区为单位，如果 offset 位于扇区内部，那么在读到offset偏移处的数居前还读取了长度为offset的无用数据，我们便需要重新设置 va，以保证 offset 偏移处的数据位于原先 va 处。</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 kernel 开始于扇区 1，因此此处需要加一，以计算所读数据的开始扇区。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次循环，以读取扇区数据。</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取磁盘指定位置的数据(可以看到，总共需要读取 8 个扇区，可能是为确保 ELF 头部全部被读至内存)至 (uintptr_t)ELFHDR (0x10000)。</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该文件是否为 ELF 文件</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ELF 文件中的 program header 表 (其中存放程序执行直接相关的目标文件结构信息，用于定位各段)，随后加载各段至指定位置。</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        <span class="comment">// 此处会将各段加载至相应的虚拟地址中，该虚拟地址由 kernel.ld 链接脚本设定。查看该文件，可知：代码段位于 0x100000 处。</span></span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用入口函数，无需返回（从ELF header中查询到OS kernel的入口地址，然后使用函数调用的方式跳转到该地址上去）</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bad 这部分没什么用。</span></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h2><p>此练习需要了解函数调用过程的底层原理，并基于此实现 <code>print_stackframe()</code> 函数。</p><p>函数调用过程时栈的组织结构可简化为下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+|  栈底方向        | 高位地址</span><br><span class="line"> |    ...          |</span><br><span class="line"> |    ...          |</span><br><span class="line"> |  参数3           |</span><br><span class="line"> |  参数2           |</span><br><span class="line"> |  参数1           |</span><br><span class="line"> |  返回地址         |</span><br><span class="line"> |  上一层[ebp]     | &lt;-------- [ebp]</span><br><span class="line"> |  局部变量        |  低位地址</span><br></pre></td></tr></table></figure><p>基于寄存器 <code>ebp</code> 取值，我们可以很容易地得到如下内容：当前函数的参数、当前函数的返回地址、父函数的 <code>ebp</code> 取值。基于父函数的 <code>ebp</code> 取值，我们可以递归得到祖先函数的相关信息。</p><p>基于上述知识，可以很容易实现 <code>print_stackframe()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 此二者函数借助于汇编代码以获取寄存器 ebp/eip 取值。</span></span><br><span class="line">     <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">     <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">     <span class="comment">// 正如 bootasm.S 中看到的，最初 ebp 取值为 0，因此可借于此判断是否到达栈底。</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 此时的ebp是当前栈帧的ebp寄存器中的值，此时的eip是当前函数中所调用函数的调用指令的下一条指令的地址（即所调用函数的返回地址）</span></span><br><span class="line">         cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x &quot;</span>, ebp, ra);</span><br><span class="line">         <span class="keyword">uint32_t</span>* args = (<span class="keyword">uint32_t</span> *) (ebp + <span class="number">8</span>);</span><br><span class="line">         cprintf(<span class="string">&quot;args:0x%08x 0x%08x 0x%08x 0x%08x\n&quot;</span>, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>], args[<span class="number">3</span>]);</span><br><span class="line">         <span class="comment">// 借助于调试信息以获取其所在函数的位置信息。参数为eip-1的目的是指向这个call指令（eip-1表示的地址落在call指令占的地址范围）</span></span><br><span class="line">         print_debuginfo(eip - <span class="number">1</span>);  </span><br><span class="line">         <span class="comment">// 更新 eip 和 ebp。</span></span><br><span class="line">         eip = ((<span class="keyword">uint32_t</span>*)ebp)[<span class="number">1</span>];</span><br><span class="line">         ebp = ((<span class="keyword">uint32_t</span>*)ebp)[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析最后一行输出各个数值的意义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ebp:0x00007bf8 eip:0x00007d6e args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br><span class="line">    &lt;unknow&gt;: -- 0x00007d6d --</span><br></pre></td></tr></table></figure><p>根据上述打印栈帧信息的过程，可以推测出打印出的ebp是第一个被调用函数的栈帧的base pointer，eip是在该栈帧对应函数中调用下一个栈帧对应函数的指令的下一条指令的地址，而args是传递给这第一个被调用的函数的参数</p><p>为了验证这个想法，不妨在反汇编出来的kernel.asm和bootblock.asm中寻找0x7d6e这个地址，可以发现这个地址上的指令恰好是bootmain函数中调用OS kernel入口函数的指令的下一条，也就是说最后一行打印出来的是bootmain这个函数对应的栈帧信息，其中ebp表示该栈帧的base pointer，eip表示在该函数内调用栈上的下一个函数指令的返回地址，而后面的args则表示传递给bootmain函数的参数，但是由于bootmain函数不需要任何参数，因此这些打印出来的数值并没有太大的意义，后面的<code>unkonw</code>之后的<code>0x00007d6d</code>则是bootmain函数内调用OS kernel入口函数的该指令的地址;</p><p>关于其他每行输出中各个数值的意义为：ebp, eip等这一行数值意义与上述一致，下一行的输出调试信息，在*.c之后的数字表示当前所在函数进一步调用其他函数的语句在源代码文件中的行号，而后面的+22一类数值表示从该函数汇编代码的入口处到进一步调用其他函数的call指令的最后一个字节的偏移量，以字节为单位；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ebp:<span class="number">0x00007b38</span> eip:<span class="number">0x00100a28</span> args:<span class="number">0x00010094</span> <span class="number">0x00010094</span> <span class="number">0x00007b68</span> <span class="number">0x0010007f</span></span><br><span class="line">    kern/debug/kdebug.<span class="built_in">c</span>:<span class="number">306</span>: print_stackframe+<span class="number">22</span></span><br></pre></td></tr></table></figure><h2 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h2><p>此练习需要了解中断向量表及中断处理流程，从而实现中断初始化函数 <code>idt_init()</code> 及 <code>trap_dispatch()</code> 中的时钟中断处理。</p><p>首先简单介绍 <code>labcodes/lab1/kern/init/init.c</code> 文件内 <code>kern_init()</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kern_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> edata[], end[];</span><br><span class="line">    <span class="built_in">memset</span>(edata, <span class="number">0</span>, end - edata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化控制台 (硬件相关，暂时忽略)。</span></span><br><span class="line">    cons_init();               </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;(THU.CST) os is loading ...&quot;</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;%s\n\n&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 OS 相关信息。</span></span><br><span class="line">    print_kerninfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终会调用 print_stackframe() 函数，可以忽略。</span></span><br><span class="line">    grade_backtrace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化物理内存(重点关注)</span></span><br><span class="line">    pmm_init();                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化中断控制器(涉及硬件底层，可以忽略) </span></span><br><span class="line">    pic_init();  </span><br><span class="line">    <span class="comment">// 初始化中断描述符表(重点关注)</span></span><br><span class="line">    idt_init();                 </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时钟 (硬件相关，暂时忽略)</span></span><br><span class="line">    clock_init();              </span><br><span class="line">    <span class="comment">// 使能中断</span></span><br><span class="line">    intr_enable();             </span><br><span class="line"></span><br><span class="line">    <span class="comment">// lab1 challenge</span></span><br><span class="line">    <span class="comment">// lab1_switch_test();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>labcodes/lab1/kern/mm/pmm.c</code> 中查看 <code>pmm_init()</code> 的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pmm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> <span class="title">ts</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *  global segment number </span></span><br><span class="line"><span class="comment"> *  #define SEG_KTEXT   1</span></span><br><span class="line"><span class="comment"> *  #define SEG_KDATA   2</span></span><br><span class="line"><span class="comment"> *  #define SEG_UTEXT   3</span></span><br><span class="line"><span class="comment"> *  #define SEG_UDATA   4</span></span><br><span class="line"><span class="comment"> *  #define SEG_TSS     5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  global descrptor numbers </span></span><br><span class="line"><span class="comment"> *  #define GD_KTEXT    ((SEG_KTEXT) &lt;&lt; 3)      // kernel text</span></span><br><span class="line"><span class="comment"> *  #define GD_KDATA    ((SEG_KDATA) &lt;&lt; 3)      // kernel data</span></span><br><span class="line"><span class="comment"> *  #define GD_UTEXT    ((SEG_UTEXT) &lt;&lt; 3)      // user text</span></span><br><span class="line"><span class="comment"> *  #define GD_UDATA    ((SEG_UDATA) &lt;&lt; 3)      // user data</span></span><br><span class="line"><span class="comment"> *  #define GD_TSS      ((SEG_TSS) &lt;&lt; 3)        // task segment selector</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  #define DPL_KERNEL  (0)</span></span><br><span class="line"><span class="comment"> *  #define DPL_USER    (3)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  #define KERNEL_CS   ((GD_KTEXT) | DPL_KERNEL)</span></span><br><span class="line"><span class="comment"> *  #define KERNEL_DS   ((GD_KDATA) | DPL_KERNEL)</span></span><br><span class="line"><span class="comment"> *  #define USER_CS     ((GD_UTEXT) | DPL_USER)</span></span><br><span class="line"><span class="comment"> *  #define USER_DS     ((GD_UDATA) | DPL_USER)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GDT 中，内核段和用户段基本相同，均细分为代码段和数据段，均采用扁平模式，唯一不同点在于权限不同。</span></span><br><span class="line"><span class="comment">// TSS 是一种比较特殊的段，只要记住：其中的 SS0/ESP0 分别用于存放内核栈的栈段和 ESP 值。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]    = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gdtr 寄存器的具体结构。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uint32_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lgdt</span><span class="params">(struct pseudodesc *pd)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lgdt (%0)&quot;</span> :: <span class="string">&quot;r&quot;</span> (pd))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%gs&quot;</span> :: <span class="string">&quot;a&quot;</span> (USER_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%fs&quot;</span> :: <span class="string">&quot;a&quot;</span> (USER_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%es&quot;</span> :: <span class="string">&quot;a&quot;</span> (KERNEL_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%ds&quot;</span> :: <span class="string">&quot;a&quot;</span> (KERNEL_DS))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movw %%ax, %%ss&quot;</span> :: <span class="string">&quot;a&quot;</span> (KERNEL_DS))</span></span>;</span><br><span class="line">    <span class="comment">// reload cs</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;ljmp %0, $1f\n 1:\n&quot;</span> :: <span class="string">&quot;i&quot;</span> (KERNEL_CS))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* temporary kernel stack */</span></span><br><span class="line"><span class="keyword">uint8_t</span> stack0[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gdt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 TSS 内部的 ss0/esp0。</span></span><br><span class="line">    ts.ts_esp0 = (<span class="keyword">uint32_t</span>)&amp;stack0 + <span class="keyword">sizeof</span>(stack0);</span><br><span class="line">    ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GDT 中的 TSS 段描述符。</span></span><br><span class="line">    gdt[SEG_TSS] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line">    gdt[SEG_TSS].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 gdtr 和 tr 寄存器，并重新初始化各种段寄存器。</span></span><br><span class="line">    lgdt(&amp;gdt_pd);</span><br><span class="line">    ltr(GD_TSS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmm_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重新规划 GDT。</span></span><br><span class="line">    gdt_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>labcodes/lab1/kern/trap/trap.c</code> 中查看 <code>idt_init()</code> 的具体实现 (相较于源代码，此部分已经修改)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idt 数组，即中断描述符表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">idt</span>[256] =</span> &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idtr 寄存器的具体结构。</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">idt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)idt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个 中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 该变量存放 vector.S 中各 vectori 函数的地址，这些函数为相应中断号对应的中断处理程序。</span></span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">     <span class="comment">// 循环填充 idt 表。</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 对于 SETGATE 而言，其参数含义分别为：某个中断描述符、当前中断是否为 trap、对应中断处理程序的段选择子、所对应中断处理程序的段内偏移、使用该中断所需的权限等级</span></span><br><span class="line">         <span class="comment">// 就目前而言，对于大多数终端而言，其非 trap、段选择子为 GD_KTEXT/KERNEL_CS，段内偏移为 __vectors[i]、所需权限为 DPL_KERNEL。</span></span><br><span class="line">         SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL)</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// T_SWITCH_TOK 比较特殊，它供用户使用，以切换至内核。</span></span><br><span class="line">     SETGATE(idt[T_SWITCH_TOK], <span class="number">1</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 加载 idt 寄存器。</span></span><br><span class="line">     lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析代码，我们可以得到中断处理流程：</p><p>CPU 接收中断号 i</p><p> –&gt; 调用 idt[i] 进行处理，跳转到相应的中断中断处理入口，并在桟中压入相应的 error_code（是否存在与异常号相关） 以及 trap_no</p><p> –&gt; 调用 <code>__alltraps()</code> 进行处理（在栈中保存当前被打断程序的 trapframe 结构，设置相应的寄存器）</p><p> –&gt; 调用 <code>trap()</code> 进行处理</p><p> –&gt; 调用 <code>trap_dispatch()</code> 进行处理 </p><p>–&gt; 依据中断号，执行相应功能，并返回。</p><p>在 <code>trap_dispatch()</code> 内部，针对时钟中断进行如下处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向 屏幕上打印一行文字”100 ticks”。</span></span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print_ticks();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><blockquote><p>对于机器而言，部分硬件的中断号是固定的，部分硬件的中断号是动态分配的，此处的时钟中断号便是固定的。</p></blockquote><h2 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h2><p>该练习需要理解 intel 机器处理中断的具体流程，从而实现用户空间与内核空间的自主切换。</p><p>首先简要说明 intel 的硬件处理机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 每执行完一条指令，CPU 都会判断是否存在待处理的中断，如果存在，则先行获取中断号。</span><br><span class="line">- 如果中断号所示的中断描述符权限 DPL &gt;&#x3D; CPL，则表明当前权限高于该中断的允许使用权限，故而可执行此次中断，否则为非法。</span><br><span class="line">- 如果中断号所示的段选择子的段描述符权限 DPL &lt; CPL, 则表明当前权限低于对应中断处理程序所需的权限，因此存在特权级转换。</span><br><span class="line">    - 如果存在特权级转换，则 CPU 会获取 TSS 中的 ss0&#x2F;esp0，并将其设置给相应的寄存器，同时压入当前进程的 ss&#x2F;esp 至内核栈（这是一个新的栈）。  +++++</span><br><span class="line">    - CPU 保存 cs&#x2F;eip&#x2F;eflags 等寄存器至内核栈。  +++++</span><br><span class="line">    - CPU 保存设置该中断号对应的中断处理程序的 cs&#x2F;eip 至相应寄存器，从而开始执行中断处理程序。  +++++</span><br><span class="line">    - 中断处理程序首先保存 ds&#x2F;es&#x2F;fs&#x2F;gs&#x2F;各种通用寄存器至内核栈 (如果中断处理程序不会使用它们，则可不保存)，然后真正执行中断处理程序。  ----- </span><br><span class="line">    - 中断处理程序即将完成时，其会自动恢复上述保存的各种寄存器。  ----- </span><br><span class="line">- CPU 执行 iret 指令，内核栈中弹出 cs&#x2F;eip&#x2F;eflags 等寄存器。  +++++</span><br><span class="line">- 如果存在特权级转换，则 CPU 保存当前 ss&#x2F;esp 至 TSS，然后从内核栈中弹出 ss&#x2F;esp。  +++++ </span><br><span class="line"># +++++ 表示由硬件自动完成，---- 表示由软件完成。</span><br></pre></td></tr></table></figure><p>其次，我们简单看看源代码与上述机制间的联系：</p><ul><li><p><code>__alltraps</code> 的具体实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # 压入相关段寄存器和通用寄存器值(实际上，这些寄存器也并非会用到，只是为保证能够在栈上构建 struct trapframe)</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # 根据上述硬件处理机制描述，硬件已经自动设置 ss&#x2F;cs 等段寄存器了。 </span><br><span class="line">    # 设置相应数据段寄存器。</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # 压入 esp 值，等价于向 trap 传递参数。</span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    # call trap(tf), where tf&#x3D;%esp</span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line">    # pop the pushed stack pointer(即取出之前压入的esp值)</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    # 相关操作处理完成后的恢复操作</span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    popal</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    # 返回中断</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure></li><li><p><code>trap()</code> 的具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    trap_dispatch(tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>struct trapframe/pushregs</code> 的具体结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察 __alltraps 的压栈顺序，可以发现：此结构与其顺序相同（重要）。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_oesp;          <span class="comment">/* Useless */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_eax;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>接下来，我们准备实现该练习。</p><p>在 <code>labcodes/lab1/kern/init/init.c</code> 中，主函数调用 <code>lab1_switch_test()</code> 以测试功能实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_user</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为当前便是内核空间，因此调用中断不会引发特权级转换，而返回时由于切换到用户空间，发生了特权级转换，所以需要弹出 ss/esp，故而需要预留 8 字节空间。</span></span><br><span class="line">    <span class="comment">// 因为需要切换至用户空间，直接调用相关中断即可。（内联汇编格式可自行查阅相关资料）</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;movl %%ebp, %%esp&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 之所以需要这条代码，原因在于：由于当前函数均为汇编代码，编译得到的汇编代码少了 `movl %%ebp, %%esp` 这么一句，如果不显式补上这句，可能出问题。</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 具体详见：https://piazza.com/class/i5j09fnsl7k5x0?cid=1468</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : </span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_kernel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为需要切换至内核空间，直接调用相关中断即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">&quot;movl %%ebp, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// 之所以需要这条代码，原因同上。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : </span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_test</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于汇编获取相关寄存器值，并将其显示于屏幕上。</span></span><br><span class="line">    lab1_print_cur_status();</span><br><span class="line">    cprintf(<span class="string">&quot;+++ switch to  user  mode +++\n&quot;</span>);</span><br><span class="line">    lab1_switch_to_user();</span><br><span class="line">    lab1_print_cur_status();</span><br><span class="line">    cprintf(<span class="string">&quot;+++ switch to kernel mode +++\n&quot;</span>);</span><br><span class="line">    lab1_switch_to_kernel();</span><br><span class="line">    lab1_print_cur_status();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>labcodes/lab1/kern/trap/trap.c</code> 中，实现 <code>T_SWITCH_TOU</code> 和 <code>T_SWITCH_TOK</code> 的中断处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">        <span class="comment">// 切换为用户空间，只需修改相关段寄存器即可。</span></span><br><span class="line">        tf-&gt;tf_cs = USER_CS;</span><br><span class="line">        tf-&gt;tf_ds = USER_DS;</span><br><span class="line">        tf-&gt;tf_es = USER_DS;</span><br><span class="line">        tf-&gt;tf_ss = USER_DS;</span><br><span class="line">        <span class="comment">// 需要开启 IO 权限，才能实现输出。</span></span><br><span class="line">        tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">        tf-&gt;tf_ds = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        <span class="comment">// 根据上述硬件处理机制，ss 设置由硬件自动实现。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h2><p>因为 intel 的特权级概念十分重要 (借助于此，可实现部分的保护机制)，因此在此简单介绍一番。</p><p>对于 intel 而言，特权级分为四个等级，使用 2 bit 进行表示，具体如图所示。实际之中，往往仅使用等级 0 (用于内核使用) 和等级 3 (用于用户使用)。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210820155144.jpg" alt="img" style="zoom: 33%;" /><p>特权级具体表现在各种段寄存器、段描述符、门描述符之内，使用 <code>CPL/RPL/DPL</code> 进行表示，简要如图所示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210820211937.png" alt="img" style="zoom:80%;" /><p>对于代码段/栈段选择子而言，其中 CPL （存在于CS，SS寄存器）表示当前代码/进程所处的特权级；而 RPL（存在于DS，ES，FS，GS寄存器）说明的是进程对段访问的请求权限，是对于段选择子而言的，基于此可以提供更为细致的保护机制（RPL对每个段来说是不固定的，两次访问同一段时的RPL可以不同，RPL会削弱CPL的作用，例如当前CPL=0的进程要访问i一个数据段，段选择子的RPL设为3，这样它对该段就只有特权级3的访问权限）；对于各种描述符而言，其中 DPL（存在于段描述符，门描述符） 表示访问此部分内容所需的权限。</p><p>现在，基于上述知识，简单说明 intel 提供的保护机制。</p><ul><li>如果当前进程欲访问某数据段，则硬件判断 <code>Max(CPL,RPL) &lt;= 数据段的 DPL</code>，如果满足此等式，则允许执行此指令，否则存在权限冲突，直接报错。</li><li>如果当前进程欲访问某系统服务，则硬件判断 <code>CPL &lt;= 门描述符的 DPL</code>，如果满足此等式，则允许访问系统服务，否则表示不允许。另外，如果满足 <code>CPL &gt; 门描述符的段选择子对应的段描述符的 DPL</code> ，则表明存在特权级转换。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：启动、中断、异常和系统调用（一）</title>
      <link href="2021/08/20/os/os%EF%BC%9A%E5%90%AF%E5%8A%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>2021/08/20/os/os%EF%BC%9A%E5%90%AF%E5%8A%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统的启动过程"><a href="#计算机系统的启动过程" class="headerlink" title="计算机系统的启动过程"></a>计算机系统的启动过程</h2><p>CPU在加电之后，执行的第一条指令在<strong>内存</strong>中。</p><p>但是我们说过，停电之后，内存中的DRAM会丢失全部数据。所以CPU是如何启动的呢？</p><p>本节参考：</p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/tyong/articles/10141205.html">BIOS固件-电脑开机的启动流程 - tyong - 博客园www.cnblogs.com/tyong/articles/10141205.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814214155.jpg" alt="img"></p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>内存中一部分存储是ROM，启动程序的代码存在ROM中。<br>计算机加电之后，首先<strong>读取</strong>（或许因此叫基本输入输出系统Basic IO System）并运行这部分程序。这部分程序叫<strong>BIOS启动固件</strong>，是一种固化到主板上的重要系统程序。</p><p><strong>BIOS启动固件</strong></p><ul><li>有20位地址信息，共1MB</li><li>两个重要的寄存器CS:IP：加电稳定之后从0xf000:fff0（cs*16+ip）处读取第一条跳转指令。</li></ul><blockquote><p> 更详细内容可参考<a href="https://zhuanlan.zhihu.com/p/258863021">0704：CS和IP</a></p></blockquote><ul><li>系统处于实模式</li><li>内容包括基本输入输出的程序、<strong>系统配置信息**</strong>、开机<strong>自检程序</strong>（POST）、<strong>系统自启动程序</strong></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814213853.jpg" alt="img" style="zoom:50%;" /><p>BIOS首先检查内存、显卡等启动必须的重要部件。如果硬件出现问题通过蜂鸣器报错并停止启动。称为<strong>硬件自检</strong>（Power-On Self-Test）</p><p>查找并执行显卡等接口卡BIOS，进行<strong>设备初始化</strong>；执行系统BIOS，进行<strong>系统检测</strong>（即插即用设备）；更新CMOS中的扩展配置数据（ESCD）</p><p>完成自检之后，BIOS把控制权交给下一阶段的启动程序，这时，BIOS需要知道，“下一阶段的启动程序”存放在那哪一个设备，也即BIOS需要一个外部存储设备的排序，谁排在前，谁将优先被转交控制权。这种排序叫做“<strong>启动顺序</strong>”（Boot Sequence）</p><p><strong>关于BIOS的系统调用</strong> BIOS以中断调用的方式提供了基本的IO功能：</p><ul><li>INT 10h：字符显示</li><li>INT 13h：磁盘删去读写</li><li>INT 15h：检测内存大小</li><li>INT 16h：键盘输入</li></ul><p>只能在x86的实模式下访问</p><h3 id="主引导记录"><a href="#主引导记录" class="headerlink" title="主引导记录"></a>主引导记录</h3><p>BIOS按照启动顺序，将控制权转交给排在第一位的存储设备。然后从所选引导设备的硬盘驱动器加载前 512 个字节——这 512 个字节就是通常所说的 MBR—主引导记录。结构如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814214130.jpg" alt="img" style="zoom:67%;" /><p>主引导记录由三个部分组成： </p><ul><li>第1-446字节：调用操作系统的机器码。</li><li>第447-510字节：分区表（Partition table）。 </li><li>第511-512字节：主引导记录签名（0x55和0xAA）。</li></ul><p>如果这512个字节的最后两个字节是0x55和0xAA（主引导记录签名），表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权转交给启动顺序中的下一个设备。</p><h4 id="引导代码（Bootstrap-Code）"><a href="#引导代码（Bootstrap-Code）" class="headerlink" title="引导代码（Bootstrap Code）"></a>引导代码（Bootstrap Code）</h4><p>引导代码的目的是从磁盘中查找另一个文件并加载它，以执行实际的引导过程。因此，这个引导代码通常被称为“第一阶段引导加载程序”。“第一阶段引导加载程序”会指向“第二阶段引导加载程序”，根据操作系统不同，“第二阶段引导加载程序”的确切位置不同。</p><p>但在 Windows 上，“第一阶段引导加载程序”将在 MBR 的分区表中搜索标记为<strong>“活动”的分区</strong>，这个活动分区的开头在其起始扇区（也称为“引导扇区”）中包含引导代码的下一部分。在正确创建的 MBR 磁盘上，一次只能将一个分区标记为活动分区。</p><h4 id="（硬盘）分区表（DPT）"><a href="#（硬盘）分区表（DPT）" class="headerlink" title="（硬盘）分区表（DPT）"></a>（硬盘）分区表（DPT）</h4><p>“分区表”的作用，是将硬盘分成若干个区，硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。每个主分区的16个字节，由6个部分组成：</p><ul><li>1：如果为0x80，则为激活分区，控制权要转交给这个分区，</li><li>2-4：主分区第一个扇区的物理位置</li><li>5：主分区类型</li><li>6-8：主分区最后一个扇区的物理位置</li><li>9-12：主分区第一个扇区的逻辑地址</li><li>13-16：扇区总数（决定了主分区的长度不超过 $2^32$ )</li></ul><h4 id="引导签名"><a href="#引导签名" class="headerlink" title="引导签名"></a>引导签名</h4><p>在 IBM 兼容的 PC（基本上就是所有的电脑）上，512 字节 MBR 的最后两个字节称为 引导签名，BIOS 使用它们来确定所选的引导驱动器（就是MBR所在的这个启动设备/启动盘/驱动器 0）是否实际可引导。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权转交给启动顺序中的下一个设备。</p><h3 id="分区引导扇区（The-Partition-Boot-Sector）："><a href="#分区引导扇区（The-Partition-Boot-Sector）：" class="headerlink" title="分区引导扇区（The Partition Boot Sector）："></a>分区引导扇区（The Partition Boot Sector）：</h3><p>MBR 中的引导程序代码通常会从活动分区的开头加载一个字节序列。分区的确切布局取决于创建或格式化分区的文件系统，但通常看起来像这样</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814214141.jpg" alt="img" style="zoom:67%;" /><p>通过分区引导扇区，我们可以知道引导加载程度的位置并且在之后执行它。</p><blockquote><p>除了BIOS-MBR之外，另外的启动规范有BIOS-GPT、PXE，以及最终的<strong>统一标准UEFI</strong></p></blockquote><h3 id="引导加载程序（bootloader）"><a href="#引导加载程序（bootloader）" class="headerlink" title="引导加载程序（bootloader）"></a>引导加载程序（bootloader）</h3><p>磁盘上的实际引导加载程序文件构成引导加载过程的最后部分。当人们谈论引导加载程序和引导文件时，他们通常指的是引导过程的最后一个关键步骤。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814215338.jpg" alt="img" style="zoom:80%;" /><blockquote><p>引导加载程序序列:</p><ul><li>PC 的控制权从 BIOS 移交给 MBR 中的引导程序代码，</li><li>然后从 MBR 移交给分区引导扇区中的引导程序代码，</li><li>最后从那里移交给活动分区上的可执行引导文件，实际逻辑涉及确定要加载哪个操作系统、从哪里加载它、传递给它的参数/选项以及完成可能可用的与用户的任何交互，启动操作系统的实际过程就开始了。</li></ul></blockquote><h2 id="中断、异常和系统调用"><a href="#中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>内核是被信任的第三方，只有内核才可以执行特权指令（比如Win中的Admin，Linux中的root、sudo）。</p><p>CPU执行操作系统代码时，CPU处于内核态（又称管态），2.2介绍的三种机制都是在内核态下运行的</p><p><strong>安全-功能权衡</strong>：既要隔离kernel保障安全，又要让<strong>用户态</strong>的应用程序得到系统服务：</p><ul><li><strong>中断</strong>：处理<strong>外设回调</strong>类的事件，比如键盘按键，负责有序提供服务</li><li><strong>异常</strong>：防止应用程序处理<strong>意外情况</strong>，保证内核安全</li><li><strong>系统调用</strong>：系统调用和功能调用（函数接口）</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>正规的定义如下：</p><ul><li><strong>系统调用</strong>（system call）：应用程序<strong>主动</strong>向操作系统发出的服务请求</li><li><strong>异常</strong>（exception）：非法指令或者其他原因导致当前<strong>指令执行失败</strong></li><li><strong>中断</strong>（hardware interrupt）：来自硬件<strong>外设</strong>的处理请求</li></ul><p>在下图中对应关系：</p><ul><li>中断：外设发送信号，设备驱动双向处理数据</li><li>异常：中断向量表→异常服务例程→程序处理（也可能导致中止；另外也可能是因为内核运行出错）</li><li>调用：系统调用接口，函数库（功能调用接口）</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814215608.jpg" alt="img" style="zoom:80%;" /><h3 id="三种机制的对比"><a href="#三种机制的对比" class="headerlink" title="三种机制的对比"></a>三种机制的对比</h3><p>源头：</p><ul><li>中断：外设</li><li>异常：应用程序意想不到的行为</li><li>系统调用：应用程序请求提供服务</li></ul><p>响应方式：</p><ul><li>中断：异步</li><li>异常：同步</li><li>系统调用：异步或同步</li></ul><p>处理机制：</p><ul><li>中断：持续，对用户态不可见</li><li>异常：kill或re-execute意外指令</li><li>系统调用：等待或持续</li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><blockquote><p>在操作系统中，有三种特殊的中断事件。由CPU外部设备引起的外部事件如I/O中断、时钟中断、控制台中断等是异步产生的（即产生的时刻不确定），与CPU的执行无关，我们称之为异步中断(asynchronous interrupt)也称外部中断,简称中断(interrupt)。而把在CPU执行指令期间检测到不正常的或非法的条件(如除零错、地址访问越界)所引起的内部事件称作同步中断(synchronous interrupt)，也称内部中断，简称异常(exception)。把在程序中使用请求系统服务的系统调用而引发的事件，称作陷入中断(trap interrupt)，也称软中断(soft interrupt)，系统调用(system call)简称trap。</p></blockquote><p>硬件处理：在CPU初始化时设置中断使能标志</p><ul><li>依据内部或外部事件设置中断标志（比如键盘就对应着一个阵列通断对应的高低电平）</li><li>依据中断向量调用相应中断服务例程（相当于是一个回调机制）</li></ul><p>软件处理：</p><ul><li><strong>现场保存</strong>（编译器）</li><li><strong>中断服务处理</strong>（服务例程）</li><li><strong>清除中断标记</strong>（服务例程）</li><li><strong>现场恢复</strong>（编译器）</li></ul><p>硬件中断服务例程可以被打断</p><ul><li>不同硬件中断源可能在<strong>中断处理时</strong>出现</li><li>硬件中断服务例程中需要临时禁止中断请求</li><li>中断请求会会保持到CPU做出响应</li></ul><p>异常服务例程可以被硬件中断打断<br>异常服务例程可以嵌套，出现<strong>缺页</strong>（可以发生在用户态）</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>下图是系统调用的模式图，从中可以看出系统调用的一个基本点，即内核态与用户态的隔离。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210814215656.jpg" alt="img"></p><p><strong>背景</strong>：应用程序一般无法直接访问硬件，也无法执行特权指令。所以，需要通过操作系统来间接完成相关的工作。而基于安全和可靠性的需求，应用程序运行在用户态，操作系统内核运行在内核态，导致应用程序无法通过函数调用来访问操作系统提供的各种服务，于是通过系统调用的方式就成了应用程序向OS发出请求并获得服务反馈的唯一通道和接口。</p><p><strong>定义</strong>：</p><ul><li>操作系统服务的编程接口</li><li>通常由高级语言编写</li><li>程序访问通常是通过高层次的<strong>API接口</strong>（函数调用），而不是直接进行系统调用。</li></ul><p>三种最常访问的API：</p><ul><li>Win32 API</li><li>POSIX API用于POSIX-based systems（类UNIX，包括Linux和MacOS X的所有版本）</li><li>Java API用于Java虚拟机（JVM）</li></ul><p><strong>实现</strong>：</p><ul><li>每个系统调用对应一个系统调用编号：来维护<strong>系统调用表</strong>的索引</li><li>调用内核态中的<strong>系统调用功能</strong>实现，并返回系统调用的<strong>状态和结果</strong></li><li><strong>黑盒性</strong>，用户不需要知道系统调用的实现</li></ul><h3 id="系统调用与函数调用的不同"><a href="#系统调用与函数调用的不同" class="headerlink" title="系统调用与函数调用的不同"></a>系统调用与函数调用的不同</h3><ul><li>INT和IRET用于系统调用：堆栈切换和特权级转换</li><li>CALL和RET用于常规调用（<strong>不用堆栈切换</strong>）</li></ul><h3 id="系统调用的开销"><a href="#系统调用的开销" class="headerlink" title="系统调用的开销"></a>系统调用的开销</h3><p>超过函数调用的原因是系统调用的：</p><ul><li>引导机制</li><li>内核堆栈</li><li>验证参数</li><li>映射到用户态的地址空间</li><li>内核态独立地址空间：TLB</li></ul><h2 id="一些测试题"><a href="#一些测试题" class="headerlink" title="一些测试题"></a>一些测试题</h2><ul><li>（2012统考）中断处理和子程序调用都需要压栈以保护现场。中断处理一定会保存而子程序调用不需要保存其内容的是<strong>程序状态字寄存器</strong>。程序状态字（PSW）寄存器用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息，主要作用是实现程序状态的保护和恢复。所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。</li><li>中断向量地址是<strong>中断服务例程入口</strong>的地址</li><li>即便是管理员用户的程序，也运行在<strong>用户态</strong>，不能执行特权指令</li><li>(西北工业大学)CPU执行操作系统代码的时候称为处理机处于内核态（又称管态）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 清华os课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp虚拟内存：显式分配器（九）</title>
      <link href="2021/08/12/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>2021/08/12/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>对应于书中的9.9。</p><hr><ul><li>虚拟页的存在是作为虚拟内存和物理内存传输数据块的单位，是由一系列连续的虚拟内存地址组成的，并且这些虚拟地址的特点由虚拟页定义。而虚拟内存段是将一系列大量的连续的具有相似特点的虚拟地址聚集起来，且虚拟内存段也描述了这些虚拟地址的一些特点，并且这些虚拟地址以虚拟页为单位进行组织，即虚拟内存段包含虚拟页。<br>我们使用虚拟内存时是以虚拟地址为单位的，只是根据我们对其使用方式的不同要求和权限，会处于不同虚拟段中的不同虚拟页中。</li><li>当调用<code>malloc</code>函数来分配块时，首先会在空闲链表中寻找是否有合适的空闲块，如果尝试了合并空闲块还是没找到，则会调用<code>sbrk</code>函数来向内核申请更大的堆内存。所以在一开始将堆与匿名文件映射时，堆内存为0，则第一次调用<code>malloc</code>函数时，会直接调用<code>sbrk</code>函数来申请得到一块大的空闲块，该空闲块可能会比你尝试分配的块大，然后就一直在这个堆中进行操作。</li><li>堆的起始地址到<code>brk</code>之间是已申请的堆内存，可以在里面进行动态内存分配，而<code>brk</code>之外的是未申请的堆内存，只有当找不到合适的空闲块时，才会向内核申请更大的可用空间，此时就会移动<code>brk</code>。</li></ul><hr><p>除了上一章介绍的通过<code>mmap</code>函数能让用户自定义内存映射，将磁盘文件映射到虚拟内存中以外，也可以在运行时使用<strong>动态内存分配器（Dynamic Memory Allocator）</strong>来分配额外的虚拟内存。动态内存分配器维护着虚拟内存中的堆段，将堆视为一组不同大小的块的集合，每个块由若干个连续的虚拟地址构成（一个块不一定处在同一个虚拟页），每个块具有<strong>两种状态：</strong></p><ul><li><strong>已分配：</strong>已分配的块能为应用程序所用，且块会保持已分配状态直到被释放</li><li><strong>空闲的：</strong>空闲的块无法使用，直到它被分配</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110902.jpg" alt="img" style="zoom:80%;" /><p>而在最开始进行内存映射时，堆是与匿名文件关联起来的，所以堆是一个全0的段，即处于空闲状态，它紧跟在未初始的数据段后面，向地址更大的方向延伸，且内核对每个进程都维护了<code>brk</code>变量来指向堆顶。</p><p>动态内存分配器具有两种类型，都要求由应用程序显示分配块，但是由不同实体来负责释放已分配的块：</p><ul><li><strong>显示分配器（Explicit Allocator）：</strong>要求应用程序显示释放已分配的块。比如C中通过<code>malloc</code>来分配块，再通过<code>free</code>来显示释放已分配的块，C++中的<code>new</code>和<code>delete</code>相同。</li><li><strong>隐式分配器（Implicit Allocator）：</strong>由分配器检测哪些块已不被应用程序使用，就自动释放这些块。这种隐式分配器称为<strong>垃圾收集器（Garbage Collector）</strong>，而这种过程称为<strong>垃圾收集（Garbage Collection）</strong>。比如Java、ML和Lisp。</li></ul><p>程序使用动态内存分配器来动态分配内存的<strong>意义在于：</strong>有些数据结构只有在程序运行时才知道大小。通过这种方式就无需通过硬编码方式来指定数组大小，而是根据需要动态分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span>, i, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一章主要介绍管理堆内存的显示分配器。</p><hr><h2 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a><code>malloc</code>和<code>free</code>函数</h2><p>C中提供了malloc显示分配器，程序可以通过<code>malloc</code>函数来显示地从堆中分配块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; </span><br></pre></td></tr></table></figure><p>该函数会返回一个指向大小至少为<code>size</code>字节的未初始化内存块的指针，且根据程序的编译时选择的字长，来确定内存地址对齐的位数，比如<code>-m32</code>表示32位模式，地址与8对齐，<code>-m64</code>表示64位模式，地址与16对齐。如果函数出现错误，则返回NULL，并设置<code>errno</code>。我们也可以使用<code>calloc</code>函数来将分配的内存块初始化为0，也可以使用<code>realloc</code>函数来改变已分配块的大小。</p><p>程序可以通过<code>free</code>函数来释放已分配的堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>ptr</code>参数要指向通过<code>malloc</code>、<code>calloc</code>或<code>realloc</code>函数获得的堆内存。</p><p>动态内存分配器可以使用<code>mmap</code>和<code>munmap</code>函数，也可以使用<code>sbrk</code>函数来向内核申请堆内存空间，只有先申请获得堆内存空间后，才能尝试对块进行分配让应用程序使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line">`brk`函数会将`brk`设置为`addr`指定的值。`sbrk`函数通过`incr`来增加`brk`</span><br></pre></td></tr></table></figure><ul><li>当<code>incr</code>小于0时，会减小<code>brk</code>来解除已分配的堆内存</li><li>当<code>incr</code>等于0时，会返回当前的<code>brk</code>值</li><li>当<code>incr</code>大于0时，会增加<code>brk</code>来分配更多的堆内存</li></ul><p>当<code>sbrk</code>函数运行正常时，会返回之前的<code>brk</code>值，否则会返回-1并设置<code>errno</code>为<code>ENOMEM</code>。</p><p>当我们使用<code>malloc</code>函数申请较小的堆内存时，会通过<code>brk</code>或<code>sbrk</code>函数设置<code>brk</code>来实现。<code>brk</code>和<code>sbrk</code>函数分配的堆内存类似于缓冲池，每次<code>malloc</code>从缓冲池获得内存时，如果缓冲池大小不够，就会调用<code>brk</code>或<code>sbrk</code>函数来扩充缓冲池，然后从该缓冲池中获得对应的内存，而<code>free</code>函数就会将应用程序使用的内存空间归还缓冲池。</p><p><strong>通过<code>sbrk</code>和<code>brk</code>函数来针对小块内存的申请，会产生内存碎片问题。对于大块内存的申请，会直接使用<code>mmap</code>函数，直接将大段的虚拟地址空间与匿名文件关联起来，就不会有内存碎片问题</strong>。</p><p>在本章节中，以字为单位进行操作，每个字为4字节，并进行双字对齐（下图中，一格代表一字）。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812105756.jpg" alt="img"></p><p><strong>注意：</strong></p><ul><li>分配堆内存时，会进行地址对齐</li><li>释放内存后，其指针不会被删除，所以要谨慎被删除的指针的使用</li></ul><h2 id="显示分配器的要求和目标"><a href="#显示分配器的要求和目标" class="headerlink" title="显示分配器的要求和目标"></a>显示分配器的要求和目标</h2><p>显示分配器的<strong>要求</strong>有：</p><ul><li>只要满足每个释放请求都对应于一个由以前分配请求获得的已分配的块，则应用程序可以以任意顺序发送分配请求和释放请求。</li><li>分配器必须立即响应请求，不允许对请求进行重排列或缓存。</li><li>为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆内。</li><li>为了能保存任意类型的数据对象，分配必须对齐块。（比如讲解<code>struct</code>时，它根据对齐要求对起始虚拟地址是有要求的）</li><li>当块被分配了，分配器不允许对其进行修改或移动，因为已分配块属于应用程序了。</li></ul><p>显示分配器的<strong>目标</strong>为：吞吐率最大化和内存使用率最大化</p><ul><li><p>吞吐率是指每个单位时间内完成的请求数。一个分配请求的最差运行时间与空闲块的数量成线性关系（要一次搜索每个空闲块来确定是否适合），而一个释放请求的运行时间是常数，则我们可以通过最小化分配请求和释放请求的平均运行时间来最大化吞吐率，主要约束项在分配请求。</p></li><li><p>一个系统中所有进程分配的虚拟内存的全部数量是受磁盘上的交换空间限制的，所以要尽可能最大化内存使用率。首先，我们给定n个分配请求和释放请求的序列 $R_0,R_1,…,R_k,…,R_{n-1}$ ，然后定义以下概念：</p></li><li><ul><li><strong>有效载荷（Payload）：</strong>应用程序请求一个p字节的块，则该已分配的块的有效载荷为p字节。（分配器为了对齐要求和块的格式，可能会申请比p更大的块）</li><li><strong>聚集有效载荷（Aggregate Payload）</strong>P：当前已分配的块的有效载荷之和</li><li>然后我们可以通过<code>brk</code>变量来确定堆当前的大小 $H_k$ （假设是单调不递减的）<br>由此我们可以确定前k+1个请求的<strong>峰值利用率（Peak Utilization）</strong>$U_k = \frac{max_{i \leq k}P_i}{H_k}$ 。通过峰值利用率就能确定分配器使用堆的效率，并且对于任意的分配和释放序列，最大的 $P_i$ 是相同的。在理想状态下，每个块的内容都是有效载荷，所以利用率为1。</li></ul></li></ul><p>造成堆内存使用效率低下的主要原因是<strong>碎片（Fragmentation）</strong>现象，当空闲的内存不能满足分配请求时就会产生碎片，主要分为两种：</p><ul><li><strong>内部碎片（Internal Fragmentation）：</strong>当已分配的块比有效载荷大时，就会产生内部碎片。比如分配器为了满足对齐要求或保存块的数据结构，就会对分配块增加额外的内存空间。我们可以通过已分配块的大小与其有效载荷的差来量化内部碎片，则内部碎片的数量主要取决于之前请求的模式和分配器的实现方法。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110939.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>外部碎片（External Fragmentation）：</strong>当空闲的内存合起来够满足一个分配请求，但单独一个空闲内存不够时，就会产生外部碎片。外部碎片比较难进行量化，因为它主要取决于未来请求的模式，所以分配器通常试图维持少量的大的空闲块。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110948.jpg" alt="img" style="zoom:80%;" /><p>为了让分配器能平衡吞吐率和利用率，需要考虑以下几个<strong>问题：</strong></p><ul><li>如何记录堆中空闲的块？</li><li>如何选择一个合适的空闲块来放置一个新分配的块？</li><li>再将一个新分配的块放置在某个空闲块后，如何处理空闲块中剩余部分？</li><li>如何处理一个刚刚被释放的块？</li><li>当我们对一个指针调用<code>free</code>时，怎么知道要释放多少内存？</li></ul><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>对于堆内存中的块，我们可以将其定义为以下数据结构形式</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812110955.jpg" alt="img" style="zoom:80%;" /><p>则每个块由三部分构成：</p><ul><li><strong>头部：</strong>大小为一个字（一个字为4字节），可以用来保存块大小，如果我们添加一个双字的对齐要求，则块大小就总是8的倍数，则头部中表示块大小的低3位就总是0，我们可以拿这3位来表示该块是否被分配。（则一个块最大只能是 $2^{29}-1$字节)</li><li><strong>有效载荷：</strong>应用通过<code>malloc</code>请求的有效载荷</li><li><strong>填充：</strong>可选的，分配器可用来处理外部碎片，或满足对齐要求。</li></ul><p>我们通过块的这种数据结构来组织堆内存，则通过块头部的块大小来将堆中的所有块链接起来。分配器可以通过遍历所有块，然后通过块头部的字段来判断该块是否空闲的，来间接遍历整个空闲块集合。我们可以通过一个大小为0的已分配块来作为<strong>终止头部（Terminating Header）</strong>，来表示结束块。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812111253.png" alt="img"></p><blockquote><p>头部标记为（大小（字节）/已分配位）</p></blockquote><p><strong>注意：</strong>计算块大小时，要先将有效载荷加上块头部大小，然后再计算满足对齐要求时的块大小。</p><p>由于地址对齐要求和分配器对块格式的选择，会对<strong>最小块</strong>的大小有限制，没有已分配的块和空闲块比最小块还小，如果比最小块还小，就会变成外部碎片（所以最小块越大，内部碎片程度越高）。比如这里如果对齐要求是双字8字节的，则最小块大小为双字：第一个字用来保存头部，另一个字用来满足对齐要求。</p><h4 id="选择空闲块"><a href="#选择空闲块" class="headerlink" title="选择空闲块"></a>选择空闲块</h4><p>当应用请求一个k字节的空闲块时，分配器会搜索空闲链表，并根据不同的<strong>放置策略（Placement Policy）</strong>来确定使用的空闲块：</p><ul><li><p><strong>首次适配（First Fit）：</strong>分配器从头开始搜索空闲链表，选择第一个块大小大于k的空闲块。</p></li><li><ul><li><strong>优点：</strong>趋向于将大的空闲块保留在空闲链表后面。</li><li><strong>缺点：</strong>空闲链表开始部分会包含很多碎片</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812111626.jpg" alt="img" style="zoom:67%;" /><ul><li><p><strong>下一次适配（Next Fit）：</strong>分配器从上一次查询结束的地方开始进行搜索，选择第一个块大小大于k的空闲块。</p></li><li><ul><li><strong>优点：</strong>运行比首次适配块一些，可以跳过开头的碎片</li><li><strong>缺点：</strong>内存利用率比首次适配低很多</li></ul></li><li><p><strong>最佳适配（Best Fit）：</strong>分配器会查找所有空闲块，选择块大小大于k的最小空闲块。</p></li><li><ul><li><strong>优点：</strong>内存利用率比前两者都高一些</li><li><strong>缺点：</strong>需要遍历完整的空闲链表</li></ul></li></ul><p>如果分配器可以找到满足要求的空闲块，则需要<strong>确定如何使用这个空闲块：</strong></p><ul><li>如果空闲块与k大小相近，则可以直接使用这一整个空闲块</li><li>如果空闲块比k大很多，如果直接使用整个空闲块，则会造成很大的内部碎片，所以会尝试对该空闲块进行分割，一部分用来保存k字节数据，另一部分构成新的空闲块。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812111802.jpg" alt="img" style="zoom:80%;" /><p>如果分配器找不到满足要求的空闲块，则会首先尝试将物理上相邻的两个空闲块合并起来创建一个更大的空闲块，如果还是不满足要求，则分配器会调用<code>sbrk</code>函数来向内核申请额外的堆内存，然后将申请到的新空间当做是一个空闲块。</p><h4 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h4><p>当我们尝试释放分配块时，如果当前块与其他空闲块相邻，则会产生<strong>假碎片（Fault Fragmentation）</strong>现象，即许多可用的空闲块被分割为小的无法使用的空闲块，此时分配器就可以合并相邻空闲块来解决假碎片问题，具有以下策略：</p><ul><li><p><strong>立即合并（Immediate Coalescing）：</strong>当我们释放一个分配块时，就合并与其相邻的空闲块。</p></li><li><ul><li><strong>优点：</strong>可在常数时间内完成</li><li><strong>缺点：</strong>可能一个空闲块会被来回分割和合并，产生抖动</li></ul></li><li><p><strong>推迟合并（Deferred Coalescing）：</strong>当找不到合适的空闲块时，再扫描整个堆来合并所有空闲块。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112351.jpg" alt="img" style="zoom:80%;" /><p>为了高效合并前一个空闲块，需要使用<strong>边界标记（Boundary Tag）</strong>技术，使得当前块能迅速判断前一个块是否为空闲的</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112438.jpg" alt="img" style="zoom:80%;" /><p>在块的数据结构中，会添加一个块头部的副本到脚部。这样当前块从起始位置向前偏移一个字长度，就能得到前一个块的脚部，通过脚部就能判断前一个快是否为空闲的，并且也能得到前一个块的大小。且当前块通过自己头部的块大小就能得到下一个块的头部，由此来判断下一个块是否空闲，以及下一个块的大小。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112553.jpg" alt="img"></p><p>可以将所有情况分成以下几种：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112637.jpg" alt="img" style="zoom:80%;" /><ul><li>前一块和后一块都是分配的：此时不会发生合并操作。</li><li>前一块是已分配的，后一块是空闲的：当前块会将头部中的块大小设置为当前快的大小和下一块大小之和，并且修改下一块的脚部。</li><li>前一块是空闲的，下一块是已分配的：前一块会将头部中的块大小设置为自己的块大小和当前块大小之和，并且修改当前块的脚部。</li><li>前一块和当前快都是空闲的：前一块会将头部中的块大小设置为这三个块的大小之和，并修改下一块的脚部。</li></ul><p>该技术的缺点是会显著增加内存开销，由于引入了脚部，使得有效载荷大小变小，而使得内部碎片变多了，并且最小块的大小变大导致外部碎片也变多了。</p><p>我们可以对其进行优化，有些情况是不需要边界标记的，只有在合并时才需要脚部，而我们只会在空闲块上进行合并，所以在已分配的块上可以不需要脚部，那空闲块如何判断前一个块是否为已分配的呢？可以在自己的头部的3个位中用一个位来标记前一个块是否为空闲的，如果前一个块为已分配的，则无需关心前一个块的大小，因为不会进行合并；如果前一个块为空闲的，则前一个块自己就有脚部，说明了前一个块的大小，则可以顺利进行合并操作。</p><blockquote><p>通过合并操作，空闲块的两侧一定都是已分配的块。</p></blockquote><p><strong>隐式空闲链表的特点总结：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812112840.jpg" alt="img" style="zoom:80%;" /><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>由于隐式空闲列表的块分配耗费时间与堆块的总数呈线性关系，其对于通用的分配器是不适合的。</p><p>一种更好的方法是将空闲块组织成某种形式的显示数据结构。因为空闲块中除了头部和脚部以外都是没有被使用的，所以可以在空闲块中的其余部分引入其他信息，这里引入了一个指向前一个空闲块的<code>pred</code>指针，还有一个指向下一个空闲块的<code>succ</code>指针，由此就将空闲块组织成双向链表形式。 但是这种方法需要更大的空闲最小块，否则不够存放两个指针，这就提高了外部碎片的程度。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812151512.jpg" alt="img" style="zoom:80%;" /><p>对于已分配块，可以通过头部和脚部来得到地址相邻两个块的信息，而对于空闲块，可以通过头部和脚部来得到地址相邻两个块，也可以通过两个指针直接获得相邻的两个空闲块。<strong>注意：</strong>逻辑上看这两个空闲块是相邻的，但物理地址上不一定是相邻的，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812151627.jpg" alt="img"></p><p>分配器使用这种形式的块结构，可以将首次适配时间从块总数的线性时间降低为空闲块总数的线性时间（因为要依次遍历检索到满足要求的空闲块）。比如我们这里存在以下3个空闲块的双向链表，此时想要分配中间的空闲块，且对其进行分割</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812152357.jpg" alt="img" style="zoom:80%;" /><p>此时就会获得以下形式，因为已分配块可以根据指针来定位，所以不需要额外进行链接。而空闲块会从中分割出合适的部分用于分配，其余部分作为新的空闲块，此时只要更新对应的指针就行。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812152415.jpg" alt="img" style="zoom:80%;" /><p>而当我们想要释放已分配块时，它并不在空闲链表中，要将其放在空闲链表什么位置？我们对空闲链表的维护会影响释放已分配块的时间：</p><ul><li><strong>后进先出（LIFO）策略：</strong>将释放的已分配块放到空闲链表开始的地方，则只需要常数时间就能释放一个块。如果使用后进先出和首次适配策略，则分配器会先检索最近使用过的块。但是碎片化会比地址顺序策略严重。</li><li><strong>地址顺序策略：</strong>释放一个块需要遍历空闲链表，保证链表中每个空闲块的地址都小于它后继的地址。这种策略的首次适配会比后进先出的首次适配有更高的内存利用率。</li></ul><p>接下来以LIFO策略为例，说明在四种情况下如何进行空闲块合并：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153523.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况一：要释放的块前后都为已分配的块</center><p>我们可以通过后面块的头部以及前面块的脚部来得知相邻两个块的已分配状况（这就是保留头部和脚部的意义）。由于相邻的都是已分配的块，所以不会进行空闲块合并，直接更新Root的<code>succ</code>指针使其指向要释放的块，而让要释放的块的<code>pred</code>指向Root，<code>succ</code>指向原来第一个空闲块，然后更新原来的第一个空闲块的<code>pred</code>指针。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153514.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况一解决方案</center><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153504.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况二：要释放的块后面为空闲块，前面为已分配的块</center><p>要释放的块后面为空闲块，则需要将当前块和后一块进行合并。我们可以简单地修改头部和脚部直接将两个空闲块合并，但是后一块为空闲块，会处于空闲链表的某个位置，所以要修改后一块的前后两个空闲块的指针，使其跳过后一块。然后修改对应指针就行。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153455.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况二的解决方案</center><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153447.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况三：要释放的块前面为空闲块，后面为已分配的块</center><p>和情况二类似。如果不是LIFO策略，其实可以直接保留前一个块的指针。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153434.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况三的解决方案</center><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153425.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况四：当前块的前后两个块都为空闲块</center><p>情况四其实就是情况二和三的合并。对于前后两个空闲块，直接让其指针前后的两个空闲块修改指针跳过，然后修改头部和脚部进行合并</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153415.jpg" alt="img" style="zoom:80%;" /><center style="color:#C0C0C0;text-decoration:underline">情况四的解决方案</center><p><strong>显示链表特点总结：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153407.jpg" alt="img" style="zoom:80%;" /><h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><p>为了减少分配时间，可以使用<strong>分离存储（Segregrated Storage）</strong>方法，首先将所有空闲块根据块大小分成不同类别，称为<strong>大小类（Size Class）</strong>，比如可以根据2幂次分成</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153623.png" alt="img"></p><p>这样不同空闲块就落在不同的大小类中，然后对于每个大小类都生成自己独立的空闲链表，然后分配器根据大小类的大小，将对应的空闲链表按照升序保存在数组中。由此能极大加快分配速度。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210812153701.jpg" alt="img" style="zoom:80%;" /><p>当我们想要分配一个大小为n的块时，会首先根据空闲链表数组确定对应的大小类，找到合适的空闲链表，搜索是否有合适的空闲块，如果有，可以对其进行分割，则剩下的部分要放到合适合适的空闲链表中，如果没有合适的空闲块，则会找下一个更大的大小类，重复上述步骤。</p><p>如果遍历了所有大小类的空闲链表还是找不到合适的空闲块时，分配器就会向内核申请更大的堆内存空间，然后将作为一个空闲块放在最大的大小类的空闲链表中。</p><p>当我们想要释放一个块时，需要对其地址周围的空闲块进行合并，然后将其放在合适的大小类中。</p><p>分离的空闲链表是当前最好的分配器类型，对于吞吐量方面，由于将原来巨大的空闲链表根据大小类将其划分为很多小的空闲链表，使得在单一空闲链表中搜索速度快很多，对于内存利用率方面，由于大小类的存在，使得你正在搜索的空闲链表是最适合你想要分配的大小，在这里使用首次适配策略就能得到接近在整个空闲链表中使用最佳适配策略的性能。最极端的情况是为每个块都设置一个大小类，这样就等于最佳适配策略的性能了。</p><h4 id="简单分离存储"><a href="#简单分离存储" class="headerlink" title="简单分离存储"></a>简单分离存储</h4><p>简单分离存储具有以下<strong>特点：</strong></p><ul><li>每个大小类中都只包含大小相同的块，且块大小就是这个大小类中最大元素的大小。比如<code>&#123;5~8&#125;</code>就只包含大小为8的空闲块。</li><li>不执行分割</li><li>不执行合并</li></ul><p>当进行分配时，会根据块大小先找到对应的空闲链表，如果存在空闲块则直接分配第一个空闲块，如果不存在，则分配器向内核请求得到一个固定大小的虚拟内存片，然后将其划分为大小相同的空闲块，将其链接起来得到新的空闲链表。</p><p>当进行释放时，直接将其插入对应的空闲链表头部。</p><ul><li><strong>优点：</strong>分配和释放块都是常数时间，不分割，不合并，已分配块不需要头部和脚部，空闲链表只需是单向的，因此最小块为单字大小。</li><li><strong>缺点：</strong>由于使用分割和合并，所以会有大量的内部和外部碎片。</li></ul><h4 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配"></a>分离适配</h4><p>分离适配的分配器维护一个空闲链表的数组，每个链表和一个大小类相关联，包含大小不同的块。分配块时，确定请求的大小类，对适当的空闲链表做首次适配，如果找到合适的块，可以分割它，将剩余的部分插入适当的空闲链表中；如果没找到合适的块，查找更大的大小类的空闲链表。如果没有合适的块，就向内核请求额外的堆内存，从这堆内存中分割出合适的块，然后将剩余部分放到合适的大小类中。每释放一个块时，就进行合并，并将其放到合适的大小类中。</p><p>分离适配方法比较常见，如GNU malloc包。这种方法既快、利用率也高。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>伙伴系统（Buddy System）是分离适配的一种特例，要求每个大小类都是2的幂。假设一个堆大小为$2^m$​，为每个大小为 $2^k$ 的空闲块都维护了对应的空闲链表。最开始只有一个 $2^m$ 大小的空闲块：</p><ul><li><strong>请求分配时：</strong>找到第一个可用的大小为 $2^j$ 的空闲块，将其递归平均分割直到刚好能装下我们的数据。每次分割下来的另一部分为伙伴，被放在相应的空闲链表中。</li><li><strong>请求释放时：</strong>会不断合并空闲的伙伴，直到遇到一个已分配的伙伴就停止。</li></ul><p>我们可以通过地址和块大小很快计算出伙伴地址。主要优点在于快速搜索和快速合并，但是会造成大量的内部碎片。</p><h2 id="隐式分配器"><a href="#隐式分配器" class="headerlink" title="隐式分配器"></a>隐式分配器</h2><p>显示分配器要求应用程序显示地调用<code>free</code>函数来释放已分配块，比如以下代码中在<code>garbage</code>函数中调用了<code>malloc</code>函数来分配块，但是函数返回时并没进行释放，使得<code>p</code>指向的分配块始终保持已分配的状态，则分配器就无权对该分配块进行操作，由于<code>p</code>保存在函数<code>garbage</code>的栈帧中，当<code>garbage</code>返回时也丢失了<code>p</code>，所以这个已分配块就变成了垃圾，无法被使用，直到程序终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">garbage</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>而在隐式分配器中，分配器会释放程序不再使用的已分配块，自动对其调用<code>free</code>函数进行释放。则应用程序只需要显示分配自己需要的块，而回收过程由分配器自动完成。</p><p>隐式分配器也被称为垃圾收集器，关于垃圾收集器的相关知识可参考jvm的<a href="https://icbtbo.github.io/2021/06/04/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">这篇博文</a></p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp虚拟内存：系统（九）</title>
      <link href="2021/08/11/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>2021/08/11/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本章对应于书中的9.7-9.8。</p><hr><ul><li>有一系列保存在磁盘中的数据，首先以页为单位将其划分成很多数据块（虚拟页），然后根据每个数据块的特点（比如读写权限）进行组合，得到若干个由若干个数据块组成的段，通过任务结构对这些段进行描述，包括：段的起始虚拟地址、段的终止虚拟地址、段的读写权限等等，由此就确定了段中每个数据块所能用的虚拟地址范围以及读写权写。接下来根据这个约束，对每个数据块分配一个虚拟地址，然后分配一个指向数据块磁盘位置的指针，确定该数据块的读写权限，然后将所有数据块的信息组合起来，就得到了页表.</li></ul><blockquote><p>页表是描述每个数据块的，任务结构是描述由数据块组成的段，确定了页表的信息。</p></blockquote><ul><li>虚拟内存在磁盘的内容称为交换空间</li><li>对于私有对象，页设置为只读的，页所在的段设置为私有的写时复制的。则当尝试对页进行写操作时，会触发保护故障，然后根据私有的写时复制进行操作。</li><li>为了能维护自己的状态，需要将状态所在的段标记为私有写时复制的。当没有对其进行修改时，所有都共享相同的物理页，如果对其修改了，就会新建一个物理页，这样就能保证自己的状态不会被别的进程修改。</li><li>内存映射仅仅是将虚拟内存和磁盘文件对应起来，并没有拷贝到内存中，只是指定虚拟页的初始值。会按需自动加载虚拟页到物理页中。</li></ul><hr><h2 id="Intel-Core-i7-Linux内存系统"><a href="#Intel-Core-i7-Linux内存系统" class="headerlink" title="Intel Core i7/Linux内存系统"></a>Intel Core i7/Linux内存系统</h2><p>这里通过介绍运行Linux的Intel Core i7来总结虚拟内存的内容。</p><h3 id="Intel-Core-i7"><a href="#Intel-Core-i7" class="headerlink" title="Intel Core i7"></a>Intel Core i7</h3><p>现在的Core i7支持48位虚拟地址空间和52位物理地址空间，还兼容32位虚拟和物理地址空间。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811215252.jpg" alt="img" style="zoom:80%;" /><p>如上图所示是一个<strong>处理器封装（Processor Package）</strong>，其中有一组基于QuickPath技术的点对点链路，为了让一个核与其他核和外部I/O桥直接通信。</p><ul><li><strong>高速缓存：</strong>具有3层高速缓存层次结构，其中L3是所有核共享的高速缓存，其中数据块大小为64字节，所以高速缓存具有以下性质。其中，数据块为64字节，则需要6位的块偏移，L1 d-cache有64组，则需要6位的组索引，其余的为标志位。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811215320.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>页表：</strong>这里采用4级页表结构，页大小为4KB，说明需要12位的VPO，而虚拟地址为48位，所以VPN为36位，则每一级的VPN为9位。每个进程有自己私有的页表层次结构，并且存在CR3控制寄存器指向第一级页表的起始位置，其中CR3是每个进程上下文的一部分，每次进行上下文切换时，都会被恢复。页表的PTE格式如下所示</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811215333.jpg" alt="img" style="zoom:80%;" /><p>其中每个PTE为8字节，而每一级的VPN为9位，则每个PTE引用了一个$2^9*2^3 = 4KB$  的子页表，这里就要求物理页4KB对齐。由于物理地址为52位，PPO为12位，则PPN为40位，所以这里的页表物理基地址为40位。这里增加了3个权限位来控制对页的访问：<code>R/W</code>、<code>U/S</code>和<code>XD</code>，其中<code>XD</code>是64位系统引入的，限制了只能在只读代码段执行，降低了缓冲区溢出攻击的风险。此外，当MMU访问一个页时，会设置<strong>引用位（Reference Bit）</strong>A位，让内核实现页替换算法，当MMU修改一个页时，会设置**脏位（Dirty Bit)**D位，使得内核对牺牲页进行写回。以下是Core i7的页表翻译</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811215619.jpg" alt="img" style="zoom:80%;" /><ul><li><p><strong>TLB：</strong>这里TLB也采用层次结构，并且为数据和指令分别使用两个一级TLB。其中，L1 d-TLB有4路64个PTE，则一共有16个组，需要4位TLBI；L1 i-TLB有4路128个PTE，一共有32组，需要5位TLBI；L2 TLB有4路512个PTE，一共有128个组，需要7位TLBI。</p></li><li><ul><li>这里之所以使用L2 TLB而不是扩大L1 TLB，是因为如果舍弃L2 TLB而增大L1 TLB，仍然可能出现工作集大于缓存的情况，就会出现容量不命中，通过增加L2 TLB来减少不命中惩罚。</li></ul></li></ul><p>下面是Core i7地址翻译的整体架构（省略了i-cache、i-TLB和L2统一TLB）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811215639.jpg" alt="img" style="zoom:80%;" /><p>这里可以发现一个<strong>特点：</strong>高速缓存的CI+CO=12位，而VPO也是12位。这不是巧合，而是故意这样设计来加速地址翻译。我们知道，VPO=PPO，而PPN需要通过地址翻译获得，则一开始输入虚拟地址时，就能一下等到PPO，然后等待检索PPN。此时我们就能直接将PPO输入到高速缓存中，因为PPO确定了对应的高速缓存组和块偏移量，就能先通过PPO获得对应的高速缓存组，然后只要等检索到PPN时，就能直接和高速缓存组中每一行的标志位进行比较，极大加速了地址翻译过程。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811215653.jpg" alt="img"></p><h3 id="Linux虚拟内存系统"><a href="#Linux虚拟内存系统" class="headerlink" title="Linux虚拟内存系统"></a>Linux虚拟内存系统</h3><p>Linux为每个进程都维护了一个单独的虚拟地址空间，如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811220018.jpg" alt="img" style="zoom: 50%;" /><p>可以发现内核将一组连续的虚拟页（大小等于DRAM总量）映射到一组相应的连续物理页上，这样内核可以在这个虚拟内存上进行读写，实际上就是对物理内存进行读写，这为内核提供一种便利的方法来访问物理内存。这部分内容对所有进程都是一样的。</p><p>此外， 与进程相关的一些信息被保存在内核虚拟内存中，并且Linux将虚拟内存组织成段集合的形式，比如代码段、数据段、共享库段以及用户栈，这些段就是已分配的连续虚拟页。每个已分配的虚拟页都保存在某个段中。通过这种组织成段的形式，可以使得虚拟地址存在间隙。这是通过内核为系统中每个进程维护一个单独的<code>task_struct</code>实现的（在最上面那块中），该结构中包含或指向内核运行该进程所需的所有信息，其中有一条指向描述虚拟内存当前状态的结构<code>mm_struct</code>，其中包含的<code>pgd</code>就是指向一级页表的起始地址，当进程被调度时，就会将<code>pdg</code>条目拷贝到CR3中，通过这种形式来改变虚拟地址空间；<code>mmap</code>指向一个链表结构的头结点，其中每个节点<code>vm_area_struct</code>就描述了虚拟内存中的一个段，其中包含：</p><ul><li><code>vm_end</code>段结束的虚拟地址；</li><li><code>vm_start</code>段开始的虚拟地址；</li><li><code>vm_prot</code>段中所有页的读写权限；</li><li><code>vm_flags</code>描述当前段中的虚拟页是否与其他进程共享，如果是共享的，则称为<strong>共享段</strong>，否则称为<strong>私有段</strong>；</li><li><code>vm_next</code>下一个段的节点。</li></ul><p>由此，就能通过将输入虚拟地址与各个节点的起始地址和终止地址进行比较，判断虚拟地址所在的段。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811220040.jpg" alt="img" style="zoom:80%;" /><p>该任务结构的存在，使得缺页异常处理多了虚拟地址的判断。当MMU翻译虚拟地址A时，由于还未将对应的虚拟页缓存到物理页中，所以触发了缺页异常，随后执行缺页异常处理程序，包含以下步骤：</p><ul><li><strong>判断虚拟地址A是否合法：</strong>虚拟地址是否合法，主要看它是否存在某个段中。处理程序会将虚拟地址A与链表中的所有节点中的<code>vm_start</code>和<code>vm_end</code>进行比较，判断虚拟地址A所处的段，如果不存在任一段中，则会触发段错误，终止进程。</li><li><strong>判断对虚拟地址A的访问是否合法：</strong>当虚拟地址A处在某个段中时，可以通过<code>vm_prot</code>确定该段的读写许可，然后与我们所需要的操作进行对比，如果操作违背了许可，则会触发保护异常，终止进程，Linux也将其报告为段错误。</li><li>如果以上两个步骤都是合法的，则执行正常的缺页处理。处理程序会选择一个物理牺牲页，如果牺牲页被修改了，则进行写回，然后将虚拟地址A对应的虚拟页写入对应的物理页中，修改对应的页表，然后从处理程序返回。</li></ul><p><strong>注意：</strong></p><ul><li>缺页异常时才会检查虚拟地址是否合法</li><li>task_struct是比页表更大的结构，该task_struct是以段为单位来组织虚拟地址，其中包含了许多虚拟页，而页表是以虚拟页为单位来组织虚拟地址，所以需要先从task_struct开始。</li></ul><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>如果虚拟内存系统可以集成到传统的文件系统中，就能提供一种简单而高效的方法把程序和数据加载到内存中。这里通过<strong>内存映射（Memory Mapping）</strong>将一个虚拟内存段与一个磁盘上的<strong>对象（Object）</strong>关联起来，来初始化虚拟内存段的内容，所以当我们第一次引用某个段时，它的初始值来自于磁盘上的普通文件，然后通过按需页面调度，将需要的虚拟内存段加载到物理内存中。</p><blockquote><p>主要说明如何将虚拟内存段和磁盘内容关联起来。<br>每个段包含的虚拟页都和磁盘文件中的某些部分关联起来，并且虚拟页的初始内容都来自于磁盘文件。</p></blockquote><p>内存映射可以用两种磁盘上的对象来初始化虚拟内存段：</p><ul><li><strong>Linux文件系统中的普通文件：</strong>比如一个可执行目标文件，将其分成页大小的数据块，用来初始化对应的虚拟内存段，如果段比文件大，则用0来填充剩下的内容。然后按需将虚拟页复制到物理页中。</li><li><strong>匿名文件：</strong>内核可以创建大小任意的全是二进制0的匿名文件，该文件其实并不存在。当我们想要创建一个全为0的页，可以将虚拟页和匿名文件关联起来，当内核引用该虚拟页时，会直接覆盖牺牲页的内容，得到全为0的页，然后修改对应的页表内容。这个过程磁盘和内存之间没有实际的数据传送。</li></ul><blockquote><p>匿名文件主要用于创建全为0的页。</p></blockquote><p>这些与虚拟内存段关联的磁盘内容处于<strong>交换空间（Swap Space）</strong>中（即虚拟内存在磁盘空间上的内容就是在交换空间中，也就是说交换空间保存了映射到虚拟内存中的磁盘数据），则交换空间限制了当前运行着的进程能够分配的虚拟页总数（虚拟内存大小确定了，虚拟页大小也确定了，则页数目也就确定了）。</p><p>内存映射概念的存在，使得我们可以重新回去看共享对象和私有对象、<code>fork</code>函数和<code>execve</code>函数。</p><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>如上所述，虚拟内存段中通过<code>vm_prot</code>确定该虚拟内存段中的虚拟页是否在进程之间共享，如果共享，则称该段为<strong>共享段</strong>，则各个进程在该段中的操作是互相可见的，且变化也会反映在磁盘上；如果不共享，则称该段为<strong>私有段</strong>，则各个进程在该段中的操作是互相不可见的，也不会反映到磁盘上。</p><p>如下图所示，在进程1中，当我们将磁盘上的一个对象映射到它的虚拟内存的一个区域，就会使得虚拟页对应的PTE指向该对象，当引用该对象时，就会将对应的虚拟页加载到物理页中；而进程2也要将该对象与自己的一个共享段关联起来时，当对其引用时，由于每个对象都有一个唯一的文件名，所以内核可以发现进程1已经将该对象加载到物理页，就直接在进程2中将对应的PTE指向相同的物理页就行了。</p><p><strong>注意：</strong></p><ul><li>进程1和进程2 的虚拟地址空间是不同的</li><li>即使一个对象与多个进程的共享段关联，物理内存中始终只有该对象的一个副本。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811221129.jpg" alt="img" style="zoom:80%;" /><h3 id="私有对象"><a href="#私有对象" class="headerlink" title="私有对象"></a>私有对象</h3><p>如下图所示，在进程1中，当我们将磁盘上的一个对象映到该进程的一个私有段时，就会使得虚拟页对应的PTE指向该对象，当引用该对象时，就会将对应的虚拟页加载到物理页中；当进程2也要将该对象与自己的一个私有段关联起来时，当对其引用时，也会直接在进程2中将对应的PTE指向相同的物理页，即当未对私有对象进行修改时，物理内存中只会保存同一个对象副本，且各个进程中对该对象的PTE都是只读的，而虚拟内存段被标记为<strong>私有写时复制的（Private Copy-On-Write）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811221142.jpg" alt="img"></p><p>但是假设进程2对该私有对象的某个页面进行修改时，会触发保护故障，故障处理程序就会在物理内存中创建一个该物理页的副本，然后让进程2的对应PTE指向新的副本，并设置该虚拟页具有写权限，然后处理程序返回，从写指令重新运行。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811221150.jpg" alt="img"></p><blockquote><p>图中大块的表示对象，可能由很多个页组成，当我们尝试对其中一个页进行修改时，只会对该页进行复制，并修改该页对应的PTE，而该对象的其他页保持不变。</p></blockquote><p><strong>问题：</strong>当虚拟页的读写权限修改后，与所在段的读写权限冲突时，是否要修改虚拟页所在的段？即上图进程2深色和浅色的页是处在不用段中？还是说段的读写权限是用来初始化其中包含的虚拟页的读写权限，但是虚拟页的读写权限可以自己修改？</p><p><strong>答</strong>：个人认为是第二个答案</p><p>通过写时复制这种策略，尽可能延迟物理内存中的拷贝，能最大效率地使用物理内存。</p><blockquote><p>当只对虚拟空间进行读操作，则永远不会复制，而是共享相同的物理内存。</p></blockquote><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><code>fork</code>函数</h3><p>在父进程中调用<code>fork</code>函数时，会创建一个具有相似但独立虚拟地址空间的子进程，并分配一个唯一的PID，而写时复制技术会给<code>fork</code>函数提供一个高效的解决方案：</p><ul><li>为了具有和父进程相同的<strong>虚拟内存状态</strong>，内核会复制父进程的<code>mm_struct</code></li><li>为了具有和父进程相同的<strong>虚拟内存段分配</strong>，内核会复制父进程的<code>vm_area_struct</code></li><li>为了子进程和父进程具有相同的<strong>虚拟内存内容</strong>，内核会复制父进程的页表，就能将相同的磁盘内容映射到相同的虚拟页中，并将虚拟页缓存在相同的物理页中。</li><li>为了子进程和父进程的虚拟地址空间能<strong>相互独立</strong>，两个进程的页都设置为只读的，且段都标记为私有的写时复制。当父子进程都没有对页进行修改时，父子进程是共享相同的物理内存的，当其中一个进程对页进行修改时，就会对该页进行写时复制，并为该页赋予写权限，并更新进程对应的页表。</li></ul><h3 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a><code>execve</code>函数</h3><p>当我们运行<code>execve(&quot;a.out&quot;, NULL, NULL)</code>执行可执行目标文件<code>a.out</code>时，包含以下步骤：</p><ul><li><p><strong>删除用户段：</strong>将进程的虚拟地址空间中的用户段删除，即删除<code>vm_area_struct</code>和页表。</p></li><li><p><strong>映射私有段：</strong>首先为可执行目标文件中的不同数据节创建对应的段，即在<code>vm_area_struct</code>中新建节点，并设置对应的段起始虚拟地址、段终止虚拟地址，设置这些段为私有写回复制的。然后将这些段通过内存映射与<code>a.out</code>中的内容关联起来。（对私有对象的读写参考2.2）</p></li><li><ul><li>对于需要初始化为0的段，可将其与匿名文件进行关联。</li></ul></li><li><p><strong>映射共享段：</strong>对于共享库的内容，会将其映射到共享库的内存映射段中，即在<code>vm_area_struct</code>中创建一个共享段，然后将其与共享库的内容关联起来，这样就能在多个进程中共享相同的共享库。（对共享对象的读写参考2.1）</p></li><li><ul><li>如果共享库有维护状态的静态变量，比如随机生成器在调用时会维持状态，且不同的进程的状态不同，对于这种要修改静态数据的函数，应该将该段标记为私有写时复制的，这样就能在不同进程中维护自己独立的状态。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811222240.jpg" alt="img"></p><ul><li>设置程序计数器，使其指向代码段的入口点。</li></ul><blockquote><p>通过将对象映射到不同的段中，就能决定对该对象进行读写时的特点。</p></blockquote><p><strong>注意：</strong>当程序运行时，我们并没有加载任何内容到内存中，所做的只是设置内存映射，在内核中创建数据结构，由此创建了虚拟地址空间和这些对象之间的映射关系，而实际的拷贝工作会由缺页异常按需完成。</p><h3 id="通过mmap函数自定义内存映射"><a href="#通过mmap函数自定义内存映射" class="headerlink" title="通过mmap函数自定义内存映射"></a>通过<code>mmap</code>函数自定义内存映射</h3><p>用户通过<code>mmap</code>函数能自己创建虚拟内存段，并将对象映射到该段中，由此我们可以通过修改该段的参数，来达到对对象的设置。比如设置该虚拟内存段是全部进程共享的，则映射到该段的对象就能在所有进程中共享。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> port, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>文件描述符<code>fd</code>指定一个磁盘文件，该函数会将磁盘文件中偏移<code>offset</code>处的<code>length</code>个字节的对象映射到虚拟内存中的<code>start</code>处。<code>start</code>指定的段如果是有效的，则内核会将其映射到指定段，如果指定段的部分虚拟地址空间被某个已存在的段包含了，则内核会另外找一个有效的位置，<code>start</code>可以设置为NULL，让内核自动分配。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811222252.jpg" alt="img" style="zoom:80%;" /><p>其中，**<code>prot</code>**对应于段结构中的<code>vm_prot</code>参数，用来确定该虚拟内存段的读写权限：<code>PROT_EXEC</code>表示该段中的页是可执行的；<code>PROT_READ</code>表示该段中的页是可读的；<code>PROT_WRITE</code>表示该段中的页是可写的；<code>PROT_NONE</code>表示该段内的页是不可访问的。</p><p>**<code>flags</code>**对应于段结构中的<code>vm_flags</code>：<code>MAP_PRIVATE</code>表示该段是私有的写时复制的；<code>MAP_SHARED</code>表示该段是共享的。也可以设置<code>MAP_ANON</code>，表示是一个匿名对象。</p><p>当函数执行成功时，会返回指向该段的指针，如果失败，则返回<code>MAP_FAILED</code>。</p><p>可以通过以下函数来删除虚拟内存中的段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>; </span><br></pre></td></tr></table></figure><p>使用自定义内存映射的<strong>好处在于：</strong></p><ul><li>使得磁盘文件中的一块数据能与虚拟内存地址空间中的某个段建立映射关系，此时我们就能直接通过对该虚拟内存段的访问来间接访问磁盘文件内容，不必执行文件I/O操作，也无需对文件内容进行缓存处理。并且虚拟内存进行按序页面调度的，当你访问了文件内容，它就会将对应的虚拟页加载到物理页中，此时就能从内存中很快地访问文件内容。当你处理大文件或频繁读写文件时能提速，因为此时就直接将文件内容加载到物理内存中了，一切读写操作都是在物理内存中进行的，速度特别快，只有在内核将其牺牲时，才会进行写回。</li><li>通过内存映射方法，我们还能定义一个进程共享的虚拟内存段，使得能让多个进程对一个区域进行访问和修改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp虚拟内存：概念（九）</title>
      <link href="2021/08/11/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>2021/08/11/csapp/csapp%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9A%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>对应于书中的9.1~9.6</strong></p><ul><li>虚拟内存被组织为存放在磁盘上的N个连续字节大小的单元数组，每个字节都有一个唯一的虚拟地址，而该数组的内容被缓存在主存中。（所以虚拟内存本质上是磁盘上的字节数组，该数组的索引就是虚拟地址，且主存作为该数组的缓存。）</li><li>CPU通过虚拟内存地址进行访问，会首先确定对应的PTE，然后通过PTE的状态访问对应的物理页。</li><li>加载器不会将磁盘内容复制到内存，而是为可执行目标文件分配虚拟页，初始化页表。实际的加载工作由内核完成。</li><li>只有分配页面了，CPU才会产生该页的虚拟地址</li><li>MMU负责地址翻译和访问权限检查</li><li>页表和TLB中只需要保存PPN。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811202247.jpg" alt="img" style="zoom:67%;" /><hr><p>进程之间相互共享CPU和主存资源，但是如果太多进程需要太多内存资源，可能就会使得进程无法运行，并且当进程写了另一个进程使用的内存时，会造成错误。所以为了更好管理内存，现代系统提供了一种对主存的抽闲概念，称为<strong>虚拟内存（Virtual Memory）</strong>，它完美交互了硬件异常、硬件地址翻译、主存、磁盘文件和内核软件，为每个进程都提供了一个大的、一致的私有的地址空间。</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间（Address Space）</strong>是一个非负整数地址的有序集合${0,1,2,…}$​ ，如果地址空间中的整数是连续的，则称为<strong>线性地址空间（Linear Address Space）</strong>。</p><p>计算机系统的主存被组织成一个由M个字节大小的单元组成的数组，每个字节都有一个唯一的<strong>物理地址（Physical Address）</strong>，并且物理地址是连续的。由此就构成了一个<strong>物理地址空间（Physical Address Space）</strong>，对应于系统中物理内存的M个字节。CPU可以通过物理地址来访问内存，这种方式称为<strong>物理寻址（Physical Addressing）</strong>，再将获得的数据字保存到寄存器中。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811202601.jpg" alt="img"></p><p>现代系统会尝试虚拟化资源，提供资源不同的视图，通常会呈现某种抽象或某种不同的资源视图，你可以通过介入对该资源的访问过程来实现。所以当你有一些资源，并且想要进行虚拟化时，可以通过干预或介入对该资源的访问过程来实现，一但你拦截了访问的过程，你就能用任何你想要的方式来处理它，就能有很多方法来改变那个资源对用户的视图。比如访问磁盘特定的扇区，需要制定柱面、磁道和盘面，但是磁盘控制器将磁盘抽象成一系列逻辑块的形式，使得内核能直接直接制定逻辑块号来访问磁盘，这就是一种虚拟化技术，它通过拦截来自内核的读写请求来呈现出这种视图，将内核发送的逻辑块号转化为实际的物理地址。</p><p>对于主存存储器资源也可以通过虚拟内存提供另一种不同的视图。现代CPU从一个有$N=2^n$ 个地址的地址空间中生成<strong>虚拟地址（Virtual Address）</strong>，该地址空间称为<strong>虚拟地址空间（Virtual Address Space）</strong>，虚拟地址空间的大小由表示最大虚拟地址所需的位数$n$ 来确定，现代系统支持32位或64位的虚拟地址空间。CPU会使用虚拟地址来访问主存，称为<strong>虚拟寻址（Virtual Addressing）</strong>，需要首先通过<strong>地址翻译（Address Translation）</strong>将虚拟地址转换为对应的物理地址，再通过物理地址来访问内存。而地址翻译类似于异常处理（软硬结合），需要CPU上的**内存管理单元（Memory Management Unit，MMU)**，以及内存中由操作系统管理的查询表来动态翻译虚拟内存。所以通过MMU来控制对内存的读写，达到对内存进行虚拟化的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811203001.jpg" alt="img"></p><p>通常虚拟地址空间会比物理地址空间大很多，物理地址空间对应于系统中实际拥有的DRAM容量，对于系统上运行的所有进程，虚拟地址空间是相同的。</p><p>为什么要增加MMU来对内存进行抽象呢？<strong>主要原因在于：</strong></p><ul><li>虚拟内存将DRAM内存作为磁盘上实际数据的高速缓存，即我们可以在主存访问磁盘大小的空间，而主存只保存活动区域，根据需要在磁盘和主存之间来回传送数据，使得进程可以得到更大的地址空间，并且更有效地利用主存资源。</li><li>虚拟内存为每个进程提供一致的虚拟地址空间，代码和数据总是加载到固定的地址，堆栈位于用户课件地址空间的顶部等等，但是实际上与那些虚拟地址相对应的内容分布在整个主存储器中，所以通过使用虚拟内存可以简化内存的管理。</li><li>虚拟内存保护每个进程的地址空间不会被别的进程破坏。</li></ul><h2 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h2><h3 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>虚拟内存被组织为存放在磁盘上的N个连续字节大小的单元数组，每个字节都有一个唯一的虚拟地址，而该数组的内容被缓存在主存中。（所以虚拟内存本质上是磁盘上的字节数组，该数组的索引就是虚拟地址，且主存作为该数组的缓存。）</p><p>虚拟内存是在20世纪60年代早期发明的，早于SRAM高速缓存之前，所以即使两者使用相似的概念，术语也存在很大的不同。在虚拟内存中，数据块被称为<strong>页（Page）</strong>，磁盘和内存之间传送给页称为<strong>交换（Swapping）</strong>或<strong>页面调度（Paging）</strong>。所有现代系统都使用<strong>按序页面调度（Demand Paging）</strong>的方式，一直等待直到发生不命中时，才换页面。</p><p>虚拟内存之所以有效，也是因为局部性。虚拟内存作为下一层存储器层次，大小会比物理内存大，所以运行过程中程序引用的不同页面总数可能会超出物理内存大小。如果程序具有好的局部性，则在任意时刻的工作集较小，程序会趋于在一个较小的<strong>活动页面（Active Page）</strong>集合上工作，所以只需要在一开始将工作集页面调度到物理内存中，过后就不会产生额外的磁盘流量了。但是如果局部性较差，则工作集超过了物理内存大小，则会发生<strong>抖动（Thrashing）</strong>，使得不断从磁盘中读取页到物理内存中，程序性能大大降低。在Linux中，可以通过<code>getrusage</code>函数检测缺页的数量。</p><blockquote><p>虚拟内存从缓存的概念考虑，要求程序具有较好的局部性</p></blockquote><p>从缓存的角度来看，内存是作为虚拟内存的缓存，则这两层存储器层次之间传输数据的块大小相同，都为 $P=2^p$ 字节，在物理内存中的数据块称为<strong>物理页（Physical Page，PP）</strong>，也称为<strong>页帧（Page Frame），</strong>在虚拟内存中的数据块称为<strong>虚拟页（Virtual Page，VP）</strong>。虚拟页有三种状态：</p><ul><li><strong>未分配的：</strong>未分配的虚拟页就是没有任何数据和它关联的数据块，不占用任何磁盘空间。</li><li><strong>缓存的：</strong>已保存在物理页中的已分配的虚拟页</li><li><strong>未缓存的：</strong>还未保存在物理页中的已分配的虚拟页</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811203656.jpg" alt="img"></p><p>其次，主存作为虚拟内存的缓存，如果主存不命中，就会从速度特别慢的磁盘中读取数据，造成很大的开销，所以虚拟内存和主存之间传输的数据块大小P较大，通常为4KB~2MB，由此增强空间局部性。并且为了避免数据块冲突，内存是全相联的，意味着虚拟页能保存在任意的物理页中。最后，由于对磁盘的访问时间较长，内存采用写回的形式。</p><p>虚拟页到物理页的映射关系保存在物理内存中常驻的<strong>页表（Page Table）</strong>数据结构中，该页表由操作系统维护，每个虚拟页在页表中都保存了它对应的物理页，所以一共需要 $2^n/P$ 个<strong>页表条目（Page Table Entry，PTE）</strong>。每次地址翻译硬件将一个虚拟地址转换为物理地址时，就会访问该页表。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811203943.jpg" alt="img" style="zoom:80%;" /><p>如上所示是一个页表数据结构，每个PTE包含一个有效位和一个n位地址字段组成。当有效位为1时，表示已将该虚拟页缓存在物理页中，则地址字段就是对应的物理页的起始物理地址；当有效位为0时，如果虚拟页是未分配的，则地址字段为NULL，如果虚拟页分配了，则地址字段就是对应的虚拟页在磁盘上的起始地址。</p><p><strong>注意：</strong>由于内存采用全相联结构，所以任意的虚拟页能缓存在任意的物理页中。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>当CPU想要访问位于虚拟地址<code>x</code>中的数据字时，会首先通过地址翻译硬件将虚拟地址作为一个索引来定位PTE，然后通过PTE来确定对应的虚拟页的状态。如果PTE的有效位为1，说明该虚拟页被缓存在物理内存了，则CPU可以通过该PTE的地址字段获得物理内存的地址，然后进行访问</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811204243.jpg" alt="img" style="zoom: 80%;" /><p>如果该PTE的有效位为0，且地址字段指向虚拟页在磁盘的位置，则说明该虚拟页还未缓存在物理页中，则出现了<strong>缺页（Page Fault）</strong>（对应于不命中）。处理器会发起缺页异常，然后调用内核中的缺页异常处理程序，会执行以下步骤：</p><ul><li>由于内存使用全相联结构，如果存在空的高速缓存行，则会选择该物理页，否则会从中选择一个牺牲页，由于采用了写回的策略，所以如果该物理页的数据被修改过，就将其复制会磁盘中。</li><li>修改牺牲页对应的PTE，将地址字段指向虚拟页在磁盘的位置，说明该虚拟页未被缓存</li><li>内核从磁盘复制目标虚拟页到该牺牲页中，并修改目标虚拟页对应的PTE，将地址字段指向牺牲页的物理内存地址</li><li>缺页异常返回到导致缺页异常的指令，重新执行该指令，此时由于缓存了目标虚拟页，所以会命中</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811204816.jpg" alt="img" style="zoom:80%;" /><p>上图展示的是cpu引用了VP3中一个字出现缺页的情形。左边是缺页之前，右边是缺页之后（选择VP4为牺牲页）。</p><p>而当CPU想要分配一个新的虚拟页时，比如调用了<code>malloc</code>函数，则首先在磁盘中创建一个虚拟页大小的空间，然后修改对应的PTE，将有效位置为0，且地址字段指向新的虚拟页在磁盘中的位置。</p><h3 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h3><p>内核在进程上下文中为每个进程都维护了自己独立的页表，使得每个进程有独立的虚拟地址空间。每个进程的页表将该进程连续的虚拟地址空间映射到DRAM物理地址空间中的任意位置，并且不同的虚拟页和不同的进程可以映射到不同的物理页中。通过这种形式，可以提供一种视图：每个进程都有一个非常相似的虚拟地址空间，有相同大小的地址空间，代码和数据分别从同一个地址开始，但是进程使用的物理页实际上可能会分散在DRAM内存中。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811204849.jpg" alt="img" style="zoom:80%;" /><p>按序页表调度和独立的虚拟地址空间，提供了以下便利：</p><ul><li><strong>简化链接：</strong>由于每个进程都有自己独立的虚拟地址空间，则相同的虚拟地址在不同的进程中可以通过进程自己的页表来确定最终的物理地址，所以链接器生成可执行目标文件确定内存地址时，无需考虑当前物理内存的状态，可以根据我们预定义的内存模型来分配虚拟内存地址，因为不同进程之间的虚拟地址是独立的，最终可以通过页表来映射到真实的物理地址。这就极大简化了链接器的工作，可以直接按内存模型来分配地址。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811205047.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>简化加载：</strong>想要把可执行目标文件加载到物理内存中，Linux加载器只需要为可执行目标文件中的代码段和数据段分配虚拟页，然后在页表中将这些虚拟页设置为无效的（表示还未缓存），然后将地址字段指向对应的位置，则实际的加载工作会由操作系统自动地按需执行。当访问某一虚拟地址时，发现其对应的PTE是无效的，则会发起缺页异常，通过缺页异常处理程序自动地将虚拟页加载到物理页中。所以加载器不会将磁盘内容复制到内存，而是为可执行目标文件分配虚拟页。这种将一组连续的虚拟页映射到任意一个文件中的任意位置称为<strong>内存映射（Memory Mapping）</strong>。</li><li><ul><li>加载实际是非常高效的机制，比如你的程序中包含一个巨大的数组，但是你只访问该数组的一部分，实际上不会将整个数组对应的虚拟页保存到物理页中，因为加载器只是初始化页表。当你代码中访问该数组的一部分时，内核会执行缺页异常处理程序，将包含你想要的数据的虚拟页加载到对应的物理页中，所以效率很高。</li></ul></li><li><strong>简化共享：</strong>通过为每个进程设置独立的页表，可以很简单地实现共享库和内核的共享。之前介绍过，共享库会在加载时或运行时动态加载到物理内存的任意位置，让所有进程进行共享。这里只需要在进程中通过一个PTE指向该共享的数据或代码的物理页，就能实现在所有进程中共享的结果。也侧面说明了<code>plt</code>和<code>got</code>的必要性，可以避免修改共享库的内容。</li><li><strong>简化内存分配：</strong>进行内存分配时，可以通过<code>malloc</code>函数在物理内存中的任意位置进行创建，因为页表只需要让虚拟页指向该物理页，就能提供连续的虚拟地址抽象，让进程误以为是在连续的地址空间中进行操作的，由此简化了内存分配需要的工作。</li></ul><h3 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h3><p>通过对页表的改进，可以很容易地进行内存保护</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811210620.jpg" alt="img" style="zoom:80%;" /><p>这里在每个PTE中引入了三个字段：</p><ul><li><code>SUP</code>：确定该物理页的访问权限，确定是否需要内核模式才能访问</li><li><code>READ</code>：确定该物理页的读权限</li><li><code>WRITE</code>：确定该物理页的写权限</li></ul><p>MMU每次访问时都会检查这些位，如果有一条指令违背了这些许可条件，就会触发一个保护故障，Linux shell一般会将这种异常报告为<strong>段错误（Segment Fault）</strong>。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>接下来简单介绍下地址翻译，地址翻译就是一个N元素的虚拟地址空间（VAS）中的元素和一个M元素的物理地址空间（PAS）中元素之间的映射</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811210855.png" alt="img"></p><p>主要通过MMU硬件利用保存在物理内存中的页表来实现，MMU具有以下结构</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811210948.jpg" alt="img" style="zoom:80%;" /><p>首先，虚拟页大小为P个字节，所以需要虚拟地址的低p位来索引一个虚拟页中的字节，得到<strong>虚拟页偏移量（Virtual Page Offset，VPO）</strong>，然后通过虚拟地址的高n-p位来确定虚拟页在页表中的索引，得到<strong>虚拟页号（Virtual Page Number，VPN）</strong>。而页表的起始地址保存在一个特殊的CPU寄存器<strong>页表基址寄存器（Page Table Base Register，PTBR）</strong>中，所以可以通过VPN和PTBR得到想要的PTE的物理内存地址。并且由于虚拟页和物理页的大小相同，所以两者编码页中偏移量所需的位数p相同，所以数据在虚拟页和在物理页中的偏移量相同，由此就无需在页表中保存<strong>物理页偏移量（Physical Page Offset，PPO）</strong>，只需要保存<strong>物理页号（Physical Page Number，PPN）</strong>，可以直接将VPO复制给PPO，来确定数据在物理页中的偏移量。</p><blockquote><p>从全相联缓存的角度来看，VPN其实就是标志位，而VPO就是块偏移。</p></blockquote><p><strong>注意：</strong>页表中只保存PPN。</p><p><strong>页面命中主要执行以下步骤</strong>，可以发现完全由硬件处理：</p><ul><li>CPU生成一个虚拟地址，将它发送给MMU</li><li>MMU根据虚拟地址获得VPN，然后通过PTBR确定该PTE所在的物理内存地址（PTEA）（因为页表保存在物理内存中），然后将PTEA发送给物理内存</li><li>物理内存根据PTEA将对应的PTE发送给MMU，其中PTE只包含PPN（因为数据在页内偏移量相同）</li><li>MMU将PPN和VPO拼接起来，就可以得到虚拟地址对应的物理地址。然后MMU再将物理地址发送给物理内存</li><li>物理内存根据物理地址将数据发送给处理器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811211322.jpg" alt="img"></p><p><strong>缺页主要执行以下步骤</strong>，由硬件和操作系统共同完成：</p><ul><li>前三步相同，当MMU接收到PTE时，发现有效位为0，说明该虚拟页还未缓存在物理页中，就会发起一个缺页异常，由内核来执行缺页异常处理程序。</li><li>通过内核来确定一个牺牲页，如果该牺牲页中的数据被修改过，就将其复制到对应的磁盘虚拟页中</li><li>内核将需要的虚拟页保存到对应的物理页中，并修改对应的PTE</li><li>从缺页异常处理程序返回到导致异常的指令，重新执行该指令，就会执行页面命中的步骤。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811211534.jpg" alt="img" style="zoom:80%;" /><p>在高速缓存中，为了不同进程能共享相同的物理页且避免相同虚拟页的冲突，这里使用物理寻址。所以MMU负责地址翻译和访问权限检查，然后使用物理内存地址访问高速缓存</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811211554.jpg" alt="img" style="zoom:80%;" /><h3 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h3><p>可以发现，每次CPU将一个虚拟地址发送给MMU时，MMU都会将需要的PTE物理地址发送给高速缓存/内存来获得PTE，如果高速缓存刚好保存了该PTE，则MMU可以很快获得，否则需要等待很多时钟周期从内存中读取。</p><p>为了减小这个开销并进一步利用局部性原理，在MMU中引入了一个保存最近使用的PTE缓存，称为<strong>翻译后备缓冲器（Translationi Lookaside Buffer，TLB）</strong>。在TLB中，使用虚拟地址进行寻址，具有较高的相联度，每个高速缓存行保存一个PTE，每次都是以一整个PTE进行读写，不需要含有块偏移，记得我们之前是通过VPN在页表中索引获得PTE，所以虚拟地址的划分为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811212050.jpg" alt="img" style="zoom:80%;" /><blockquote><p>多个进程访问TLB时，每个进程都有一个TLB，还是上下文切换时清空TLB？</p></blockquote><p>所以<strong>当TLB命中时</strong>的步骤为：</p><ul><li>CPU产生一个虚拟地址，发送给MMU</li><li>MMU提取出当前虚拟地址的VPN，发送给TLB</li><li>TLB对VPN进行分解，得到TLBI和TLBT，根据TLBI确定所在的高速缓存组，然后在高速缓存组中依次比较各个高速缓存行的标记是否和TLBT相同，如果相同，则TLB命中，将对应的PPN发送给MMU</li><li>MMU将PPN和VPO拼接起来得到虚拟地址对应的物理地址。然后MMU再将物理地址发送给物理内存</li><li>物理内存根据物理地址将数据发送给处理器</li></ul><p>由于TLB位于MMU中，速度特别快。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811212508.jpg" alt="img" style="zoom:80%;" /><p>当<strong>TLB不命中时</strong>的步骤为：</p><ul><li>CPU产生一个虚拟地址，发送给MMU</li><li>MMU提取出当前虚拟地址的VPN，发送给TLB</li><li>TLB对VPN进行分解，得到TLBI和TLBT，没有找到有效的PTE，发生TLB不命中</li><li>MMU根据PTBR和VPN得到PTE对应的PTEA，将其发送给高速缓存/内存</li><li>高速缓存/内存将对应的PTE发送给MMU和TLB</li><li>TLB会根据VPN将PTE保存在合适的位置</li><li>MMU接收到PTE后，将PPN和VPO拼接起来得到虚拟地址对应的物理地址。然后MMU再将物理地址发送给物理内存</li><li>物理内存根据物理地址将数据发送给处理器</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811212616.jpg" alt="img" style="zoom:80%;" /><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>在一个32位地址空间中，每个页面大小为4KB，则一共需要 $2^{32}/2^{2+10} = 2^{20} = 1M$​​​ 个页面，假设每个PTE大小为4字节，则页表总共为4MB。当使用一级页表时，需要始终在内存中保存着4MB大小的页表，我们这里可以使用多级页表来压缩内存中保存的页表内容。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213001.jpg" alt="img" style="zoom:67%;" /><p>首先，我们这里有1M个虚拟页，将连续的1024个虚拟页当成一个<strong>片（chunk）</strong>，一级页表就负责指向每个片对应的二级页表，则一级页表需要 $2^{20}/2{10} = 1K$​​ 个PTE，每个PTE4字节，则一共需要4KB大小的一级页表。</p><p><strong>注意：</strong>这里只有当片中至少一个页被分配了才会指向对应的二级页表，否则为NULL。而二级页表就类似于我们之前的页表结构，这里只需要负责一个片的虚拟页，则每个二级页表为4KB。</p><p>当一级页表的某个PTE为NULL时，表示该片不存在被分配的虚拟页，所以就可以去掉对应的二级页表。并且在内存中只保存一级页表和较常使用的二级页表，极大减小了内存的压力，而其他的二级页表按需创建调入调出。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213217.jpg" alt="img" style="zoom:80%;" /><p>以上是一个k级页表层次结构的地址翻译，前面k-1个页表的PTE都是指向下一级页表的基址，而第k级页表指向的是PPN或磁盘地址。所以每次地址翻译时，MMU需要从内存中访问k个PTE，但是TLB的存在弥补了这个开销。首先，一级页表覆盖了所有的地址空间，所以一定会缓存在TLB中，而二级页表覆盖了大量的地址空间，所以他们也有很大可能会在TLB中，以此类推，只要你程序具有良好的局部性，就有很大概率从TLB中获得想要的PTE，由此弥补了多次访问页表的性能损失。</p><blockquote><p>TLB应该要将不同层次的PTE独立开来</p></blockquote><h3 id="地址翻译实例"><a href="#地址翻译实例" class="headerlink" title="地址翻译实例"></a>地址翻译实例</h3><p>首先我们需要作出以下假设：</p><ol><li>内存是按字节寻址的</li><li>内存访问是针对1字节的字的</li><li>虚拟地址是14位长的</li><li>物理地址是12位长的</li><li>页面大小是64字节的</li><li>TLB是四路组相连的，总共有16个条目</li><li>L1 d-cache是直接映射的，行大小为4字节，总共有16个字节</li></ol><p>根据以上假设，我们可以从获取页表、TLB和高速缓存的信息：</p><ul><li><strong>页表：</strong>当前只使用一级页表，页表大小为64字节，则虚拟页有$2^{14}/2^6 = 256$ 个，则页表具有256个PTE；物理页有$2^{12}/2^6 = 64$ 个。根据地址翻译，可以将虚拟地址和物理地址进行以下划分</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213631.jpg" alt="img" style="zoom:80%;" /><p>由此可以通过VPN在页表中获得对应的PTE，然后通过VPO获得在虚拟页中的数据，物理地址也同理。</p><ul><li><strong>TLB：</strong>四路组相连说明每个高速缓存组中具有四个高速缓存行，而TLB是以PTE为单位进行存取的，所以每个高速缓存行能保存一个PTE，而TLB一共能保存16个PTE，说明该缓存具有4个高速缓存组，则需要2位的组索引TLBI。因为TLB是虚拟寻址的，所以是在虚拟地址上进行划分的，且以PTE为单位进行存取，所以是在VPN中进行划分的，低2位为TLBI，则高6位为标志位TLBT</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213739.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>高速缓存：</strong>直接映射的高速缓存，说明每个高速缓存组只有一个高速缓存行，行大小为4字节，则需要2位的块偏移（CO），一个有16个组，则需要4位的组索引（CI），其余的为标志位（CT）。由于高速缓存是物理寻址的，所以要在物理地址上进行划分</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213807.jpg" alt="img" style="zoom:80%;" /><p>假设当前页表、TLB和高速缓存的内容如下</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213816.jpg" alt="img" style="zoom:80%;" /><p>当CPU产生虚拟地址<code>0x03d4</code>时，执行步骤为：</p><ul><li>首先根据虚拟地址，我们可以进行以下划分，MMU会将VPN字段<code>0x0f</code>发送给TLB</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213831.jpg" alt="img"></p><ul><li>当TLB接收到VPN时，会从中划分出TLBT<code>0x03</code>和TLBI<code>0x03</code>，然后根据TIBI确定在TLB中的高速缓存组，依次将TLBT和标志位进行比较，可以发现第二个高速缓存行具有相同的标志，则TLB命中，会返回对应的PPN<code>0x0D</code>给MMU</li><li>MMU将PPN<code>0x0D</code>和VPO<code>0x14</code>拼接起来，得到物理页对应的物理地址<code>0x354</code></li><li>根据物理地址，可以进行以下划分，MMU将物理地址发送给高速缓存</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811213847.jpg" alt="img"></p><ul><li>高速缓存根据CI确定所在的高速缓存组，并将组内的高速缓存行的标志位依次与CT进行比较，可以发现高速缓存命中了，并根据CO在块内偏移，得到想要的数据<code>0x36</code>，将其返回给MMU</li><li>MMU获得数据后，将其返回给CPU</li></ul><p>以上是比较简单的情况，即TLB命中和高速缓存命中，其他较复杂的情况需要MMU很多后续的操作。</p><p><strong>大致的步骤为：</strong></p><ol><li>将虚拟地址根据TLB规则进行划分，在TLB中进行检索，如果存在则将PPN返回给MMU，如果不存在，将地址根据页表规则进行划分，从存储在内存中的页表中得到对应的PTE，将其保存到TLB，并将PPN返回给MMU</li><li>MMU根据PPN和VPO构建出物理地址，并将物理地址发送给高速缓存</li><li>将物理地址根据高速缓存规则进行换分，在高速缓存中检索，如果存在则将数据返回给MMU，如果不存在则需要从内存中进行检索</li></ol><p><strong>综上：</strong>页表和TLB是虚拟寻址的，都是返回对应的PPN；高速缓存是物理寻址的，返回对应的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp链接（七）</title>
      <link href="2021/08/11/csapp/csapp%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>2021/08/11/csapp/csapp%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><p>由于局部非静态变量保存在寄存器或栈中，所以符号只包含函数、全局变量和静态变量。</p><p><strong>判断符号的信息：</strong></p><ul><li><p><strong>判断符号所在的节：</strong></p></li><li><ul><li>如果是函数，则在<code>.text</code>节中</li><li>如果是未初始化全局变量，则在<code>COMMIN</code>节中</li><li>如果是未初始化静态变量，以及初始化为0的全局变量或静态变量，则在<code>.bss</code>节中</li><li>如果是初始化过的全局变量或静态变量，则在<code>.data</code>节中</li></ul></li><li><p><strong>判断符号类型：</strong></p></li><li><ul><li>如果是在当前文件中定义的函数或全局变量，则为全局符号</li><li>如果是在当前文件定义的静态函数或静态全局变量，则为局部符号</li><li>如果在别的文件中定义，则为外部符号</li></ul></li><li><p><strong>注意：</strong>局部非静态变量保存在栈或寄存器中，所以不考虑</p></li></ul><p>保存在什么表，是根据符号的类型和定义情况，而定义和引用是从变量或函数的角度来看的</p><p><strong>判断符号采用哪种定义：</strong></p><ul><li>在各个文件中确定同名全局符号的强弱，其中符号和初始化的全局符号为强符号，未初始化的全局符号为弱符号</li><li>如果存在多个同名的强符号，则会出现链接错误</li><li>如果存在一个强符号和多个同名的弱符号，则会采用强符号的定义</li><li>如果存在多个同名的弱符号，则会随机采用一个弱符号的定义</li></ul><p>需要根据目标文件和库之间对符号解析的依赖关系，来确定命令行中输入文件的顺序，保证前面文件中未解析的符号，能在后面文件中得到解析。</p><p>重定位包含两层意思：分配内存地址，根据重定位表条目来修改占位符。</p><hr><p><strong>链接（Linking）</strong>是将各种代码和数据片段收集并组合成一个单一的文件的过程，然后该文件会被加载到内存中执行。该过程由<strong>链接器（Linker）</strong>程序自动执行。<strong>链接存在三种类型：</strong></p><ul><li>执行于<strong>编译时（Compile Time）</strong>，即在源代码被翻译成机器代码时的传统静态链接</li><li>执行于<strong>加载时（Load Time）</strong>，即程序被<strong>加载器（Loader）</strong>加载到内存并执行时的动态链接</li><li>执行于<strong>运行时（Run Time）</strong>，即由应用程序来执行的动态链接</li></ul><p><strong>作用：</strong>链接的存在，使得<strong>分离编译（Separate Compilation）</strong>成为可能，一个大型应用程序可以分解成若干个小的模块，只需要对这些模块进行修改编译，然后通过链接器将其组合成大的可执行文件就行。</p><p><strong>学习的意义：</strong>能帮助你构建大型程序，避免一些危险的编程错误，理解语言的作用域规则是如何实现的，理解其他重要的系统概念，比如加载和运行程序、虚拟内存、分页和内存映射，并且可以让你利用共享库。</p><p><strong>本文使用的环境：</strong>运行Linux的x86-64系统，使用标准的ELF-64目标文件格式。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>大多数编译系统提供<strong>编译器驱动程序（Compiler Driver）</strong>，使得用户可以调用预处理器、编译器、汇编器和链接器对程序进行编译。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811110952.jpg" alt="img" style="zoom:67%;" /><p>如上图所示是一个示例程序，对于GNU编译系统，可以通过输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o prog main.c sum.c    // -Og 指定了优化级别</span><br></pre></td></tr></table></figure><p>来调用GCC驱动程序，然后执行以下过程：</p><ol><li>GCC驱动程序运行<strong>C预处理器（cpp）</strong>，将C源程序<code>main.c</code>翻译为ASCII码的中间文件<code>main.i</code>。<code>cpp [other arg] main.c /tmp/main.i</code></li><li>GCC驱动程序运行<strong>C编译器（ccl）</strong>，将<code>main.i</code>翻译成ASCII汇编语言文件<code>main.s</code>。<code>ccl /tmp/main.i -Og [other arg] -o /tmp/main.s</code>。</li><li>GCC驱动程序运行<strong>汇编器（as）</strong>，将<code>main.s</code>翻译成一个<strong>可重定位目标文件（Relocatable Object File）</strong><code>main.o</code>。<code>as [other arg] -o /tmp/main.o /tmp/main.s</code>。</li><li>对<code>sum.c</code>执行相同的过程，得到<code>sum.o</code>。</li><li>GCC驱动程序运行<strong>链接器（ld）</strong>，将<code>main.o</code>和<code>sum.o</code>以及其他必要的系统目标文件组合起来，得到<strong>可执行目标文件（Executable Object File）</strong><code>prog</code>。<code>ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o</code>。</li><li>在shell中输入<code>./prog</code>，则shell会调用操作系统的<strong>加载器（Loader）</strong>函数，将该可执行文件<code>prog</code>复制到内存中，然后执行该程序。</li></ol><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811111013.jpg" alt="img" style="zoom:67%;" /><p>可以发现存在不同的目标文件，<strong>主要包含：</strong></p><ul><li><p><strong>可重定位目标文件：</strong>由各种不同的二进制代码和<strong>数据节（Section）</strong>组成，每一节是一个连续的字节序列，不同节存放不同的数据。</p></li><li><ul><li><strong>生成：</strong>由编译器和汇编器生成</li><li><strong>用处：</strong>在编译时与其他可重定位目标文件合并起来，得到一个可执行目标文件。</li></ul></li><li><p><strong>可执行目标文件：</strong>包含二进制代码和数据</p></li><li><ul><li><strong>生成：</strong>将可重定位目标文件和静态库输入到链接器中，可产生可执行目标文件</li><li><strong>用处：</strong>可被加载器直接复制到内存中并执行</li></ul></li><li><p><strong>共享目标文件：</strong>特殊类型的可重定位目标文件，可以在加载时或运行时被动态地加载进内存并链接。</p></li></ul><blockquote><p><strong>注意：</strong>我们称<strong>目标模块（Object Module）</strong>为一个字节序列，而<strong>目标文件（Object File）</strong>是以文件形式存放在磁盘的目标模块。</p></blockquote><p>目标文件是按照特定的目标文件格式进行组织的，Windews中使用<strong>可移植可执行（Portable Executable，PE）</strong>格式，Max OS-X使用<strong>Mach-O</strong>格式，x86-64 Linux和Unix使用<strong>可执行可链接格式（Executable and Linkable Format，ELF）</strong>。</p><p>以<strong>可重定位目标文件的ELF格式</strong>为例，如下图所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811111059.jpg" alt="img" style="zoom:67%;" /><ul><li><p><strong>ELF头（ELF header）：</strong>包含生成该目标文件的系统的字大小和字节顺序、ELF头的大小、目标文件类型、机器类型、节头部表的文件偏移，以及节头部表中条目的大小和数目。</p></li><li><p><code>.text</code>： 已编译程序的机器代码</p></li><li><p><code>.rodata</code>： 只读数据，比如跳转表等等</p></li><li><p><code>.data</code>： 保存已初始化的全局变量和静态变量（全局和局部）</p></li><li><p><code>.bss</code>： 保存未初始化的静态变量（全局和局部），以及被初始化为0的全局变量和静态变量（全局和局部）</p></li><li><ul><li><p><strong>注意：</strong></p></li><li><ul><li>在目标文件中<code>.bss</code>不占据实际的空间，只是一个占位符</li><li>之所以要将初始化和未初始化分成两个节，因为在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，运行时，再在内存中分配这些变量，初始值为0。</li><li>局部变量在运行时只保存在栈中，不出现在<code>.data</code>和<code>.bss</code>中</li><li>静态局部变量不受函数栈的管理，所以也要在这个位置创建</li></ul></li></ul></li><li><p><code>.symtab</code>： 符号表，存放在程序中<strong>定义和引用</strong>的函数和变量的符号信息</p></li><li><ul><li><strong>注意：</strong>不包含局部非静态变量条目，因为该变量是由栈管理的</li></ul></li><li><p><code>.rel.text</code>：<code>.text</code>节的重定位信息，可执行目标文件中需要修改的指令地址</p></li><li><p><code>.rel.data</code>： <code>.data</code>节的重定位信息，合并后的可执行目标文件中需要修改的指针数据的地址</p></li><li><ul><li><p><strong>注意：</strong></p></li><li><ul><li>一般已初始化的全局变量，如果初始值是一个全局变量地址或外部定义函数的地址，就需要被修改</li><li>可执行目标文件已完成重定位，就不需要<code>.rel.text</code>和<code>.rel.data</code>数据节了。</li></ul></li></ul></li><li><p><code>.debug</code>：调试符号表，其条目是程序中定义的局部变量和类型定义，程序汇总定义和引用的全局变量，以及原始的C源文件</p></li><li><p><code>.line</code>： 原始C源程序中的行号和.text节中机器指令之间的映射</p></li><li><ul><li><strong>注意：</strong>只有以-g选项调用编译器驱动程序，才会出现<code>.debug</code>和<code>.line</code></li></ul></li><li><p><code>.strtab</code>： 字符串表，包括<code>.symtab</code>和<code>.debug</code>节中的符号表，以及节头部中的节名字</p></li><li><p><strong>节头部表（Section Header Table）：</strong>给出不同节的大小和位置等其他信息</p></li></ul><blockquote><p>我们可以使用GNU READELF程序来查看目标文件内容。</p><p><a href="https://zhuanlan.zhihu.com/p/114348061">可重定位目标文件和可执行目标文件的具体实例可以看这篇博文</a></p></blockquote><p>每个可重定位目标模块都会有一个由汇编器构造的<strong>符号表.symtab</strong>，包含了当前模块中定义和引用的符号信息。在链接器的上下文中（链接器是对不同的可重定位目标文件进行操作的，所以它的上下文就是不同的可重定位目标模块），根据符号定义和引用的情况，可以将其分成以下类型：</p><ul><li><strong>全局链接器符号：</strong>在当前可重定位目标模块中定义，并能被其他模块引用的符号。对应于非静态的函数和全局变量。</li><li><strong>外部链接器符号：</strong>在别的可重定位目标模块中定义，并被当前模块引用的符号。对应于在其他模块中定义的非静态的函数和全局变量。（外部连接器符号也是全局连接器符号）</li><li><strong>局部链接器符号：</strong>只在当前可重定位目标模块定义和引用的符号。对应于静态的函数和全局变量，这些符号在当前模块中任何位置都可见，但不能被别的模块引用。</li></ul><blockquote><p><strong>注意：</strong>局部静态变量不在栈中管理，所以编译器在<code>.data</code>或<code>.bss</code>中为其分配空间，并在符号表<code>.symtab</code>中创建一个有唯一名字的局部链接器符号。</p></blockquote><p>符号表<code>.symtab</code>中的每个条目具有以下格式</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811111808.jpg" alt="img" style="zoom:80%;" /><ul><li><p><strong>name：</strong>保存符号的名字，是<code>.strtab</code>的字节偏移量</p></li><li><p><strong>type：</strong>说明该符号的类型，是函数、变量还是数据节等等</p></li><li><p><strong>binding：</strong>说明该符号是局部还是全局的</p></li><li><p><strong>value：</strong>对于可重定位目标文件而言，是定义该符号的节到该符号的偏移量（比如函数就是在<code>.text</code>中，初始化的变量在<code>.data</code>，未初始化的变量在<code>.bss</code>中）；对于可执行目标文件而言，是绝对运行形式地址。</p></li><li><p><strong>size：</strong>是符号的值的字节数目。（通过value和size就能获得该符号的值）</p></li><li><p><strong>section：</strong>说明该符号保存在哪个节中，是节头部表中的偏移量。</p></li><li><ul><li><p><strong>注意：</strong>可重定位目标文件中有三个无法通过节头部表进行索引的数据节，称为<strong>伪节（Pseudosection）</strong></p></li><li><ul><li><strong>ABS：</strong>不该被重定位的符号</li><li><strong>UNDEF：</strong>未定义的符号，即在当前可重定位目标文件中引用，但在别的地方定义的符号</li><li><strong>COMMON：</strong>表示未被分配位置的未初始化的全局变量。此时value给出对齐要求，size给出最小的大小。</li></ul></li></ul></li></ul><p>对于像Linux LD这样的<strong>静态链接器（Static Linker）</strong>，是以一组可重定位目标文件和命令参数为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。为了构造可执行目标文件，<strong>链接器有两个任务：</strong></p><ul><li><strong>符号解析（Symbol Resolution）：</strong>将每个符号引用和一个符号定义关联起来</li><li><strong>重定位（Relocation）：</strong>编译器和汇编器生成从地址0开始的代码和数据节，链接器会对代码、数据节、符号分配内存地址，然后使用汇编器产生的<strong>重定位条目（Relocation Entry）</strong>的指令，修改所有对这些符号的引用，使得它们指向正确的内存位置。</li></ul><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p><strong>定义：</strong>链接器符号解析是将每个符号引用与输入的所有可重定位目标文件的符号表中的一个确定的符号定义关联起来。</p><ul><li>对于局部链接器符号，由于符号定义和符号引用都在同一个可重定位目标文件中，情况相对简单，编译器只允许每个可重定位目标文件中每个局部链接器符号只有一个定义。而局部静态变量也会有局部链接器符号，所以编译器还要确保它有一个唯一的名字。</li><li>对于全局符号（包括全局符号和外部符号），编译器可能会碰到不在当前文件中定义的符号，则会假设该符号是在别的文件中定义的，就会在重定位表中产生该符号的条目，让链接器去解决。而链接器可能还会碰到在多个可重定位目标文件中定义相同名字的全局符号，也要解决这些冲突。</li></ul><h3 id="链接器解析多重定义的全局符号"><a href="#链接器解析多重定义的全局符号" class="headerlink" title="链接器解析多重定义的全局符号"></a>链接器解析多重定义的全局符号</h3><p>编译器会向汇编器输出每个全局符号是<strong>强（Strong）</strong>还是<strong>弱（Weak）</strong>，而汇编器会把这些信息隐式编码在可重定位目标文件的符号表中。函数和已初始化的全局符号是强符号，未初始化的全局符号是弱符号。</p><p>然后链接器通过以下规则来处理在多个可重定位目标文件中重复定义的全局符号：</p><ol><li>不允许有多个同名的强符号，如果存在，则链接器会报错</li><li>如果有一个强符号和多个弱符号同名，则符号选择强符号的定义</li><li>如果有多个弱符号同名，符号就随机选择一个弱符号的定义</li></ol><p>我们从编译器的角度来看，当编译器看到一个弱全局符号时，它并不确定是否会在别的文件中对该符号进行定义，也无法确定链接器会采用多重定义的哪个定义。所以编译器将未初始化的全局符号放在<code>COMMON</code>表中，让链接器去决定。而当全局符号初始化为0时，它就是一个强全局符号，根据规则1可知该符号是唯一的，所以编译器可以直接将其分配到<code>.bss</code>中。而对于静态变量，由于其符号也是唯一的，所以编译器也可以直接将其放到<code>.bss</code>或<code>.data</code>中。</p><p>特别要注意的是，当同名符号的类型不同时，规则2和3可能会导致意想不到的错误，比如以下代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811113345.jpg" alt="img" style="zoom:80%;" /><p>这里在文件<code>foo5.c</code>中，<code>x</code>和<code>y</code>是强全局符号，而在文件<code>bar5.c</code>中，<code>x</code>是弱全局符号，所以链接器会选择<code>foo5.c</code>中对<code>x</code>的定义，将其定义为<code>int</code>类型。但是<code>f</code>函数会用<code>double</code>类型的<code>-0.0</code>对<code>x</code>进行赋值，而<code>int</code>是4字节，<code>double</code>是8字节的，可能会造成错误。</p><h3 id="静态库的链接与解析引用"><a href="#静态库的链接与解析引用" class="headerlink" title="静态库的链接与解析引用"></a>静态库的链接与解析引用</h3><p>链接器除了能将一组可重定位目标文件链接起来得到可执行目标文件以外，编译系统还提供一种机制，将所有相关的目标模块打包为一个单独文件，称为<strong>静态库（Static Library）</strong>，可以作为链接器的输入。静态库是以<strong>存档（Achive）</strong>的文件格式存放在磁盘的，它是一组连接起来的可重定位目标文件的集合，有一个头部来描述每个成员目标文件的大小和位置，后缀为<code>.a</code>。<strong>使用静态库的优点有：</strong></p><ul><li>相关的函数可以被编译为独立的目标模块，然后封装成一个独立的静态库文件。</li><li>链接时，链接器只会复制静态库中被应用程序引用的目标模块，减少了可执行文件在磁盘和内存中的大小</li><li>应用程序员只需要包含较少的库文件名就能包含很多的目标模块，比如ISO C99中在<code>libc.a</code>静态库中包含了<code>atoi.o</code>、<code>scanf.o</code>、<code>strcpy.o</code>等可重定位目标模块，在<code>libm.a</code>静态库中包含了数学函数的目标模块。</li></ul><p>比如我们有以下函数</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811150259.jpg" alt=" " style="zoom:80%;" /><p>我们可以用AR工具创建包含这些函数的静态库，首先需要得到这两个函数的可重定位目标文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c addvec.c multvec.c</span><br></pre></td></tr></table></figure><p>由此可以得到<code>addvec.o</code>和<code>multvec.o</code>，然后创建包含这两个可重定位目标文件的静态库</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libvector.a addvec.o multvec.o </span><br></pre></td></tr></table></figure><p>由此就得到了静态库<code>libvector.a</code>。</p><p>为了便于说明静态库中包含了那些函数，以及这些函数的原型，我们会创建一个头文件来包含这两个函数的函数原型，便于想要使用该静态库的人员查看</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811150646.jpg" alt="img" style="zoom:80%;" /><p>如上面的代码，在头文件<code>vector.h</code>中给出了函数<code>addvec</code>和<code>multvec</code>的函数原型。想要创建可执行目标文件，就要编译和链接<code>main2.o</code>和<code>libvector.a</code>。首先先产生可重定位目标文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main2.c </span><br></pre></td></tr></table></figure><p>由此可以得到<code>main2.o</code>，然后运行以下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -o prog2c main2.o ./libvector.a </span><br></pre></td></tr></table></figure><p>由此就能得到一个可执行目标文件<code>prog2c</code>。这里的<code>-static</code>表示链接器需要构建一个完全链接的可执行目标文件，可以加载到内存并运行，无需进一步链接。我们同样可以使用以下方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -o prog2c main.o -L. -lvector </span><br></pre></td></tr></table></figure><p>这里的<code>-lvector</code>是<code>libvector.a</code>的缩写，<code>-L.</code>告诉链接器在当前目录中查找<code>libvector.a</code>静态库。</p><p>当运行了该命令行，在符号解析阶段，链接器会维护一个可重定位目标文件的集合<code>E</code>，一个引用了但是还未定义的符号集合<code>U</code>，一个前面输入文件中已经定义的符号集合<code>D</code>，然后在命令行中从左到右依次扫描可重定位目标文件和存档文件：</p><ul><li>如果输入文件是可重定位目标文件，链接器就将其添加到<code>E</code>中，然后根据该文件的符号表来修改<code>U</code>和<code>D</code>，然后继续下一个输入文件。</li><li>如果输入文件是存档文件，则链接器会依次扫描存档文件中的成员<code>m</code>，如果<code>m</code>定义了<code>U</code>中的一个符号，则将<code>m</code>添加到<code>E</code>中，然后根据<code>m</code>的符号表来修改<code>U</code>和<code>D</code>。最后没有包含在<code>E</code>中的成员就会被丢弃，然后继续下一个输入文件。</li><li>如果链接器扫描完毕，<code>U</code>中还存在没有确定定义的符号，则链接器会报错并终止，否则链接器会合并和重定位<code>E</code>中的目标文件，得到可执行目标文件。</li></ul><p>在这个例子中，链接器首先得到输入文件<code>mian2.o</code>，其中存在未解析的符号<code>addvec</code>，则会将该符号保存在集合<code>U</code>中，然后扫描下一个输入文件<code>libvector.a</code>时，由于是存档文件，就会依次扫描其中的成员，首先扫描到<code>addvec.o</code>时，能对符号<code>addvec</code>进行解析，则将<code>addvec.o</code>保存在<code>E</code>中，并将符号<code>addvec</code>从<code>U</code>中删除，扫描到<code>multvec.o</code>时，由于<code>U</code>中已不存在未解析的符号了，所以不会将<code>multvec.o</code>包含在<code>E</code>中，最终链接器会合并和重定位<code>E</code>中的目标文件，得到可执行目标文件。所以链接器最终只会从静态库<code>libvector.a</code>中提取<code>addvec.o</code></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811154246.jpg" alt="img" style="zoom:80%;" /><p>根据以上过程的描述，我们<strong>需要小心命令行上库和目标文件的顺序</strong>，要保证前面输入文件中未解析的符号能在后续输入文件中进行解析，否则会出现链接错误，一般是将库放在后面，如果库之间存在依赖，也要注意库之间的顺序，并且为了满足依赖关系，可以在命令行上重复库。</p><p><strong>特别的：</strong>首先输入目标文件，由于目标文件会直接包含在<code>E</code>中，所以可以得到目标文件中所有未解析的符号，并且提供了该目标文件中的所有解析的符号，相当于“无条件加入”的，如果存在库依赖目标文件，就无需再输入目标文件了。然后根据库之间的依赖来排序库，存档文件会根据<code>U</code>的内容来确定是否将成员<code>m</code>保存在<code>E</code>中，相当于“按序加入”的，所以需要重复输入库来满足依赖关系。</p><p>比如<code>p.o -&gt; libx.a -&gt; liby.a</code>且<code>liby.a -&gt; libx.a -&gt; p.o</code>。此时我们先输入<code>p.o</code>，就包含了解析<code>lib.a</code>符号的定义了，然后我们根据依赖输入<code>libx.a liby.a</code>，此时由于第一个<code>libx.a</code>只是解析了<code>p.o</code>中未定义的符号，而<code>liby.a</code>中还存在由<code>libx.a</code>解析的符号，所以我们还需输入<code>libx.a</code>来解析<code>liby.a</code>的符号。</p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>当链接器完成符号解析时，就能确定在多个目标文件中重定义的全局符号的解析，以及获得静态库中需要的目标模块，此时所有符号引用都能和一个符号定义关联起来了。此时开始重定位步骤，<strong>包括：</strong></p><ul><li>链接器将所有目标模块中相同类型的节合并成同一类型的新的聚合节，比如将所有输入目标模块的<code>.data</code>节聚合成可执行文件中的<code>.data</code>节，其他节也如此操作。</li><li>此时链接器知道代码节和数据节的确切大小，就将运行时内存地址赋给新的聚合节，以及输入模块定义的每个符号。此时程序的每条指令和全局变量都有唯一的运行时内存地址了。</li><li>记得之前可重定位目标文件中，由于编译器和汇编器并不知道符号的运行时内存地址，所以使用一个占位符来设置符号引用的地址，而当前链接器已为符号分配了内存地址，所以链接器需要修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时内存地址。</li></ul><p>当汇编器生成目标模块时，它无法确定数据和代码最终会放在内存的什么位置，也无法确定该模块引用外部定义的函数和全局变量的位置，所以汇编器先用占位符来占领位置，然后对地址未知的符号产生一个<strong>重定位条目（Relocation Entry）</strong>，代码的重定位条目会保存在<code>.rel.text</code>节中，已初始化数据的重定位条目会保存在<code>rel.data.</code>节中。重定位条目的数据结构如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811160026.jpg" alt="img" style="zoom:80%;" /><p>其中，<code>offset</code>表示要修改符号引用的内存地址，<code>type</code>表示重定位的类型，<code>symbol</code>是符号表的索引值，表示引用的符号，可以通过该符号获得真实的内存地址，<code>addend</code>是一个有符号常数，有些重定位需要使用这个参数来修改引用位置。</p><p>我们通过以下代码来介绍两个重定位类型：<code>R_X86_64_PC32</code>和<code>R_X86_64_32</code>。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811160045.jpg" alt="img" style="zoom:80%;" /><p>我们可以通过<code>objdump -dx main.o</code>来得到<code>main.o</code>的反汇编代码，可以发现该函数中无法确定<code>array</code>和其他目标模块中定义的函数<code>sum</code>在内存中的地址，所以会对<code>array</code>和<code>sum</code>产生重定位条目</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811160052.jpg" alt="img" style="zoom:80%;" /><h3 id="R-X86-64-PC32"><a href="#R-X86-64-PC32" class="headerlink" title="R_X86_64_PC32"></a><code>R_X86_64_PC32</code></h3><p>该重定位条目主要用来产生32位PC相对地址的引用，即函数调用时的重定位。</p><p>其中<code>call</code>指令的开始地址处于节偏移<code>0xe</code>处，然后有一个字节的操作码<code>e8</code>，后面跟着的就是函数<code>sum</code>的32位PC相对引用的<strong>占位符</strong>，所以链接器修改的位置在当前节偏移<code>0xf</code>处。该重定位条目<code>r</code>包含以下字段</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = 0xf //该值是当前节的偏移量，定位到重定位的位置</span><br><span class="line">r.symbol = sum //保存的是要重定位的符号</span><br><span class="line">r.type = R_X86_64_PC32 //保存的是重定位的类型</span><br><span class="line">r.addend = -4 </span><br></pre></td></tr></table></figure><p>当前链接器已经确定了各个节和符号的的内存地址，该代码处于<code>.text</code>节中，则我们可以通过<code>.text</code>和<code>r.offset</code>的值来确定占位符的内存地址</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = 0x4004d0</span><br><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">        = 0x4004d0 + 0xf</span><br><span class="line">        = 0x4004df</span><br></pre></td></tr></table></figure><p>然后我们需要计算占位符的内容，根据相对地址的计算方法，可以知道占位符的内容是目标地址减去当前PC的下一条指令的地址。可以通过<code>ADDR(r.symbol)</code>来获得目标地址，即<code>sum</code>函数的地址，可以通过<code>refaddr</code>减去4字节来获得下一指令的地址，然后可以通过以下计算公式来计算占位符内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">refptr = s + r.offset //占位符的指针</span><br><span class="line">ADDR(r.symbol) = ADDR(sum) = 0x4004e8</span><br><span class="line">*refptr = (unsigned)(ADDR(s.symbol) + r.addend - refaddr)</span><br><span class="line">        = (unsigned)(0x4004e8 + (-4) - 0x4004df)</span><br><span class="line">        = (unsigned) 0x5</span><br></pre></td></tr></table></figure><p>由此在可执行目标文件中，<code>call</code>指令就有如下的重定位形式：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811160641.png" alt="img"></p><h3 id="R-X86-64-32"><a href="#R-X86-64-32" class="headerlink" title="R_X86_64_32"></a><code>R_X86_64_32</code></h3><p>该重定位条目主要用来产生32位绝对地址的引用，即数组的重定位。</p><p>使用数组<code>array</code>的指令处于<code>.text</code>节偏移<code>0x9</code>处，后面有一个字节的操作码，后面跟着的就是数组<code>array</code>的32位绝对地址的引用的<strong>占位符</strong>，所以链接器修改的位置在当前节偏移<code>0xa</code>处。该重定位条目<code>r</code>包含以下字段</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = 0xa</span><br><span class="line">r.symbol = array</span><br><span class="line">r.type = R_X86_64_32</span><br><span class="line">r.added = 0</span><br></pre></td></tr></table></figure><p>我们可以通过<code>r.symbol</code>的地址来确定数组<code>array</code>的内存地址，然后直接将该内存地址保存到占位符中，即</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refptr = s + r.offset //占位符的指针</span><br><span class="line">*refptr = (unsigned)(ADDR(r.symbol) + r.addend)</span><br><span class="line">        = (unsigned) 0x601018 </span><br></pre></td></tr></table></figure><p>由此在可执行目标文件中，该引用有以下重定位形式</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811161231.png" alt="img"></p><p>重定位后，加载器就会将这些节的字节直接复制到内存中，可以直接执行。</p><h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><h3 id="ELF格式"><a href="#ELF格式" class="headerlink" title="ELF格式"></a>ELF格式</h3><p>通过以上符号解析和重定位过程，链接器已将可重定位目标文件和库合并成一个可执行目标文件了，目标文件的ELF格式如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811161627.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>ELF头：</strong>描述了文件的总体格式，还包括程序的<strong>入口点（Entry Point）</strong>，即当程序运行时要执行的第一条指令的地址。</li><li><code>.init</code>：定义了一个小函数<code>_init</code>，程序的初始化代码会调用</li><li><code>.text</code>、<code>.rodata</code>和<code>.data</code>和可重定位目标文件中的类似，只是这里被重定位到了最终的运行时内存地址</li><li>由于可执行目标文件是完全链接的，已经不需要重定位了，所以不需要<code>.rel</code>节了。</li></ul><p><strong>段头部表（Segment Header Table）：</strong>包括页大小、虚拟地址内存段（节）、段大小等等。描述了可执行文件连续的片到连续的内存段的映射关系，如下图所示是通过<code>OBJDUMP</code>显示的<code>prog</code>的段头部表</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811161650.jpg" alt="img"></p><p>在可执行目标文件中，根据不同数据节对读写执行的不同要求，将不同的数据节分成了两个段：代码段和数据段，其中<strong>代码段</strong>包含ELF头、段头部表、<code>.init</code>、<code>.text</code>和<code>.rodata</code>，<strong>数据段</strong>包括<code>.data</code>和<code>.bss</code>。然后段头部表中就描述了代码段和数据段到内存段的映射关系，其中<code>off</code>是目标文件中的偏移，表示要从目标文件的什么位置开始读取该段；<code>vaddr/paddr</code>是内存地址，表示要将该段加载到的内存地址；<code>align</code>是对齐要求；<code>filesz</code>是目标文件中的段大小，则通过<code>off</code>和<code>filesz</code>就能确定我们要加载的段的内容；<code>memsz</code>是内存中的段大小，表示我们养将目标文件中的该段加载到多大的内存空间中；<code>flags</code>表示该段运行时的访问权限。</p><p>比如第1行、第2行描述的就是代码段，表示将目标文件中从<code>0x0</code>开始的<code>0x69c</code>个字节数据保存到从<code>0x400000</code>开始的，大小为<code>0x69c</code>字节的内存空间中，并具有读和可执行权限。第3行、第4行描述的是数据段，表示将目标文件从<code>0xdf8</code>开始的<code>0x228</code>个字节数据保存到从<code>0x600df8</code>开始的，大小为<code>0x230</code>字节的内存空间中，并具有读写权限。</p><p>这里为了使得程序执行时，目标文件中的段能高效地传送到内存中，要求</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811161930.png" alt="image-20210811161930621" style="zoom:67%;" /><h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><p>当我得到可执行目标文件<code>prog</code>时，我们可以在<code>shell</code>中输入<code>./prog</code>。</p><p>由于<code>prog</code>不是内置的shell命令，所以shell会认为<code>prog</code>是一个可执行目标文件，就通过调用<code>execve</code>函数来调用内核中的<strong>加载器（Loader）</strong>，则加载器会在可执行目标文件的段头部表的引导下，将可执行文件中的数据段和代码段复制到对应的内存位置，然后加载器会创建如下运行时内存映射</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811162001.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>代码段和数据段：</strong>x86-64通常将代码段保存在<code>0x400000</code>处，所以会将可执行目标文件的代码段和数据段映射为如上形式。<strong>注意：</strong>这里数据段为了满足对齐要求，会和代码段之间存在间隙。</li><li><strong>运行时堆：</strong>在数据段之后会有一个运行时堆，是通过调用<code>malloc</code>库动态往上增长的</li><li><strong>共享库：</strong>在堆之后是一个共享库的内存映射区域</li><li><strong>用户栈：</strong>用户栈是从最大的合法用户地址开始，向较小的地址增长</li><li><strong>内核：</strong>最上方的是位内核中的数据和代码保留的，是操作系统驻留在内存的位置</li></ul><p><strong>注意：</strong>链接器通常会使用地址空间布局随机化（ASLR）来修改堆、共享库和栈的地址，但是会保持三者相对位置不变。</p><p>随后加载器会跳转到程序的入口点，到达<code>_start</code>函数的地址，然后该函数调用系统启动函数<code>_libc_start_main</code>，然后该函数初始化执行环境，然后调用用户层的<code>main</code>函数。其中，<code>_start</code>定义在系统目标文件<code>ctrl.o</code>，<code>__libc_start_main</code>定义在<code>libc.so</code>中。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/114348061">可重定位目标文件和可执行目标文件的具体实例可以看这篇博文</a></p></blockquote><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p><strong>静态库具有以下缺点：</strong>需要定期维护和更新，并且几乎所有C程序都会使用标准I/O函数，则运行时这些函数的代码会被复制到每个运行进程的文本段中，占用大量的内存资源。</p><p>为了解决静态库的问题提出了<strong>共享库（Shared Library）</strong>，它是一个目标模块，不会在产生可执行目标文件时将数据段和代码段复制到可执行目标文件中进行静态链接，而是等到程序要加载时或要运行时才进行链接，我们可以提供最新的共享库，使得可执行目标文件可以直接和最新的共享库在加载或运行时链接，无需重新产生可执行目标文件。共享库由<strong>动态链接器（Dynamic Linker）</strong>加载到任意的内存地址，并和一个在内存中的程序链接起来，该过程称为<strong>动态链接（Dynamic Linking）</strong>。动态链接器本身就是一个共享目标，Linux中为<code>ld-linux.so</code>。</p><p>共享库的“共享”具有<strong>两层含义：</strong></p><ul><li>在任意文件系统中，一个库只有一个<code>.so</code>文件，所有引用该共享库的可执行目标文件都共享该<code>.so</code>文件中的代码和数据，不像静态库的内容会被复制到可执行目标文件中。</li><li>在内存中，一个共享库的<code>.text</code>节可以被不同正在运行的进程共享。</li></ul><h3 id="加载时动态链接"><a href="#加载时动态链接" class="headerlink" title="加载时动态链接"></a>加载时动态链接</h3><p>我们可以通过以下形式产生共享库</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libvector.so addvec.c multvec.c</span><br></pre></td></tr></table></figure><p>其中，<code>-shared</code>指示链接器创建一个共享的目标文件，<code>-fpic</code>指示编译器生成与位置无关的代码。然后我们可以通过以下形式利用该共享库</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o prog2l main2.c ./libvector.so </span><br></pre></td></tr></table></figure><p>由此就创建了一个可执行目标文件<code>prog2l</code>，其过程如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811163445.jpg" alt="img"></p><ul><li>在创建可执行目标文件时，链接器会复制共享库中的重定位<code>.rel</code>和符号表<code>.symtab</code>信息，使得运行时可以解析对共享库中代码和数据的引用，由此得到部分链接的可执行目标文件。<strong>注意：</strong>此时没有将共享库的代码和数据节复制到可执行文件中。</li><li>调用加载器加载部分链接的可执行目标文件时，加载器会在段头部表的引导下，将可执行文件中的数据段和代码段复制到对应的内存位置。</li><li>加载器可以在<code>prog2l</code>中发现<code>.interp</code>节，其中保存了动态链接器的路径，则加载器会加载和运行这个动态链接器</li><li>动态链接器会将不同的共享库的代码和数据保存到不同的内存段中</li><li>动态链接器还会根据共享库在内存的位置，来重定位<code>prog2l</code>中所有对共享库定义的符号的引用</li><li>最后加载器将控制权传递给应用程序，此时共享库的位置就固定了，并在程序执行的过程中不会改变。</li></ul><p>此时就能在应用程序被加载之后，在运行之前动态链接器加载和链接共享库。</p><h3 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h3><p>应用程序还可以在它运行时要求动态链接器加载和链接某个共享库。</p><p>Linux为动态链接器提供一个接口，使得应用程序在运行时加载和链接共享库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><p><code>dlopen</code>函数可以打开<code>filename</code>指定的共享库，并返回句柄指针，而参数<code>flag</code>可以用来确定共享库符号解析方式以及作用范围，两个可用<code>|</code>相连，包括：</p><ul><li><code>RTLD_NOW</code>：在dlopen返回前，解析出全部没有定义符号，假设解析不出来，则返回NULL</li><li><code>RTLD_LAZY</code>：在dlopen返回前，对于共享库中的没有定义的符号不运行解析，直到执行来自共享库中的代码（仅仅对函数引用有效，对于变量引用总是马上解析）。</li><li><code>RTLD_GLOBAL</code>：共享库中定义的符号可被其后打开的其他库用于符号解析</li><li><code>RTLD_LOCAL</code>：与<code>RTLD_GLOBAL</code>作用相反，共享库中定义的符号不能被其后打开的其他库用于重定位，是默认的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">char</span> *symbol)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数返回之前打开的共享库的句柄中<code>symbol</code>指定的符号的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>; </span><br></pre></td></tr></table></figure><p>用来关闭打开的共享库句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果<code>dlopen</code>、<code>dlsym</code>或<code>dlclose</code>函数发生错误，就返回字符串。</p><p>如下图所示的代码示例</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811163804.jpg" alt="img" style="zoom:67%;" /><p>该程序就会在运行时动态链接共享库<code>libvector.so</code>，然后调用<code>addvec</code>函数。</p><p>我们可以用以下的编译方式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -rdynamic -o prog2r dll.c -ldl</span><br></pre></td></tr></table></figure><p>其中，<code>-rdynamic</code>通知链接器将全部符号加入到动态符号表中，就可以通过使用<code>dlopen</code>来实现向后跟踪，<code>-ldl</code>表示程序运行时会动态加载共享库。</p><h3 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h3><p>当链接器产生可执行目标文件时，已为目标文件中的数据节和符号分配好了内存地址，如果可执行目标文件有引用共享库中的符号时，就需要假设共享库符号的地址。较早存在<strong>静态共享库（Static Shared Library）</strong>方法，即操作系统会在某个特定的地址中划分一部分，为已知的共享库预留空间，则共享库会被加载到对应的地址空间中，而可执行目标文件就可以在对应的地址空间中找到想要的共享库。但是该方法会造成地址冲突，并造成地址空间的浪费，以及维护的困难。</p><p>所以就想能否将共享库加载到任意的内存位置，还能使得可执行目标文件能找到。类似于使用静态库时，链接器会根据重定位表和分配好的内存地址来替换编译时未知的地址，这里可以使用<strong>加载时重定位（Load Time Relocation）</strong>方法，由于编译、汇编和链接时对共享库在内存的位置是未知的，所以可执行目标文件对共享库的符号的引用也用占位符代替，当加载器加载可执行目标文件进行加载时，会调用动态链接加载器将共享库加载到内存中，此时就能根据共享库被加载的内存地址，对可执行目标文件中的占位符进行重定位。<strong>但是该方法会对共享库中的指令进行修改，由于指令被重定位后对于每个进程是不同的，所以该共享库无法在多个进程中共享。</strong></p><blockquote><p>对这句话的理解：共享对象也就是动态链接库在被装载到物理内存后，始终是只有一份的，不管有多少个进程使用它。但是对于每一个进程，共享对象会映射一次到虚拟地址空间，也就是每个进程空间都有一份共享对象的映射，此时，对于不同的进程，映射的地址（基址）是不一样的（大部分情况下）。紧接着，进行装载时重定位。加载时重定位由动态链接器完成，动态链接器会被一起映射到进程空间中。它根据共享对象在虚拟内存空间中的地址修改在物理内存中的共享对象中的指令，为什么会修改指令，原因在于绝对地址访问（如模块内的变量访问）是直接用mov指令完成的（<strong>x86 上 mov 之类访问程序中数据段的指令，它要求操作数是绝对地址</strong>），也就是直接将地址打入寄存器，所以，此时的重定位会直接修改指令。进一步，共享对象中修改的指令是<strong>根据共享对象被映射到虚拟空间中的地址（基址）决定的</strong>，而每个进程对共享对象的映射不可能都是在相同地址。所以也就无法完成这一部分代码的共享。</p></blockquote><p>但是共享库中的数据部分在多个进程中是有自己备份的，所以这就给我们提供了一个思路。我们的目的其实就是希望共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为**地址无关代码(PIC, Position-independent Code)**的技术。</p><p><strong>注意：</strong>对于动态库的创建，<code>-fpic</code>选择地址无关代码是必须的编译选项。</p><h4 id="PIC-数据引用的实现原理"><a href="#PIC-数据引用的实现原理" class="headerlink" title="PIC 数据引用的实现原理"></a>PIC 数据引用的实现原理</h4><p>编译器通过运用以下事实来生成对全局变量的PIC引用：无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段和代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。</p><p>编译器在数据段开始的地方创建了一个表，叫做全局偏移表（Global Offset Table, GOT）。在GOT中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的GOT。GOT属于数据段的一部分。示例如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210819110243.png" alt="image-20210819110242965" style="zoom:90%;" /><h3 id="PIC函数调用的实现原理"><a href="#PIC函数调用的实现原理" class="headerlink" title="PIC函数调用的实现原理"></a>PIC函数调用的实现原理</h3><p>如果程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段（要想通过动态链接器对可执行目标文件的代码段进行修改，需要先将此段重映射为可写段这种修改需要预留交换空间，并且会形成此进程的文本段专用副本，此文本段不再供多个进程共享，会严重影响性能），GNU编译系统使用了一种很有趣的技术来解决这个问题，成为<strong>延迟绑定（lazy binding）</strong>，将过程地址的绑定推迟到第一次调用该过程时。</p><p>一个程序只会调用共享库中一部分的程序，将<strong>函数地址</strong>的绑定推迟到实际调用的时候，能够避免动态链接器在加载的时候进行成百上千不需要的重定位（<strong>意思是有些函数声明了，但是没有被调用？</strong>）。</p><p>延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：<strong>全局偏移量表（Global Offset Table，GOT）</strong>和<strong>过程链接表（Procedure Linkage Table，PLT）</strong>。我们以下方的例子进行介绍PIC函数调用的过程：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811164735.jpg" alt="img" style="zoom:80%;" /><p>我们可以通过以下命令行来产生位置无关代码的共享库<code>libvector.so</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o libvector.so addvec.c multvec.c</span><br></pre></td></tr></table></figure><p>然后通过以下命令行产生可执行目标文件<code>prog</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o prog main2.c ./libvector.so</span><br></pre></td></tr></table></figure><p>首先，为了不对可执行目标文件的代码段进行修改，减小开销，编译器在数据段的开头新建了一个<code>.got</code>节，用来保存共享库函数的地址，由于数据节是可写的，所以就能在知道共享库函数地址时，对该数据节进行修改，使其指向正确的共享库函数的地址。比如我们这里可以通过<code>readelf -a -x .got prog</code>来解读可执行目标文件，得到以下<code>.got</code>数据节</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hex dump of section &#x27;.got&#x27;:</span><br><span class="line"> NOTE: This section has relocations against it, but these have NOT been applied to this dump.</span><br><span class="line">  0x00200fb0 b00d2000 00000000 00000000 00000000 .. .............</span><br><span class="line">  0x00200fc0 00000000 00000000 46060000 00000000 ........F.......</span><br><span class="line">  0x00200fd0 56060000 00000000 00000000 00000000 V...............</span><br><span class="line">  0x00200fe0 00000000 00000000 00000000 00000000 ................</span><br><span class="line">  0x00200ff0 00000000 00000000 00000000 00000000 ................</span><br></pre></td></tr></table></figure><p>其次，由于链接器无法修改编译器产生的汇编代码，所以无法修改调用共享库的函数的<code>call</code>指令，所以编译器在代码段新建一个<code>.plt</code>节，然后对所有引用自共享库中的函数都在该数据节中创建一个新函数<code>xxx@plt</code>，然后将代码中调用地址替换成<code>call xxx@plt</code>，所以就能通过函数<code>xxx@plt</code>来完成对<code>.got</code>的更新，以及指向正确的地址。</p><p>我们这里可以通过<code>objdump -dx prog</code>来将其转化为汇编代码。首先查看<code>main</code>函数中对共享库<code>libvector.so</code>的<code>addvec</code>函数和共享库<code>glibc.so</code>的<code>printf</code>函数的调用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">000000000000077a &lt;main&gt;:</span><br><span class="line"> 77a:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line"> 77e:b9 02 00 00 00       mov    $0x2,%ecx</span><br><span class="line"> 783:48 8d 15 9e 08 20 00 lea    0x20089e(%rip),%rdx        # 201028 &lt;z&gt;</span><br><span class="line"> 78a:48 8d 35 7f 08 20 00 lea    0x20087f(%rip),%rsi        # 201010 &lt;y&gt;</span><br><span class="line"> 791:48 8d 3d 80 08 20 00 lea    0x200880(%rip),%rdi        # 201018 &lt;x&gt;</span><br><span class="line"> 798:e8 a3 fe ff ff       callq  640 &lt;addvec@plt&gt;</span><br><span class="line"> 79d:8b 0d 89 08 20 00    mov    0x200889(%rip),%ecx        # 20102c &lt;z+0x4&gt;</span><br><span class="line"> 7a3:8b 15 7f 08 20 00    mov    0x20087f(%rip),%edx        # 201028 &lt;z&gt;</span><br><span class="line"> 7a9:48 8d 35 a4 00 00 00 lea    0xa4(%rip),%rsi        # 854 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line"> 7b0:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line"> 7b5:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 7ba:e8 91 fe ff ff       callq  650 &lt;__printf_chk@plt&gt;</span><br><span class="line"> 7bf:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 7c4:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line"> 7c8:c3                   retq   </span><br><span class="line"> 7c9:0f 1f 80 00 00 00 00 nopl   0x0(%rax)</span><br></pre></td></tr></table></figure><p>可以发现，这里将对<code>addvec</code>函数和对<code>prinrf</code>函数的调用转化为了对<code>addvec@plt</code>和对<code>__printf_chk@plt</code>函数的调用，这两个函数就是在<code>.plt</code>节中定义的，而<code>.plt</code>节中的内容如下所示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000000000000630 &lt;.plt&gt;:</span><br><span class="line"> 630:ff 35 82 09 20 00    pushq  0x200982(%rip)        # 200fb8 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line"> 636:ff 25 84 09 20 00    jmpq   *0x200984(%rip)        # 200fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line"> 63c:0f 1f 40 00          nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000640 &lt;addvec@plt&gt;:</span><br><span class="line"> 640:ff 25 82 09 20 00    jmpq   *0x200982(%rip)        # 200fc8 &lt;addvec&gt;</span><br><span class="line"> 646:68 00 00 00 00       pushq  $0x0</span><br><span class="line"> 64b:e9 e0 ff ff ff       jmpq   630 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">0000000000000650 &lt;__printf_chk@plt&gt;:</span><br><span class="line"> 650:ff 25 7a 09 20 00    jmpq   *0x20097a(%rip)        # 200fd0 &lt;__printf_chk@GLIBC_2.3.4&gt;</span><br><span class="line"> 656:68 01 00 00 00       pushq  $0x1</span><br><span class="line"> 65b:e9 d0 ff ff ff       jmpq   630 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><p>这里首先需要介绍一个<strong>位置无关代码的性质</strong>：我们将可以加载而无需重定位的代码称为位置无关代码。由于我们无论在内存什么位置加载该目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变的。所以我们可以让处于代码段的<code>plt</code>函数通过距离常量来访问处于数据段中对应的<code>got</code>中保存的地址。</p><p>比如上面我们调用<code>addvec@plt</code>函数时，会执行<code>0x640</code>处的<code>jmpq *0x200982(%rip)</code>指令， 这里的<code>0x200982</code>就是上面所说的距离常量，用来指向特定的<code>got</code>项，这里可以得到访问的<code>got</code>项的地址为<code>0x200982+0x646=0x200fc8</code>，而该地址对应的<code>got</code>内容如下所示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00200fc0 00000000 00000000 46060000 00000000 ........F.......</span><br></pre></td></tr></table></figure><p>根据小端法可以得知跳转地址为<code>0x646</code>，即跳转回到下一条指令，然后调用<code>.plt</code>函数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000630 &lt;.plt&gt;:</span><br><span class="line"> 630:ff 35 82 09 20 00    pushq  0x200982(%rip)        # 200fb8 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line"> 636:ff 25 84 09 20 00    jmpq   *0x200984(%rip)        # 200fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line"> 63c:0f 1f 40 00          nopl   0x0(%rax)</span><br></pre></td></tr></table></figure><p>其中第一条指令是将地址<code>0x200982+0x636=0x200fb8</code>作为参数压入栈中，而第二条指令是跳转到<code>0x200984+0x63c=0x200fc0</code>处保存的地址，我们通过上面可以看到，在未运行可执行目标文件时，该地址的值为<code>0</code>，而当运行了可执行目标文件时，该地址的值会修改到动态链接器中的<code>_dl_runtime_resolve</code>函数，来进行地址解析，查看共享库的<code>addvec</code>被加载到什么内存地址。那该函数是如何知道要获得哪个函数的地址，以及要将函数地址保存到哪个<code>got</code>项呢？</p><p>我们观察可执行目标文件中以下共享库的函数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000640 &lt;addvec@plt&gt;:</span><br><span class="line"> 640:ff 25 82 09 20 00    jmpq   *0x200982(%rip)        # 200fc8 &lt;addvec&gt;</span><br><span class="line"> 646:68 00 00 00 00       pushq  $0x0</span><br><span class="line"> 64b:e9 e0 ff ff ff       jmpq   630 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">0000000000000650 &lt;__printf_chk@plt&gt;:</span><br><span class="line"> 650:ff 25 7a 09 20 00    jmpq   *0x20097a(%rip)        # 200fd0 &lt;__printf_chk@GLIBC_2.3.4&gt;</span><br><span class="line"> 656:68 01 00 00 00       pushq  $0x1</span><br><span class="line"> 65b:e9 d0 ff ff ff       jmpq   630 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><p>可以发现每个函数的第一条指令是跳转到对应的<code>got</code>项，而对应的<code>got</code>项被初始化为下一条指令的地址，当<code>got</code>项没有被修改时，就自动跳转到下一条指令。而第二条指令在不同函数中是不同的，其实对应的是<code>.rela.plt</code>的索引</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x5e8 contains 2 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000200fc8  000300000007 R_X86_64_JUMP_SLO 0000000000000000 addvec + 0</span><br><span class="line">000000200fd0  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __printf_chk@GLIBC_2.3.4 + 0</span><br></pre></td></tr></table></figure><p>其中，<code>offset</code>表示对应的<code>got</code>项的地址，<code>Sym.Name</code>就是函数的名字。所以动态链接器通过索引值和<code>.rela.plt</code>数据组就能确定要定位哪个动态库函数，以及将其内存地址保存到哪个<code>got</code>项。</p><p>当动态链接后的<code>addvec</code>函数的内存地址保存到对应的<code>got</code>项时，下次再调用<code>addvec</code>函数时，就能直接通过该<code>got</code>项直接获得<code>addvec</code>函数的内存地址。</p><p>我们可以发现，第一次调用共享库的函数时，对应的<code>xxx@plt</code>函数并不会跳转到正确的函数地址，而是调用动态链接器来获得函数的地址，然后将其保存到<code>got</code>项中，下一次再运行时，才会跳转到正确的函数地址，该方法称为<strong>延迟绑定（Lazy Binding）</strong>，只有共享库的函数要用时，才会重定位它的地址，否则不会，由此防止可执行目标文件加载时需要对大量的共享库的地址进行重定位。</p><p><strong>综上所述：</strong>当函数要访问共享库中的函数时，实现执行<code>call xxx@plt</code>，访问该函数的封装函数，然后该<code>plt</code>函数会访问对应的<code>got</code>项，如果<code>got</code>项被赋值为对应的<code>xxx</code>函数的地址，则会调用该函数，否则会调用<code>.plt[0]</code>中的动态链接器，来定位<code>xxx</code>函数的内存地址，然后将其保存到对应的<code>got</code>项中。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210819103354.png" alt="image-20210819103353778" style="zoom:80%;" /><h2 id="库打桩"><a href="#库打桩" class="headerlink" title="库打桩"></a>库打桩</h2><p>Linux链接器支持<strong>库打桩（Library Interpositioning）</strong>技术，允许你截获对共享库函数的调用，替换成自己的代码。<strong>基本思想</strong>为：创建一个与共享库函数相同函数原型的包装函数，是不不同的库打桩技术，使得系统调用包装函数，而不是调用目标函数。</p><h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811182815.jpg" alt="img" style="zoom:80%;" /><p>我们以以上代码为例，说明编译时打桩技术，替换动态库<code>libc.so</code>的<code>malloc</code>和<code>free</code>函数的调用。</p><p>首先，我们可以定义一个本地的头文件<code>malloc.h</code>，如下所示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//本地malloc.h</span><br><span class="line">#define malloc(size) mymalloc(size)</span><br><span class="line">#define free(ptr) myfree(ptr)</span><br></pre></td></tr></table></figure><p>然后在编译<code>int.c</code>时，使用<code>-I.</code>编译选项，使得预处理器首先从本地查找<code>malloc.h</code>文件，由此就能将共享库的<code>malloc</code>和<code>free</code>函数替换成我们自己的<code>mymalloc</code>混合<code>myfree</code>函数。</p><p>而我们需要自己实现<code>mymalloc</code>和<code>myfree</code>函数，其中需要调用原始的<code>malloc.h</code>，所以需要先将该函数进行编译，所以创建以下文件</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811182910.jpg" alt="img" style="zoom:80%;" /><p>所以我们可以通过以下代码得到该函数的可重定位目标文件<code>mymalloc.o</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DCOMPILETIME -c mymalloc.c</span><br></pre></td></tr></table></figure><p>然后在本地的<code>malloc.h</code>中给出包装函数的函数原型，即</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811182938.jpg" alt="img"></p><p>然后就可以通过以下命令行进行编译时打桩</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I. -o intc int.c mymalloc.o </span><br></pre></td></tr></table></figure><p>此时，由于<code>-I.</code>编译选项，对于<code>int.c</code>中的<code>malloc.h</code>，预处理器会首先从本地搜索<code>malloc.h</code>文件，而在本地<code>malloc.h</code>文件中，对<code>malloc</code>和<code>free</code>函数重新包装成<code>mymalloc</code>和<code>myfree</code>函数，而这两个函数在之前编译好的<code>mymalloc.o</code>可重定位目标文件中，此时就完成了编译时打桩。</p><p><strong>综上所述：</strong>想要在编译时打桩，意味着要通过<code>#define</code>来使用预处理器将目标函数替换成包装函数。</p><h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>Linux静态链接器也支持使用<code>--wrap f</code>标志进行链接时打桩，此时会将符号<code>f</code>解析为<code>__wrap_f</code>，而将对<code>__real_f</code>符号的引用解析为<code>f</code>， 意味着原始对函数<code>f</code>的调用，还会替换成对<code>__wrap_f</code>函数的调用，而通过<code>__real_f</code>函数来调用原始函数<code>f</code>。</p><p>我们定义以下函数</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811183101.jpg" alt="img" style="zoom:80%;" /><p>然后我们可以同时进行编译</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DLINKTIME -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.c mymalloc.c</span><br></pre></td></tr></table></figure><p>也可以分开编译</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -DLINKTIME -c mymalloc.c</span><br><span class="line">gcc -c int.c</span><br><span class="line">gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o</span><br></pre></td></tr></table></figure><p>其中，<code>-Wl</code>表示传递链接器参数，而这些参数通过<code>,</code>相连。</p><p>由此，<code>int.c</code>中对<code>malloc</code>和<code>free</code>函数的调用，会变成对<code>__wrap_malloc</code>和<code>__wrap_free</code>函数的调用。</p><p><strong>综上所述：</strong>想要在链接时打桩，意味着在对可重定位目标文件的符号进行解析时，进行替换。</p><h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>想要在运行时进行打桩，意味着是对共享库的函数进行打桩，这里使用动态链接器提供的<code>LD_PRELOAD</code>环境变量，通过该变量设置共享库路径列表，执行可执行目标文件时，动态链接器就会先搜索<code>LD_PRELOAD</code>共享库。</p><p>我们可以定义以下函数</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210811183813.jpg" alt="img" style="zoom:67%;" /><p>然后通过以下命令行将其编译成共享库</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl </span><br></pre></td></tr></table></figure><p>然后在运行时指定环境变量<code>LD_PRELOAD</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o intr int.c</span><br><span class="line">./LD_PRELOAD=&quot;./mymalloc.so&quot; ./intr </span><br></pre></td></tr></table></figure><p>此时运行到<code>malloc</code>和<code>free</code>函数时，就会调用动态链接器搜索该符号的定义，此时会先搜索<code>LD_PRELOAD</code>指定的共享库，而<code>mymalloc.so</code>中定义了这两个符号，所以就替换了这两个函数的具体实现。<strong>注意：</strong>如果想要调用原始的定义，就需要用运行动态链接的方式，通过指定<code>dlsym</code>的参数为<code>RTLD_NEXT</code>，来在后续的共享库中获得<code>malloc</code>的定义。</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp存储器层次结构（六）</title>
      <link href="2021/08/05/csapp/csapp%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>2021/08/05/csapp/csapp%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><blockquote><p>理想状态中，我们将存储器系统视为一个线性字节数组，CPU能在常数时间内访问每个存储器位置。但实际上<strong>存储器系统（Memory System）</strong>是一个具有不同容量、成本和访问时间的存储设备的层次结构，分别具有以下几部分：</p><ol><li>CPU中的寄存器保存最常使用的数据，能在0个时钟周期内访问</li><li><strong>高速缓存存储器（Cache Memory）</strong>是靠近CPU的、较小的快速存储器，保存一部分从<strong>主存储器（Main Memory）</strong>取出的常用指令和数据，能在4~75个时钟周期内访问</li><li>主存缓存存储磁盘上的数据，需要上百个时钟周期访问</li><li>磁盘存储通过网络连接的其他机器的磁盘或磁带上的数据，需要几千万格周期进行访问</li></ol><p>上方存储器作为下方存储器的缓存，速度更快、容量更小。</p><p>存储器的层次结构之所有有效，是因为程序具有<strong>局部性（Locality）</strong>的基本属性，倾向于不断访问相同的数据项集合，或者倾向于访问相邻的数据项集合。我们希望程序能具有更好的局部性，使得数据项存储在较高层次的存储器中，这样程序就会倾向于从存储器结构中较高层次访问数据项，运行会更快。</p></blockquote><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><p><strong>随机访问存储器（Random-Access Memory，RAM）</strong>根据存储单元实现方式可以分为两类：静态的RAM（SRAM）和动态的RAM（DRAM）。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805205301.png" alt="img"></p><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><ul><li>将每个位保存到由6个晶体管电路构成的<strong>双稳态的（Bistable）</strong>存储器单元。</li><li><strong>属性：</strong>可以无限期地保持在两个不同的电压配置或状态之一，而其他的都是不稳定状态，会迅速转移到两个稳定状态之一。</li><li><strong>特点：</strong>由于具有双稳态，所以只要有电，就会永远保持它的值，即使有干扰，当干扰消除时就会恢复到稳态。</li></ul><p>由于SRAM存取速度较快，只要供电就会保持不变，对光和电噪音等干扰不敏感，但是每位的存储需要6个晶体管，使得造价较为昂贵，且密集度低，使其适合作为小容量高速的高速缓存存储器。</p><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><ul><li><p>将每个位保存为，对一个由访问晶体管控制的电容的充电。</p></li><li><p><strong>特点：</strong></p></li><li><ul><li>由于每个存储单元比较小，DRAM可以制造的十分密集，可以作为主存或图形系统的帧缓冲区。</li><li>由于通过电容电压来保存位，当电容电压受到扰动时就无法恢复了。并且电容存在漏电现象，存储单元10~100毫秒会失去电荷，使得内存系统必须周期性通过读出重写来刷新内存的每一位。</li><li>暴露在光线中会导致电容电压改变。</li></ul></li></ul><p>我们可以将w个DRAM单元组成一个<strong>超单元（Supercell）</strong>，使得一个超单元就能存储w位的信息，并且将d个超单元组合在一个构成一个 d x w <strong>DRAM芯片</strong>，能够存储dw位信息，并且能对每个超单元进行寻址。并且为了降低地址引脚的数量，我们可以将d个超单元组织成r行、c列的阵列形式。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805205438.jpg" alt="img" style="zoom:67%;" /><p>如上图所示，我们有一个 16 x 8 的DRAM芯片，其中包含16个超单元，每个超单元由8个DRAM单元组成，使得每个超单元能存储8位信息。并且16个超单元被组成4行4列的阵列形式。由一个<strong>内存控制器（Memory Controller）</strong>通过<code>addr</code>引脚和<code>data</code>引脚将控制DRAM芯片数据的传入和传出，比如想要获得<code>(2,1)</code>处超单元的数据</p><ol><li>内存控制器发送<strong>行地址（Row Access Strobe，RAS）</strong>2到DRAM芯片，则DRAM芯片会将行2中的整行内容复制到<strong>内部行缓冲区</strong>。</li><li>内存控制器发送<strong>列地址（Column Access Strobe，CAS）</strong>1到DRAM芯片，则DRAM芯片会从内部行缓冲区获得1列的数据，将其发送到内存控制器。</li></ol><p><strong>注意：</strong></p><ul><li>内存控制器发送RAS和CAS时，使用相同的<code>addr</code>引脚，使得必须分两步发送地址，会增加访问时间。</li><li>如果将16个DRAM单元组织成线性形式，则需要4位的地址引脚才能索引到每个超单元，但是将其组织成4行4列的阵列形式，只需要2位的地址引脚。</li></ul><p>为了一次性能访问更多的数据，可以将多个DRAM芯片封装到一个<strong>内存模块（Memory Module）</strong>中，将其扎到主板的扩展槽中。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805205529.jpg" alt="img" style="zoom:67%;" /><p>如上图所示是封装了8个 <code>8M x 8</code>  DRAM芯片的内存模块，每个DRAM芯片负责8位数据，这样一次能对64位字进行读写。比如想要获得地址A处的字：</p><ul><li>内存控制器首先将A转化为<code>(i,j)</code>的超单元地址，然后内存控制器依次将<code>i</code>和<code>j</code>广播到所有DRAM芯片中</li><li>每个DRAM芯片依次接收到RAS<code>i</code>和CAS<code>j</code>，会通过上述的方法输出8位数据</li><li>模块中的电路收集到所有DRAM芯片输出的8位数据，然后将其合并成一个64位的字，返回给内存控制器</li></ul><p>为了进一步扩大存储能力，可以将多个内存模块连接到内存控制器，能够聚合成主存。当内存控制器想要读取地址A处的字时，会先找到包含地址A的内存模块k，然后根据上述步骤得到对应的字。</p><p>而基于传统的DRAM单元，可以做一些优化来提高访问基本DRAM单元的速度：</p><ul><li><strong>快页模式DRAM（Fast Page Mode DRAM，FPM DRAM）：</strong>传统的DRAM芯片通过CAS获得数据后，会将那一行的数据从内部行缓冲区直接删掉，如果访问多个在同一行的超单元时，需要反复读取相同的行。而FPM DRAM能够获取一次行数据后，后面的读取直接从内部行缓冲区读取。</li><li><strong>扩展数据输出DRAM（Extended Data Out DRAM，EDO DRAM）：</strong>对FPM DRAM进行改进，使得各个CAS信号在时间上更加紧密。</li><li><strong>同步DRAM（Synchronous DRAM，SDRAM）：</strong>DRAM芯片与内存控制器的通信使用一组显示的控制信号，通常是异步的，而SDRAM使用了，控制内存控制器的外部时钟信号的上升沿来代替控制信号。</li><li><strong>双倍数据速率同步DRAM（Double Data-Rate Sychronous DRAM，DDR SDRAM）：</strong>对SDRAM的优化，通过使用两个时钟沿作为控制信号，从而使得DRAM的速度翻倍。</li><li><strong>视频RAM（Video RAM，VRAM）：</strong>用于图形系统的帧缓冲区，与FPM DRAM的区别：VRAM的输出是通过对内部缓冲区的移位得到的，VRAM允许对内存并行地读和写。</li></ul><p>从更高层面来看，数据流是通过称为<strong>总线（Bus）</strong>的共享电子电路在处理器和DRAM主存之间传递数据的。总线是一组并行的导线，能够携带地址、数据和控制信号，也可以将数据和地址信号使用相同的导线。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805210144.jpg" alt="img" style="zoom:80%;" /><p>如上图所示是一个连接CPU和DRAM主存的总线结构。其中<strong>I/O桥接器（I/O Bridge）</strong>芯片组包括内存控制器，能够将系统总线的电子信号和内存总线的电子信号互相翻译，也能将系统总线和内存总线连接到I/O总线。</p><p>当从内存加载数据到寄存器中：</p><ol><li>CPU芯片通过<strong>总线接口（Bus Interface）</strong>在总线上发起<strong>读事务（Read Transaction）</strong></li><li>CPU会将内存地址发送到系统总线上</li><li>I/O桥将信号传递到内存总线</li><li>内存接收到内存总线上的地址信号，会从DRAM读取出数据字，然后将数据写到内存总线</li><li>I/O桥将内存总线信号翻译成系统总线信号，然后传递到系统总线上</li><li>CPU从系统总线上读取数据，并将其复制到寄存器中</li></ol><p>当将寄存器中的数据保存到内存中：</p><ol><li>CPU芯片通过总线接口发起<strong>写事务（Write Transaction）</strong></li><li>CPU会将内存地址发送到系统总线上</li><li>I/O桥将信号传递到内存总线</li><li>内存接收到内存总线上的地址信号，会等待数据到达</li><li>CPU将寄存器中的数据字复制到系统总线</li><li>I/O桥将系统总线信号翻译成内存总线信号，然后传递到内存总线上</li><li>内存从内存总线读出数据，并将其保存到DRAM中。</li></ol><p>这里的读事务和写事务统称为<strong>总线事务（Bus Transaction）</strong>。</p><h4 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h4><p>之前介绍的DRAM和SRAM在断电时都会丢失数据，所以是<strong>易失的（Volatile）</strong>，而<strong>非易失性存储器（Nonvolatile Memory）</strong>即使断电后，也会保存信息，该类存储器称为<strong>只读存储器（Read-Only Memory，ROM）</strong>，但是现在ROM中有的类型既可以读也可以写了，可以根据ROM能够重编程的次数以及对它们进行重编程所用的机制进行区分，包括：</p><ul><li><strong>可编程ROM（PROM）：</strong>可以编程一次</li><li><strong>可擦写PROM（EPROM）：</strong>可以批量擦除</li><li><strong>闪存（Flash Memory）：</strong>具有部分（块级）擦除功能，大约擦除十万次后会耗尽</li></ul><p>存储在ROM设备中的程序称为<strong>固件（Firmware）</strong>，包括BIOS、磁盘控制器、网卡、图形加速器和安全子系统等。当计算机系统通电后，会运行存储在ROM中的固件。</p><h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p><strong>磁盘（Disk）</strong>是被用来保存大量数据的存储设备，但是读信息的速度比DRAM慢10万倍，比SRAM慢100万倍。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805210454.jpg" alt="img" style="zoom:67%;" /><p>如上图所示是一个磁盘的构造。磁盘是由多个叠放在一起的<strong>盘片（Platter）</strong>构成，每个盘片有两个覆盖着磁性记录材料的<strong>表面（Surface）</strong>。每个表面由一组称为<strong>磁道（Track）</strong>的同心圆组成，每个磁道被划分为若干<strong>扇区（Sector）</strong>，每个扇区包含相同数量的数据位（通常为512位）作为读写数据的基本单位。扇区之间通过<strong>间隙（Gap）</strong>分隔开来，间隙不保存数据信息，只用来表示扇区的格式化位。通常会使用<strong>柱面（Cylinder）</strong>来描述不同表面上相同磁道的集合，比如柱面k就是6个表面上磁道k的集合。盘片中央会有一个可以旋转的<strong>主轴（Spindle）</strong>，使得盘片以固定的旋<strong>转速率（Rotational Rate）</strong>旋转，单位通常为<strong>RPM（Revolution Per Minute）</strong>。</p><p>将磁盘能记录的最大位数称为最大容量（容量），主要由以下方面决定：</p><ul><li><strong>记录密度（Recording Density）：</strong>一英寸的磁道中可以放入的位数</li><li><strong>磁道密度（Track Density）：</strong>从盘片中心出发，沿着半径方向一英寸，包含多少磁道</li><li><strong>面密度（Areal Density）：</strong>记录密度和磁道密度的乘积</li></ul><p>磁盘容量的计算公式为：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805210747.png" alt="img" style="zoom:80%;" /><p>在面密度较低时，每个磁道都被分成了相同的扇区，所以能够划分的扇区数由最内侧磁道能记录的扇区数决定，这就使得外侧的磁道具有很多间隙。现代大容量磁盘采用<strong>多区记录（Multiple Zone Recording）</strong>技术，将一组连续的柱面划分成一个区，在同一个区中，每个柱面的每条磁道都有相同数量的扇区，由该区中最内侧的磁道决定，由此使得外侧的区能划分成更多的扇区。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805210756.jpg" alt="img"></p><p>如上图所示，磁盘通过一个连接在<strong>传动臂（Actuator Arm）</strong>上的<strong>读/写头（Read/Write Head）</strong>来进行读写，对于有多个盘面的磁盘，会用多个位于同一柱面上的垂直排列的读/写头。对于扇区的<strong>访问时间（Access Time）</strong>由以下几部分构成：</p><ul><li><p><strong>寻道时间：</strong>为了读取到目标扇区，会先控制传动臂将读/写头移动到该扇区对应的磁道上，该时间称为寻道时间。</p></li><li><ul><li><strong>影响因素：</strong>依赖于读/写头之前的位置，以及传动臂在盘面上移动的速度。</li><li>通常为3~9ms，最大时间可为20ms。</li></ul></li><li><p><strong>旋转时间：</strong>当读/写头处于目标磁道时，需要等待目标扇区的第一个位旋转到读/写头下。</p></li><li><ul><li><strong>影响因素：</strong>目标扇区之前的位置，以及磁盘的旋转速度。</li><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805211053.png" alt="image-20210805211053630" style="zoom:67%;" />，平均旋转时间为该值的一半</li></ul></li><li><p><strong>传送时间：</strong>当读/写头处于目标扇区的第一位时，就可以进行传送了</p></li><li><ul><li><strong>影响因素：</strong>磁盘旋转速率，以及每条磁道的扇区数</li><li><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805211316.png" alt="image-20210805211316063" style="zoom:80%;" /></li></ul></li></ul><p><img src="https://pic1.zhimg.com/80/v2-c14149b05b66531d45f079a78883c10c_720w.jpg" alt="img"></p><p><strong>可以发现：</strong>寻道时间和旋转时间是主要影响部分，并且两者大致相等，通常可以寻道时间乘2来估计访问时间。</p><p>由于磁盘构造的复杂性，现代磁盘将其抽象为B个扇区大小的逻辑块序列，编号为<code>0,1,...,B-1</code>，通过磁盘中的<strong>磁盘控制器</strong>来维护逻辑块号和实际扇区之间的映射关系。为此需要通过磁盘控制器对磁盘进行格式化：</p><ul><li>会用表示扇区的信息填写在扇区之间的间隙</li><li>表示出表面有故障的柱面，并且不进行使用</li><li>在每个区会预留一组柱面作为备用，没有映射为逻辑块。当损坏时，磁盘控制器会将数据复制到备用柱面，则磁盘就可以继续正常工作了。</li></ul><p>当从磁盘读取数据到主存，需要以下步骤：</p><ol><li>操作系统发送一个命令到磁盘控制器，读取某个逻辑块号</li><li>磁盘控制器上的固件执行快速表查找，得到该逻辑块号翻译成一个三元组<code>（盘面，磁道，扇区）</code></li><li>磁盘控制器解释三元组信息，将读/写头移动到对应的扇区</li><li>将读取到的信息放到磁盘控制器的缓冲区中</li><li>将缓冲区中的数据保存到主存中。</li></ol><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805211447.jpg" alt="img" style="zoom:80%;" /><p>如上图所示是一个总线结构实例。对于像图形卡、鼠标、键盘、监视器这类输入/输出设备，都是通过<strong>I/O总线</strong>连接到CPU和主存的，比如Intel的<strong>外围设备互联（Peripheral Component Interconnect，PCI）总线</strong>，在PCI模型中，系统中所有的设备共享总线，一个时刻只能有一台设备访问这些线路，目前PCI总线已被PCEe总线取代了。虽然I/O总线比系统总线和内存总线慢，但是能容纳种类繁多的第三方I/O设备</p><ul><li><strong>通用串行总线（Universal Serial Bus，USB）控制器：</strong>USB总线是一个广泛使用的标准，连接许多外围I/O设备，而USB控制器作为连接到USB总线的设备的中转站。</li><li><strong>图形卡（或适配器）：</strong>包含硬件和软件逻辑，负责CPU在显示器上画像素。</li><li><strong>主机总线适配器：</strong>用于将一个或多个磁盘连接到I/O总线，使用<strong>主机总线接口</strong>定义的通信协议，磁盘接口包括<strong>SCSI</strong>和<strong>SATA</strong>，通常SCSI磁盘比SATA磁盘速度更快更昂贵，且SCSI主机总线适配器可以支持多个磁盘驱动器，而SATA只能支持一个。</li><li><strong>网络适配器：</strong>可以通过将适配器插入到主板上空的插槽，从而连接到I/O总线。</li></ul><p><strong>注意：</strong>系统总线和内存总线是与CPU相关的，而PCI总线这样的I/O总线被设计成与底层CPU无关。</p><p>CPU会在地址空间中保留一块地址用于与I/O设备通信，每个地址称为<strong>I/O端口（I/O Port）</strong>，而连接到总线的设备会被映射到一个或多个端口，则处理器可通过端口地址来访问该I/O设备，该技术称为<strong>内存映射I/O（Memory-mapped I/O）</strong>。</p><p>假设磁盘控制器映射到端口<code>0xa0</code>，探讨磁盘的读取过程：</p><ul><li><p>CPU会通过对地址<code>0xa0</code>执行三个存储指令，将地址<code>0xa0</code>的内容保存到内存中，完成对磁盘的读取。发送完指令后，由于磁盘读取速度比CPU执行速度慢很多，所以CPU会先去执行其他工作。</p></li><li><ul><li>指令1：发送一个命令字，告诉磁盘发起一个Read</li><li>指令2：指明应该读取的逻辑块号</li><li>指令3：指明保存的内存地址</li></ul></li><li><p>磁盘控制器接收到Read命令后，会通过上述方法直接将磁盘内容传送到主存中。这种设备可以自己执行读写总线事务而无需CPU干涉的过程，称为<strong>直接内存访问（Direct Memory Access，DMA）</strong>。</p></li><li><p>磁盘发送完数据后，会给CPU发送一个中断信号，暂停CPU正在做的工作，然后将控制返回到CPU被中断的地方。</p></li></ul><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p><strong>固态硬盘（Solid State Disk，SSD）</strong>是一种基于闪存的存储技术，插在I/O总线上标准硬盘插槽（通常为USB或SATA），处于磁盘和DRAM存储器的中间点。从CPU的角度来看，SSD与磁盘完全相同，有相同的接口和包装。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805211737.jpg" alt="img" style="zoom:67%;" /><p>如上图所示是一个SSD的基本结构。它由<strong>闪存</strong>和<strong>闪存翻译层（Flash Translation Layer）</strong>组成</p><ul><li>闪存翻译层是一个硬件/固件设备，用来将对逻辑块的请求翻译成对底层物理设备的访问。</li><li>闪存的基本属性决定了SSD随机读写的性能，通常由B个块的序列组成，每个块由P页组成，页作为数据的单位进行读写。通常页大小为512字节<del>4KB，块中包含32</del>128页，则块的大小有16KB~512KB。</li></ul><p>当对页进行写操作时，首先需要先对该页所处的整个块进行擦除。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805211842.jpg" alt="img" style="zoom:80%;" /><p>以上是Intel SSD 730的性能，IOPS是每秒I/O操作数，吞吐量数量基于4KB块的读写。我们可以发现随机写操作较慢，这是因为：</p><ul><li>对页进行写操作时，通常需要花费较长时间来擦除块，比访问页所需的时间慢了一个数量级</li><li>当块中包含其他数据时，会先将块中带有有效数据的页复制到被擦出过的块中，才能对那个块进行擦除。在闪存翻译层中实现了复杂的逻辑，试图最小化这些重复的操作。</li></ul><p>块的擦除次数是有限的，当块磨损后，就不能再使用了，闪存翻译层中的<strong>平均磨损（Wear Leveling）</strong>逻辑会试图将擦除平均到所有块中，来最大化每个块的寿命。</p><p>SSD的优缺点：</p><ul><li><strong>优点：</strong>由于闪存是半导体存储器，没有移动的部件，所以速度比磁盘更快且磨损小，能耗低</li><li><strong>缺点：</strong>SSD每字节比磁盘贵大约30倍，所以常用的存储容量比磁盘小100倍左右。</li></ul><h3 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h3><p>具有以下重要思想：</p><ul><li><strong>不同存储技术有不同的价格和性能折中：</strong>从性能而言，SRAM&gt;DRAM&gt;SSD&gt;磁盘，而从每字节造价而言，SRAM&gt;DRAM&gt;SSD&gt;磁盘。</li><li>不同存储技术的价格和性能属性以不同的速率变化着</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212020.jpg" alt="img" style="zoom:80%;" /><p>从上一图中可看出，DRAM主存和磁盘的性能滞后于CPU性能，访问时间比单个处理器的周期时间更慢，而SRAM的性能虽然也滞后于CPU性能，但是还保持增长，所以现代计算机会使用基于SRAM的高速缓存，来弥补CPU和内存之间的差距。</p><h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>具有良好<strong>局部性（Locality）</strong>的程序，会倾向于引用最近引用过的数据项本身，或者引用最近引用过的数据项周围的数据项。局部性主要具有两种形式：</p><ul><li><strong>时间局部性（Temporal Locality）：</strong>引用过的数据项在不久后会被多次引用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212037.png" alt="img"></p><ul><li><strong>空间局部性（Spatial Locality）：</strong>引用过的数据项，在不久后会引用附近的数据项。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212112.png" alt="img"></p><p>从硬件到操作系统，再到应用程序，都利用了局部性</p><ul><li><strong>硬件：</strong>在处理器和主存之间引入一个小而快速的高速缓存存储器，来保存最近引用的指令和数据，从而提高对主存的访问速度。</li><li><strong>操作系统：</strong>用主存来缓存虚拟空间中最近被引用的数据块。</li><li><strong>应用程序：</strong>比如Web浏览器会将最近引用的文档放入本地磁盘中，来缓存服务器的数据。</li></ul><p>有良好局部性的程序比局部性较差的程序运行更快。</p><p>想要分析一个程序的局部性是否好，可以依次分析程序中的每个变量，然后根据所有变量的时间局部性和空间局部性来综合判断程序的局部性。</p><p><strong>例1：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212209.jpg" alt="img" style="zoom:80%;" /><p>分析上述程序的局部性。对于变量<code>sum</code>，每一轮迭代都会引用一次，所以<code>sum</code>具有好的时间局部性，而<code>sum</code>是标量，所以没有空间局部性。对于变量<code>v</code>，其数据在内存中的分布如图b中所示，每一轮迭代都是引用不同的数据项，所以时间局部性较差，但是会按照内存存储的顺序依次引用数据项，所以空间局部性较好。 综合来说，该程序具有较好的局部性。</p><p>并且由于程序是以指令形式保存在内存中的，而CPU会从内存中读取指令，所以也可以考虑取指的局部性。由于该循环体内的指令是顺序保存在内存中的，而CPU会按顺序进行取指，所以具有良好的空间局部性，并且迭代多次会反复读取相同的指令，所以具有良好的时间局部性，所以该程序的局部性较好。</p><p>对于一个向量，如果每一轮引用的数据项之间在内存空间中相隔k，则称该程序具有<strong>步长为k的引用模式（Stride-k Reference Pattern）</strong>。步长k越大，则每一轮引用的数据在内存中间隔很大，则空间局部性越差。</p><p><strong>例2：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212411.jpg" alt="img" style="zoom:80%;" /><p>对于以上代码，变量<code>sum</code>的时间局部性较好且不具有空间局部性，对于二维数组变量<code>a</code>，在内存中是按照行优先存储的，而代码中也是按照行优顺序进行应用的，所以变量<code>a</code>具有步长为1的引用模式，所以具有较好的空间局部性，而时间局部性较差。总体来说，该程序具有良好的局部性。</p><p><strong>例3：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212417.jpg" alt="img" style="zoom:80%;" /><p>上述代码将变量<code>a</code>的引用顺序变为了列优先，则根据<code>a</code>的内存存储形式，变量<code>a</code>具有步长为N的引用模式，则时间局部性较差，且空间局部性也较差。总体来说，该程序的局部性较差。</p><p><strong>例4：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212430.jpg" alt="img" style="zoom:67%;" /><p>我们需要判断以上三个函数的局部性。首先根据结构体的定义可以得到结构体数组在内存中的存储形式如下所示</p><p><img src="https://pic4.zhimg.com/80/v2-91128cb42e57ffa12c5fa6c10809f46b_720w.png" alt="img"></p><p>则<code>clear1</code>函数的步长为1，具有良好的空间局部性；而<code>clear2</code>函数会在结构体中不同的字段中反复跳跃，空间局部性相对<code>clear1</code>差一些；而<code>clear3</code>函数会在相邻两个结构体中反复跳跃，空间局部性相比<code>clear2</code>更差。</p><p><strong>总体而言：</strong></p><ul><li>重复引用相同变量的程序具有良好的时间局部性</li><li>考虑变量的内存存储形式，判断程序引用模式的步长，步长越大则空间局部性越差</li><li>从取指角度而言，具有循环体则空间局部性和时间局部性较好，而且循环体越小、迭代次数越多，则局部性越好。</li></ul><h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>通过上面两节，我们可以得到存储技术和软件的<strong>基本属性：</strong></p><ul><li>不同存储技术的访问时间相差较大，速度快的技术每字节的成本比速度慢的技术高，且容量小。并且CPU和主存之间的差距在变大。</li><li>编写良好的程序具有良好的局部性。</li></ul><p>两者存在一定的互补，由此可以得到一种组织存储器系统的方法，<strong>存储器层次结构（Memory Hierarchy）</strong>。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212713.jpg" alt="img" style="zoom:80%;" /><p>如上图所示是一种经典的存储器层次结构，会使用基于SRAM的高速缓存存储器来解决CPU和DRAM主存之间的鸿沟，通常还可以在DRAM主存和本地磁盘之间添加一层SSD，来弥补两者之间的差距。通常还可以在本地磁盘下方添加一个本地磁带，提供成本更低的存储。</p><p><strong>高速缓存（Cache）</strong>是一个小而快速的存储设备，用来作为存储在更大更慢设备中的数据对象的缓冲区域。而使用高速缓存的过程称为<strong>缓存（Caching）</strong>。</p><p>存储器层次结构的<strong>中心思想</strong>是让层次结构中的每一层来缓存低一层的数据对象，将第k层的更快更小的存储设备作为第k+1层的更大更慢的存储设备的缓存。</p><p><strong>该结构之所以有效</strong>，是因为程序的局部性原理。相比于第k+1层的数据，程序会倾向于访问存储在第k层的数据。如果我们访问第k+1层存储的数据，我们会将其拷贝到第k层，因为根据局部性原理我们很有可能将再次访问该数据，由此我们就能以第k层的访问速度来访问数据。而且因为我们不经常访问第k+1层的数据，我们就可以使用速度更慢且更便宜的存储设备。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805212755.jpg" alt="img" style="zoom:80%;" /><p>上图展示的是存储器层次结构的基本缓存原理。每一层存储器都会被划分成连续的数据对象组块，称为<strong>块（Block）</strong>，每个块都有一个唯一的地址或名字，并且通常块的大小都是固定的。第k层作为第k+1层的缓存，数据会以块大小作为<strong>传送单元（Transfer Unit）</strong>在第k层和第k+1层之间来回赋值，使得第k层保存第k+1层块的一个子集的副本。通常存储器层次结构中较低层的设备的访问时间较长，所以较低层中会使用较大的块。</p><h3 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h3><p>当程序需要第k+1层的某个数据对象d时，会现在第k层的块中搜索d，如果d刚好缓存在第k层中，则成为<strong>缓存命中（Cache Hit）</strong>，则该程序会直接从第k层中读取d。根据存储器层次结构，可以知道第k层的读取速度更快，因此缓存命中会使得程序更快。</p><h3 id="缓存不命中"><a href="#缓存不命中" class="headerlink" title="缓存不命中"></a>缓存不命中</h3><p>如果第k层没有缓存数据对象d，则称为<strong>缓存不命中（Cache Miss）</strong>，则会从第k+1层中取出包含d的块，然后第k层的缓存会执行某个<strong>放置策略（Placement Policy）</strong>来决定该块要保存在第k层的什么位置</p><ul><li><p>来自第k+1层的任意块能保存在第k层的任意块中，如果第k层的缓存满了，则会覆盖现存的一个<strong>牺牲块（Victim Block）</strong>，称为<strong>替换（Replacing）</strong>或<strong>驱逐（Evicting）</strong>这个牺牲块，会根据<strong>替换策略（Replacement Policy）</strong>来决定要替换第k层的哪个块</p></li><li><ul><li><strong>随机替换策略：</strong>会随机选择一个牺牲块</li><li><strong>最近最少被使用（LRU）替换策略：</strong>选择最后被访问的时间离现在最远的块</li></ul></li></ul><p>随机放置块会使得定位起来代价很高。</p><ul><li>可以采用更严格的放置策略，将第k+1层的某个块限制放置在第k层块的一个小的子集中，比如第k+1层的第i个块保存在第k层的<code>i mod 4</code>中。但是该放置策略会引起<strong>冲突不命中（Conflict Miss）</strong>，此时缓冲区足够大，但是由于需要的对象会反复映射到同一个缓存块，使得缓存一直不命中。此时就需要修改放置策略。</li></ul><p>比较特殊的情况是第k层的缓存为空，那么对于任意的数据对象的访问都会不命中。空的缓存称为<strong>冷缓存（Cold Cache）</strong>，该不命中称为<strong>强制性不命中（Compulsory Miss）</strong>或<strong>冷不命中（Cold Miss）</strong>。</p><p>程序通常会按照一系列阶段来运行，每个阶段会访问缓存块的某个相对稳定不变的集合，则该集合称为<strong>工作集（Working Set）</strong>，如果工作集大小超过缓存大小，则缓存会出现<strong>容量不命中（Capacity Miss）</strong>，这是由缓存太小导致的。</p><h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><p>对于每层存储器，都会有某种形式的逻辑来管理缓存：将缓存划分成块、在不同层之间传递块、判断缓存是否命中并进行处理。</p><ul><li>编译器管理寄存器文件，当寄存器文件中不含有数据时出现不命中，它会决定何时发射加载操作，以及确定用哪个寄存器来存放数据。</li><li>SRAM高速缓存是DRAM主存的缓存，由内置在缓存中的硬件逻辑管理的。</li><li>在有虚拟内存的系统中，DRAM主存是本地磁盘的缓存，由操作系统软件和CPU上的地址翻译硬件共同管理。</li><li>在具有分布式文件系统的机器中，本地磁盘作为缓存，由运行在本地机器上的客户端进程管理。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805213003.jpg" alt="img" style="zoom:80%;" /><p>通过以上内容，就能解释局部性好的程序的优势：</p><ul><li><strong>时间局部性：</strong>当一个数据对象在第一次不命中被复制到缓存中时，我们希望程序的时间局部性好，则在不久的将来就能反复在第k层访问到该块，使得程序运行更快。</li><li><strong>空间局部性：</strong>由于缓存中一个块包含多个数据对象，我们希望程序的空间局部性好，就可以直接利用第k层的数据块，避免再从第k+1层传输块到第k层。</li></ul><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><blockquote><ul><li><p>当高速缓存大小大于数据的大小，如果分配良好，则只会出现冷不命中。</p></li><li><p>缓存不命中比内存访问次数影响更大</p></li><li><p>由内存系统的设计来决定块大小，是内存系统的固定参数。首先决定块大小，然后决定期望的缓存大小，然后再决定关联性，最终就能知道组的数目。</p></li><li><p>块的目的就是利用空间局部性</p></li><li><p>缓存是硬件自动执行的，没有提供指令集对其进行操作</p></li><li><p><strong>建议：</strong></p></li><li><ul><li>将注意力集中在内循环中，因为大部分的计算和内存访问都集中在这里</li><li>按照数据对象存储在内存中的顺序，以步长为1来读数据，使得空间局部性最大。比如步长为2的命中率就比步长为1的命中率降低一半。</li><li>一旦从存储器读入一个数据对象时，就尽可能使用它，使得时间局部性最大。特别是局部变量，编译器会将其保存在寄存器中。</li></ul></li></ul></blockquote><h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>较早期的计算机系统的存储器层次结构只有三层：CPU寄存器、主存和磁盘，但是随着CPU的发展，使得主存和CPU之间的读取速度逐渐拉大，由此在CPU和主存之间插入一个小而快速的SRAM高速缓存存储器，称为<strong>L1高速缓存</strong>，随着后续的发展，又增加了<strong>L2高速缓存</strong>和<strong>L3高速缓存</strong>。</p><h3 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a>通用的高速缓存存储器组织结构</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805213857.jpg" alt="img" style="zoom:80%;" /><p>如上图的b中所示，会将m位的地址划分成三部分：</p><ul><li><strong>s位：</strong>高速缓存被组织成一个数组，而该数组通过$S=2^s$​ 进行索引。</li><li><strong>b位：</strong>每个组中包含E个<strong>高速缓存行（Cache Line）</strong>，每个行有一个$B=2^b$​字节的**数据块（Block)**组成。</li><li><strong>t位：</strong>每一个高速缓存行有一个$t = m - (s+b)$ 位的**标记位（Valid Bit)**，唯一表示存储在这个高速缓存行中的数据块，用于搜索数据块。</li></ul><p>该高速缓存的结构可以通过元组<code>(S, E, B, m)</code>来描述，且容量C为所有块的大小之和，$C = S * E * B$  。</p><p><strong>注意：</strong>如果将组索引放在最高有效位，则连续的内存块就会映射到相同的高速缓存组中，通过将组索引放在中间，可以使得连续的内存块尽可能分散在各个高速缓存组中，可以充分利用各个高速缓存组</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805214444.jpg" alt="img"></p><p>当一条加载指令指示CPU从主存地址A中读取一个字w时，会将该主存地址A发送到高速缓存中，则高速缓存会根据以下步骤判断地址A是否命中：</p><ol><li><strong>组选择：</strong>根据地址划分，将中间的s位表示为无符号数作为组的索引，可得到该地址对应的组。</li><li><strong>行匹配：</strong>根据地址划分，可得到t位的标志位，由于组内的任意一行都可以包含任意映射到该组的数据块，所以就要线性搜索组中的每一行，判断是否有和标志位匹配且设置了有效位的行，如果存在，则缓存命中，否则缓冲不命中。</li><li><strong>字抽取：</strong>如果找到了对应的高速缓存行，则可以将b位表示为无符号数作为块偏移量，得到对应位置的字。</li></ol><p>当高速缓存命中时，会很快抽取出字w，并将其返回给CPU。如果缓存不命中，CPU会进行等待，高速缓存会向主存请求包含字w的数据块，当请求的块从主存到达时，高速缓存会将这个块保存到它的一个高速缓存行中，然后从被存储的块中抽取出字w，将其返回给CPU。</p><p><strong>注意：</strong>为了使得地址中的b位能够编码块偏移量，要求从下一层存储器中，根据块偏移量的值从中截取出块大小的数据块。</p><p>该编码方式具有以下<strong>特点：</strong></p><ul><li>能够通过组索引位来唯一确定高速缓存组</li><li>映射到同一个高速缓存组的块由标志位唯一地标识</li><li>标记位和组索引位能够唯一的表示内存中的每个块</li><li>有可能会存在多个块映射到同一个高速缓存组中（只要地址的组索引相同）</li></ul><p>可以根据每个组的高速缓存行数E，将高速缓存分成不同的类型</p><h4 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h4><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805214613.jpg" alt="img"></p><p>如上图所示，当$E=1$时，高速缓存称为<strong>直接映射高速缓存（Direct-mapped Cache）</strong>，每个高速缓存组中只含有一个高速缓存行。</p><p>当缓存不命中时需要进行缓存行替换，会先从下一层的存储器中请求得到包含目标的块，然后根据地址计算出高速缓存组的索引，然后由于一个组中只含有一个高速缓存行，所以会直接将该块替换当前的块。</p><p>这里需要<strong>注意</strong>的一点是：当程序访问大小为2的幂的数组时，直接映射高速缓存中通常会发生冲突不命中。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805214801.jpg" alt="img"></p><p>如以上代码，该函数具有良好的空间局部性，所以我们期望它的缓存命中率会高一点。</p><p>我们首先假设数组<code>x</code>排在数组<code>y</code>之前，且<code>x</code>的地址从0开始。然后直接映射高速缓存的$b = 4$​ 和$s = 1$​ ，即有两个高速缓存组，每个高速缓存组有一个高速缓存行，每个高速缓存行能保存16字节数据块，即4个浮点数，则高速缓存容量为32字节，我们可以得到高速缓存对地址的划分如下所示（64位系统中)</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805215434.jpg" alt="img" style="zoom:80%;" /><p>然后我们可以根据这两个数组的地址得到它们在高速缓存中的组索引（因为只有一个高速缓存行，所以不考虑标志位）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805215446.jpg" alt="img" style="zoom:80%;" /><p>我们可以发现，循环第一次迭代引用<code>x[0]</code>时，缓存不命中会使得包含<code>x[0]</code><del><code>x[3]</code>的数据块保存到高速缓存组0处，但是当引用<code>y[0]</code>时，会发现高速缓存组0处保存的数据不匹配，又出现了缓存不命中，就会使得包含<code>y[0]</code></del><code>y[3]</code>的数据块保存到高速缓存0处，依次类推。可以发现始终会发生缓存不命中，使得性能下降。这种情况称为<strong>抖动（Thrash）</strong>，即高速缓存反复地加载和驱逐相同的高速缓存块的组。</p><p><strong>可以发现：</strong>即使程序的局部性良好，且工作集的大小没有超过高速缓存容量，但是由于这些数据块都被映射到了相同的高速缓存组中，且直接映射高速缓存每个组中只有一个高速缓存行，所以会出现抖动，不断出现缓存不命中。</p><p>我们这里想要相同所以的<code>x</code>和<code>y</code>可以保存到不同的高速缓存组中，就能避免抖动现象，这里可以在数组<code>x</code>后填充B个字节，使得数组<code>y</code>的地址向后偏移，得到如下形式</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805215631.jpg" alt="img" style="zoom:80%;" /><h4 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h4><p>直接映射高速缓存的冲突不命中是由于每个高速缓存组中只有一个高速缓存行，所以扩大E的值，当$1 &lt; E &lt; C/B$​ 时，称为**E路组相联高速缓存（Set Associative Cache）**，此时需要额外的硬件逻辑来进行行匹配，所以更加昂贵。（ $E &lt; C/B$​ 即要求$S &gt; 1$​  )</p><p>下图所示的就是二路组相连：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220141.jpg" alt="img" style="zoom:80%;" /><p>当缓存不命中时需要进行缓存行替换，如果对应的高速缓存组中有空的高速缓存行，则直接将其保存到空行中。但是如果没有空行，就要考虑合适的<strong>替换策略</strong>：</p><ul><li>最简单的替换策略是随机选择要替换的行</li><li><strong>最不常使用（Least-Frequently-Used，LFU）策略：</strong>替换过去某个时间窗口内引用次数最少的一行。</li><li><strong>最近最少使用（Least-Recently-Used，LRU）策略：</strong>替换最后一次访问时间最久远的那一行</li></ul><h4 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h4><p><strong>全相联高速缓存（Full Associative Cache）</strong>是用一个包含所有高速缓存行的组组成的，其中$E = C/B$​​  ，即 $S = 1$ 。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220231.jpg" alt="img" style="zoom:80%;" /><p>由于全相联高速缓存只有一个组，所以不包含组索引编码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220252.jpg" alt="img" style="zoom:80%;" /><p>其行匹配和字选择与组相联高速缓存相同，只是规模大小不同。想要得到高速的全相联高速缓存十分困难，所以通常适合用于较小的高速缓存，比如虚拟内存中的翻译备用缓冲器（TLB）。</p><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>当CPU想要对地址A进行写操作时，会通过地址A判断是否缓存了该地址，如果缓存了称为<strong>写命中（Write Hit）</strong>，否则称为<strong>写不命中（Write Miss）</strong>。</p><ul><li><p><strong>写命中：</strong>高速缓存会先更新缓存的副本，然后可以采取不同方法更新下一层的副本</p><ul><li><p><strong>直写（Write-Though）：</strong>立即更新下一层的副本值。缺点是每次写都会引起总线流量。</p></li><li><p><strong>写回（Write-Back）：</strong>为每个高速缓存行维护一个<strong>修改位（Dirty Bit）</strong>，表明这个高速缓存块是否被修改。当被修改的高速缓存块被驱逐时，会查看修改位，判断该块是否被修改，只有被修改才会更新下一层的副本值。能够显著减少总线流量，但是复杂性高。</p></li></ul></li><li><p><strong>写不命中：</strong></p><ul><li><p><strong>写不分配（Not-Write-Allocate）：</strong>直接将字写到下一层中。</p></li><li><p><strong>写分配（Write-Allocate）：</strong>加载相应的下一层的块到当前层的高速缓存中，然后更新当前高速缓存块。得益于空间局部性，进行一次写分配后，下一次有较高几率会写命中，但是缺点是每次写不命中就要将块从第一层向上传输。</p></li></ul></li></ul><p>直写高速缓存通常为写不分配的，写回高速缓存通常为写分配的。</p><p>建议采用写回写分配模型，因为随着逻辑电路密度的提高，写回的复杂性不再成为阻碍，并且和处理读相同，都利用了局部性原理，效率较高。</p><h3 id="真实高速缓存结构"><a href="#真实高速缓存结构" class="headerlink" title="真实高速缓存结构"></a>真实高速缓存结构</h3><p>之前介绍的高速缓存值保存程序数据，但是高速缓存同样也能保存指令。可以将高速缓存分成以下几种：</p><ul><li><strong>i-cache：</strong>只保存指令的高速缓存</li><li><strong>d-cache：</strong>只保存程序数据的高速缓存</li><li><strong>Unified Cache：</strong>即能保存指令，也能保存程序数据的高速缓存</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220554.jpg" alt="img" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220604.jpg" alt="img"></p><p>如上图所示是Intel Core i7的高速缓存层次结构，可以发现在L1高速缓存中分成了L1 d-cache和L1 i-cache，这样做的<strong>好处在于：</strong></p><ol><li>将数据和指令分别保存在两个高速缓存中，使得处理器可以同时读一个指令字和一个数据字</li><li>i-cache通常是只读的，所以会比较简单</li><li>可以针对不同的访问模式优化这两个高速缓存，使用不同的块大小、相联度和容量</li><li>确保数据访问和指令访问之间不形成冲突不命中</li></ol><p>代价就是会导致高速缓存容量变小，提高出现容量不命中的可能性。</p><h3 id="参数对性能的影响"><a href="#参数对性能的影响" class="headerlink" title="参数对性能的影响"></a>参数对性能的影响</h3><p>衡量高速缓存的指标有：</p><ul><li><strong>命中率（Hit Rate）：</strong>内存引用命中的比率，<code>命中数量/引用数量</code>。</li><li><strong>不命中率（Miss Rate）：</strong>内存引用不命中的比率，<code>不命中数量/引用数量</code>。通常，L1高速缓存为3~10%，L2高速缓存为&lt;1%。</li><li><strong>命中时间（Hit Time）：</strong> 从高速缓存传输一个字到CPU的时间，包括组选择、行匹配和字选择时间。通常，L1高速缓存需要4个时钟周期，L2高速缓存需要10个时钟周期。</li><li><strong>不命中处罚（Miss Penalty）：</strong>当缓存不命中时，要从下一层的存储结构中传输对应块到当前层中，需要额外的时间（不包含命中时间）。通常，主存需要50~200个时钟周期。</li></ul><p><strong>注意：</strong>命中和不命中两者对性能影响很大，比如99%命中率的性能会比97%命中率高两倍。</p><p>接下来讨论高速缓存中不同参数对高速缓存性能的影响：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220704.jpg" alt="img" style="zoom: 50%;" /><p>想要编写高速缓存友好（Cache Friendly）的代码，<strong>基本方法为：</strong></p><ul><li>让最常见的情况运行得快，将注意力集中在核心函数的循环中</li><li>尽可能减少每个循环内部的缓存不命中，可以对局部变量反复引用，因为编译器会将其保存到寄存器中，其他的变量最好使用步长为1的引用模式。</li></ul><p><strong>可以看书中的练习题6.17探讨缓存命中和不命中的情况</strong>。</p><h2 id="存储器山"><a href="#存储器山" class="headerlink" title="存储器山"></a>存储器山</h2><p>一个程序从存储器系统中读取数据的速率称为<strong>读吞吐量（Read Throughput）</strong>或<strong>读带宽（Read Bandwidth）</strong>，单位为<code>MB/s</code>。 我们通过以下代码来衡量空间局部性和时间局部性对程序吞吐量的影响</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220940.jpg" alt="img" style="zoom:67%;" /><p>第37行我们首先对高速缓存进行暖身，然后在第38行计算程序运行的时钟周期个数。</p><ul><li><strong>时间局部性：</strong>通过<code>size</code>来控制我们工作集的大小，由此来控制工作集存放的高速缓存的级别。假设工作集很小，则工作集会全部存放在L1高速缓存中，模拟了时间局部性优异的程序反复读取之前访问过的数据，则都是从L1高速缓存读取数据的。假设工作集很大，则工作集会存放到L3高速缓存中，模拟了时间局部性很差的程序，不断读取新的数据，则会出现缓存不命中，而不断从L3高速缓存中取数据的过程。所以通过控制工作集大小，来模拟程序局部性。</li><li><strong>空间局部性：</strong>通过<code>stride</code>来控制读取的步长，来控制程序的空间局部性。</li></ul><p>通过调整<code>size</code>和<code>stride</code>来度量程序的吞吐量，可以得到以下存储器山（Memory Mountain）</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805220959.jpg" alt="img" style="zoom:80%;" /><p>可以保持<code>stride</code>不变，观察高速缓存的大小和时间局部性对性能的影响</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805221029.jpg" alt="img" style="zoom:80%;" /><p>可以发现，当工作集大小小于L1高速缓存的大小时，模拟了时间局部性很好的程序，所有读都是直接在L1高速缓存中进行的，则吞吐量较高；当工作集大小较大时，模拟了时间局部性较差的程序，读操作需要从更高的高速缓存中加载，则吞吐量下降了。</p><p>可以保持工作集为4MB，沿着L3山脊查看空间局部性对性能的影响</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805221037.jpg" alt="img" style="zoom:80%;" /><p>可以发现，步长越小越能充分利用L1高速缓存，使得吞吐量较高。当步长为8字节时，会跨越64字节，而当前高速缓存的块大小只有64字节，说明每次读取都无法在L2高速缓存中命中，都需要从L3高速缓存读取，所以后续保持不变。</p><p><strong>综上所述：</strong>需要利用时间局部性来访问L1高速缓存，还需要利用空间局部性，使得尽可能多的字从一个高速缓存行中读取到。</p><h2 id="改善程序"><a href="#改善程序" class="headerlink" title="改善程序"></a>改善程序</h2><h3 id="重新排列循环来改善空间局部性"><a href="#重新排列循环来改善空间局部性" class="headerlink" title="重新排列循环来改善空间局部性"></a>重新排列循环来改善空间局部性</h3><p>我们可以有不同的循环方式来实现矩阵乘法</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805221615.jpg" alt="img" style="zoom: 50%;" /><p>假设每个块中能保存4个元素，则可以分析每个变量的命中率</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805221631.jpg" alt="img" style="zoom:80%;" /><p>说明我们可以对循环重排列，来提高空间局部性，增加命中率。</p><h3 id="使用分块来提高时间局部性"><a href="#使用分块来提高时间局部性" class="headerlink" title="使用分块来提高时间局部性"></a>使用分块来提高时间局部性</h3><p>分块的主要思想是将一个程序中的数据结构组织成大的<strong>片（Chunk）</strong>，使得能够将一个片加载到L1高速缓存中，并在这个偏重进行读写。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805223026.jpg" alt="img"></p><p>如上图所示是一个普通的矩阵乘法函数，这里将二维数组想象成一个连续的字节数组，通过显示计算偏移量进行计算。这里假设每个块中可保存8个元素，并且高速缓存容量远小于矩阵的行列数。</p><p>每一次迭代就计算一个C的元素值，我们分析每一次迭代的不命中次数</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805223049.jpg" alt="img"></p><p>对于矩阵<code>a</code>，一次会保存行的8个元素到块中，则一行元素一共会有<code>n/8</code>次不命中。对于矩阵<code>b</code>，因为是列优先读取的，所以无法利用高速缓存中保存的块，所以一行元素会有n次不命中。则一共会有<code>9n/8</code>次不命中，对于C中的<code>n*n</code>个元素，一共会有 <img src="https://www.zhihu.com/equation?tex=9n%5E3/8" alt="[公式]"> 次不命中。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805223055.jpg" alt="img"></p><p>如上图所示是使用分块技术实现的矩阵乘法，将矩阵乘法分解为若干个<code>BxB</code>小矩阵的乘法，每次能将一个<code>BxB</code>的小矩阵加载到缓存中。</p><p>每一次迭代就计算C中一个<code>BxB</code>大小的块，我们分析每一次迭代的不命中次数</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210805223108.jpg" alt="img"></p><p>每个块有$B^2/8$ 次不命中次数，而每一行每一列有<code>n/B</code>个块，所以计算一次C中的一个块会有$2n/B * B^2/8 = nB/4$  次不命中，则一共会有 $nB/4 * (n/B)^2 = n^3/(4B)$​ 次不命中，我们就能调整B的大小来减小不命中率。</p><p>分块降低不命中率是因为加载一个块后，就反复使用该块，提高了空间局部性。</p><blockquote><p>分块技术的介绍：<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf">http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf</a></p></blockquote><p><strong>建议：</strong></p><ul><li>将注意力集中在内循环中，因为大部分的计算和内存访问都集中在这里</li><li>按照数据对象存储在内存中的顺序，以步长为1来读数据，使得空间局部性最大。比如步长为2的命中率就比步长为1的命中率降低一半。</li><li>一旦从存储器读入一个数据对象时，就尽可能使用它，使得时间局部性最大。特别是局部变量，编译器会将其保存在寄存器中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器层次结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csappECF：信号和非本地跳转（八）</title>
      <link href="2021/08/04/csapp/csappECF%EF%BC%9A%E4%BF%A1%E5%8F%B7%E5%92%8C%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>2021/08/04/csapp/csappECF%EF%BC%9A%E4%BF%A1%E5%8F%B7%E5%92%8C%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>这一章将讨论一种更高层次的软件形式的异常，称为Linux<strong>信号</strong>。信号就是一条小消息，可以通知系统中发生了一个某种类型的事件，<strong>比如：</strong></p><ul><li>内核检测到了一个系统事件，比如除零错误、执行非法指令或子进程终止，低层次的硬件异常都是由内核异常处理程序处理的，对用户进程是不可见的，但是可以通过给用户进程发送信号的形式来告知，比如除零错误就发送<code>SIGFPE</code>信号，执行非法指令就发送<code>SIGILL</code>信号，子进程终止内核就发送<code>SIGHLD</code>到父进程中，则此时父进程就能对该子进程调用<code>waitpid</code>来进行回收。</li><li>内核或其他进程出现了较高层次的软件事件，比如输入组合键，或一个进程尝试终止其他进程，都是显示要求内核发送一个信号给目标进程，比如输入组合键内核会发送<code>SIGINT</code>信号给所有进程，进程可以发送<code>SIGKILL</code>信号给别的进程来进行终止。</li></ul><p><strong>注意：</strong>与异常机制很类似，只是异常是由硬件和软件共同实现的，而信号时完全由软件实现的，且都是由内核进行发送的。</p><p>所以信号可以是内核检测到事件来发送到目标进程，也可以是其他进程通过内核来发送信号到目标进程。如下所示是Linux系统上支持的不同类型的信号，每种信号类型都对应某种系统事件</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804102632.jpg" alt="img" style="zoom:67%;" /><ul><li><code>SIGINT</code>：当用户输入<code>Ctrl+C</code>时，内核会向前台作业发送<code>SIGINT</code>信号，该信号默认终止该作业。</li><li><code>SIGTSTP</code>：当用户输入<code>Ctrl+Z</code>时，内核会向前台作业发送<code>SIGTSTP</code>信号，默认停止作业，可通过发送<code>SIGCONT</code>信号来恢复该作业。</li><li><code>SIGKILL</code>：该信号的默认行为是用来终止进程的，无法被修改或忽略。</li><li><code>SIGSEGV</code>：当你试图访问受保护的或非法的内存区域，就会出现段错误，内核会发送该信号给进程，默认终止该进程。</li><li><code>SIGCHLD</code>：当子进程终止或停止时，内核会发送该信号给父进程，由此父进程可以对子进程进行回收。</li></ul><p>传送一个信号到目的进程是由两个步骤组成的：</p><ul><li><strong>发送信号：</strong>内核通过更新目的进程上下文中的某个状态，来表示发送了一个信号到目的进程，所以这里除了目标进程上下文中的一些位被改变了，其他没有任何变化。</li><li><strong>接收信号：</strong>当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接受了信号。比如忽略信号、终止进程，或执行用户级的<strong>信号处理程序（Signal Handler）</strong>来捕获信号。</li></ul><p><strong>注意：</strong>执行信号处理程序类似于执行异常处理程序，只是异常处理程序是内核级别的，而信号处理程序就只是你的C代码程序。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804102705.jpg" alt="img" style="zoom:80%;" /><p>当执行完信号处理程序后，会返回到下一条指令继续执行，类似于一次中断。</p><p>我们将发送了但是还没被接收的信号称为<strong>待处理信号（Pending Signal）</strong>，而进程可以选择阻塞接收某种信号，则该信号可以被发送，但是在阻塞解除前无法被目标进程处理。我们可以发现不同的信号具有不同的编码，所以内核为每个进程在** <code> pending</code>位向量<strong>中维护待处理信号的集合，根据信号的编号来设置对应位的值，来传送信号，当进程接收了该信号，就会将其从<code>pending</code>位向量中重置该位的值；也为每个进程在</strong> <code>blocked</code>位向量 **中维护了被阻塞的信号集合，可以通过查看位向量对应的位来确定该信号是否被阻塞。</p><p><strong>注意：</strong>通过位向量的形式来保存待处理信号和被阻塞信号，可以发现每种类型的信号最多只会有一个待处理信号，并且一个待处理信号只能被接受一次。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>Unix基于<strong>进程组（Process Group）</strong>的概念，提供了大量向进程发送信号的机制。</p><p>进程组由一个正整数<strong>进程组ID</strong>来标识，每个进程组包含一个或多个进程，而每个进程都只属于一个进程组，默认父进程和子进程属于同一个进程组。我们将shell为了对一条命令行进行求值而创建的进程称为<strong>作业（Job）</strong>，比如输入<code>ls / sort</code>命令行，就会创建两个进程，分别运行<code>ls</code>程序和<code>sort</code>程序，这两个进程通过Unix管道连接到一起，由此就得到了一个作业。<strong>注意：</strong></p><ul><li>任何时刻，最多只有一个前台作业和任意数量的后台作业。</li><li>shell会为每个作业创建一个独立的进程组，该进程组ID由该作业中任意一个父进程的PID决定。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804103235.jpg" alt="img" style="zoom:80%;" /><p>这里提供了以下对进程组的操作，允许你可以同时给一组进程发送信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//返回所在的进程组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgip</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>; <span class="comment">//设置进程组, 将进程pid的进程组改为pgid</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 如果pid大于零，就使用进程pid；如果pid等于0，就使用当前进程的PID。</span></span><br><span class="line"><span class="comment"> * 如果pgid大于0，就将对应的进程组ID设置为pgid；如果pgid等于0，就用pid指向的进程的PID作为进程组ID</span></span><br><span class="line"><span class="comment"> */</span> </span><br></pre></td></tr></table></figure><ul><li><strong>用<code>/bin/kill</code>向进程发送任意信号</strong></li></ul><p>程序<code>/bin/kill</code>具有以下格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/<span class="built_in">kill</span> [-信号编号] id  </span><br></pre></td></tr></table></figure><p>当<code>id&gt;0</code>时，表示将信号传递给PID为<code>id</code>的进程；当<code>id&lt;0</code>时，表示将信号传递给进程组ID为<code>|id|</code>的所有进程。我们可以通过制定信号编号来确定要传输的信号，默认使用<code>-15</code>，即<code>SIGTERM</code>信号，为软件终止信号。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804103932.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>从键盘发送信号</strong></li></ul><p>通过键盘上输入<code>Ctrl+C</code>会使得内核发送一个<code>SIGINT</code>信号到前台进程组中的所有进程，终止前台作业；通过输入<code>Ctrl+Z</code>会发送一个<code>SIGTSTP</code>信号到前台进程组的所有进程，停止前台作业，直到该进程收到<code>SIGCONT</code>信号。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804103946.jpg" alt="img" style="zoom: 50%;" /><p><code>ps</code>命令可以查看进程的信息，<code>STAT</code>表示进程的状态：<code>S</code>表示进程处于睡眠状态，<code>T</code>表示进程处于停止状态，<code>R</code>表示进程处于运行状态，<code>Z</code>表示僵死进程，而<code>+</code>表示前台作业。</p><p>在以上代码中，我们输入<code>Ctrl-Z</code>，可以发现两个<code>fork</code>进程的状态变成了停止状态了，通过输入<code>fg</code>命令可以将这些被挂起的进程恢复到前台运行，再通过<code>Ctrl+C</code>可以停止这两个前台进程。</p><ul><li><strong>用<code>kill</code>函数发送信号</strong></li></ul><p>可以在函数中调用<code>kill</code>函数来对目的进程发送信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>; </span><br></pre></td></tr></table></figure><p>当<code>pid&gt;0</code>时，会将信号<code>sig</code>发送给进程<code>pid</code>；当<code>pid=0</code>时，会将信号<code>sig</code>发送给当前进程所在进程组的所有进程；当<code>pid&lt;0</code>时，会将信号<code>sig</code>发送给进程组ID为<code>|pid|</code>的所有进程。</p><ul><li><strong>用<code>alarm</code>函数发送<code>SIGALARM</code>信号</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>; </span><br></pre></td></tr></table></figure><p>当<code>alarm</code>函数时，会取消待处理的闹钟，返回待处理闹钟剩下的时间，并在<code>secs</code>秒后发送一个<code>SIGALARM</code>信号给当前进程。</p><h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核把进程p从内核模式切换回用户模式时，比如从系统调用返回或完成了一次上下文切换时，会检查进程p的未被阻塞的待处理信号的集合，即<code>pending &amp; ~blocked</code>，如果是空集合，则内核会将控制传递给p的逻辑流中的下一条指令，如果集合非空，则内核会选择集合中编号最小的信号k（所以我们需要根据优先级来排列信号），强制进程p采取某些行为来接收该信号，对该集合中的所有信号都重复这个操作，直到集合为空，此时内核再将控制传递回p的逻辑流中的下一条指令。</p><blockquote><p>每次从内核模式切换回用户模式，将处理所有信号</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-87e94740120e138a0a861452afdfb060_720w.jpg" alt="img"></p><p>每种信号类型具有以下一种预定的<strong>默认行为：</strong></p><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程挂起直到被<code>SIGCONT</code>信号重启</li><li>进程忽略信号</li></ul><p>我们这里可以通过<code>signal</code>函数来修改信号的默认行为，但是无法修改<code>SIGSTOP</code>和<code>SIGKILL</code>信号的默认行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>signum</code>为信号编号，可以直接输入信号名称</p></li><li><p><code>handler</code>为我们想要对信号<code>signum</code>采取的行为</p></li><li><ul><li>当<code>handler</code>为<code>SIG_IGN</code>，表示要进程忽略该信号</li><li>当<code>handler</code>为<code>SIG_DFL</code>，表示要恢复该信号的默认行为</li><li>当<code>handler</code>为用户自定义的<strong>信号处理程序</strong>地址，则会调用该函数来处理该信号，该函数原型为<code>void signal_handler(int sig);</code>。调用信号处理程序称为<strong>捕获信号</strong>，置信信号处理程序称为<strong>处理信号</strong>。当信号处理程序返回时，会将控制传递回逻辑流中的下一条指令。<strong>注意：</strong>信号处理程序可以被别的信号处理程序中断。</li></ul></li><li><p>当<code>signal</code>函数执行成功，则返回之前<code>signal handler</code>的值，否则返回<code>SIG_ERR</code></p></li></ul><p><strong>例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(signal(SIGCHLD, handler) == SIG_ERR)</span><br><span class="line">    unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只要在<code>main</code>函数开始调用一次<code>signal</code>，就相当于从此以后改变了<code>SIGCHLD</code>信号的默认行为，让它去执行<code>handler</code>处理程序。当子进程终止或停止时，发送<code>SIGCHLD</code>信号到父进程，则父进程会调用<code>handler</code>函数来对该子进程进行回收。</p><h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2><p>Linux提供阻塞信号的隐式和显示的机制：</p><ul><li><strong>隐式阻塞机制：</strong>内核默认阻塞当前正在处理信号类型的待处理信号。</li><li><strong>显示阻塞机制：</strong>应用程序通过<code>sigprocmask</code>函数来显示阻塞和解阻塞选定的信号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>how</code>来决定如何改变阻塞的信号集合<code>blocked</code></p></li><li><ul><li>当<code>how=SIG_BLOCK</code>时，<code>blocked = blocked | set</code></li><li>当<code>how=SIG_UNBLOCK</code>时，<code>blocked = blocked &amp; ~set</code></li><li>当<code>how=SETMASK</code>时，<code>block = set</code></li></ul></li><li><p>如果<code>oldset</code>非空，则会将原始的<code>blocked</code>值保存在<code>oldset</code>中，用于恢复原始的阻塞信号集合</p></li></ul><p>这里还提供一些额外的函数来对<code>set</code>信号集合进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; <span class="comment">//初始化set为空集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; <span class="comment">//把每个信号都添加到set中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>; <span class="comment">//将signum信号添加到set中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>; <span class="comment">//将signum从set中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>; <span class="comment">//如果signum是set中的成员，则返回1，否则返回0</span></span><br></pre></td></tr></table></figure><p>以下是一个使用例子</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804105217.jpg" alt="img" style="zoom:80%;" /><p>以上执行内部函数时，就不会接收到<code>SIGINT</code>信号，即不会被<code>Ctrl+C</code>终止。</p><p>通过阻塞信号来消除函数冲突，或者保证程序运行逻辑正确。</p><h1 id="信号处理程序"><a href="#信号处理程序" class="headerlink" title="信号处理程序"></a>信号处理程序</h1><p>我们之前已经看过了进程之间的并发了，只要两个进程的逻辑流在时间上是重叠的，则这两个进程的逻辑流是并发流。由于进程有各自独立的地址空间，所以比较不用担心一个进程受到别的进程的影响，所以并发流不会互相妨碍。</p><p>而信号也是并发的一个例子，信号处理程序是一个独立的逻辑流（不是进程），与主程序并发运行。比如我们在进程A中执行一个<code>while</code>循环，当该进程受到一个信号时，内核会将控制权转移给该信号的处理程序，所以该信号处理程序是并发执行的，当信号处理程序结束时，再将控制转移给主程序。由于信号处理程序与主程序在同一进程中，所以具有相同的上下文，所以会共享程序中的所有全局变量。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804105601.jpg" alt="img" style="zoom:80%;" /><p><strong>注意：</strong>信号处理程序与主程序在相同进程中并发执行。</p><p>将信号处理程序看成并发流的另一种方式是使用上下文切换图。当有个信号传递给进程A时，只是简单的设置了<code>pending</code>位向量对应的位，并不会有额外操作，当进程A后面执行上下文切换，到达进程B后，进程B执行若干指令后，通过上下文切换到达进程A，此时就会根据<code>pending</code>位向量记录的未处理信号集合来依次调用对应的信号处理程序，过后再将其传递到下一条指令的地址。所以信号处理程序和其他程序都处于相同的进程中。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804105609.jpg" alt="img" style="zoom:80%;" /><p>信号发送的对象是进程，因为信号处理程序执行在相同的进程中，所以当该进程接收到信号时，信号处理程序是可以被别的信号处理程序中断的，构成以下多层嵌套的信号处理程序，由于这些信号处理程序和主程序处于相同的进程中，所以共享相同的全局变量，这就使得全局变量的状态较难控制。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804105619.jpg" alt="img" style="zoom:80%;" /><h2 id="安全的信号处理"><a href="#安全的信号处理" class="headerlink" title="安全的信号处理"></a>安全的信号处理</h2><p>信号处理的一个<strong>难点在于：</strong>处理程序与主程序在同一进程中是并发运行的，它们共享同样的全局变量，可能会与主程序和其他处理程序相互干扰。这里推荐一系列措施来进行安全的信号处理：</p><ul><li><p><strong>G0：</strong>处理程序要尽可能简单。</p></li><li><ul><li>当处理程序尽可能简单时，就能避免很多错误。<strong>推荐做法：</strong>处理程序修改全局标志指示出现的信号，然后直接返回，主程序会周期性检查并重置这个全局标志。</li></ul></li><li><p><strong>G1：</strong>在处理程序中调用异步信号安全的函数。</p></li><li><ul><li>异步信号安全的函数能被处理程序安全地调用，因为它是可重入的（比如所有变量都是保存在栈上的局部变量），或不能被信号处理程序中断的。Linux中保证安全的系统级函数如下所示，<strong>注意：</strong><code>printf</code>，<code>sprintf</code>，<code>malloc</code>和<code>exit</code>是不安全的，而<code>write</code>是安全的。</li></ul></li><li><p><strong>G2：</strong>保存和恢复<code>errno</code></p></li><li><ul><li>全局变量<code>errno</code>在系统级函数出现错误时才会被赋值，许多Linux异步信号安全的函数都会在出错时返回并设置<code>errno</code>，当处理程序要返回时，最好提前将<code>errno</code>保存为局部变量，再在返回时重置<code>errno</code>，使得主程序可以使用原本的<code>errno</code>。</li></ul></li><li><p><strong>G3：</strong>阻塞所有的信号，保护对共享全局数据结构的访问</p></li><li><ul><li>对于数据结构的访问（读取或写入），可能需要若干条指令，当主程序在访问全局数据结构中途被中断，进入处理程序时，如果处理程序也访问当前数据结构，可能会发现该数据结构的状态是不一致的。所以对全局数据结构进行访问时，要阻塞所有的信号（无论在主程序还是信号处理程序中）。</li></ul></li><li><p><strong>G4：</strong>用<code>volatile</code>声明在主程序和信号处理程序共享的全局变量</p></li><li><ul><li>比如G0说的使用全局变量来保存标志，处理程序更新标志，主程序周期性读取该标志，编译器可能会感觉主程序中该标注没有变化过，所以直接将其值缓存在寄存器中，则主程序就无法读取到处理程序的更新值。所以我们需要使用<code>volatile</code>来声明该标志，使得编译器不会缓存该变量，使得主程序每次都从内存中读取该标志。</li></ul></li><li><p><strong>G5：</strong>用<code>sig_atomic_t</code>声明那些仅进行读写操作，不会进行增量或更新操作的变量</p></li><li><ul><li>通过使用C提供的整型数据类型<code>sig_atomic_t</code>来声明变量，使得对它的读写都是原子的，不会被中断，所以就不需要暂时阻塞信号了。大多数系统中，<code>sig_atomic_t</code>是<code>int</code>类型。<strong>注意：</strong>对原子性的保证只适用于单个读和写，不适用于<code>flag++</code>或<code>flag+=1</code>这类操作。</li></ul></li></ul><p><strong>综上所述：</strong>是处理函数尽可能简单，在处理程序中调用安全函数，保存和恢复<code>errno</code>，保护对共享数据结构的访问，使用<code>volatile</code>和<code>sig_atomic_t</code>。</p><h2 id="正确的信号处理"><a href="#正确的信号处理" class="headerlink" title="正确的信号处理"></a>正确的信号处理</h2><p>在信号处理中，还存在一个<strong>问题：</strong>我们这里使用<code>pending</code>位向量来保存未处理的信号集合，当处理程序处理信号时，就会将其从该集合中删除，但是由于是位向量形式，所以当集合中存在信号k时，就不会再接收信号k了，<strong>意味着：</strong>如果存在一个未处理的信号k，则表明至少有一个信号k到达，所以我们不能通过信号来对其他进程中发生的事件进行记数，我们要使得处理程序一次能够执行尽可能多的操作。</p><p>比如主程序通过接收<code>SIGCHLD</code>信号来回收子程序，不正确的处理程序是如下形式的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler1</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child %d\n&quot;</span>, (<span class="keyword">int</span>)pid);</span><br><span class="line">    Sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler1) == SIG_ERR)</span><br><span class="line">unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent creates children */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from child %d\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent waits for terminal input and then processes it */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果众多子进程一次性发送过多的<code>SIGCHLD</code>信号给父进程，当父进程还在信号处理程序时，就会丢失若干个<code>SIGCHLD</code>信号，使得无法得到正确的回收子进程的数目，可以改成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler2</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Handler reaped child %d\n&quot;</span>, (<span class="keyword">int</span>)pid);</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main函数中handler1改为handler2，其余不变</span></span><br></pre></td></tr></table></figure><p>这里我们假设接收到一个<code>SIGCHLD</code>信号意味着有多个信号被终止或停止，所以通过<code>while</code>循环来回收所有的进程，此时就不会遗漏子进程的回收。</p><p><strong>例：</strong>判断下列程序的输出</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804111305.jpg" alt="img" style="zoom: 67%;" /><p>这里需要注意以下几点：</p><ul><li>在23行捕获一个<code>SIGUSR1</code>信号，此时还没有到<code>fork</code>函数，所以是父进程和子进程共享的代码，所以父进程和所有子进程都要捕获这个信号。</li><li>在27行父进程给子进程发送<code>SIGUSR1</code>信号，当子进程捕获到这个信号时，会跳转到执行<code>handler1</code>函数，这里对全局共享的变量的访问要阻塞信号。然后通过安全的<code>_exit(0)</code>终止子进程。</li><li><strong>注意：</strong>通过<code>fork</code>函数创建的子进程，具有和父进程相似但独立的地址空间，意味着在子进程中<code>--counter</code>，并不会影响父进程中的<code>counter</code>值。</li></ul><h2 id="可移植的信号处理"><a href="#可移植的信号处理" class="headerlink" title="可移植的信号处理"></a>可移植的信号处理</h2><p>信号处理的另一个<strong>缺陷</strong>是：不同的系统有不同的信号处理语义，比如：</p><ul><li><code>signal</code>函数的语义各不相同，有的Unix系统，当处理完信号时，就会将对该信号的处理恢复为默认行为。</li><li>存在一些潜在的会阻塞进程较长时间的系统调用，称为<strong>慢速系统调用</strong>，比如<code>read</code>、<code>write</code>或<code>accpet</code>。在执行慢速系统调用时，如果进程接收到一个信号，可能会中断该慢速系统调用，并且当信号处理程序返回时，无法继续执行慢速系统调用，而是返回一个错误条件，并将<code>errno</code>设置为<code>EINTR</code>。</li></ul><p>这些可以通过<code>sigaction</code>函数来明确信号处理语义，由于该函数的复杂性，提供一个封装好的函数</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804111627.jpg" alt="img" style="zoom:80%;" /><p>可以类似<code>signal</code>函数那样使用，信号处理语义为：</p><ul><li>只有当前信号处理程序正在处理的信号类型会被阻塞</li><li>只要可能，被中断你的系统调用会自动重启</li><li>一旦设置了信号处理程序，就会一直保持</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="同步流来消除并发错误"><a href="#同步流来消除并发错误" class="headerlink" title="同步流来消除并发错误"></a>同步流来消除并发错误</h3><p>并发流可能以任何交错方式运行，所以信号发送的时机很难预测，可能会出现错误，所以需要首先对目标信号进行阻塞，先执行预定操作，然后将其解阻塞进行捕获。比如以下代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804111721.jpg" alt="img" style="zoom:67%;" /><p>如果缺少30和32行，则<code>addjob</code>函数和<code>deletejob</code>函数之间存在竞争，必须在<code>deletejob</code>函数之前调用<code>addjob</code>函数，否则在<code>deletejob</code>函数中通过<code>waitpid</code>函数释放了子进程，过后调用<code>addjob</code>函数就会出错（将一个不存在的子进程添加到作业列表中）。但是由于内核调度进程是不可控的，以及<code>SIGCHLD</code>信号的发送时机是不确定的，所以可能出现这个错误。可以如上所示，在主进程中先对<code>SIGCHLD</code>信号进行阻塞，在执行完<code>addjob</code>函数后再解阻塞，保证了先执行<code>addjob</code>函数再执行<code>deletejob</code>函数。</p><p><strong>经验之谈：</strong>不要对代码做任何假设，比如子进程运行到这里才终止。</p><p><strong>注意：</strong>可以通过阻塞信号来控制信号的接收时机。</p><h3 id="显示等待信号"><a href="#显示等待信号" class="headerlink" title="显示等待信号"></a>显示等待信号</h3><p>当我们想要主进程显示等待某个信号时，可以用以下代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804111854.jpg" alt="img" style="zoom:80%;" /><p>这里主进程会显示等待子进程被回收，这里使用了<code>sigsuspend(&amp;mask)</code>函数，它等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure><p>但是它是这三条代码的原子版本，即第一行和第二行是一起调用的，则<code>SIGCHLD</code>信号不会出现在第一行和第二行之间，造成程序不会停止。</p><p><strong>注意：</strong>第26行要先对<code>SIGCHLD</code>信号进行阻塞，防止过早发送给主进程，则<code>pause</code>函数就无法中断，就会使得程序不会停止。</p><h1 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h1><p>C语言提供了一种用户级异常控制流形式，称为<strong>非本地跳转（Nonlocal Jmup）</strong>，它可以直接将控制从一个函数转移到另一个当前正在执行的函数，不需要经过调用-返回。</p><p>这里需要两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br></pre></td></tr></table></figure><p>我们首先需要定义一个<code>jmp_buf</code>类型的全局变量<code>env</code>，通过调用<code>setjmp(env)</code>，能将当前调用环境保存到<code>env</code>中，包括程序计数器、栈指针和通用目的寄存器，而<code>setjmp</code>函数会返回0。而后我们在代码某处调用<code>longjmp(env, retval)</code>，会从<code>env</code>中恢复调用环境，并跳转到最近一次初始化<code>env</code>的<code>setjmp</code>函数，让<code>setjmp</code>函数返回<code>retval</code>。</p><p>接下来介绍非本地跳转的两个应用</p><h2 id="无需解析调用栈，直接从深层嵌套函数中返回"><a href="#无需解析调用栈，直接从深层嵌套函数中返回" class="headerlink" title="无需解析调用栈，直接从深层嵌套函数中返回"></a>无需解析调用栈，直接从深层嵌套函数中返回</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804112331.jpg" alt="img" style="zoom:80%;" /><p>在<code>main</code>函数中，首先在12行中执行<code>setjmp(buf)</code>函数将当前调用环境保存到<code>buf</code>中，并返回0，所以就调用<code>foo</code>函数和<code>bar</code>函数，当这两个函数中出现错误，则通过<code>longjmp(buf, retval)</code>恢复调用环境，并跳转回第13行，然后让<code>setjmp</code>函数返回<code>retval</code>的值，由此就无需解析调用栈了。但是该方法可能存在内存泄露问题（例如，中间函数调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而产生内存泄漏）。</p><h2 id="控制信号处理程序结束后的位置"><a href="#控制信号处理程序结束后的位置" class="headerlink" title="控制信号处理程序结束后的位置"></a>控制信号处理程序结束后的位置</h2><p>在信号处理中也有对应的两个非本地跳转的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglomgjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> retval)</span></span>; </span><br></pre></td></tr></table></figure><p>其中<code>sigsetjmp</code>函数还会将待处理信号和被阻塞信号保存到<code>env</code>中。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804112357.jpg" alt="img" style="zoom:80%;" /><p>首先，在<code>main</code>函数中第12行通过<code>sigsetjmp</code>函数将调用环境保存到<code>buf</code>中，并返回0，随后设置信号处理程序。当用户输入<code>Ctrl+C</code>时，会调用信号处理程序<code>handler</code>，此时会通过<code>siglongjmp</code>恢复调用环境，然后跳转回第12行，然后让<code>sigsetjmp</code>返回<code>1</code>，此时就避免了返回到中断的下一条指令处。</p><p><strong>注意：</strong><code>signal</code>要在<code>sigsetjmp</code>之内，避免还未设置<code>sigsetjmp</code>就接收到信号而执行<code>siglongjmp</code>。</p><p>该程序的执行结果为</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210804112417.png" alt="img"></p><p><strong>问题：</strong>  <code>siglongjmp</code>函数会恢复调用环境，再返回到<code>sigsetjmp</code>处。而调用<code>sigsetjmp</code>时还未设置<code>SIGINT</code>信号的处理函数，那么调用环境中应该也不包含该信号处理函数吧？那么<code>siglongjmp</code>函数恢复调用环境后，应该就不会用<code>handler</code>来处理<code>SIGINT</code>信号了吧？</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
            <tag> 非本地跳转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csappECF：异常和进程（八）</title>
      <link href="2021/08/04/csapp/csappECF%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>2021/08/04/csapp/csappECF%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%9B%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习ECF的意义在于：</p><ul><li>将有助于理解重要的系统概念，ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制。</li><li>将有助于理解应用程序是如何与操作系统交互的，应用程序通过<strong>系统调用（System Call）</strong>的ECF形式，向操作系统请求服务。</li><li>将有助于理解并发机制</li><li>将有助于理解软件异常的工作方式</li></ul></blockquote><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在处理器中，状态被编码为不同的位和信号，而状态变化成为<strong>事件（Event）</strong>。当出现事件时，<strong>异常（Exception）</strong>会将控制权转移到操作系统内核，来响应处理器状态中的某些变化，由此形成了控制流中的突变。异常位于硬件和操作系统交接的部分，通过硬件修改<code>%rip</code>来实现控制转移，而由于该异常而执行的代码是由操作系统内核设置和确定的，所以异常一部分由硬件实现，一部分由软件实现。</p><p>系统为每种类型的异常都分配了一个唯一的非负整数的<strong>异常号（Exception Number）</strong>，有些异常号由处理器设计者分配，有些异常号由操作系统内核设计者分配，分别用来表示不同层次的异常。在系统启动时，操作系统会分配和初始化一张称为<strong>异常表（Exception Table）</strong>的跳转表，其中第k个表项包含专门处理异常号为k的异常的<strong>异常处理程序（Exception Handler)</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212109.png" alt="image-20210803212109388" style="zoom:67%;" /><p>在跳转到异常处理程序之前，根据异常的类型，会将不同的返回地址压入栈中，要么返回到事件发生时的地址，要么返回到事件发生时的下一条指令地址。此外，处理器会将一些额外的处理器状态压入栈中，使得当处理器返回时，能从栈中返回中断程序原始的状态。</p><p><strong>注意：</strong>如果控制从用户程序转移到内核，则这些数据都保存在内核栈中，而不是用户栈。此外，异常处理程序运行在内核模式下，使得它们对所有系统资源都有完全的访问权限。</p><p>当异常处理运行完成时，将执行“从中断返回”指令，根据栈中的数据确定返回地址和恢复中断前程序的状态，如果引起异常中断的是用户程序，就将状态恢复为用户模式。</p><h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><p>异常可以分成以下<strong>四种类型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212540.jpg" alt="img"></p><p>其中，异步异常是由于处理器外部发生的状态变化而引起的，而同步异常指的是当前指令运行的结果，这类指令也称为<strong>故障指令（Faulting Instruction）</strong>。</p><p>在x86-64中，一共有256种不同的异常，其中0<del>31号异常是由Intel架构师定义的异常，32</del>255号异常是由操作系统定义的中断和陷阱。几个比较特殊的如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212603.jpg" alt="img" style="zoom:67%;" /><h3 id="中断异常"><a href="#中断异常" class="headerlink" title="中断异常"></a>中断异常</h3><p>中断异常是由I/O设备的信号触发的，不是由指令造成的。在I/O设备中，通过向处理器芯片上的中断引脚发送信号，将标识引起中断的设备的异常号放在系统总线上，来触发中断。则当当前指令执行完后，处理器发现中断引脚的电压变高，就从系统总线中获取异常号，然后调用对应的<strong>中断处理程序（Interrupt Handler）</strong>，执行完毕后返回执行下一条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212620.jpg" alt="img"></p><p>中断的一个常见例子是<strong>定时器中断（Timer Interrupt）</strong>。所有系统都有一个内置计时器，每隔几毫秒就会关闭一次，此时就将中断引脚置为高电平，并且有一个特殊的异常编号用于定时器中断，由此来使得内核再次获得对系统的控制，再由内核决定要做什么，否则用户程序可能会陷入无限循环永远运行，无法让操作系统获得控制权。</p><p>其次来自外部设备的<strong>I/O中断（I/O Interrupt）</strong>也是一个常见的例子。</p><h3 id="陷阱异常"><a href="#陷阱异常" class="headerlink" title="陷阱异常"></a>陷阱异常</h3><p>操作系统内核为程序提供各种服务，但是你的程序没有直接访问内核的权限，无法调用内核函数，无法访问内核数据，因此在用户程序和内核之间提供一个类似函数的接口，称为<strong>系统调用</strong>（<code>syscall n</code>指令），用户会通过执行系统调用来向内核请求服务，比如读取文件（read）、创建新进程（fork）、加载程序（execve）或终止程序（exit），所以陷阱异常是一个有意的异常。处理器会根据<code>syscall n</code>的参数，调用适当的内核程序，然后再将控制权返回给调用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212642.jpg" alt="img"></p><p><strong>注意：</strong></p><ul><li>从程序员角度来看，系统调用和函数调用一样，但是两者存在巨大的区别。系统调用运行在内核模式，而函数调用运行在用户模式。</li><li>系统调用是陷阱的一种，陷阱是同步异常的一种，要分清层次关系。</li></ul><p>通常每个系统调用都有唯一一个对应的整数号，对应于一个到内核中跳转表的偏移量。</p><h3 id="故障异常"><a href="#故障异常" class="headerlink" title="故障异常"></a>故障异常</h3><p>故障异常由错误引起的，但是能被故障处理程序修正。当发生故障时，处理器将控制转移给故障处理程序，如果处理程序能修复故障，则重新执行引发中断的指令，否则处理程序返回到内核的<code>abort</code>例程，终止应用程序。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212927.png" alt="image-20210803212927123" style="zoom:67%;" /><p>当应用尝试除以0时，会出现除法错误（异常0），Unix不会尝试从除法错误中恢复，而是直接终止程序，而Linux shell通常会吧除法错误报告为<strong>浮点异常（Floating Exception）</strong>。造成一般保护故障（异常13）的原因有很多，通常是因为程序引用了一个未定义的虚拟内存区域，或者程序试图写一个只读文件，Linux不会尝试恢复这类故障，shell中会将其报告为<strong>段故障（Segmentation Fault）</strong>。遇到缺页异常（异常14），处理器会将适当的磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行产生故障的指令。</p><h3 id="终止异常"><a href="#终止异常" class="headerlink" title="终止异常"></a>终止异常</h3><p>终止异常通常是不可修复的错误造成的，通常是硬件错误，处理程序会直接将控制返回一个<code>abort</code>例程，终止应用程序。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803212955.png" alt="image-20210803212955111" style="zoom:67%;" /><p>比如在x86-64中，机器检查异常（异常18）是在导致故障的指令中检测到致命的硬件错误。</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>异常是允许操作系统内核提供<strong>进程（Process）</strong>概念的基本构造块。</p><p>进程就是一个执行中程序的实例，每个程序都会运行在某个由内核维护的进程<strong>上下文（Context）</strong>中，其中包含了保证程序正确运行所需的状态，包括存放在内存中的程序的代码和数据、栈、通用目的寄存器的内容、程序计数器、环境变量等等。当我们执行可执行文件时，shell会先创建一个新的进程，给程序提供自己的上下文，然后再在该进程的上下文中运行这个可执行目标文件。</p><p><strong>注意：</strong>进程与程序是不同的，程序可以保存在不同地方，比如保存为C文件的文本，保存为<code>.text</code>的二进制文件，可以作为已加载到内存中的字节存在，而进程指的是正在运行的程序的实例。</p><p>而进程的出现，给我们提供了以下<strong>假象：</strong></p><ul><li>我们的程序是当前唯一在系统运行的程序</li><li>我们的程序独占地使用处理器和内存</li><li>处理器好像无间断地执行我们程序中的指令</li><li>我们程序中的代码和数据好像是系统内存中唯一的对象</li></ul><p>我们这里只讨论处理器和内存系统的假象。</p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>当我们单步执行程序时，可以看到一系列PC值，这个PC序列就称为<strong>逻辑控制流</strong>，简称<strong>逻辑流</strong>。<strong>注意：</strong>之前的控制流值的是物理控制流，是在系统层次上的指令地址序列，而逻辑控制流是在程序级别上的，所以物理控制流包含逻辑控制流。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803214404.jpg" alt="img" style="zoom:80%;" /><p>如上图所示，运行了3个进程，每个进程上下文中的PC值序列就是对应的逻辑流，就是上图中的黑色竖线，而物理控制流就是所有竖线的合并。所以处理器中的物理控制流被分成了3个逻辑控制流，每个进程有一个。并且可以看出，3个逻辑流是交错进行的，只有轮到了进程的逻辑流，才表示该进程在使用处理器，所以进程是轮流使用处理器的，当进程执行了一部分逻辑流时，就会被别的进程<strong>抢占（Preempted）</strong>。但是从当个进程的角度来看，它的逻辑流是连续的，意味着提供了独占处理器的假象，只是指令执行过程中有时会出现停顿，那时候就是出现了抢占。</p><p>这里将多个进程轮流运行的概念称为<strong>多任务（Multitasking）</strong>，将进程每次执行一部分逻辑流的时间称为<strong>时间片（Time Slice）</strong>，则多任务也叫<strong>时间分片（Time Slicing）</strong>。比如进程A就由两个时间片组成。</p><p>当逻辑流X在逻辑流Y开始之后和Y结束之前运行，或逻辑流Y在逻辑流X开始之后和X结束之前运行，则称这两个流为<strong>并发流（Concurrent Flow）</strong>。比如进程A和B是并发流，进程A和C也是并发流。我们将这种多个流并发地执行的现象称为<strong>并发（Concurrency）</strong>。</p><p><strong>注意：</strong>并发流的思想与流运行的处理器数目或计算机数目无关，只和它们运行时间是否重叠有关。但是，如果两个并发流是在不同的处理器核或计算机上运行的，则称它们为并行流<strong>（Parallel Flow）</strong>。</p><blockquote><p>两个进程的逻辑流在时间上重叠，则成为并发流，如果并发流在不同核或计算机上运行，则成为并行流。并行流属于并发流，区别只在于是否在同一处理器上运行。</p></blockquote><h3 id="内存系统"><a href="#内存系统" class="headerlink" title="内存系统"></a>内存系统</h3><p>进程为每个程序提供了他自己的<strong>私有地址空间</strong>，其他进程不能读或写该地址空间中的内存字节。如下是一个私有地址空间的架构</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803214421.jpg" alt="img" style="zoom:80%;" /><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>处理器为进程提供了两种模式，用户模式和内核模式，处理器通过某个控制寄存器的<strong>模式位（Mode Bit）</strong>来进行切换</p><ul><li><strong>内核模式：</strong>当处理器设置了模式位时，为内核模式。此时进程可以执行指令集中的所有指令，并且可以访问系统中的任何内存位置。</li><li><strong>用户模式：</strong>当处理器不设置模式位时，为用户模式，是进程的初始模式。此时进程不能执行<strong>特权指令（Privileged Instruction）</strong>，比如停止处理器、改变模式位或者发起I/O操作，也不能引用内核区域中的指令和数据，只能通过系统调用接口来间接访问。</li></ul><p>进程初始是为用户模式，当出现异常（中断、陷阱、故障）时会变为内核模式，并跳转到异常处理程序中，当返回应用程序时，又会改回用户模式。</p><p>为了处于用户模式的进程能访问内和数据结构的内容，Linux提供了<code>/proc</code>文件系统。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>我们知道内核为每个进程维护了一个上下文，包含了进程所需的所有信息。当进程执行出现中断或某些异常时，内核中的<strong>调度器（Scheduler）</strong>会决定抢占当前进程，并重新开始一个之前被抢断了的进程，此时就需要进行<strong>上下文切换（Context Switch）</strong>，将当前进程的上下切换成要运行的进程的上下文，比如地址空间和寄存器的变化。主要包含以下步骤：</p><ul><li>保存当前进程的上下文，方便过后再进行调度</li><li>恢复之前某个被抢占进程的上下文</li><li>将控制传递给这个新恢复的进程</li></ul><p><strong>注意：</strong>上下文切换是较高层次的异常控制流，建立在之前低层次异常机制之上。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803214549.jpg" alt="img" style="zoom:80%;" /><p>比如以上过程中，首先内核开始执行进程A，处于用户模式。当进程A调用了<code>read</code>系统调用时，内核中的陷阱处理程序请求来自磁盘控制器的DMA传输，由于磁盘读取数据比较耗时，所以调度程序决定运行进程B，就会重新指定地址空间，完成进程B的寄存器加载，然后将控制权转移到进程B，进程B就从中断处继续运行，内核就完成了从进程A切换到进程B并开始执行进程B。当磁盘控制器完成从磁盘到内存的数据传输后，磁盘会发起中断，此时内核判断进程B已运行了足够长的时间了，就会从进程B切换到进程A，直到下次异常出现。</p><p><strong>注意：</strong>进程是由内存中共享的内核进行管理的，内核并不是独立的进程，而是作为某些现有进程的一部分，始终位于地址空间顶部的代码，当出现异常时会进行执行。</p><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>现在Linux提供许多函数，可以从用户程序调用操作进程，这个操作进程的过程称为<strong>进程控制（Process Control）</strong>。这些函数主要通过系统级函数的形式来进行系统调用，如果出现错误，通常会返回-1，然后设置全局变量<code>errno</code>来指明原因，所以我们必须检查这些函数的返回值，通常可以对这些函数进行封装，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">Fork</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>每个进程都有一个唯一的正数<strong>进程ID（PID）</strong>，可以通过<code>getpid</code>函数返回当前进程的PID，可以通过<code>getppid</code>函数返回创建当前进程的父进程PID。类型都为<code>pid_t</code>，Linux系统中在<code>type.h</code>中定义为<code>int</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程会处于以下三种状态之一：</p><ul><li><strong>运行：</strong>进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。即被抢占的进程也属于运行状态。</li><li><strong>停止：</strong>当进程收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>信号时，进程的执行被<strong>挂起（Suspended）</strong>且不会被调度，直到收到<code>SIGCONT</code>信号，进程才会运行。即进程暂时不会被调度，但是还有可能被调度。</li><li><strong>终止：</strong>进程被永久停止了，主要<strong>原因在于：</strong>进程收到了终止进程的信号；从主程序返回<code>return</code>；调用<code>exit</code>函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>status</code>表示进程的退出状态，等价于<code>return status;</code>。</p><h3 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h3><p>父进程通过<code>fork</code>函数创建一个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当调用<code>fork</code>函数时，就立即以当前进程作为父进程，创建一个新的子进程，具有以下<strong>特点：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803215044.jpg" alt="img"></p><ul><li>两个进程具有相同的地址空间，意味着两个进程具有相同的用户栈、局部变量值、堆、全局变量和代码。但是两者的地址空间又是独立的，所以<code>fork</code>函数之后对两个进程的操作都是独立的。即父子进程具有执行<code>fork</code>函数之前相同的设置，而执行完<code>fork</code>函数后，两个进程就是并发独立的了。</li><li>子进程还获得与父进程任何打开文件描述符相同的副本，即子进程可以读写父进程打开的任何文件。</li><li><code>fork</code>函数会有两个返回值——父进程会返回子进程的PID，而子进程会返回0。所以我们可以通过<code>fork</code>函数的返回值判断当前所处的进程，如果不加以区分，则父进程和子进程会执行后续相同的代码。</li></ul><p><strong>例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  </span><br><span class="line">  pid = Fork();</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">//处于子进程中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child%d : x=%d\n&quot;</span>,getpid(), ++x);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">//处于父进程中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent%d : x=%d\n&quot;</span>, getpid(), --x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在父进程中的<code>x=0</code>，在子进程中的结果为<code>x=2</code>，由于这两个进程是并发的，所以无法确定这两条输出哪条先显示。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803215054.jpg" alt="img"></p><p><strong>例2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Fork();</span><br><span class="line">  Fork();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803215107.jpg" alt="img"></p><p><strong>注意：</strong>有<code>fork</code>存在的程序，最好画出进程图，进程图的全排列是所有可能出现的结果。</p><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当子进程终止时，内核会一直保持它的状态直到它被父进程<strong>回收（Reaped）</strong>，因为父进程可能想知道子进程的退出状态，这类进程称为<strong>僵死进程（Zombie）</strong>，仍然消耗系统的内存资源。当父进程回收僵死进程时，内核就会将子进程的退出状态返回给父进程，并抛弃僵死进程。有一个特殊的进程<strong>init进程</strong>，其PID为1，是所有进程的祖先。如果父进程终止了，则由init进程接管它所有的子进程，并回收它的僵死进程。</p><p><strong>注意：</strong>如果父进程没有对子进程进行回收，则子进程会成为僵死进程。子进程可以自己独立运行，需要显示进行终止。</p><p>我们可通过调用以下函数来等待子进程的终止或停止，父进程会得到被回收的子进程PID，且内核会删除僵死进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span>; </span><br></pre></td></tr></table></figure><ul><li><p><strong>等待集合<code>pid</code></strong></p></li><li><ul><li>如果<code>pid&gt;0</code>，则等待集合就是一个单独的子进程</li><li>如果<code>pid=-1</code>，则等待集合就是该进程的所有子进程</li><li><strong>注意：</strong>当父进程创造了许多子进程，这里通过<code>pid=-1</code>进行回收时，子程序的回收顺序是不确定的，并不会按照父进程生成子进程的顺序进行回收。可通过按顺序保存子进程的PID，然后按顺序指定<code>pid</code>参数来消除这种不确定性。</li></ul></li><li><p><strong>等待行为<code>options</code></strong></p></li><li><ul><li>**<code>0</code>**：默认选项，则会挂起当前进程，直到等待集合中的一个子进程终止，则函数返回该子进程的PID。此时，已终止的子进程已被回收。</li><li><strong><code>WNOHANG</code>：</strong>如果等待子进程终止的同时还向做其他工作，该选项会立即返回，如果子进程终止，则返回该子进程的PID，否则返回0。</li><li><strong><code>WUNTRACED</code>：</strong>当子进程被终止或暂停时，都会返回。</li><li><strong><code>WCONTINUED</code>：</strong>挂起当前进程，知道等待集合中一个正在运行的子进程被终止，或停止的子进程收到<code>SIGCONT</code>信号重新开始运行。</li><li><strong>注意：</strong>这些选项可通过<code>|</code>合并。</li></ul></li><li><p>如果<code>statusp</code>非空，则<code>waitpid</code>函数会将子进程的状态信息放在<code>statusp</code>中，可通过<code>wait.h</code>中定义的宏进行解析</p></li><li><ul><li><strong><code>WIFEXITED(statusp)</code>：</strong>如果子进程通过调用<code>exit</code>或<code>return</code>正常终止，则返回真。此时可通过<code>WEXITSTATUS(statusp)</code>获得退出状态。</li><li><strong><code>WIFSIGNALED(status)</code>：</strong>如果子进程是因为一个未捕获的信号终止的，则返回真。此时可通过<code>WTERMSIG(statusp)</code>获得该信号的编号。</li><li><strong><code>WIFSTOPPED(statusp)</code>：</strong>如果引起函数返回的子进程是停止的，则返回真。此时可通过<code>WSTOPSIG(statusp)</code>获得引起子进程停止的信号编号。</li><li><strong><code>WIFCONTINUED(statusp)</code>：</strong>如果子进程收到<code>SIGCONT</code>信号重新运行，则返回真。</li></ul></li><li><p>如果当前进程没有子进程，则<code>waitpid</code>返回-1，并设置<code>errno</code>为<code>ECHILD</code>，如果<code>waitpid</code>函数被信号中断，则返回-1，并设置<code>errno</code>为<code>EINTR</code>。否则返回被回收的子进程PID。</p></li></ul><p><strong>注意：</strong> <code>waitpid</code>通过设置<code>options</code>来决定是否回收停止的子进程。并且能通过<code>statusp</code>来判断进程终止或停止的原因。</p><p>有个简化的<code>waitpid</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statusp)</span></span>;</span><br></pre></td></tr></table></figure><p>调用<code>wait(&amp;status)</code>等价于调用<code>waitpid(-1, &amp;status, 0)</code>。</p><p><strong>注意：</strong>当调用<code>waitpid</code>函数之前，就有子进程被终止或停止，一调用<code>waitpid</code>函数就会马上将该子进程回收。</p><h3 id="休眠进程"><a href="#休眠进程" class="headerlink" title="休眠进程"></a>休眠进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>函数<code>sleep</code>将进程挂起一段时间，而该函数的返回值为剩下的休眠时间。</p><p>函数<code>pause</code>将进程挂起，直到该进程收到一个信号。</p><h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p><code>execve</code>函数可在当前进程的上下文中加载并运行一个程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>; </span><br></pre></td></tr></table></figure><p><code>execve</code>函数加载并运行<code>filename</code>可执行目标文件，参数列表<code>argv</code>和环境列表<code>envp</code>是以<code>NULL</code>结尾的字符串指针数组，其中<code>argv[0]</code>为文件名。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803215956.jpg" alt="img"></p><p>调用<code>exevec</code>函数其实就是调用加载器，则加载器会在可执行目标文件<code>filename</code>的指导下，将文件中的内容复制到代码段和数据段，再调用<code>_libc_start_main</code>来初始化执行环境，调用<code>main</code>函数，<code>main</code>函数的函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>argc</code>为参数数目，<code>argv</code>为参数列表，<code>envp</code>为环境列表。其用户栈的架构如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210803220006.jpg" alt="img" style="zoom:80%;" /><p><strong>注意：</strong>可以通过全局变量<code>environ</code>来获得环境列表。</p><p>这里还有一些函数用来对环境变量进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; <span class="comment">//获得名字为name的环境值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *newvalue, <span class="keyword">int</span> overwrite)</span></span>; <span class="comment">//对环境值进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; <span class="comment">// 删除环境变量</span></span><br></pre></td></tr></table></figure><p><code>fork</code>函数和<code>execve</code>区别：</p><ul><li><code>fork</code>函数新建一个不同PID的子进程，具有和父进程相同的上下文，是父进程的复制品，运行相同的代码、程序和变量，就是程序不变，而在不同进程。而<code>execve</code>函数保持PID不变，在当前进程的上下文中加载并运行一个新程序，会覆盖当前进程的地址空间，并继承调用<code>execve</code>函数时已打开的所有文件描述符，就是保持进程不变，但是运行完全不同的程序。</li><li><code>fork</code>函数调用一次返回两次，而<code>execve</code>函数调用后，只有出现错误才会返回到调用程序。</li><li>当你想要创建并发服务器时，可以通过<code>fork</code>函数创建多个服务器副本，可以运行多个相同代码。</li></ul><p>想要保持当前进行运行的情况下，运行另一个程序，可以先通过<code>fork</code>新建一个进程，然后在子进程中用<code>execve</code>执行另一个程序，此时在父进程就运行原来的程序，而在子进程中就运行另一个程序。</p><p><strong>例子：</strong>我们想要在当前环境中，在子进程中运行<code>/bin/ls -lt /usr/include</code></p><p>首先可以设置参数<code>argv</code>和<code>envp</code></p><p><img src="https://pic4.zhimg.com/80/v2-51ffd017f0a3b52662f8736a9afcee5f_720w.jpg" alt="img"></p><p>然后调用以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;  <span class="comment">//在子进程中运行</span></span><br><span class="line">  <span class="keyword">if</span> (execve(myargv[<span class="number">0</span>], myargv, environ) &lt; <span class="number">0</span>) &#123;  <span class="comment">//这里直接用全局变量environ，表示在当前环境中运行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, myargv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
            <tag> 进程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp优化程序性能（五）</title>
      <link href="2021/07/31/csapp/csapp%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>2021/07/31/csapp/csapp%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>程序优化的步骤：</strong></p><ol><li>消除不必要的工作，让代码尽可能有效地执行所期望的任务。包括消除不必要的函数调用、条件测试和内存引用。</li><li>利用处理器提供的指令级并行能力来同时执行多条指令，会介绍降低一个计算不同部分之间的数据相关，来提高并行度。</li><li>使用<strong>代码剖析程序（Profiler）</strong>来测量程序各部分性能，找到代码中效率最低的部分。</li></ol><p>我们这里简单地将程序优化看成是一系列转换的线性变换，但是实际上我们需要通过汇编代码来确定代码执行的具体细节，比如寄存器使用不当、可以并行执行的操作、如何使用处理器资源等等，然后不断修改源代码使得编译器能够产生高效的代码就可以了，由此保证了代码的可移植性。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="编译器的能力和局限性"><a href="#编译器的能力和局限性" class="headerlink" title="编译器的能力和局限性"></a>编译器的能力和局限性</h3><p>编译器能够提供对程序的不同优化级别，命令行选项<code>-Og</code>调用GCC使用一组基本的优化，而<code>-O1</code>、<code>-O2</code>和<code>-O3</code>可以让GCC进行更大量的优化， 但是过度的优化会使得程序规模变大，且更难调试，通常使用<code>-O2</code>级别的优化。</p><p>但是编译器只会提供安全的优化，保证优化前后的程序由一样的行为，这里会有两个OB（<strong>optimization blocker</strong>）使得编译器不会对其进行优化：</p><ul><li><strong>内存别名使用（Memory Aliasing）</strong>：编译器会假设不同的指针可能会指向相同的位置，如果发现会改变程序行为，就会避免一些优化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span>&#123;</span><br><span class="line">  *xp += *yp;</span><br><span class="line">  *xp +== *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码需要6次内存引用（2次读取<code>yp</code>、2次读取<code>xp</code>和2次写<code>xp</code>），我们可以将其优化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle2</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span>&#123;</span><br><span class="line">  *xp += <span class="number">2</span>* *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要3次内存引用（1次读取<code>yp</code>，1次读取<code>xp</code>和1次写<code>xp</code>），但是编译器会假设<code>xp</code>和<code>yp</code>指向相同的内存位置，由此函数<code>twiddle1</code>和<code>twiddle2</code>的计算结果就不同了，所以编译器不会讲<code>twiddle2</code>作为<code>twiddle1</code>的优化版本。</p><ul><li><strong>函数调用</strong>：大多数编译器不会试图判断函数是否没有副作用，如果没有就会对函数调用进行优化，但是编译器会假设最坏的情况，保持所有函数的调用不变</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f()+f()+f()+f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>*f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>func1</code>需要调用4次函数<code>f</code>，而函数<code>func2</code>只需要调用1次函数<code>f</code>，但是如果函数<code>f</code>是以下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> count++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>就具有副作用，改变调用<code>f</code>的次数会改变程序行为，所以编译器不会将函数<code>func1</code>优化为<code>func2</code>。</p><p>我们通常可以使用<strong>内联函数替换（Inline Substitution，内联）</strong>来优化函数调用，它直接将函数调用替换成函数体，然后在对调用函数进行优化。比如以上例子中，会得到一个内联函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1in</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> t = count++;</span><br><span class="line">  t += count++;</span><br><span class="line">  t += count++;</span><br><span class="line">  t += count++;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>由此不仅减少了函数调用带来的开销，并且能够对代码进一步优化，得到以下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1opt</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> t = <span class="number">4</span>*count+<span class="number">6</span>;</span><br><span class="line">  count += <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GCC中，我们可以使用<code>-finline</code>、<code>-O1</code>或更高级别的优化来得到这种优化。但是具有以下<strong>缺点</strong>：</p><ul><li>GCC只支持在单个文件中定义的函数的内联</li><li>当对某个函数调用使用了内联，则无法在该函数调用上使用断点和跟踪</li><li>当对某个函数调用使用了内联，则无法使用代码剖析来分析函数调用</li></ul><h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><p>许多过程都含有在一组元素上迭代的循环，比如以下<code>psum1</code>是对一个长度为n的向量计算前置和，而<code>psum2</code>是使用<strong>循环展开（Loop Unrolling）</strong>技术对其进行优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psum1</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">float</span> p[], <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>, i&lt;n; i++)&#123;</span><br><span class="line">    p[i] = p[i<span class="number">-1</span>]+a[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psum2</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">float</span> p[], <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">float</span> mid_val = p[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    p[i] = mid_val;</span><br><span class="line">    p[i+<span class="number">1</span>] = mid_val+a[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;n)&#123;</span><br><span class="line">    p[i] = p[i<span class="number">-1</span>]+a[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用循环展开优化的函数，迭代次数通常会减少，并且我们更关注对于给定的向量长度<code>n</code>，程序运行的速度如何，所以我们使用度量标准<strong>CPE（Cycles Per Element）</strong>来度量计算每个元素需要的周期数，CPE更适合用来度量执行重复计算的程序。</p><p>我们可以调整输入的向量大小，得到以上两个函数计算时所需的周期数，然后使用最小二乘拟合来得到曲线图。<code>psum1</code>函数的结果为<code>368+9.0n</code>，而<code>psum2</code>的结果为<code>368+6.0n</code>，其中斜率就是CPE指标，所以<code>psum1</code>为9.0，<code>psum2</code>为6.0，所以根据CPE指标，<code>psum2</code>更优于<code>psum1</code>。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731200237.png" alt="image-20210731200237324" style="zoom:67%;" /><h2 id="对程序进行优化"><a href="#对程序进行优化" class="headerlink" title="对程序进行优化"></a>对程序进行优化</h2><h3 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201038.png" alt="image-20210731201037968" style="zoom:67%;" /><p>我们通过声明数据类型<code>data_t</code>、初始值<code>IDENT</code>和运算符<code>OP</code>来测量整数/浮点数数据的累加/累乘函数的性能。</p><h3 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h3><p>我们对<code>combine1</code>函数进行编译得到如下图所示的汇编代码，可以发现每次循环迭代时都会执行<code>call vec_length</code>指令来计算向量长度，但是向量长度在该函数中是不变的，所以我们可以将计算向量长度的代码移到循环外面，得到<code>combine2</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731200923.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731200929.jpg" alt="img"></p><p>当前性能如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731200937.png" alt="img"></p><p>该优化称为<strong>代码移动（Code Motion）</strong>：识别要执行多次（比如在循环内）但是计算结果不会改变的计算（会增加很多额外的函数调用，出现<code>ret</code>指令会降低流水线效率），就将该计算移到前面。</p><blockquote><p>由于存在函数调用OB，编译器会非常小心修改调用函数位置以及调用函数次数，所以编译器不会自动完成上述优化。</p></blockquote><h3 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><p>过程调用通常会带来开销，并且会阻碍编译器对程序进行优化。</p><p>我们可以看到<code>combine2</code>函数在循环中会反复调用<code>get_vev_element</code>函数来获得下一个向量元素，而在<code>get_vev_element</code>函数中会反复检查数组边界，我们可以发现该步骤在<code>combine2</code>函数中是冗余的，会损害性能。</p><p>我们可以将其改为以下形式来减少函数调用</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731200951.jpg" alt="img" style="zoom:67%;" /><p>但是该函数的性能如下图所示，性能并没有提升，说明内循环中的其他操作才是瓶颈。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201001.png" alt="img"></p><blockquote><p>由于存在函数调用OB，编译器不会自动完成上述优化</p></blockquote><h3 id="减少不必要的内存引用"><a href="#减少不必要的内存引用" class="headerlink" title="减少不必要的内存引用"></a>减少不必要的内存引用</h3><p>我们对<code>combine3</code>进行编译，得到循环内对应的汇编代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201224.jpg" alt="img" style="zoom:80%;" /><p>可以发现每次循环时，首先会从内存中读取<code>*dest</code>的值，然后将其写回内存中，再一次迭代时，又从内存中读取刚写入的<code>*dest</code>值，这就存在不必要的内存读写。</p><blockquote><p>声明为指针的数据会保存在数据栈内存中，读取指针值时会读取内存，对指针值进行赋值时，会写入内存</p></blockquote><p>我们可以将代码修改为以下形式</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201237.jpg" alt="img" style="zoom:80%;" /><p>当函数中的局部变量数目少于寄存器数目时，就会将局部变量保存到寄存器中，就无须在内存中进行读写了，其对应的汇编代码为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201245.jpg" alt="img" style="zoom:80%;" /><p>对应的性能为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201254.png" alt="img" style="zoom:80%;" /><blockquote><p>由于存在内存别名使用，两个函数可能会不同的行为，所以编译器不会自动进行优化。</p></blockquote><h2 id="现代处理器"><a href="#现代处理器" class="headerlink" title="现代处理器"></a>现代处理器</h2><p>以上方法只是减少过程调用的开销，消除一些重大的OB，但是想要进一步优化程序性能，就需要针对目标处理器微体系结构来进行优化。</p><p>现代处理器在指令运行中提供了大量的优化，支持<strong>指令级并行</strong>，使得能够同时对多条指令进行求值，并且通过一系列机制来确保指令级并行能获得机器级程序要求的顺序语义模型，这就使得处理器的实际操作和机器及程序描述的有很大差别。</p><h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731201703.jpg" alt="img" style="zoom:67%;" /><p>如上图所示是一个简化的Intel处理器的结构，包含<strong>两个特点：</strong></p><ul><li><strong>超标量（Superscalar）：</strong>处理器可以在每个时钟周期执行多个操作</li><li><strong>乱序（Out-of-order）：</strong>指令执行的顺序不一定和机器代码的顺序相同，提高指令级并行</li></ul><p>该处理器主要由两部分构成：</p><ul><li><p><strong>指令控制单元（Instruction Control Unit，ICU）：</strong>通过取值控制逻辑从指令高速缓存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作，然后发送到EU中。</p></li><li><ul><li><p><strong>取指控制逻辑：</strong>包含分支预测，来完成确定要取哪些指令。</p></li><li><ul><li><strong>分支预测（Branch Prediction）技术：</strong>当程序遇到分支时，程序有两个可能的前进方向，处理器会猜测是否选择分支，同时预测分支的目标地址，直接取目标地址处的指令。</li></ul></li><li><p><strong>指令高速缓存（Instruction Cache）：</strong>特殊的高速存储器，包含最近访问的指令。ICU通常会很早就取指，给指令译码留出时间。</p></li><li><p><strong>指令译码逻辑：</strong>接收实际的程序指令，将其转换成一组基本操作（微操作），并且可以在不同的硬件单元中并行地执行不同的基本操作。比如x86-64中的<code>addq %rax, 8(%rdx)</code>，可以分解成访问内存数据<code>8(%rdx)</code>、将其加到<code>%rax</code>上、将结果保存会内存中。</p></li><li><p><strong>退役单元（Retirement Unit）：</strong>指令译码时会将指令信息放到队列中，确保它遵守机器级程序的顺序语义。队列中的指令主要包含两个状态：</p></li><li><ul><li><strong>退役（Retired）：</strong>当指令完成，且引起这条指令的分支点预测正确，则这条指令会从队列中出队，然后完成对寄存器文件的更新。</li><li><strong>清空（Flushed）：</strong>如果引起该指令的分支点预测错误，就会将该指令出队，并丢弃计算结果，由此保证预测错误不会改变程序状态。</li><li><strong>寄存器文件：</strong>包含整数、浮点数和最近的SSE和AVX寄存器。</li></ul></li></ul></li><li><p><strong>执行单元（Execution Unit，EU）：</strong>使用投机执行技术执行由ICU产生的基本操作，通常每个时钟周期会接收多个基本操作，将这些操作分配到一组功能单元中来执行实际的操作。</p></li><li><ul><li><p><strong>投机执行（Speculative Execution）技术：</strong>直接执行ICU的预测指令，但是最终结果不会存放在程序寄存器或数据内存中，直到处理器能确定应该执行这些指令。分支操作会被送到EU中来确定分支预测是否正确。如果预测错误，EU会丢弃分支点之后计算出来的结果，并告诉分支模块。</p></li><li><p><strong>功能单元：</strong>专门用来处理不同类型操作的模块，并且可以使用寄存器重命名机制将“操作结果”直接在不同单元间进行交换，这是数据转发技术的高级版本。</p></li><li><ul><li><p><strong>存储模块</strong>和<strong>加载模块</strong>负责通过数据高速缓存来读写数据内存，各自包含一个<strong>加法器</strong>来完成地址的计算，并且单元内部都包含<strong>缓冲区</strong>来保存未完成的内存操作请求集合。每个时钟周期可完成开始一个操作。</p></li><li><p><strong>分支模块：</strong>当得知分支预测错误，就会在正确的分支目的中取指。</p></li><li><p><strong>算数运算模块：</strong>能够执行各种不同的操作。</p></li><li><p><strong>寄存器重命名机制（Register Renaming）：</strong>会维护一个寄存器的重命名表来进行数据转发，主要有以下步骤</p></li><li><ul><li>当执行一条更新寄存器<code>r</code>的指令<code>I1</code>，会产生一个指向该操作结果的唯一标识符<code>t</code>，然后将<code>(r, t)</code>加入重命名表中。</li><li>当后续有需要用到寄存器<code>r</code>作为操作数的指令时，会将<code>t</code>作为操作数源的值输入到单元中进行执行</li><li>当<code>I1</code>执行完成时，就会产生一个结果<code>(v, t)</code>，表示标识符<code>t</code>的操作产生了结果<code>v</code>，然后所有等待<code>t</code>作为源的操作都会使用<code>v</code>作为源值。</li><li><strong>意义：</strong>使用寄存器重命名机制，可以将值从一个操作直接转发到另一个操作，而无需进行寄存器文件的读写，使得后续的操作能在第一个操作<code>I1</code>完成后尽快开始。并且投机执行中，在预测正确之前不会将结果写入寄存器中，而通过该机制就可以预测着执行操作的整个序列。</li><li><strong>注意：</strong>重命名表只包含未进行寄存器写操作的寄存器，如果有个操作需要的寄存器没有在重命名表中，就可以直接从寄存器文件中获取值。</li></ul></li></ul></li><li><p><strong>数据高速缓存（Data Cache）：</strong>存放最近访问的数据值。</p></li></ul></li></ul><h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>我们提供一种参考机Intel Core i7 Haswell，总共具有8个功能单元</p><ul><li>整数运算、浮点乘、整数和浮点数除法、分支</li><li>整数运算、浮点加、整数乘、浮点乘</li><li>加载、地址计算</li><li>加载、地址计算</li><li>存储</li><li>整数运算</li><li>整数运算、分支</li><li>存储、地址计算</li></ul><p>其中，整数运算包含加法、位级操作和移位等等。存储操作需要两个功能单元，一个用于计算存储地址，一个使用保存数据。我们可以发现，其中有4个能进行整数运算的功能单元，说明处理器一个时钟周期内可执行4个整数运算操作。其中有2个能进行加载的功能单元，说明处理器一个时钟周期可读取两个操作数。</p><p>该参考机的算数运算性能如下图所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731202411.jpg" alt="img" style="zoom:67%;" /><ul><li><strong>延迟（Latency）：</strong>表示完成单独一个运算所需的时钟周期总数</li><li><strong>发射时间（Issue Time）：</strong>表示采用流水线时，两个连续的同类型运算之间需要的最小时钟周期数</li><li><strong>容量（Capacity）：</strong>表示能够执行该运算的功能单元数量</li></ul><p>每个运算都能在对应的功能单元进行计算，每个功能单元内部都是用流水线实现的，使得运算在功能单元内是分阶段执行的。发射时间为1的运算，意味着对应的功能单元是<strong>完全流水线化的（Fully Popelined）</strong>，要求运算在功能单元内的各个阶段是连续的，且逻辑上独立的，才能每个时钟周期执行一个运算。当发射时间大于1，意味着该运算在功能单元内不是完全流水线化的，特别是除法运算的延迟等于发射时间，意味着需要完全执行完当前的除法运算，才能执行下一条除法运算。</p><p>从系统层次而言，可以通过吞吐量来衡量运算的性能，对于一个容量为<code>C</code>，发射时间为<code>I</code>的操作而言，其吞吐量为<code>C/I</code>。</p><p>根据以上运算性能，我们可以得到CPE值的两个基本界限，来描述程序的最大性能：</p><ul><li><p><strong>延迟界限：</strong></p></li><li><ul><li><strong>意义：</strong>当指令存在数据相关时，指令的执行必须严格顺序执行，就会限制了处理器指令级并行的能力，延迟界限就会限制程序性能。</li><li><strong>解释：</strong>当存在数据相关时，指令是严格顺序执行的，意味着我们无法通过指令并行来进行加速。而通过参考机的运算性能知道执行每种运算所需的延迟，就确定了执行该运算所需的最小时钟周期数，此时CPE的延迟界限就是运算操作的延迟。比如整数乘法的延迟为3个时钟周期，意味着我们需要用3个时钟周期才能完成一个整数乘法运算，不可能更快了，所以当前的CPE值为3。</li></ul></li><li><p><strong>吞吐量界限：</strong></p></li><li><ul><li><strong>意义：</strong>刻画了处理器功能单元的原始计算能力，是程序性能的终极限制。</li><li><strong>解释：</strong>表示我们考虑系统中的所有的功能单元，计算出来运算结果的最大速率。比如参考机含有4个可以执行整数加法的功能单元，且整数加法的发射时间为1，所以系统执行整数加法的吞吐量为4，意味着CPE值为0.25，但是参考机中只有两个支持加载的功能单元，意味着每个时钟周期只能读取两个操作数，所以这里的吞吐量就受到了加载的限制，CPE值为0.5。再比如参考机内只含有一个能执行整数乘法的功能单元，说明一个时钟周期只能执行一个整数乘法，此时性能吞吐量就受到了功能单元运算的限制，CPE值为1。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731202429.jpg" alt="img" style="zoom:80%;" /><p>我们可以发现除了整数加法外，<code>combine4</code>的结果与延迟界限结果相同，说明<code>combine4</code>中存在数据相关问题。</p><h3 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h3><p>这里介绍一种非正式的程序的<strong>数据流（Data-flow）</strong>表示，可以展示不同操作之间的数据相关是如何限制操作的执行顺序，并且图中的<strong>关键路径（Cirtical Path）</strong>给出了执行这些指令所需的时钟周期数的下界。</p><h4 id="从机器级代码到数据流图"><a href="#从机器级代码到数据流图" class="headerlink" title="从机器级代码到数据流图"></a>从机器级代码到数据流图</h4><p>由于对于大向量而言，循环执行的计算是决定性能的主要因素，我们这里主要考虑循环的数据流图。首先可以得到循环对应的机器级代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731202926.jpg" alt="img" style="zoom:67%;" /><p>我们根据机器级代码可以获得寄存器在执行指令时进行的操作，然后可以得到以下对应的数据流图。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731202937.jpg" alt="img" style="zoom:67%;" /><p>上方寄存器为输入的寄存器，下方寄存器为输出的寄存器，从寄存器指向操作的箭头表示该操作读取寄存器的值，从操作指向寄存器表示操作的结果保存在寄存器中，如果某些操作产生的值不对应于任何寄存器，就在操作间用弧线连接起来。其中，<code>vmulsd (%rdx), %xmm0, %xmm0</code>包含从内存中读取<code>(%rdx)</code>的值，然后计算浮点数乘法的基本操作。</p><p>根据数据流图可以将寄存器分成以下几种：</p><ul><li><strong>只读：</strong>只包含寄存器指向操作的箭头，不包含从操作指向该寄存器的箭头。比如<code>%rax</code>。</li><li><strong>只写：</strong>只包含从操作指向该寄存器的箭头，不包含从寄存器指向操作的箭头。</li><li><strong>局部：</strong>寄存器值在循环内部修改和使用，迭代与迭代之间不相关。比如条件码寄存器。</li><li><strong>循环：</strong>寄存器既作为源又作为目的，并且一次迭代中产生的值会在另一次迭代中使用。比如<code>%rdx</code>和<code>%xmm0</code>。</li></ul><p><strong>注意：</strong>因为迭代之间是数据相关的，必须保证循环寄存器在上一轮迭代中计算完成，才能在下一轮迭代中使用该循环寄存器，所以循环寄存器之间的操作链决定了限制性能的数据相关。</p><p>我们可以对数据流图进行修改，上方寄存器只有只读寄存器和循环寄存器，下方寄存器只有只写寄存器和循环寄存器，得到如下图所示的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731202952.jpg" alt="img" style="zoom:80%;" /><p>所以同时出现在上方和下方的寄存器为循环寄存器。我们删除非循环寄存器以外的寄存器，并删除不在循环寄存器之间的操作，得到以下简化的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203003.jpg" alt="img" style="zoom:80%;" /><p>其中下方每个寄存器代表了一个数据相关：</p><ul><li><code>%xmm0</code>：当前迭代中<code>%xmm0</code>的计算，需要上一轮计算出来的<code>%xmm0</code>以及<code>%rdx</code></li><li><code>%rdx</code>：当前迭代中<code>%rdx</code>的计算，需要上一轮计算出来的<code>%rdx</code></li></ul><p>我们可以将上图中的数据流重复n次，就得到了函数中循环n次的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203013.jpg" alt="img" style="zoom:80%;" /><p>可以发现里面有两个数据相关链，只有当上方的计算完成时才会计算下一个。并且由于相邻迭代的循环寄存器存在数据相关，所以只能顺序执行，所以要独立地考虑操作对应的延迟。由于参考机中浮点数乘法的延迟为5个时钟周期，而整数加法的延迟为1个时钟周期，所以左侧数据相关链是关键路径，限制了程序的性能。只要左侧操作的延迟大于1个时钟周期（比右侧的延迟大），则程序的CPE就是该操作的延迟。</p><p><strong>注意：</strong>数据流中的关键路径只是提供程序需要周期数的下界，还有很多其他因素会限制性能。比如当我们将左侧的操作变为整数加法时，根据数据流预测的CPE应该为1，但是由于这里的操作变得很快，使得其他操作供应数据的速度不够快，造成实际得到的CPE为1.27。</p><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>我们可以通过对函数实行循环展开，增加每次迭代计算的元素数量，减少循环的迭代次数。</p><p>这里介绍一种<strong>kx1循环展开</strong>方法，格式如下所示，将一个循环展开成了两部分，第一部分是每次循环处理k个元素，能够减少循环次数；第二部分处理剩下还没计算的元素，是逐个进行计算的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> k 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine5</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> length = vec_length(v);</span><br><span class="line">  <span class="keyword">long</span> limit = length-k+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">data_t</span> *data = get_vec_start(v);</span><br><span class="line">  <span class="keyword">data_t</span> acc = IDENT;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;limit; i+=k)&#123;</span><br><span class="line">    acc = ((acc OP data[i]) OP data[i+<span class="number">1</span>]) ... OP data[i+k<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(; i&lt;length; i++)&#123;</span><br><span class="line">    acc = acc OP data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到改程序具有以下性能</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203100.jpg" alt="img" style="zoom:80%;" /><p>可以发现整数加法优化到了延迟界限，因为延迟展开能减少不必要的操作的数量（例如循环索引计算和条件分支），但是其他的并没有优化，因为其延迟界限是主要限制因素。</p><p>可以发现循环展开无法突破延迟界限。我们可以得到<code>combine5</code>循环部分的汇编代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203108.jpg" alt="img" style="zoom:80%;" /><p>可以得到对应的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203136.jpg" alt="img" style="zoom:80%;" /><p>其中，<code>%xmm0</code>保存<code>acc</code>，<code>%rdx</code>保存<code>i</code>。可以发现循环展开虽然能将循环次数减少为原来的k分之一，但是每次迭代所需的时钟周期变为了原来的k倍，使得总体的延迟不变，无法突破延迟界限。</p><p><strong>总结：</strong>延迟展开可以减少迭代次数，使得不必要的操作数量减少，但是没有解决数据相关问题，无法突破延迟界限。</p><h3 id="多个变量提高并行性"><a href="#多个变量提高并行性" class="headerlink" title="多个变量提高并行性"></a>多个变量提高并行性</h3><p>我们可以通过引入多个变量来提高循环中的并行性。</p><p>这里介绍一种<strong>kxk循环展开</strong>方法，格式如下所示，将一个循环展开成了两部分，第一部分是每次循环处理k个元素，能够减少循环次数，并且引入k个变量保存结果；第二部分处理剩下还没计算的元素，是逐个进行计算的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine6</span><span class="params">(vec_ptr v, <span class="keyword">data_t</span> *dest)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> length = vec_length(v);</span><br><span class="line">  <span class="keyword">long</span> limit = length-k+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">data_t</span> *data = get_vec_start(v);</span><br><span class="line">  <span class="keyword">data_t</span> acc0 = IDENT;</span><br><span class="line">  <span class="keyword">data_t</span> acc1 = IDENT;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">data_t</span> acck_1 = IDENT; <span class="comment">//k个变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;limit; i+=k)&#123;</span><br><span class="line">    acc0 = acc0 OP data[<span class="number">0</span>];</span><br><span class="line">    acc1 = acc1 OP data[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">    acck_1 = acck_1 OP data[k<span class="number">-1</span>]; <span class="comment">//更新k个变量</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">for</span>(; i&lt;length; i++)&#123;</span><br><span class="line">    acc0 = acc0 OP data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  *dest = acc0 OP acc1 OP ... OP acck_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到改程序具有以下性能</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203209.jpg" alt="img" style="zoom:80%;" /><p>可以通过循环对应的数据流图来分析</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203217.jpg" alt="img" style="zoom:80%;" /><p>其中，<code>%xmm0</code>保存<code>acc0</code>，<code>%xmm</code>保存<code>%acc1</code>，<code>%rdx</code>保存<code>i</code>。可以发现，我们通过在循环中引入多个变量，使得原来在同一个循环寄存器中的浮点数乘法运算分配到不同的循环寄存器中，就消除了循环寄存器的数据相关限制，就可以使用不同的功能单元，或利用功能单元的流水线进行并行计算，就<strong>能突破延迟界限</strong>。</p><p>为了接近吞吐量界限，我们需要使用系统中的所有功能单元，并且保证功能单元的流水线始终是慢的，所以对于容量为C、延迟为L的操作而言，需要设置 K&gt;=C*L（最快每个时钟周期执行一个操作)。</p><p><strong>限制</strong></p><p>使用kxk循环展开时，我们需要申请k个局部变量来保存中间结果，如果k大于寄存器的数目，则中间结果就会保存到内存的堆栈中，使得计算中间结果要反复读写内存，造成性能损失。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203708.jpg" alt="img" style="zoom: 67%;" /><h3 id="改变结合顺序提供并行性"><a href="#改变结合顺序提供并行性" class="headerlink" title="改变结合顺序提供并行性"></a>改变结合顺序提供并行性</h3><p><code>combine5</code>中还存在数据相关，是因为循环里中的计算如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acc = (acc OP data[i]) OP data[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>中间计算的局部结果会不断保存到<code>acc</code>的循环寄存器中，使得数据流图如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203731.png" alt="img" style="zoom:80%;" /><p>如果我们改变计算方法为下图所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acc = acc OP (data[i] OP data[i+<span class="number">1</span>]) ;</span><br></pre></td></tr></table></figure><p>则中间计算的局部结果不会直接保存到acc的循环寄存器中，数据流图变为如下所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731203747.jpg" alt="img" style="zoom: 33%;" /><p>由此能减少关键路径中<code>%xmm0</code>的操作数量，并且通过循环展开来利用多个功能单元、及其功能单元的流水线，这样就能够<strong>突破延迟界限</strong>。</p><p><strong>注意：</strong>我们可以统计对<code>acc</code>的操作次数，知道关键路径中有几个操作。</p><p>该方法的性能如下图所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731204917.jpg" alt="img" style="zoom:80%;" /><p>可以发现kx1a的性能类似于kxk的性能。</p><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>在使用投机执行的处理器中，会直接执行预测分支的执行，并且EU不会直接修改寄存器或内存，知道确定预测是否正确，当分支预测错误时，会丢弃之前执行的结果，重新开始取指令过程，会造成性能损失。</p><p>但是一般分支是很容易预测的，比如函数<code>combine2</code>中的边界检查一定是正确的，循环操作除了最后一次分支是跳出循环以外，之前的分支都是继续循环操作，所以这些分支是可预测的，并且分支指令的执行和我们循环体的执行通常不会有数据相关，所以当我们使用AT策略预测分支时，能使得将其全部流水线化，不会造成很大的性能损失。</p><blockquote><p>当分支是高度可预测，且分支和循环体不存在数据相关时，不会造成很大的性能损失</p></blockquote><p>如果处理器将条件分支使用条件传送时，就能将其变为流水线的一部分，无需进行分支预测，也就没有了预测错误的处罚了。我们需要尝试不断修改代码使编译器将分支变成条件传送指令。</p><p>比如以下代码</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731205627.jpg" alt="img" style="zoom:67%;" /><p>会被翻译成条件控制形式，但是如果我们改成以下代码，就会翻译成条件传送</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731205642.jpg" alt="img" style="zoom:67%;" /><h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2><p>所有现代处理器都包含一个或多个高速缓存存储器，现在考虑所有数据都存放在高速缓存中，研究设计加载（从内存到寄存器）和存储（从寄存器到内存）操作的程序性能。</p><h3 id="加载性能"><a href="#加载性能" class="headerlink" title="加载性能"></a>加载性能</h3><p>我们的参考机包含两个加载功能单元，意味着当流水线完全时，一个时钟周期最多能够执行两个加载操作，由于每个元素的计算需要加载一个值，所以CPE的最小值只能是0.5。对于每个元素的计算需要加载k个值的应用而言，CPE的最小值只能是k/2。</p><p>由于我们之前计算内存地址都是通过循环索引<code>i</code>，所以两个加载操作之间不存在数据相关（每一轮的加载操作只要根据<code>i</code>计算地址，无需等到上一轮加载操作完成才能计算当前轮的内存地址），也就不用考虑加载延迟。</p><p>但是对于如下所示的链表函数，计算当前加载地址，需要先获取上一轮的地址，由此加载操作之间就存在数据相关，就需要考虑加载延迟了。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731205919.jpg" alt="img" style="zoom:80%;" /><p>循环中对应的汇编代码为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731205929.jpg" alt="img" style="zoom:80%;" /><p>其中，<code>%rax</code>保存<code>len</code>，<code>%rdi</code>保存<code>ls</code>，我们可以得到对应的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731205938.jpg" alt="img" style="zoom:80%;" /><p>可以发现这里有两个数据相关的循环寄存器<code>%rdi</code>和<code>%rax</code>，其中加法操作需要的延迟通常比加载操作的延迟小，所以左侧为关键路径，这里测得该函数的CPE为4.0，就是加载操作对应的延迟。</p><h3 id="存储性能"><a href="#存储性能" class="headerlink" title="存储性能"></a>存储性能</h3><p>存储操作是将寄存器中的数据保存到内存中，所以存储操作不会产生数据相关，但是存储操作会影响加载操作，出现<strong>写/读相关（Write/Read Dependency）</strong>。</p><p>首先需要先了解加载和存储单元的细节。如下图所示，在存储单元中会有一个<strong>存储缓冲区</strong>，用来保存发射到存储单元但是还未保存到数据高速缓存的存储操作的地址和数据，由此避免存储操作之间的等待。并且加载操作会检查存储缓冲区中是否有需要的地址，如果有，则直接将存储缓冲区中的数据作为加载操作的结果。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731210038.jpg" alt="img" style="zoom:80%;" /><p>我们看以下代码，会从<code>*src</code>处读取数据，然后将其保存到<code>*dest</code></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731210054.jpg" alt="img" style="zoom:80%;" /><p>循环内对应的汇编代码为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731210112.jpg" alt="img" style="zoom:80%;" /><p>我们可以的带对应的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731210125.jpg" alt="img" style="zoom:67%;" /><p>我们需要注意以下几点：</p><ul><li><code>movq %rax, (%rsi)</code>表示存储指令，其被分为两个操作，首先会进行<code>s_addr</code>操作计算存储操作的地址，在存储缓冲区创建一个条目，并设置该条目的地址字段。完成后才进行<code>s_data</code>操作来计算存储操作的数据字段。</li><li>后续<code>movq (%rdi), %rax</code>的<code>load</code>操作会等待<code>s_addr</code>操作计算完成后，判断加载操作的地址和<code>s_addr</code>操作计算出来的地址是否相同，如果相同，则需要等<code>s_data</code>操作将其结果保存到存储缓冲区中，如果不同，则<code>load</code>操作无需等待<code>s_data</code>操作。所以<code>load</code>操作和<code>s_addr</code>操作之间存在数据相关，而<code>load</code>操作和<code>s_data</code>操作之间存在有条件的数据相关。</li></ul><p>对其进行重新排列，并且去除掉非循环寄存器，可以得到如下的数据流图</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210731210137.jpg" alt="img" style="zoom:67%;" /><p>我们可以发现：</p><ul><li>当加载操作和存储操作的地址相同：图中的虚线就存在，则<code>%rax</code>为循环寄存器，关键路径为左侧路径，包含存储数据计算、加载操作和加法操作，CPE大约为7.3。</li><li>当加载操作和存储操作的地址不同：图中的虚线就不存在，则<code>%rax</code>就不是循环寄存器，其中<code>s_data</code>操作和<code>load</code>操作可以并行执行，关键路径为右侧路径，只有一个减法操作，CPE大约为1.3。</li></ul><p><strong>注意：</strong>要在更大范围观察写/读相关，不一定存在一个迭代中，可能在相邻迭代中，只要发现有存储操作，而后执行相同地址的加载操作，就会有写/读相关。</p><h2 id="程序剖析"><a href="#程序剖析" class="headerlink" title="程序剖析"></a>程序剖析</h2><p><strong>程序剖析（Profiling）</strong>会在代码中插入工具代码，来确定程序的各个部分需要的时间。可以在实际的基准数据上运行实际程序的同时进行剖析，不过运行会比正常慢一些（2倍左右）。</p><p>Unix系统提供一个剖析程序GPROF，提供以下信息：</p><ul><li>确定程序中每个函数运行的CPU时间，用来确定函数的重要性</li><li>计算每个函数被调用的次数，来理解程序的动态行为</li></ul><p>GPROF具有以下特点：</p><ul><li>计时不准确。编译过的程序为每个函数维护一个计时器，操作系统每隔x会中断一次程序，当中断时，会确定程序正在执行什么函数，然后将该函数的计时器加上x。</li><li>假设没有执行内联替换，则调用信息是可靠的</li><li>默认情况下，不会对库函数计时，将库函数的执行时间算到调用该库函数的函数上</li></ul><p><strong>使用方法：</strong></p><ul><li>程序要为剖析而编译和连接，加上<code>-pg</code>，并且确保没有进行内联替换优化函数调用</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -pg prog.c -o prog</span><br></pre></td></tr></table></figure><ul><li>正常执行程序，会产生一个文件<code>gmon.out</code></li><li>使用GPROF分析<code>gmon.out</code>的数据</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gprof prog</span><br></pre></td></tr></table></figure><p>书中的几个建议：</p><ul><li>使用快速排序来进行排序</li><li>通常使用迭代来代替递归</li><li>使用哈希函数来对链表进行划分，减少链表扫描的时间</li><li>链表的创建要注意插入位置的影响</li><li>要尽量使得哈希函数分布均匀，并且要产生较大范围</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp处理器体系结构（四）</title>
      <link href="2021/07/24/csapp/csapp%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>2021/07/24/csapp/csapp%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="硬件控制语言HCL"><a href="#硬件控制语言HCL" class="headerlink" title="硬件控制语言HCL"></a>硬件控制语言HCL</h2><p><strong>硬件描述语言（Hardware Description Language，HDL）</strong>可以用来描述硬件结构，是一种文本语言，类似于编程语言，包括Verilog和VHDL。<strong>逻辑合成程序（Logic Synthesis）</strong>可以根据HDL的描述来生成有效的电路设计。所以从手工设计电路到合成生成的转变，就好像从手写汇编到高级语言的转变。</p><p><strong>硬件控制语言（Hardware Control Language，HCL）只</strong>表达硬件设计的控制部分，只有有限的操作集合，也没有模块化，可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-hcl.pdf">这里</a>。</p><p>这门课开发了将HCL翻译成Verilog的工具，然后结合基本硬件单元的Verilog代码，就能产生HDL描述，由此就能合成实际能工作的微处理器了。可以参考<a href="https://link.zhihu.com/?target=http://csapp.cs.cmu.edu/3e/waside/waside-verilog.pdf">这里</a>。</p><h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>当前逻辑<code>1</code>是由1.0伏特左右的高电压表示，逻辑<code>0</code>是由0.0伏特左右的低电压表示。</p><p>实现一个数字系统主要有<strong>三个组成部分：</strong></p><ol><li>计算对位进行操作的函数的组合逻辑</li><li>存储位的存储器单元</li><li>控制存储器单元更新的时钟信号</li></ol><h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p>逻辑门是数字电路的<strong>基本计算单元</strong>。如下图所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724154528.jpg" alt="img" style="zoom:80%;" /><p>其中第一行是布尔表达式，第二行是标准符号，第三行是HCL表达式。我们可以将AND和OR扩展到多个输入的版本。</p><blockquote><p><strong>注意：</strong>1. 逻辑门只对单个位的值进行操作。2. 当一个门的输入发生变化时，输出会很快相应变化。</p></blockquote><p>将很多逻辑门组合成一个实现某种功能的网，就能构成<strong>计算块（Computational block）</strong>，称为<strong>组合电路（Combinational Circuits）</strong>。想要构建有效的组合电路，有以下<strong>限制：</strong></p><ul><li><p>每个逻辑门的输入必须连接到以下其中之一：</p></li><li><ul><li>一个系统输入</li><li>某个存储器单元的输出</li><li>某个逻辑门的输出</li></ul></li><li><p>两个或多个逻辑门的输出不能连接在一起</p></li><li><p>网络不能形成回路</p></li></ul><p>简单的组合电路示例：</p><p><strong>例1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724154745.jpg" alt="img"></p><p><strong>HCL表达式：</strong><code>bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</code></p><p><strong>功能：</strong>用来判断输入<code>a</code>和<code>b</code>是否相同，结果保存在<code>eq</code>中。</p><p><strong>例2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724154816.jpg" alt="img"></p><p><strong>HCL表达式：</strong><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b);</code></p><p><strong>功能：</strong>该组合电路称为<strong>多路复用器（Multiplexor，MUX）</strong>， 当<code>s=1</code>时，<code>out</code>的值就是<code>a</code>的值；当<code>s=0</code>时，<code>out</code>值就是<code>b</code>的值。</p><p><strong>HCL表达式和C语言逻辑表达式区别：</strong></p><ul><li>组合电路中输出会持续响应输入的变化，而C语言只有在程序执行过程中遇到了才进行求值</li><li>逻辑门只允许对0和1进行操作，而C语言将0表示为FASLE，将其余任意值表示为TRUE</li><li>C语言中逻辑表达式存在部分求值的特点（例如，如果一个AND或OR操作的结果只用对第一个参数求值就能确定，那么就不会对第二个参数求值了），组合逻辑中不存在</li></ul><p>以上HCL都是对单个位进行运算的，可以很容易对其进行扩展实现对数据<strong>字（Word）</strong>进行操作的电路。</p><p><strong>例1：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155200.jpg" alt="img" style="zoom:50%;" /><p>直接合并64个位级相等的组合电路，再加上一个逻辑与门，就能得到一个64位的字级相等组合电路。右边是对其的抽象，其中实线表示字级信号，虚线表示布尔信号。</p><p>为了简单，可以将所有字级信号都声明为int，不指定字的大小，则该组合电路可以由两个int类型的参数A和B构成的HCL表达式描述<code>bool Eq = (A == B);</code>。</p><p><strong>例2：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155207.jpg" alt="img" style="zoom:50%;" /><p>这是一个64位字级多路复用器电路。这里只产生了一次<code>!s</code>，可以减少需要的逻辑门数量。在HCL中，多路复用器函数可以用<strong>情况表达式（Case Expression）</strong>来描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  select1 : expr1;</span><br><span class="line">  select2 : expr2;</span><br><span class="line">  ...</span><br><span class="line">  selectk : exprk;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中，<code>select</code>是布尔表达式，<code>expr</code>是字级表达式。</p><blockquote><p><strong>注意：</strong>1. 在HCL中，不要求不同的选择表达式之间是互斥的，但是实际的多路复用器的信号必须互斥。2. 选择表达式是<strong>顺序求值</strong>的，所以后续的选择表达式可以在之前的选择表达式的基础上进行简化。</p></blockquote><p>右侧是字级多路复用器的抽象，根据HCL表达式可知，首先根据<code>s</code>的值来判断是否选择<code>A</code>，如果不选择，就一定会选择<code>B</code>。</p><p><strong>例3：</strong></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155853.jpg" alt="img" style="zoom:67%;" /><p>这是一个通过两个信号来控制的四路复用器。对应的HCL表达式为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Out4 = [</span><br><span class="line">  !s1 &amp;&amp; !s2 : A; #00</span><br><span class="line">  !s1        : B; #01</span><br><span class="line">  !s2        : C; #10</span><br><span class="line">  1          : D; #11</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而我们需要从两位<code>code</code>中提取出两个信号，可以通过相等测试：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code == 2 || code == 3;</span><br><span class="line">bool s0 = code == 1 || code == 3; </span><br></pre></td></tr></table></figure><p>也可以通过<strong>判断集合关系</strong>的方式，其通用格式为<code>iexpr in &#123;iexpr1, iexpr2, ..., iexprk&#125;</code>，所以可以表示为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1 = code in &#123;2,3&#125;;</span><br><span class="line">bool s0 = code in &#123;1,3&#125;; </span><br></pre></td></tr></table></figure><p>比较重要的一个字级组合电路是<strong>算数/逻辑单元（ALU）</strong>，它包含3个输入：标号为A和B的两个数据输入，以及一个控制输入。根据控制输入的值来选择要对A和B进行的运算。如下图所示，是位Y86-64设计的ALU模型。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724155918.jpg" alt="img"></p><blockquote><p><strong>注意：</strong>组合电路值进行逻辑运算，不涉及存储信息，当某个抽象能够存储信息，就不是组合电路。</p></blockquote><h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>为了产生<strong>时序电路（Sequential Circuit）</strong>，即存在状态并且能在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。而这些存储设备是由同一个具有周期性信号的<strong>时钟</strong>控制的，决定什么时候将新值保存到存储器中。</p><p>主要有<strong>两类存储器设备：</strong></p><ul><li><p><strong>时钟寄存器（寄存器）：</strong>存储单个位或字，主要作为电路不同部分的组合逻辑之间的屏障。</p></li><li><p><strong>随机访问存储器（内存）：</strong>存储多个字，用地址来选择读写哪个字。<strong>包括：</strong></p><ul><li><p><strong>处理器的虚拟内存系统：</strong>通过操作系统对存储器进行抽象，使得处理器可以在很大的地址空间中访问，地址为虚拟内存的索引值。</p></li><li><p><strong>寄存器文件：</strong>是一个以寄存器标识符为地址，存储着对应程序寄存器值的随机访问存储器。在IA32或Y86-64处理器中，有15个程序寄存器（<code>%rax</code>~`%r14`）。</p></li></ul></li></ul><p>这里要注意区分机器级编程中的寄存器和硬件中的寄存器</p><ul><li><strong>硬件：</strong>寄存器指的是时钟寄存器，直接将它的输入和输出连接到电路的其他部分。这里称为<strong>硬件寄存器</strong>。</li><li><strong>机器级编程：</strong>寄存器代表的是存储在寄存器文件中的，CPU中少数可寻址的字，地址为寄存器标识符。这里称为<strong>程序寄存器</strong>。</li></ul><h3 id="硬件寄存器"><a href="#硬件寄存器" class="headerlink" title="硬件寄存器"></a>硬件寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724160252.jpg" alt="img"></p><p>如上图所示，硬件寄存器大多数时候会保持在稳定状态x，产生的输出也是它当前的状态。当寄存器的输入发生改变时，寄存器的输出也不会马上变化，而是等时钟变成高电位时，才会将当前状态修改为输入值。由此将当前寄存器两侧的逻辑电路分隔开来。</p><p>Y86-64处理器会使用硬件寄存器老保存程序计数器（PC）、条件代码（CC）和程序状态（Stat）。</p><h3 id="寄存器文件"><a href="#寄存器文件" class="headerlink" title="寄存器文件"></a>寄存器文件</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724160319.jpg" alt="img"></p><p>寄存器文件包含两个读端口和一个写端口，意味着能读取两个程序寄存器的同时对第三个程序寄存器进行写操作。这里的地址就是程序寄存器标识符。</p><p>寄存器文件的写入操作受时钟信号控制，只有当时钟为高电平时，才将<code>valW</code>中的值写入<code>dstw</code>指示的程序寄存器中。</p><h3 id="虚拟内存系统"><a href="#虚拟内存系统" class="headerlink" title="虚拟内存系统"></a>虚拟内存系统</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724160403.jpg" alt="img"></p><p>处理器用虚拟内存来保存程序数据。<code>read</code>和<code>write</code>是两个标志位，用来控制当前是要读还是写。包含通过逻辑电路实现的边界检查，如果地址超过虚拟内存地址空间，就会使得<code>error=1</code>。</p><p>虚拟内存的写入操作受时钟信号控制，只有当<code>write=1</code>并且时钟为高电平时，才会将<code>data in</code>的数据保存到对应地址的位置。</p><blockquote><p><strong>注意：</strong>向存储器（时钟寄存器、随机访问存储器）写入值时会受到时钟的控制，所以存在时序，而向存储器读取值时不受到时钟的控制，不存在时序，可以直接将其近似于逻辑电路，输入地址，一段延迟后，就会将值返回到输出中。</p></blockquote><h1 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h1><h2 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h2><p>想要定义一个指令集体系结构，需要包含：</p><ul><li>定义状态单元</li><li>指令集和他们的编码</li><li>编程规范和异常事件处理</li></ul><p>这几个方面的具体内容感觉没必要记，详细内容可以查看书中对应章节，这里给出一个Y86-64程序示例：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724161150.png" alt="image-20210724161150116" style="zoom: 67%;" /><h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><h3 id="处理指令的阶段"><a href="#处理指令的阶段" class="headerlink" title="处理指令的阶段"></a>处理指令的阶段</h3><p>处理一条指令我们可以将其划分成若干个阶段：</p><ol><li><p><strong>取指（Fetch）：</strong>根据程序计数器PC从内存中读取指令字节。然后完成以下步骤</p></li><li><ol><li>从指令中提取出指令指示符字节，并且确定出指令代码（<code>icode</code>）和指令功能（<code>ifun</code>）</li><li>如果存在寄存器指示符，则从指令中确定两个寄存器标识符<code>rA</code>和<code>rB</code></li><li>如果存在常数字，则从指令中确定<code>ValC</code></li><li>根据指令指令长度以及指令地址，可确定下一条指令的地址<code>valP</code></li></ol></li><li><p><strong>译码（Decode）：</strong>如果存在<code>rA</code>和<code>rB</code>，则译码阶段会从寄存器文件中读取<code>rA</code>和<code>rB</code>的值<code>valA</code>和<code>valB</code>。对于<code>push</code>和<code>pop</code>指令，译码阶段还会从寄存器文件中读取<code>%rsp</code>的值。</p></li><li><p><strong>执行（Execute）：</strong>算术逻辑单元（ALU）会根据<code>ifun</code>的值执行对应的计算，得到结果<code>valE</code>，包括</p></li><li><ol><li>计算运算结果，会设置条件码的值，则条件传送和跳转指令会根据<code>ifun</code>来确定条件码组合，确定是否跳转或传送。</li><li>计算内存引用的有效地址</li><li>增加或减少栈指针</li></ol></li><li><p><strong>访存（Memory）：</strong>写入内存或从内存读取数据<code>valM</code>。</p></li><li><p><strong>写回（Write Back）：</strong>将结果写入寄存器文件中。</p></li><li><p><strong>更新PC（PC Update）：</strong>将PC更新为<code>valP</code>，使其指向下一条指令。</p></li></ol><p>我们要做的工作就是将每条不同指令所需要的计算放入到上述那个通用框架中，以<code>OPq</code>、<code>rrmovq</code>和<code>irmovq</code>为例：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724164106.png" alt="image-20210724164106626" style="zoom:67%;" /><blockquote><p>这里可以发现，相同<code>icode</code>具有相同的步骤，而相同的<code>ifun</code>在执行阶段具有相同的计算方式，比如<code>addq</code>、<code>jmp</code>和<code>rrmovq</code>的<code>ifun</code>都是0，所以都进行加法计算。</p></blockquote><h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>我们可以得到顺序实现的SEQ硬件结构：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724172712.png" alt="image-20210724172704176" style="zoom:80%;" /><ul><li>白色方框为时钟寄存器；蓝色方框为硬件单元，当做黑盒子而不关心细节设计；白色圆圈表示线路名字。</li><li>宽度为字长的数据使用粗线；宽度为字节或更窄的数据用细线；单个位的数据用虚线，主要表示控制值。</li><li>灰色圆角矩形表示控制逻辑块，能在不同硬件单元之间传递数据，以及操作这些硬件单元，使得对每个不同的指令执行指定的运算。是本章的重点，会给出对应的HCL表达式</li></ul><p>SEQ的实现包括组合逻辑和两种存储器：时钟寄存器（程序计数器和条件码寄存器）和随机访问存储器（寄存器文件、指令内存和数据内存）。我们知道组合逻辑和存储器的读取是没有时序的，只要输入一给定，输出就会发生对应的变化。但是存储器的写入是受到时钟的控制的，只有当时钟为高电位时，才会将值写入存储器中。</p><p>所以涉及到写数据的存储器（程序计数器、条件码寄存器、寄存器文件和数据内存）就需要对时序进行明确的控制，才能控制好指令各阶段的执行顺序。为了保证每条指令执行的结果能和上一节中介绍的顺序执行的结果相同，我们要保证指令的计算<strong>不会回读</strong>，即处理器不需要为了完成一条指令的执行而去读取由该指令更新的状态。因为该指令更新的状态是写入数据，需要经过一个时钟周期，如果该指令需要读取更新过的状态，就需要空出一个时钟周期。</p><p>我们通过寄存器和内存的时钟控制，由此设计了上一节中的指令执行阶段，这样能够保证即使所有状态同时更新，也能等价于顺序执行各个阶段，也保证了能够在一个周期中完成一条指令。</p><p>具体示例可看书中图4-25。</p><h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>SEQ所需要的控制块的逻辑用HCL进行描述。</p><p>由于内容过多，在这里我们仅对SEQ取指阶段中各控制块的逻辑，其余阶段可看书中相应章节。</p><p>首先给出各指令的编码：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724182642.jpg" alt="img" style="zoom:50%;" /><p>取指阶段：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724182712.jpg" alt="img" style="zoom:80%;" /><p>该部分访问<strong>内存硬件单元</strong>。首先以PC作为第一个字节的地址，一次从内存中读取10个字节。灰色部分是我们需要确定的HCL表达式</p><ul><li><code>icode</code>为第一字节的高4位，当指令地址越界时，指令内存会返回<code>imem_error</code>信号，此时直接将其表示为<code>nop</code>指令，否则获得高4位值</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word icode = [</span><br><span class="line">  imem_error : INOP;</span><br><span class="line">  1          : imem_icode;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li><code>ifun</code>为第一字节的低4位，当出现<code>imem_error</code>信号时，会使用默认功能码，否则获得低4位值</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word ifun = [</span><br><span class="line">  imem_error : FNONE;</span><br><span class="line">  1          : imem_ifun;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li><code>instr_valid</code>表示是否为合法指令</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool instr_valid = icode in &#123;</span><br><span class="line">  INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>need_regids</code>表示该指令否包含寄存器指示符字节，如果指令不含有寄存器指示符字节，则会将其赋值为<code>0xFF</code>。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_regids = icode in &#123;</span><br><span class="line">  IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>need_valC</code>表示该指令是否含有常数字节</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool need_valC = icode in &#123;</span><br><span class="line">  IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PC增加器会根据PC值、<code>need_valC</code>和<code>need_regids</code>来确定<code>valP</code>值，则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valP &#x3D; PC+1+need_regids+8*need_valC</span><br></pre></td></tr></table></figure><h3 id="SEQ性能"><a href="#SEQ性能" class="headerlink" title="SEQ性能"></a>SEQ性能</h3><p>我们通过将指令执行过程划分成了若干个阶段，使得我们能通过统一框架来描述各个指令执行的过程，也能进一步减少需要的硬件。但是由于每次时钟变为高电平时需要写入数据，使得需要在一个时间周期内完成所有步骤，所以我们要求时钟周期特别慢。</p><p>比如执行<code>ret</code>时，当前PC指向<code>ret</code>指令的地址，当时钟变为高电平时，我们需要在下一次时钟变为高电平之前，完成：两次从寄存器文件读取<code>%rsp</code>内容，通过ALU计算<code>%rsp</code>上移8字节的地址，根据<code>%rsp</code>从内存中获得返回地址，然后将新的<code>%rsp</code>值写回寄存器文件中（此时由于时钟还是低电平，所以还没有真实写入，只是设置为了值）。由此能够保证在下一个时钟变为高电平时，能够把正确的<code>%rsp</code>值写回寄存器文件中。</p><p>而且我们可以发现，<strong>指令执行的不同阶段是在处理器的不同硬件部分，所以完全可以让不同指令同时运行，只要求他们处于不同阶段</strong>，这也是下一节中流水线的主要思想。</p><h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><h2 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191507.jpg">  </p><p>如上图所示是一个非流水线化的计算硬件。当信号输入到组合逻辑中时，通过一系列逻辑门经过300ps获得输出信号，然后经过20ps将结果加载到寄存器中，由于时钟周期控制存储器写入的频率，为了保证当时钟变为高电平之前，能够得到将计算好的结果放到寄存器的输入端口，则这里的时钟周期设定为300+20=320ps。</p><p>我们将从头到尾执行一条指令所需的时间称为<strong>延迟（Delay）</strong>，则这里延迟为320ps。我们将系统在单位时间内能执行的指令数目称为<strong>吞吐量（Throughput）</strong>，则</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191419.png" alt="image-20210724191419109"></p><p>意味着一秒能执行3.12G条指令。</p><p>由于这个是非流水线化的计算硬件，所以从流水线图中可以看到在开始下一条指令之前必须完成上一条指令。如果我们将组合逻辑根据不同功能，通过<strong>流水线寄存器（Pipline Register）</strong>划分成独立的三阶段，就能得到简易的流水线化计算硬件。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191433.jpg" alt="img" style="zoom:67%;" /><p>由于每阶段的组合逻辑实现独立的功能，并且能通过流水线寄存器来控制进入下一阶段的时机，所以如上图的流水线图所示，只需要通过流水线寄存器控制每个阶段只执行一条指令，就能流水线化地执行指令。</p><p>对于每个阶段，我们需要100ps的组合逻辑计算时间以及20ps加载到寄存器的时间，所以我们这里能将时钟周期设定为120ps。并且我们可以发现每过一个时钟周期就有一条指令完成，所以吞吐量变为了8.33GIPS，提高了2.67倍。但是每条指令需要经过3个时钟周期，所以延迟为360ps，变为原来的1.12倍。</p><p>所以<strong>流水线特点</strong>为：提高系统的吞吐量，但是会轻微增加延迟。</p><h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><h3 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h3><p>处理器中的某些硬件单元，比如ALU或内存，是无法划分成多个延迟较小的单元的，这使得我们划分的不同阶段的组合逻辑具有不同的延迟。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191811.jpg" alt="img" style="zoom:67%;" /><p>如上图所示，其中组合逻辑B需要150ps进行计算。由于整个系统共用一个时钟周期，为了保证组合逻辑B能在一个时钟周期内计算出正确结果，使得保存到流水线寄存器中，我们就需要将时钟周期设定为150+20=170ps，这使得系统吞吐量变为5.88GIPS，而运行一条指令需要的延迟为3*170=510ps。</p><p><strong>注意：</strong>想要吞吐量最大，我们需要使得时钟周期尽可能小，而时钟周期受到最慢的组合逻辑的限制，所以我们可以将最小的组合逻辑的时间加上一个寄存器的时延作为时钟周期。想要延迟最小，就不使用流水线。</p><h3 id="流水线过深，收益下降"><a href="#流水线过深，收益下降" class="headerlink" title="流水线过深，收益下降"></a>流水线过深，收益下降</h3><p>我们将每个组合逻辑进一步划分成更小的部分，构建更深的流水线</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724191824.jpg" alt="img" style="zoom:80%;" /><p>这里时钟周期变为70ps，则吞吐量为14.29GIPS。这里我们可以发现，虽然我们将组合逻辑分成了更小的单元，使得组合逻辑的时延缩小了两倍，但是吞吐量的性能并没有提升两倍。这是由于更深的流水线，会扩大寄存器时延的影响，在70ps的时钟周期中，寄存器的时延就占了28.6%，意味着更深的流水线的吞吐量会依赖于寄存器时延的性能。</p><h3 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h3><p>我们之前考虑流水线时，只有当指令之间是不相关时才是完全正确的。但是真实系统中，指令之间存在两种形式的相关：<strong>数据相关（Data Dependency）</strong>，下一条指令会用到这条指令计算出来的结果；<strong>控制相关（Control Denpendency）</strong>，一条指令要确定下一条指令的位置。这些相关可能会导致流水线产生计算错误，称为<strong>冒险（Hazard）</strong>，包括：<strong>数据冒险（Data Hazard）</strong>和<strong>控制冒险（Control Hazard）</strong>。</p><h2 id="Y86-64流水线实现"><a href="#Y86-64流水线实现" class="headerlink" title="Y86-64流水线实现"></a>Y86-64流水线实现</h2><h3 id="SEQ-和PIPE"><a href="#SEQ-和PIPE" class="headerlink" title="SEQ+和PIPE-"></a>SEQ+和PIPE-</h3><p>为了平衡一个流水线系统各个阶段的延迟，需要使用<strong>电路重定时（Circuit Retiming）</strong>在不改变逻辑行为的基础上，修改系统的状态表示。如下图所示，顺序实现的SEQ中，更新PC阶段是在时钟周期结束时才执行的，通过组合电路计算得到的<code>icode</code>、<code>Cnd</code>、<code>valC</code>、<code>valM</code>和<code>valP</code>通过组合电路计算得到新的PC，将其保存到PC的时钟寄存器中。但是这些值是在不同阶段中计算出来的，所以SEQ+新增了一系列状态寄存器来保存之前计算出来的结果，然后将更新PC阶段放到了时钟周期开始执行，这样在每个阶段时钟周期变成高电平时就会将该阶段计算出来的值保存到状态寄存器中，然后PC逻辑电路就能根据当前的状态寄存器的值来预测下一步的PC值。</p><p>对应的SEQ+硬件结构在这里就不给出了（书中图4-40），可以发现将更新PC阶段移到了时钟周期开始的位置。</p><p>我们可以在各个阶段中加入流水线寄存器，并将信号重新排列来将SEQ+转换成初步的流水线处理器PIPE-，硬件结构如下图所示</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724192903.jpg" alt="preview" style="zoom:67%;" /><h3 id="处理控制相关"><a href="#处理控制相关" class="headerlink" title="处理控制相关"></a>处理控制相关</h3><p>对于<code>call</code>和<code>jmp</code>指令，下一条指令的地址就是<code>valC</code>，而除了条件分支和<code>ret</code>指令外，下一条指令的地址就是<code>valP</code>，这些指令不存在控制相关，使得流水线处理器能够每个时钟周期就处理一条指令。如果出现了条件分支，则需要该指令运行到执行阶段后才知道是否选择该分支，如果出现了<code>ret</code>指令，则需要该指令运行到访存阶段，才知道返回地址，此时就存在了控制相关，使得处理器要经过几个时钟周期才知道要运行的下一条指令的地址，所以<strong>控制冒险只会出现在条件分支和<code>ret</code>指令中</strong>，我们可以通过预测下一条PC来处理这个问题。</p><ul><li><p><strong>条件分支：</strong>我们可以通过<strong>分支预测</strong>技术来预测分支方向，并根据预测开始取值。常见的技术包括：</p></li><li><ul><li><strong>总是选择（always taken，AT）：</strong>总是预测处理器选择了条件分支，因此预测PC值为<code>valC</code>，成功率大约为60%。</li><li><strong>从不选择（never taken，NT）：</strong>总是预测处理器不选择条件分支，因此预测PC值为<code>valP</code>，成功率大约为40%。</li><li><strong>反向选择、正向不选择（backward taken, forward not-taken，BTFNT）：</strong>条件分支通常用于循环操作，当跳转地址比下一条指令地址小，说明进入了循环，否则退出循环，而循环通常会执行多次，因此当跳转地址比下一条指令地址低就选择分支，否则就不选择分支， 成功率大约为65%。</li></ul></li><li><p><code>ret</code>指令：常见的技术包括</p></li><li><ul><li>暂停处理新指令，直到<code>ret</code>指令通过写回阶段知道下一条指令的地址</li><li>在取指单元中放入一个硬件栈，保存过程调用指令产生的返回地址</li></ul></li></ul><p>当预测PC出现错误时出现控制冒险，会执行错误的指令，所以会极大影响流水线处理器的性能，后面再讨论这个问题。</p><p>在本文中，条件分支使用AT策略，<code>ret</code>指令使用第一条策略。从PIPE-硬件结构中可知，在取值阶段首先根据<code>icode</code>从<code>valP</code>和<code>valC</code>中选出预测的PC值，对于<code>call</code>和条件分支使用<code>valC</code>，其他指令使用<code>valP</code>。然后<code>Select PC</code>逻辑电路再从<code>predPC</code>、<code>M_valA</code>和<code>W_valM</code>中进行选择。我们推测为什么是这样的</p><ul><li><strong>条件分支：</strong>首先条件分支在取指阶段会直接选择条件分支，使得<code>predPC</code>为<code>valC</code>，则当条件分支执行到译码阶段时，<code>valC</code>对应的指令就会在取指阶段开始执行。当条件分支执行到执行阶段时，可以通过<code>CC</code>知道是否真的要选择条件分支，如果真的选择分支，则继续执行，否则条件分支的下一条指令地址应该是<code>valP</code>，此时该条件分支对应的<code>valP</code>保存在<code>M_valA</code>中，所以可以让<code>Select PC</code>选择<code>M_valA</code>来重新执行条件分支的部分。</li><li><strong>ret指令</strong>：当执行<code>ret</code>指令时，会暂停传入新的指令，知道<code>ret</code>指令执行到访存阶段时，才从内存中读取了下一条指令的返回地址，保存在<code>W_valM</code>中，所以<code>Select PC</code>可以选择<code>W_valM</code>来执行返回地址对应的指令。</li></ul><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>流水线冒险主要包含数据冒险和控制冒险，当程序状态的读写<strong>不处于同一阶段</strong>，就可能出现数据冒险，当出现分支预测错误或<code>ret</code>指令时，会出现控制冒险。</p><p>在Y86-64中，程序状态包含程序寄存器、内存、条件码寄存器和状态寄存器。程序寄存器的读取处于译码阶段，而写入处于写回阶段，因此程序寄存器会出现数据冒险的可能，以以下代码为例</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210820214336.jpg" alt="img" style="zoom: 75%;" /><p>我们在代码中插入了三行<code>nop</code>指令，则当<code>addq %rdx, %rax</code>处于译码阶段读取寄存器时，第一行和第二行指令已经完成了对寄存器<code>%rdx</code>和<code>%rax</code>的写入操作，因此该代码不会出现数据冒险，但是如果减少<code>nop</code>指令，第一行和第二行指令还没完成对寄存器的写入操作时，<code>addq %rdx, %rax</code>已经处于译码阶段读取寄存器了，此时就会读取到错误的值而出现数据冒险。由于读取操作和写入操作相差3个时钟周期，所以如果一条指令的操作数被它前面三条指令中的任何一条修改时，就会出现数据冒险。</p><p>而内存的读写都处于访存阶段、条件码寄存器的读写都处于执行阶段因此它们不会出现数据冒险的情况，而我们为每个阶段都在流水线寄存器中保留了stat值，所以当异常发生时，处理器就能有条理地停止。</p><p>所以这里我们主要探讨程序寄存器数据冒险和控制冒险。</p><h4 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h4><p>我们可以在执行阶段中插入一段自动产生的<code>nop</code>指令，来保持寄存器、内存、条件码和程序状态不变，使得当前指令停在译码阶段，并且会控制程序计数器不变，使得下一条指令停在取指阶段，直到产生指令的源操作数的指令通过了写回阶段。</p><p>该方法指令要停顿最少一个最多三个时钟周期，严重降低整体的吞吐量。</p><h4 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h4><p>对于以下代码我们可以发现，在第四个周期<code>I1</code>处于访存阶段而<code>I2</code>处于执行阶段，都还没有将<code>valE</code>保存在<code>%rdx</code>和<code>%rax</code>中，所以<code>I3</code>的译码阶段无法从寄存器文件中读取到正确的<code>%rax</code>和<code>%rdx</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724194438.jpg" alt="img"></p><p>但是即使还没有将<code>valE</code>保存到对应的寄存器文件中，其实<code>I1</code>在执行阶段已经将<code>%rdx</code>的值保存到流水线寄存器M中<code>M_valE</code>，而<code>I2</code>在执行阶段通过ALU计算得到了<code>%rax</code>的值<code>e_valE</code>，所以即使没有写入对应的寄存器文件中，已经能从<code>M_valE</code>和<code>e_valE</code>得到<code>%rax</code>和<code>%rbx</code>的值了，所以<code>I3</code>的译码阶段可以从以下形式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA = R[%rdx]</span><br><span class="line">valB = R[%rax]</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valA = M_valE</span><br><span class="line">valB = e_valE</span><br></pre></td></tr></table></figure><p>此时就不存在数据冒险，以及暂停了。</p><p>除了通过ALU的计算结果来转发，还能通过内存来进行转发，并且通过当前阶段的<code>dstE</code>和<code>dstM</code>与目标指令的<code>srcA</code>和<code>srcB</code>进行判断来决定是否转发。在处理器中，<code>valA</code>和<code>valB</code>一共有5个转发源：</p><ul><li><code>e_valE</code>：在执行阶段，ALU中计算得到的结果<code>valE</code>，通过<code>E_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li><li><code>M_valE</code>：将ALU计算的结果<code>valE</code>保存到流水线寄存器M中，通过<code>M_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li><li><code>m_valM</code>：在访存阶段，从内存中读取的值<code>valM</code>，通过<code>M_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li><li><code>W_valM</code>：将内存中的值<code>valM</code>保存到流水线寄存器W中，通过<code>W_dstM</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li><li><code>W_valE</code> ：将ALU计算的结果<code>valE</code>保存到流水线寄存器W中，通过<code>W_dstE</code>与<code>d_srcA</code>和<code>d_src_B</code>进行比较决定是否转发。</li></ul><h4 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h4><p>有一类数据冒险不能单纯用转发完成。我们考虑以下代码，可以发现在执行<code>0x032</code>指令的译码阶段时，<code>%rbx</code>的值通过转发技术可以从<code>M_valE</code>中获得，但是<code>%rax</code>的值需要<code>0x028</code>指令执行到访存阶段，才能从内存中读取到<code>%rax</code>的值，但是当前<code>0x028</code>指令处于执行阶段，所以无法通过转发技术来解决这个数据冒险。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724194936.jpg" alt="img" style="zoom:67%;" /><p>我们可以通过<strong>加载互锁（Load Interlock）</strong>方法来处理这种加载/使用数据冒险，其实就是引入了暂停，如下图所示，当<code>0x032</code>指令执行到译码阶段时，对该指令暂停一个时钟周期（所谓的<strong>插入气泡</strong>），此时<code>0x028</code>指令就能执行到访存阶段，此时就能从<code>m_valM</code>中获得<code>%rax</code>的值。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724194952.jpg" alt="img" style="zoom:67%;" /><p><strong>结合加载互锁和转发技术足以解决所有类型的数据冒险</strong>，并且对模型的吞吐量不会造成很大的影响。</p><h4 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h4><p>控制冒险只会出现在<code>ret</code>指令和跳转指令预测错方向时产生。</p><ul><li><code>ret</code>指令</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195257.jpg" alt="img" style="zoom:67%;" /><p>对于以上代码，对应的流水线图为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195318.jpg" alt="img" style="zoom: 67%;" /><p>可以发现，当执行<code>call proc</code>时，在取指阶段就能获得<code>valC</code>表示下一条指令的地址，所以会取到<code>ret</code>指令。而<code>ret</code>指令只有运行到访存阶段时才能获得返回地址<code>valM</code>，并且在写回阶段的时钟电平变高时，才会写入PC寄存器中，所以需要在<code>ret</code>指令后添加3个bubble。</p><ul><li>跳转指令</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195329.jpg" alt="img" style="zoom:80%;" /><p>对于以上代码，对应的流水线图为</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195500.jpg" alt="img" style="zoom:67%;" /><p>首先对于跳转分支，我们采用AT策略，所以在执行<code>jne target</code>的取指阶段时获得的<code>valC</code>会直接作为下一条指令的地址。当跳转指令运行执行阶段时，就会通过<code>CC</code>和<code>ifun</code>得知是否预测正确，此时已经将下一条指令运行到译码阶段，第二条指令运行到了取指阶段，如果预测错误，就会分别插入两个bubble，避免运行到后续阶段，改变程序员可见状态，会浪费两个时钟周期</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。当前的ISA包含三种内部产生的异常：1. halt指令；2. 非法指令码和功能码组合的指令；3. 取值或数据读写访问非法地址。外部产生的异常包括：接收到一个网络接口受到新包的信号、点击鼠标的信号等等。</p><p>在我们的ISA中，希望处理器遇到异常时，会停止并设置适当的状态码。<strong>要求：</strong>异常指令之前的所有指令已经完成，后续的指令都不能修改条件码寄存器和内存。流水线系统包含以下问题：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195641.jpg" alt="img" style="zoom:80%;" /><ol><li>当同时多条指令引起异常时，处理器应该向操作系统报告哪个异常？<strong>基本原则：</strong>由流水线中最深的指令引起的异常，优先级最高，因为指令在流水线中越深的阶段，表示该指令越早执行。</li><li>在分支预测中，当预测分支中出现了异常，而后由于预测错误而取消该指令时，需要取消异常。</li></ol><p>在PIPE硬件架构中，我们对每个流水线寄存器中都设置了一个<code>stat</code>信号，用来保存当前阶段的异常信号，随着流水线的进行，就能解决以上问题：</p><ol><li><code>stat</code>信号只是简单存放在流水线寄存器的状态字段中，不会对流水线中的指令流有任何影响，保证了异常指令之前的指令都能完成，但是要进制流水线中后面的指令不能更新条件码寄存器和内存。</li><li>当出现异常的指令到达写回阶段时，由于流水线中的指令是顺序执行的，所以能保证当前异常是最早出现的异常。</li><li>当条件分支预测错误时，直接取消该指令后，<code>stat</code>信号就不会保存下去了。</li><li>最终流水线寄存器W中的<code>stat</code>信号会被记录为程序状态。</li></ol><h2 id="流水线控制逻辑"><a href="#流水线控制逻辑" class="headerlink" title="流水线控制逻辑"></a>流水线控制逻辑</h2><p>会讨论流水线中低级机制，使得流水线控制逻辑能将指令阻塞在流水线寄存器或往流水线中插入一个气泡。并且在流水线中，还有些特殊情况是其他机制不能处理的，包括：加载/使用冒险、处理<code>ret</code>、预测错误的分支、异常等情况。</p><h3 id="暂停和气泡"><a href="#暂停和气泡" class="headerlink" title="暂停和气泡"></a>暂停和气泡</h3><p>暂停和气泡是流水线中低级的机制，<strong>暂停</strong>能将指令阻塞在某个阶段，往流水线中插入<strong>bubble</strong>能使得流水线继续运行，但是不会改变当前阶段的寄存器、内存、条件码或程序状态。这两个状态决定了当时钟电平变高时，如何修改流水线寄存器。</p><p>对于正常状态，即不是用暂停和bubble时，只要时钟电平变高，就会将流水线寄存器的状态修改为输入值，并作为新的输出。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195906.jpg" alt="img" style="zoom:67%;" /><ul><li><strong>暂停</strong></li></ul><p>通过加入流水线寄存器，我们将指令的执行划分成了不同的阶段，并且每个阶段的输入就是流水线寄存器中的内容，所以如果我们想要将指令暂停在某个阶段时，我们可以直接将该阶段的流水线寄存器固定不变，使得该阶段的输入信息保持不变，就能在该阶段反复地执行指令，就是的指令阻塞在当前阶段了。</p><p>所以将指令暂停在某个阶段，就是当时钟电平变高时，保持该阶段的流水线寄存器的状态不变</p><img src="https://pic1.zhimg.com/80/v2-bce6ccb8cf8e5cf86a1d8c4969ff54d8_720w.jpg" alt="img" style="zoom:67%;" /><ul><li><strong>bubble</strong></li></ul><p>当时钟电平变高时，上一阶段指令的执行结果会保存到当前阶段的流水线寄存器，执行当前阶段后就会修改程序员可见状态，当我们想要保持程序员可见状态不变，可以插入一个bubble，使得寄存器状态设置成某个固定的复位配置，得到一个等效于<code>nop</code>指令的状态，相当于取消指令的运行</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724195937.jpg" alt="img" style="zoom:67%;" /><h3 id="加载-使用冒险"><a href="#加载-使用冒险" class="headerlink" title="加载/使用冒险"></a>加载/使用冒险</h3><p><code>mrmovq</code>和<code>popq</code>指令<code>I1</code>会从内存中读取值保存到寄存器中，但是是在访存阶段才会读取到内存的值，所以如果下一条指令<code>I2</code>会读取这个寄存器的值，就会出现加载/使用冒险，因为当<code>I2</code>处于译码阶段读取寄存器值时，<code>I1</code>还是处于执行阶段，所以无法读取到内存的值。<strong>触发条件</strong>为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E_icode in &#123;IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA, d_srcB&#125; </span><br></pre></td></tr></table></figure><p><strong>理想处理方式</strong>为：固定流水线寄存器D和F，使得指令<code>I2</code>和下一条指令<code>I3</code>能分别阻塞在译码阶段和取指阶段，然后在译码阶段后面插入一个时钟周期的bubble，使得<code>I1</code>和前面的指令可以继续向后执行一个时钟周期，则<code>I1</code>此时处于访存阶段，就能读取到内存的值了。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200112.png" alt="img" style="zoom:80%;" /><p>所以当触发了加载/使用冒险时，流水线寄存器会如下设置一个时钟周期</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200140.png" alt="img" style="zoom:67%;" /><h3 id="处理ret指令"><a href="#处理ret指令" class="headerlink" title="处理ret指令"></a>处理<code>ret</code>指令</h3><p>执行<code>ret</code>指令时，会从栈中读取返回地址作为下一条指令的地址，所以当<code>ret</code>执行到访存阶段时，才能读取到下一条指令的地址，然后在写回阶段的时钟电路变成高电平时，才会将其写入流水线寄存器M中，然后将<code>M_valM</code>传回去到<code>Select PC</code>逻辑模块。<strong>触发条件</strong>为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRET in &#123;D_icode, E_icode, M_icode&#125;</span><br></pre></td></tr></table></figure><p><strong>理想处理方式</strong>为：当<code>ret</code>执行到译码阶段时，会触发触发条件，此时就固定流水线寄存器F，就能保持不断读取下一条指令<code>I2</code>，并且后面在译码阶段插入3个时钟周期的bubble（根据取指阶段的HCL，会不断执行<code>valP</code>的错误指令，但是通过插入bubble，使得它只能执行到取指阶段），使得<code>ret</code>指令能向后执行3个时钟周期到达写回阶段，此时就能直接通过<code>W_valM</code>获得下一个PC的地址。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200155.jpg" alt="img" style="zoom:80%;" /><p>所以当触发了<code>ret</code>指令时，流水线寄存器会如下设置3个时钟周期</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200205.png" alt="img" style="zoom:67%;" /><h3 id="预测错误的分支"><a href="#预测错误的分支" class="headerlink" title="预测错误的分支"></a>预测错误的分支</h3><p>我们采用AT分支预测策略，所以当遇到条件分支指令<code>I1</code>时，会直接跳转到对应的地址开始执行，只有当<code>I1</code>执行到执行阶段时，才能通过<code>e_Cnd</code>判断是否发生跳转，此时已经执行了后续的两个指令<code>I2</code>和<code>I3</code>，分别处于译码阶段和取指阶段。预测错误的<strong>触发条件</strong>为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E_icode == IJXX &amp;&amp; !e_Cnd</span><br></pre></td></tr></table></figure><p>当出现预测错误时，说明我们并不需要执行已经执行了的<code>I2</code>和<code>I3</code>指令，<strong>理想的处理方式</strong>为：直接在译码阶段插入bubbl中断<code>I3</code>，在执行阶段插入bubble中断<code>I2</code>，然后将正确的指令放入取指阶段开始执行，所以分支预测错误最多损耗两个时钟周期。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200228.jpg" alt="img" style="zoom:80%;" /><p>所以当触发了预测错误的分支时，流水线寄存器就会如下设置一个时钟周期</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210724200257.png" alt="img" style="zoom:67%;" /><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3><p>当出现<code>halt</code>指令、错误的指令码和函数码组合的指令或内存地址错误时，就会出现异常，所以异常通常在取指阶段和访存阶段被发现，对于异常<strong>理想的处理方式</strong>为：异常指令之前的指令都能完成，之后的指令都不会修改程序员可见状态，异常指令到达写回阶段时停止执行。</p><p>但是存在以下<strong>困难：</strong>异常在取指阶段和访存阶段被发现，程序员可见状态在执行阶段、访存阶段和写回阶段被修改。</p><p>我们首先在所有阶段的流水线寄存器中都包含一个程序状态信号<code>stat</code>，即使出现了异常，也只是将其当做普通信号传到下一阶段。当异常指令到达访存阶段时，后续的三条指令分别处于执行阶段、译码阶段和取指阶段，只有处于执行阶段的指令会修改条件码寄存器，所以要禁止执行阶段中的指令设置条件码。并且在访存阶段插入bubble，使得异常指令执行到写回阶段时，下一条指令就阻塞在执行阶段，不会到达访存阶段来修改内存。由于流水线处理器是按顺序处理指令的，所以第一次在写回阶段检测到异常指令就是最新的异常，所以只要在写回阶段检测到异常指令，就暂停写回，并暂停流水线。</p><p><strong>触发条件</strong>为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_stat in &#123;SADR, SINS, SHLT&#125; || W_stat in &#123;SADR, SINS, SHLT&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊情况组合"><a href="#特殊情况组合" class="headerlink" title="特殊情况组合"></a>特殊情况组合</h3><p>特殊情况在这里不记录，详情可以看书中对应章节。</p><h2 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h2><h3 id="多周期指令"><a href="#多周期指令" class="headerlink" title="多周期指令"></a>多周期指令</h3><p>我们提供的Y86-64指令集只有简单的操作，在执行阶段都能在一个时钟周期内完成，但是如果要实现整数乘法和除法以及浮点数运算，我们首先要增加额外的硬件来执行这些计算，并且这些指令在执行阶段通常都需要多个时钟周期才能完成，所以执行这些指令时，我们需要平衡流水线各个部分之间的关系。</p><p>实现多周期指令的简单方法是直接暂停取指阶段和译码阶段，直到执行阶段执行了所需的时钟周期后才恢复，这种方法的性能通常比较差。</p><p>常见的方法是使用独立于主流水线的特殊硬件功能单元来处理复杂的操作，通常会有一个功能单位来处理整数乘法和除法，还有一个功能单位来处理浮点数运算。在译码阶段中遇到多周期指令时，就可以将其发射到对应的功能单元进行运算，而主流水线会继续执行其他指令，使得多周期指令和其他指令能在功能单元和主流水线中并发执行。但是如果不同功能单元以及主流水线的指令存在数据相关时，就需要暂停系统的某部分来解决数据冒险。也同样可以使用暂停、转发以及流水线控制。</p><h3 id="与存储系统的接口"><a href="#与存储系统的接口" class="headerlink" title="与存储系统的接口"></a>与存储系统的接口</h3><p>我们假设了取指单元和数据内存都能在一个时钟周期内读写内存中的任意位置，但是实际上并不是。</p><ol><li>处理器的存储系统是由多种硬件存储器和管理虚拟内存的操作系统共同组成的，而存储系统包含层次结构，最靠近处理器的一层是<strong>高速缓存（Cache）存储器</strong>，能够提供对最常使用的存储器位置的快速访问。典型系统中包含一个用于读指令的cache和一个用于读写数据的cache，并且还有一个<strong>翻译后备缓冲器（Translation Look-aside Buffer，TLB）</strong>来提供从虚拟地址到物理地址的快速翻译。将TLB和cache结合起来，大多数时候能再一个时钟周期内读指令并读写数据。</li><li>当我们想要的引用位置不在cache中时，则出现高速缓存<strong>不命中（Miss）</strong>，则流水线会将指令暂停在取指阶段或访存阶段，然后从较高层次的cache或处理器的内存中找到不命中的数据，然后将其保存到cache中，就能恢复指令的运行。这通常需要3~20个时钟周期。</li><li>如果我们没有从较高层次的cache或处理器的内存中找到不命中的数据，则需要从磁盘存储器中寻找。硬件会先产生一个<strong>缺页（Page Fault）</strong>异常信号，然后调用操作系统的异常处理程序代码，则操作系统会发起一个从磁盘到主存的传送操作，完成后操作系统会返回原来的程序，然后重新执行导致缺页异常的指令。其中访问磁盘需要数百万个时钟周期，操作系统的缺页中断处理程序需要数百个时钟周期。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 处理器体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp程序的机器级表示（三）</title>
      <link href="2021/07/23/csapp/csapp%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>2021/07/23/csapp/csapp%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。</p><p>对于机器级编程来说，其中两种抽象尤为重要：</p><ol><li>指令集体系结构（Instruction set architecture ISA）</li></ol><p>它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</p><p>IA32将程序的行为描述成好像每条指令时按顺序执行的，一条指令结束后，下一条再开始。（实际上处理器并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行完全一致）</p><ol start="2"><li>机器级程序使用的存储器地址是虚拟地址</li></ol><p>提供的存储器模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</p><p>程序存储器(program memory)包含：程序的可执行机器代码、操作系统需要的一些信息、栈、堆。程序存储器用虚拟地址来寻址（此虚拟地址不是机器级虚拟地址）。操作系统负责管理虚拟地址空间（程序级虚拟地址），将虚拟地址翻译成实际处理器存储器中的物理地址（机器级虚拟地址）。</p><h3 id="寄存器使用惯例"><a href="#寄存器使用惯例" class="headerlink" title="寄存器使用惯例"></a>寄存器使用惯例</h3><p>程序寄存器组是唯一能被所有函数共享的资源。</p><p>虽然在给定时刻只能有一个函数是活动的，但是我们必须保证当一个函数调用另一个函数时，被调用者不会覆盖某个调用者稍后会用到的值。为此，IA32采用了一组统一的寄存器使用规则，所有的函数都必须遵守，包括程序库中的函数。</p><p>根据惯例：寄存器%eax、%edx、%ecx被划分为调用者保存寄存器。当过程P调用Q时，Q可以覆盖这些寄存器，不会破坏任何P所需要的数据。</p><p>另一方面，寄存器%ebx、%esi、%edi被划分为被调用者寄存器。这意味着Q必须在覆盖这些寄存器的值之前，先把它们保存到栈中，并在返回前恢复它们。此外还必须保持寄存器%ebp和%esp。</p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>除了整数寄存器，CPU还维护着一组单个位的条件码（condition code）寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：</p><ul><li><code>CF</code> ：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作的溢出。</li><li><code>ZF</code> ：零标志。最近操作得出的结果为0。</li><li><code>SF</code> ：符号标志。最近的操作得到的结果为负数。</li><li><code>OF</code> ：溢出标志。最近的操作导致一个补码溢出——正溢出或者负溢出。</li></ul><p><code>leaq</code> 指令不改变任何条件码，因为它是用来进行地址计算的。</p><p>有两类指令（有8、16、32和64位形式），它们只设置条件码而不改变任何其他寄存器。</p><ul><li><code>CMP</code> 指令根据两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外， <code>CMP</code> 指令与 <code>SUB</code> 指令的行为是一样的。</li><li><code>TEST</code> 指令的行为与 <code>AND</code> 指令一样，除了它们指设置条件码而不改变目的寄存器的值。</li></ul><h4 id="条件控制和条件传送"><a href="#条件控制和条件传送" class="headerlink" title="条件控制和条件传送"></a>条件控制和条件传送</h4><p><strong>条件控制</strong>：当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制比较简单，但在现代处理器上可能会非常<strong>低效</strong>。</p><p><strong>条件传送</strong>：这种方法计算一个条件操作的两种结果，然后再根据条件是否满足，从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现的条件传送指令更符合现代处理器的性能特性（契合流水线操作）。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><ul><li><p>机器用栈来传递参数、存储返回信息、保存寄存器用于以后恢复以及本地存储等。</p></li><li><p>为单个过程分配的那部分栈称为<strong>栈帧</strong>（stack frame）。</p></li><li><p>栈帧以两个指针界定，寄存器%ebp为帧指针，寄存器%esp为栈指针，当程序执行时，栈指针可以移动，因此大多数信息的访问都是相对于帧指针（即帧指针为当前栈帧的固定起点）的。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210723155508.png" alt="image-20210723155508051" style="zoom:50%;" /></li></ul><h4 id="call-指令和-ret-指令"><a href="#call-指令和-ret-指令" class="headerlink" title="call 指令和 ret 指令"></a>call 指令和 ret 指令</h4><ul><li><p>call指令的效果是将返回地址入栈，并跳转到被调用过程的起始处。（返回地址是在程序正文中紧跟在call后面的那条指令的地址，这样当被调用过程返回时，执行流会从此处继续。）</p></li><li><p>ret指令从栈中弹出地址，并跳转到这个位置。（使用这条指令前，要使栈做好准备，栈顶指针要指向前面call指令存储返回地址的位置）</p></li></ul><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>通常，在栈中分配某个字节数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。C对于数组引用不进行任何边界检查，而且局部变量和状态信息，都存在栈中。这样，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。</p><p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。</p><p>通常，使用gets或其他任何能导致存储溢出的函数，都不是好的编程习惯。不幸的是，很多常用库函数，包括strcpy、strcat、sprintf，都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列。</p><h3 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h3><ol><li><p>栈随机化</p><p>为了在系统中插入攻击代码，攻击者不但要插入代码，还要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测，在不同的机器之间，栈的位置是相当固定的。</p><p><strong>栈随机化的思想使得栈的位置在程序每次运行时都有变化</strong>。因此，即使许多机器都运行相同的代码。它们的栈地址都是不同的。</p><p>实现的方式是：程序开始时，在栈上分配一段0–n字节之间的随机大小空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。</p><p>在Linux系统中，栈随机化已经变成了标准行为。（在linux上每次运行相同的程序，其同一局部变量的地址都不相同）</p></li><li><p>栈破坏检测</p><p>在C语言中，没有可靠的方法来防止对数组的越界写，但是，我们能够在发生了越界写的时候，在没有造成任何有害结果之前，尝试检测到它。</p><p>最近的GCC版本在产生的代码中加入了一种栈保护者机制，用来检测缓冲区越界，<strong>其思想是在栈中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值</strong>。这个金丝雀值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法知道它是什么。</p><p>在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者函数调用的某个操作改变了。如果是，那么程序异常终止。</p></li><li><p>限制可执行代码区域</p><p><strong>限制那些能够存放可执行代码的存储器区域</strong>。在典型的程序中，只有保存编译器产生的代码的那部分存储器才需要是可执行的，其他部分可以被限制为只允许读和写。</p><p>现在的64位处理器的内存保护引入了”NX”(不执行)位。有了这个特性，栈可以被标记为可读和可写，但是不可执行，检查页是否可执行由硬件来完成，效率上没有损失。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序的机器级表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp信息的表示和处理（二）</title>
      <link href="2021/07/13/csapp/csapp%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2021/07/13/csapp/csapp%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="信息的存储"><a href="#信息的存储" class="headerlink" title="信息的存储"></a>信息的存储</h3><p><strong>字节</strong>：大多数计算机都使用<code>字节</code>(byte)作为系统中最小内存单位，内存就可以看作一个巨大的byte数组</p><p><strong>虚拟地址空间</strong>：操作系统为程序提供<code>虚拟内存</code>(virtual memory)这一概念屏蔽了底层存储系统的复杂性，其中虚拟内存中每个字节都有自己的地址，也就是<code>虚拟地址</code>(virtual address)，虚拟内存中所有可能地址的集合就是<code>虚拟地址空间</code>(virtual address space)，C语言中某个指针的值就是某个存储块第一个字节的虚拟地址</p><blockquote><p>指针：C语言的重要特性，有<code>值</code>和<code>类型</code>两个属性，<code>值</code>是某个对象的虚拟地址，<code>类型</code>是表示那个位置上存储对象的类型</p></blockquote><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>一个字节是8位，表示成二进制是<code>00000000 ~ 11111111</code>，表示成十进制的范围是<code>0 ~ 255</code>，表示成十六进制是<code>00 ~ FF</code>，很明显十六进制的表示方式更加简洁易用，计算机系统中通常以<code>0x</code>开头表示一个以十六进制展现的内存地址</p><h4 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h4><p>所谓<code>字长</code>，就是指针携带的地址值的标称大小，32位字长的机器其虚拟地址范围就是0 ~ 2^32^（最大虚拟地址值是2^32^-1，也就是说32位字长的系统虚拟地址空间大小就是4GB），64位字长的机器其虚拟地址范围就是0 ~ 2^64^（16EB）</p><blockquote><p>向后兼容：64位机器可以运行32位机器编译的程序，但32位机器无法运行64位机器编译的程序</p></blockquote><h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><p>一个对象在内存中是以连续的字节序列的形式存储的，对象的地址就是这段字节序列中最低位置的地址值</p><p>对象字节序列中，开始位置的字节称为<code>最低有效位</code>，结束位置称为<code>最高有效位</code>，比如对于<code>0x01234567</code>这个int，最高有效位字节就是01，最低有效位字节是67</p><h5 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h5><p>对象在内存中的字节序列是由一定的顺序进行保存的，保存对象字节序列的顺序就是字节顺序，有<code>大端法</code>和<code>小端法</code>两种：</p><ul><li>大端法：从最高有效位到最低有效位的顺序存储对象</li><li>小端法：从最低有效位到最高有效位的顺序进行存储</li></ul><h5 id="字符串的字节顺序"><a href="#字符串的字节顺序" class="headerlink" title="字符串的字节顺序"></a>字符串的字节顺序</h5><p>字符串类型的字节顺序与其他类型稍有不同，在任意平台上字符串都是正序排列</p><h4 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h4><p>布尔运算在计算机系统中占有很重要的地位，在数值位运算中运用尤为广泛</p><p>基本的布尔运算逻辑有四种<code>&amp;（与）</code>，<code>|（或）</code>，<code>~（非）</code>，<code>^（异或）</code>，四种布尔运算逻辑表格如下：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210713100019.png" alt="img"></p><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>布尔代数在计算机科学中一个很重要的运用就是位运算，C和Java等高级语言都支持位运算</p><p>有以下程序，可以将x和y各自的地址相互对调：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplace_swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    *y = *x ^ *y;</span><br><span class="line">    *x = *x ^ *y;</span><br><span class="line">    *y = *x ^ *y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">9</span>;</span><br><span class="line">    inplace_swap(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果显示x=9，y=10，因为我们通过三次异或运算将x和y的值进行了对调，由此产生了一些结论：</p><ol><li>异或运算中，任何值与0的异或结果还是它本身</li><li>异或运算中，任何值与它自己的异或结果为0</li><li>异或运算支持结合律</li></ol><p>通过以下函数可以将一个数组前后颠倒：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first, last;</span><br><span class="line">    <span class="keyword">for</span> (first = <span class="number">0</span>, last = count <span class="number">-1</span>; first &lt; last; first++, last--) &#123;</span><br><span class="line">        inplace_swap(&amp;a[first], &amp;a[last]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of array is %d\n&quot;</span>, len);</span><br><span class="line">    reverse_array(a, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果是”6, 5, 4, 3, 2, 1”</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>逻辑运算符和位运算符功能相似，不过逻辑运算符针对Boolean类型，而位运算符仅仅对数字做二进制位运算</p><h5 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h5><p>移位运算通常用于对数字的二进制位进行移动计算，具体的移位运算还包括<code>逻辑移位</code>和<code>算术移位</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210713100030.png" alt="img"></p><p>与<code>逻辑右移位</code>不同的是，<code>算术右移位</code>会在空出来的高位补足移位个数的最高有效位的值</p><p>与C语言不同的是，Java中<code>&gt;&gt;</code>代表<code>算术右移位</code>，<code>&gt;&gt;&gt;</code>代表<code>逻辑右移位</code></p><p><strong>注意</strong>：移位运算符的优先级低于加减法运算符</p><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><p>整数类型在32位机器和64位机器上的取值范围是不一样的，int类型都是4字节编码，long类型在32位机器上是4字节编码，在64位机器上是8字节编码，此外C语言规定int类型可以用2字节长度来编码，long字节可以用4字节长度来编码，我想这应该是为了兼容32位和64位的平台</p><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>无符号数是没有负数编码的数字，最小值为0，在C语言中用<code>unsigned</code>进行声明，一般来说<code>int</code>表示有符号整形，<code>uintb</code>表示无符号整形 （与C语言不同，Java没有无符号数）</p><p><strong>无符号数编码唯一性</strong>：在计算机系统中无符号数的编码具有唯一性，比如无符号数<code>10</code>的二进制编码是<code>1010</code>，那么可以断言<code>1010</code>这个编码如果表示的是一个无符号数的话，那它对应的十进制就只能是<code>10</code></p><h4 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h4><p>学习有符号数前需要先了解<code>补码编码</code></p><h5 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h5><blockquote><p>补码`是计算机系统中表示负数必不可少的编码手段，通过补码表示的数字的最高有效位是符号位，为0则表示正数，为1则表示负数</p></blockquote><p><strong>补码转换为十进制有符号数</strong>：以下是换算补码二进制数到十进制数的两种方式：</p><p><strong>权重法</strong>：换算方式与无符号二进制转十进制的方式类似，不过高位符号位需要取负号：<br>$$<br>1011: -1 <em>2^3 + 0</em> 2^2 + 1 <em>2^1 + 1</em> 2^0 = -5<br>$$</p><p>$$<br>0101: 0 <em>2^3 + 1</em> 2^2 + 0 <em>2^1 + 1</em> 2^0 = 5<br>$$</p><p><strong>取反法</strong>：判断最高有效位，如果最高位为0，则为正数，计算方式与无符号数一致，如果为1，则为负数，将最高位去掉，剩余位减去1后各位再取反，得到的二进制编码则是该负数的绝对值，比如上述例子中的<code>1011</code>去掉最高位后未<code>011</code>，减去1后为<code>010</code>，全部取反后为<code>101</code>，转换为十进制为<code>5</code>，则该负数是<code>-5</code></p><p><strong>十进制有符号数转换为补码</strong>: 相应的，将十进制负数<code>-5</code>转换为补码形式<code>1011</code>就有以下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 绝对值转换为二进制： 101</span><br><span class="line"># 二进制位全部取反： 010</span><br><span class="line"># 加1： 011</span><br><span class="line"># 加上符号位： 1011</span><br></pre></td></tr></table></figure><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h4><p>使用无符号加法需要注意溢出的情况，下列无符号short求和最后结果就发生了溢出，同样产生了截断，实际结果比理想的结果少了2^16^</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> c = <span class="number">44444</span> + <span class="number">22222</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a is %u, b is %u, result is %u&quot;</span>, a, b, c);</span><br></pre></td></tr></table></figure><p>最后结果为1130，想要的结果是66666</p><h4 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h4><p>大部分时间进行数值计算都是对补码进行操作，在进行补码加法时需要考虑当结果太大或者太小时会不会发生溢出的情况</p><p>与无符号加法类似，如果加法结果超过当前数值类型的位数范围时会发生正溢出（太大）或者负溢出（太小）：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210713100044.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> c = <span class="number">-22222</span> + (<span class="number">-22222</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a is %u, b is %u, result is %u&quot;</span>, a, b, c);</span><br></pre></td></tr></table></figure><p>其结果为21092，发生了负溢出，其结果比想要的结果大了65536，也就是2^16^</p><p>以下函数无法判断两个有符号补码数相加是否发生了溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_overflow_short_add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> (c - a) == b &amp;&amp; (c - b) == a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个补码a和b相加得到结果c，不管有没有溢出，c-a的结果始终还是b，c-b的结果始终还是a</p><h4 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h4><p>无符号乘法也存在高位截断的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">222</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b = <span class="number">333</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> c = a * b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br></pre></td></tr></table></figure><p>理想结果为73926，实际得到的结果为8390，说明溢出的部分被截断了，只剩下了低16位的数据，也就是少了2^16^</p><h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p>补码乘法与无符号乘法差不多(<strong>两者的乘法运算位级表示都一样</strong>)，与补码加法一样也需要注意正溢出和负溢出截断的问题</p><h4 id="对于某些常数乘法的优化"><a href="#对于某些常数乘法的优化" class="headerlink" title="对于某些常数乘法的优化"></a>对于某些常数乘法的优化</h4><p>乘法运算在大多数计算机上都是一个相当慢的运算，需要消耗过多的时钟周期，因此编译器对常数乘法运算会进行一些优化，用移位或者加法运算来代替常数因子的乘法运算</p><p><code>移位优化</code>：某个数与2的幂作乘法就可以进行移位运算，<code>X * 2^k</code>就可以直接将X左移k位</p><p><code>加法优化</code>：将乘数拆散为2的幂次的和，比如<code>X * 14</code>就可以拆为<code>X * (2^3 + 2^2 + 2)</code>，然后再用移位计算各个部分的值，最后再统一相加</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>现代计算机采用<code>IEEE浮点数标准</code>来处理带小数点的数字</p><h4 id="二进制表示小数"><a href="#二进制表示小数" class="headerlink" title="二进制表示小数"></a>二进制表示小数</h4><p>与整数的二进制表示法类似，带小数的数字是用2的负幂次叠加来进行表示，比如5.75就可以拆散为：</p><p><code>4 + 0 + 1 + 1/2 + 1/4</code>，用二进制进行表示就是：<code>101.11</code></p><p>二进制用以下规则表示带小数的数字，整数部分就是2的正幂次，小数部分就是2的负幂次：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210713101535.png" alt="img"></p><p><strong>缺陷</strong>：可以看出，二进制表示小数无法做到像十进制这么精确，像1/5这种小数通过十进制可以表示为0.2，但是用二进制的话只能通过增加二进制小数位数构造一个近似值来逼近，例如<code>0.00110011</code>这个二进制小数转换为十进制是<code>0.19921875</code>，已经很接近了</p><h4 id="IEEE浮点数表示法"><a href="#IEEE浮点数表示法" class="headerlink" title="IEEE浮点数表示法"></a>IEEE浮点数表示法</h4><p>在二进制定点表示法的基础上，IEEE标准用以下公式来存储一个浮点数：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210713101551.png" alt="img" style="zoom:67%;" /><p>各个参数解释如下：</p><ul><li><code>s</code>：符号标记，无论是float还是double类型都是有符号数，s为1则表示负数，s为0表示正数</li><li><code>M</code>：尾数，保存浮点数的实际有效位，其大小是<code>1 &lt;= M &lt; 2</code>，以<code>1.1101</code>这样的形式展示；不过存储的时候会省略小数点左边的1，只存储右边的位，我们把保留下来的小数点右边的位称为<code>f</code></li><li><code>E</code>：阶码，对尾数M进行加权，判断M的小数点需要左移或者右移多少位，最终计算得到真正的浮点数二进制表示</li></ul><p>计算机系统保存浮点数就是对这三个参数分别进行编码保存到固定的位数中，float类型保存到32位长度中，double类型则保存到64位长度中</p><p><strong>float &amp; double</strong>：单精度浮点（float）和双精度浮点（double）除了最高位的符号位s，剩下的区别主要体现在对M和E的保存位数不一样：</p><ul><li><code>float</code>：E取8位，M取23位</li><li><code>double</code>：E取11位，M取52位</li></ul><p>以32位的float为例讲一下编码保存各个参数的规则：</p><ul><li>编码s：保存为1或者0</li><li>编码E：E的值即要表现2的正幂次，也要表现2的负幂次，而编码保存后的八位数<code>e</code>只能是无符号整数，范围是0 ~ 2^8^-1=255，因此E的真实取值范围需要在这个基础上做一个2^7^-1=127的偏移处理，也就是说<code>e = E + 127</code></li><li>编码M：省略掉M小数点左边的1，只保留小数点右边的23位，也就是<code>f</code></li></ul><p>基于这个基本表示规则，有四种不同的情况，以32位float为例：</p><ul><li><code>E编码保存的值(e)不为0或者255(2^8-1)</code>：这种情况即为普通情况，E的取值范围是<code>-126 ~ 127</code></li><li><code>e所有位都为0</code>：称为非规格化值，规定这种情况在解码时舍弃掉M小数点左边的1，只保留<code>f</code>；这种情况一般时拿来表示正0或者负0，或者非常逼近于0的小数</li><li><code>e所有位都为1 &amp; f所有位为0</code>：无穷大数，s为1是负无穷，s为0是正无穷</li><li><code>e所有位都为1 &amp; f不为0</code>：NaN，用来表现不是数字（无意义的数字）的情况</li></ul><p><strong>例子</strong>：以float类型<code>1.25</code>为例，计算机系统中使用32位二进制<code>00111111101000000000000000000000</code>来保存1.25</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210713101648.png" alt="img" style="zoom:75%;" /><p>如图：</p><ol><li>符号位s为0，表示正数</li><li>阶码位e有8位，其值是127，因此<code>E = 127 - 127 = 0</code>，阶码E为0</li><li>尾数位f有23位，其值是二进制0.01，也就是1/(2^2) = 1/4</li></ol><p>最终值<code>V = 1 * (1/(2^2)) * 1 = 1.25</code></p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解计算机系统》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之主从复制</title>
      <link href="2021/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>2021/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="复制基本原理"><a href="#复制基本原理" class="headerlink" title="复制基本原理"></a>复制基本原理</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210703162224.png" alt="image-20210703162224667" style="zoom:80%;" /><p>MySQL复制过程分为三步：</p><ul><li>Master将变更记录到二进制日志(Binary Log)。这些记录过程叫做二进制日志事件，<code>Binary Log Events</code>；</li><li>Slave将Master的<code>Binary Log Events</code>拷贝到它的中继日志(Replay Log);</li><li>Slave重做中继日志中的事件，将变更应用到自己的数据库中。MySQL复制是异步且串行化的。</li></ul><h2 id="复制基本原则"><a href="#复制基本原则" class="headerlink" title="复制基本原则"></a>复制基本原则</h2><ul><li>每个Slave只有一个Master。</li><li>每个Slave只能有一个唯一的服务器ID。</li><li>每个Master可以有多个Salve。</li></ul><h2 id="一主一从配置"><a href="#一主一从配置" class="headerlink" title="一主一从配置"></a>一主一从配置</h2><blockquote><p>1、基本要求：Master和Slave的MySQL服务器版本一致且后台以服务运行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建mysql-slave1实例</span><br><span class="line">docker run -p 3307:3306 --name mysql-slave1 \</span><br><span class="line">-v &#x2F;root&#x2F;mysql-slave1&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;root&#x2F;mysql-slave1&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v &#x2F;root&#x2F;mysql-slave1&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;333 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>2、主从配置都是配在[mysqld]节点下，都是小写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Master配置</span><br><span class="line">[mysqld]</span><br><span class="line">server-id&#x3D;1 # 必须</span><br><span class="line">log-bin&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-bin # 必须</span><br><span class="line">read-only&#x3D;0</span><br><span class="line">binlog-ignore-db&#x3D;mysql</span><br><span class="line"># Slave配置</span><br><span class="line">[mysqld]</span><br><span class="line">server-id&#x3D;2 # 必须</span><br><span class="line">log-bin&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-bin</span><br></pre></td></tr></table></figure><blockquote><p>3、Master配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 1、创建用户（mysql8.0以前的版本可以使用grant在授权的时候隐式的创建用户，8.0以后已经不支持，所以必须先创建用户，然后再授权）</span><br><span class="line">mysql&gt; CREATE USER &#39;zhangsan&#39;@&#39;172.18.0.3&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line"></span><br><span class="line"># 2、授权，GRANT REPLICATION SLAVE ON *.* TO &#39;username&#39;@&#39;从机IP地址&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;172.18.0.3&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 3、刷新命令</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 4、记录下File和Position</span><br><span class="line"># 每次配从机的时候都要SHOW MASTER STATUS;查看最新的File和Position</span><br><span class="line">mysql&gt; SHOW MASTER STATUS;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      602 |              | mysql            |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>4、Slave从机配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;172.18.0.4&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;zhangsan&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.File的编号&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;Position的最新值;</span><br><span class="line"># 1、使用用户名密码登录进Master</span><br><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST&#x3D;&#39;172.18.0.4&#39;,</span><br><span class="line">    -&gt; MASTER_USER&#x3D;&#39;zhangsan&#39;,</span><br><span class="line">    -&gt; MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,</span><br><span class="line">    -&gt; MASTER_LOG_POS&#x3D;602;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.02 sec)</span><br><span class="line"></span><br><span class="line"># 2、开启Slave从机的复制</span><br><span class="line">mysql&gt; START SLAVE;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 3、查看Slave状态</span><br><span class="line"># Slave_IO_Running 和 Slave_SQL_Running 必须同时为Yes 说明主从复制配置成功！</span><br><span class="line">mysql&gt; SHOW SLAVE STATUS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event # Slave待命状态</span><br><span class="line">                  Master_Host: 172.18.0.4</span><br><span class="line">                  Master_User: zhangsan</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 602</span><br><span class="line">               Relay_Log_File: b030ad25d5fe-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes  </span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 602</span><br><span class="line">              Relay_Log_Space: 534</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: bd047557-b20c-11ea-9961-0242ac120002</span><br><span class="line">             Master_Info_File: &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>5、测试主从复制</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Master创建数据库</span><br><span class="line">mysql&gt; create database test_replication;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"># Slave查询数据库</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test_replication   |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>6、停止主从复制功能</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># 1、停止Slave</span><br><span class="line">mysql&gt; STOP SLAVE;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 2、重新配置主从</span><br><span class="line"># MASTER_LOG_FILE 和 MASTER_LOG_POS一定要根据最新的数据来配</span><br><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST&#x3D;&#39;172.18.0.4&#39;,</span><br><span class="line">    -&gt; MASTER_USER&#x3D;&#39;zhangsan&#39;,</span><br><span class="line">    -&gt; MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">    -&gt; MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000001&#39;,</span><br><span class="line">    -&gt; MASTER_LOG_POS&#x3D;797;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; START SLAVE;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW SLAVE STATUS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.18.0.4</span><br><span class="line">                  Master_User: zhangsan</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 797</span><br><span class="line">               Relay_Log_File: b030ad25d5fe-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 797</span><br><span class="line">              Relay_Log_Space: 534</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: bd047557-b20c-11ea-9961-0242ac120002</span><br><span class="line">             Master_Info_File: &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之锁</title>
      <link href="2021/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E9%94%81/"/>
      <url>2021/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h1><p><strong>表锁特点：</strong></p><ul><li>表锁偏向<code>MyISAM</code>存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、创建表</span><br><span class="line">CREATE TABLE &#96;mylock&#96;(</span><br><span class="line">&#96;id&#96; INT NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">&#96;name&#96; VARCHAR(20)</span><br><span class="line">)ENGINE&#x3D;MYISAM DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;测试表锁&#39;;</span><br><span class="line"></span><br><span class="line"># 2、插入数据</span><br><span class="line">INSERT INTO &#96;mylock&#96;(&#96;name&#96;) VALUES(&#39;ZhangSan&#39;);</span><br><span class="line">INSERT INTO &#96;mylock&#96;(&#96;name&#96;) VALUES(&#39;LiSi&#39;);</span><br><span class="line">INSERT INTO &#96;mylock&#96;(&#96;name&#96;) VALUES(&#39;WangWu&#39;);</span><br><span class="line">INSERT INTO &#96;mylock&#96;(&#96;name&#96;) VALUES(&#39;ZhaoLiu&#39;);</span><br></pre></td></tr></table></figure><h2 id="锁表的命令"><a href="#锁表的命令" class="headerlink" title="锁表的命令"></a>锁表的命令</h2><blockquote><p>1、查看数据库表锁的命令。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看数据库表锁的命令</span><br><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure><blockquote><p>2、给<code>mylock</code>表上读锁，给<code>book</code>表上写锁。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 给mylock表上读锁，给book表上写锁</span><br><span class="line">LOCK TABLE &#96;mylock&#96; READ, &#96;book&#96; WRITE;</span><br><span class="line"></span><br><span class="line"># 查看当前表的状态</span><br><span class="line">mysql&gt; SHOW OPEN TABLES;</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| Database           | Table                                                | In_use | Name_locked |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| sql_analysis       | book                                                 |      1 |           0 |</span><br><span class="line">| sql_analysis       | mylock                                               |      1 |           0 |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br></pre></td></tr></table></figure><blockquote><p>3、释放表锁。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 释放给表添加的锁</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"></span><br><span class="line"># 查看当前表的状态</span><br><span class="line">mysql&gt; SHOW OPEN TABLES;</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| Database           | Table                                                | In_use | Name_locked |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| sql_analysis       | book                                                 |      0 |           0 |</span><br><span class="line">| sql_analysis       | mylock                                               |      0 |           0 |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br></pre></td></tr></table></figure><h2 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h2><blockquote><p>1、打开两个会话，<code>SESSION1</code>为<code>mylock</code>表添加读锁。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 为mylock表添加读锁</span><br><span class="line">LOCK TABLE &#96;mylock&#96; READ;</span><br></pre></td></tr></table></figure><blockquote><p>2、打开两个会话，<code>SESSION1</code>是否可以读自己锁的表？是否可以修改自己锁的表？是否可以读其他的表？那么<code>SESSION2</code>呢？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1</span><br><span class="line"></span><br><span class="line"># 问题1：SESSION1为mylock表加了读锁，可以读mylock表！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;mylock&#96;;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | ZhangSan |</span><br><span class="line">|  2 | LiSi     |</span><br><span class="line">|  3 | WangWu   |</span><br><span class="line">|  4 | ZhaoLiu  |</span><br><span class="line">+----+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 问题2：SESSION1为mylock表加了读锁，不可以修改mylock表！</span><br><span class="line">mysql&gt; UPDATE &#96;mylock&#96; SET &#96;name&#96; &#x3D; &#39;abc&#39; WHERE &#96;id&#96; &#x3D; 1;</span><br><span class="line">ERROR 1099 (HY000): Table &#39;mylock&#39; was locked with a READ lock and can&#39;t be updated</span><br><span class="line"></span><br><span class="line"># 问题3：SESSION1为mylock表加了读锁，不可以读其他的表！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;book&#96;;</span><br><span class="line">ERROR 1100 (HY000): Table &#39;book&#39; was not locked with LOCK TABLES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># SESSION2</span><br><span class="line"></span><br><span class="line"># 问题1：SESSION1为mylock表加了读锁，SESSION2可以读mylock表！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;mylock&#96;;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | ZhangSan |</span><br><span class="line">|  2 | LiSi     |</span><br><span class="line">|  3 | WangWu   |</span><br><span class="line">|  4 | ZhaoLiu  |</span><br><span class="line">+----+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 问题2：SESSION1为mylock表加了读锁，SESSION2修改mylock表会被阻塞，需要等待SESSION1释放mylock表！</span><br><span class="line">mysql&gt; UPDATE &#96;mylock&#96; SET &#96;name&#96; &#x3D; &#39;abc&#39; WHERE &#96;id&#96; &#x3D; 1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line"># 问题3：SESSION1为mylock表加了读锁，SESSION2可以读其他表！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;book&#96;;</span><br><span class="line">+--------+------+</span><br><span class="line">| bookid | card |</span><br><span class="line">+--------+------+</span><br><span class="line">|      1 |    1 |</span><br><span class="line">|      7 |    4 |</span><br><span class="line">|      8 |    4 |</span><br><span class="line">|      9 |    5 |</span><br><span class="line">|      5 |    6 |</span><br><span class="line">|     17 |    6 |</span><br><span class="line">|     15 |    8 |</span><br><span class="line">+--------+------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="写锁案例"><a href="#写锁案例" class="headerlink" title="写锁案例"></a>写锁案例</h2><blockquote><p>1、打开两个会话，<code>SESSION1</code>为<code>mylock</code>表添加写锁。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 为mylock表添加写锁</span><br><span class="line">LOCK TABLE &#96;mylock&#96; WRITE;</span><br></pre></td></tr></table></figure><blockquote><p>2、打开两个会话，<code>SESSION1</code>是否可以读自己锁的表？是否可以修改自己锁的表？是否可以读其他的表？那么<code>SESSION2</code>呢？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1</span><br><span class="line"></span><br><span class="line"># 问题1：SESSION1为mylock表加了写锁，可以读mylock的表！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;mylock&#96;;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | ZhangSan |</span><br><span class="line">|  2 | LiSi     |</span><br><span class="line">|  3 | WangWu   |</span><br><span class="line">|  4 | ZhaoLiu  |</span><br><span class="line">+----+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 问题2：SESSION1为mylock表加了写锁，可以修改mylock表!</span><br><span class="line">mysql&gt; UPDATE &#96;mylock&#96; SET &#96;name&#96; &#x3D; &#39;abc&#39; WHERE &#96;id&#96; &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line"># 问题3：SESSION1为mylock表加了写锁，不能读其他表!</span><br><span class="line">mysql&gt; SELECT * FROM &#96;book&#96;;</span><br><span class="line">ERROR 1100 (HY000): Table &#39;book&#39; was not locked with LOCK TABLES</span><br><span class="line"></span><br><span class="line"># SESSION2</span><br><span class="line"></span><br><span class="line"># 问题1：SESSION1为mylock表加了写锁，SESSION2读mylock表会阻塞，等待SESSION1释放！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;mylock&#96;;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line"># 问题2：SESSION1为mylock表加了写锁，SESSION2读mylock表会阻塞，等待SESSION1释放！</span><br><span class="line">mysql&gt; UPDATE &#96;mylock&#96; SET &#96;name&#96; &#x3D; &#39;abc&#39; WHERE &#96;id&#96; &#x3D; 1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line"># 问题3：SESSION1为mylock表加了写锁，SESSION2可以读其他表！</span><br><span class="line">mysql&gt; SELECT * FROM &#96;book&#96;;</span><br><span class="line">+--------+------+</span><br><span class="line">| bookid | card |</span><br><span class="line">+--------+------+</span><br><span class="line">|      1 |    1 |</span><br><span class="line">|      7 |    4 |</span><br><span class="line">|      8 |    4 |</span><br><span class="line">|      9 |    5 |</span><br><span class="line">|      5 |    6 |</span><br><span class="line">|     17 |    6 |</span><br><span class="line">|     15 |    8 |</span><br><span class="line">+--------+------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h2><p><strong><code>MyISAM</code>引擎在执行查询语句<code>SELECT</code>之前，会自动给涉及到的所有表加读锁，在执行增删改之前，会自动给涉及的表加写锁。</strong></p><p>MySQL的表级锁有两种模式：</p><ul><li>表共享读锁（Table Read Lock）。</li><li>表独占写锁（Table Write Lock）。</li></ul><p>対<code>MyISAM</code>表进行操作，会有以下情况：</p><ul><li>対<code>MyISAM</code>表的读操作（加读锁），不会阻塞其他线程対同一表的读操作，但是会阻塞其他线程対同一表的写操作。只有当读锁释放之后，才会执行其他线程的写操作。</li><li>対<code>MyISAM</code>表的写操作（加写锁），会阻塞其他线程対同一表的读和写操作，只有当写锁释放之后，才会执行其他线程的读写操作。</li></ul><h2 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#39;table%&#39;;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Table_locks_immediate      | 173   |</span><br><span class="line">| Table_locks_waited         | 0     |</span><br><span class="line">| Table_open_cache_hits      | 5     |</span><br><span class="line">| Table_open_cache_misses    | 8     |</span><br><span class="line">| Table_open_cache_overflows | 0     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以通过<code>Table_locks_immediate</code>和<code>Table_locks_waited</code>状态变量来分析系统上的表锁定。具体说明如下：</p><p><code>Table_locks_immediate</code>：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1。</p><p><code>Table_locks_waited</code>：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在较严重的表级锁争用情况。</p><p><strong>此外，<code>MyISAM</code>的读写锁调度是写优先，这也是<code>MyISAM</code>不适合作为主表的引擎。因为写锁后，其他线程不能进行任何操作，大量的写操作会使查询很难得到锁，从而造成永远阻塞。</strong></p><h1 id="行锁-偏写"><a href="#行锁-偏写" class="headerlink" title="行锁(偏写)"></a>行锁(偏写)</h1><p><strong>行锁特点：</strong></p><ul><li>偏向<code>InnoDB</code>存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</li></ul><p><strong><code>InnoDB</code>存储引擎和<code>MyISAM</code>存储引擎最大不同有两点：一是支持事务，二是采用行锁。</strong></p><p>事务的ACID：</p><ul><li><code>Atomicity [ˌætəˈmɪsəti] </code>。</li><li><code>Consistency [kənˈsɪstənsi] </code>。</li><li><code>Isolation [ˌaɪsəˈleɪʃn]</code>。</li><li><code>Durability [ˌdjʊərəˈbɪlɪti] </code>。</li></ul><h2 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 建表语句</span><br><span class="line">CREATE TABLE &#96;test_innodb_lock&#96;(</span><br><span class="line">&#96;a&#96; INT,</span><br><span class="line">&#96;b&#96; VARCHAR(16)</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;测试行锁&#39;; </span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(1, &#39;b2&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(2, &#39;3&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(3, &#39;4000&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(4, &#39;5000&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(5, &#39;6000&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(6, &#39;7000&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(7, &#39;8000&#39;);</span><br><span class="line">INSERT INTO &#96;test_innodb_lock&#96;(&#96;a&#96;, &#96;b&#96;) VALUES(8, &#39;9000&#39;);</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">CREATE INDEX idx_test_a ON &#96;test_innodb_lock&#96;(a);</span><br><span class="line">CREATE INDEX idx_test_b ON &#96;test_innodb_lock&#96;(b);</span><br></pre></td></tr></table></figure><h2 id="行锁案例"><a href="#行锁案例" class="headerlink" title="行锁案例"></a>行锁案例</h2><blockquote><p>1、开启手动提交</p></blockquote><p>打开<code>SESSION1</code>和<code>SESSION2</code>两个会话，都开启手动提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL数据库的手动提交</span><br><span class="line">mysql&gt; SET autocommit&#x3D;0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>2、读己之所写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 </span><br><span class="line"></span><br><span class="line"># SESSION1対test_innodb_lock表做写操作，但是没有commit。</span><br><span class="line"># 执行修改SQL之后，查询一下test_innodb_lock表，发现数据被修改了。</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;b&#96; &#x3D; &#39;88&#39; WHERE &#96;a&#96; &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM &#96;test_innodb_lock&#96;;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | 88   |</span><br><span class="line">|    2 | 3    |</span><br><span class="line">|    3 | 4000 |</span><br><span class="line">|    4 | 5000 |</span><br><span class="line">|    5 | 6000 |</span><br><span class="line">|    6 | 7000 |</span><br><span class="line">|    7 | 8000 |</span><br><span class="line">|    8 | 9000 |</span><br><span class="line">+------+------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># SESSION2 </span><br><span class="line"></span><br><span class="line"># SESSION2这时候来查询test_innodb_lock表。</span><br><span class="line"># 发现SESSION2是读不到SESSION1未提交的数据的。</span><br><span class="line">mysql&gt; SELECT * FROM &#96;test_innodb_lock&#96;;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | b2   |</span><br><span class="line">|    2 | 3    |</span><br><span class="line">|    3 | 4000 |</span><br><span class="line">|    4 | 5000 |</span><br><span class="line">|    5 | 6000 |</span><br><span class="line">|    6 | 7000 |</span><br><span class="line">|    7 | 8000 |</span><br><span class="line">|    8 | 9000 |</span><br><span class="line">+------+------+</span><br><span class="line">8 rows in set (0.00 se</span><br></pre></td></tr></table></figure><blockquote><p>3、行锁两个SESSION同时対一条记录进行写操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 対test_innodb_lock表的&#96;a&#96;&#x3D;1这一行进行写操作，但是没有commit</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;b&#96; &#x3D; &#39;99&#39; WHERE &#96;a&#96; &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line"># SESSION2 也对test_innodb_lock表的&#96;a&#96;&#x3D;1这一行进行写操作，但是发现阻塞了！！！</span><br><span class="line"># 等SESSION1执行commit语句之后，SESSION2的SQL就会执行了</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;b&#96; &#x3D; &#39;asdasd&#39; WHERE &#96;a&#96; &#x3D; 1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><blockquote><p>4、行锁两个SESSION同时对不同记录进行写操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 対test_innodb_lock表的&#96;a&#96;&#x3D;6这一行进行写操作，但是没有commit</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;b&#96; &#x3D; &#39;8976&#39; WHERE &#96;a&#96; &#x3D; 6;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line"># SESSION2 対test_innodb_lock表的&#96;a&#96;&#x3D;4这一行进行写操作，没有阻塞！！！</span><br><span class="line"># SESSION1和SESSION2同时对不同的行进行写操作互不影响</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;b&#96; &#x3D; &#39;Ringo&#39; WHERE &#96;a&#96; &#x3D; 4;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><h2 id="索引失效行锁变表锁"><a href="#索引失效行锁变表锁" class="headerlink" title="索引失效行锁变表锁"></a>索引失效行锁变表锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 执行SQL语句，没有执行commit。</span><br><span class="line"># 由于&#96;b&#96;字段是字符串，但是没有加单引号导致索引失效</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;a&#96; &#x3D; 888 WHERE &#96;b&#96; &#x3D; 8000;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line"></span><br><span class="line"># SESSION2 和SESSION1操作的并不是同一行，但是也被阻塞了？？？</span><br><span class="line"># 由于SESSION1执行的SQL索引失效，导致行锁升级为表锁。</span><br><span class="line">mysql&gt; UPDATE &#96;test_innodb_lock&#96; SET &#96;b&#96; &#x3D; &#39;1314&#39; WHERE &#96;a&#96; &#x3D; 1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><h2 id="间隙锁的危害"><a href="#间隙锁的危害" class="headerlink" title="间隙锁的危害"></a>间隙锁的危害</h2><blockquote><p>什么是间隙锁？</p></blockquote><p>当我们用范围条件而不是相等条件检索数据，并请求共享或者排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁，对于键值在条件范文内但并不存在的记录，叫做”间隙(GAP)”。</p><p><code>InnoDB</code>也会对这个”间隙”加锁，这种锁的机制就是所谓的”间隙锁”，是为了在<strong>可重复读</strong>隔离级别下解决<strong>幻读</strong>问题。</p><blockquote><p>间隙锁的危害</p></blockquote><p>因为<code>Query</code>执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。</p><p>间隙锁有一个比较致命的缺点，就是<strong>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。</strong>在某些场景下这可能会対性能造成很大的危害。</p><h2 id="如何锁定一行"><a href="#如何锁定一行" class="headerlink" title="如何锁定一行"></a>如何锁定一行</h2><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210703160728.png" alt="image-20210703160728429"></p><p><code>SELECT .....FOR UPDATE</code>在锁定某一行后，其他写操作会被阻塞，直到锁定的行被<code>COMMIT</code>。</p><p>mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。而共享锁则不同，如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210703160754.png" alt="image-20210703160754703"></p><h2 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h2><p><code>InnoDB</code>存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于<code>MyISAM</code>的表级锁定的。当系统并发量较高的时候，<code>InnoDB</code>的整体性能和<code>MyISAM</code>相比就会有比较明显的优势了。</p><p>但是，<code>InnoDB</code>的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让<code>InnoDB</code>的整体性能表现不仅不能比<code>MyISAM</code>高，甚至可能会更差。</p><h2 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#39;innodb_row_lock%&#39;;</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">| Variable_name                 | Value  |</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0      |</span><br><span class="line">| Innodb_row_lock_time          | 124150 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 31037  |</span><br><span class="line">| Innodb_row_lock_time_max      | 51004  |</span><br><span class="line">| Innodb_row_lock_waits         | 4      |</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>対各个状态量的说明如下：</p><ul><li><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量。</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度（重要）。</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花的平均时间（重要）。</li><li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长的一次所花的时间。</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数（重要）。</li></ul><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化策略。</p><h1 id="MySQL相关的优化建议"><a href="#MySQL相关的优化建议" class="headerlink" title="MySQL相关的优化建议"></a>MySQL相关的优化建议</h1><ul><li>尽可能让所有数据检索都通过索引完成，避免无索引时行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，减小间隙锁的不利影响</li><li>尽量控制事务大小，较少锁定资源量及时间长度</li><li>尽可能降低事务隔离级别</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之SQL语句分析及优化</title>
      <link href="2021/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8BSQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>2021/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8BSQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用MySQL时，如果发现查询语句耗时，会进行排查及调优，其中常用的一个方法是用explain查看sql执行计划。</p></blockquote><h1 id="expain命令解析"><a href="#expain命令解析" class="headerlink" title="expain命令解析"></a>expain命令解析</h1><h2 id="explain示例"><a href="#explain示例" class="headerlink" title="explain示例"></a>explain示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br><span class="line">mysql&gt;  explain</span><br><span class="line">    -&gt;  select count(*)</span><br><span class="line">    -&gt;  from table_c</span><br><span class="line">    -&gt;  where l_id &lt;&gt; &#39;&#39;</span><br><span class="line">    -&gt;  and l_id is not null</span><br><span class="line">    -&gt;  and l_id not in (</span><br><span class="line">    -&gt;    select l_id from table_l</span><br><span class="line">    -&gt;  ) ;</span><br><span class="line">+----+--------------------+---------------+------------+----------------+---------------+--------------+---------+------+-------+----------+------------------------------------+</span><br><span class="line">| id | select_type        | table         | partitions | type           | possible_keys | key          | key_len | ref  | rows  | filtered | Extra                              |</span><br><span class="line">+----+--------------------+---------------+------------+----------------+---------------+--------------+---------+------+-------+----------+------------------------------------+</span><br><span class="line">|  1 | PRIMARY            | table_c       | NULL       | range          | idx_l_id      | idx_l_id     | 51      | NULL | 98519 |   100.00 | Using where; Using index           |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | table_l       | NULL       | index_subquery | idx_l_id      | idx_l_id     | 387     | func |     2 |   100.00 | Using index; Full scan on NULL key |</span><br><span class="line">+----+--------------------+---------------+------------+----------------+---------------+--------------+---------+------+-------+----------+------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  explain</span><br><span class="line">    -&gt;  select count(*)</span><br><span class="line">    -&gt;  from table_c</span><br><span class="line">    -&gt;  where l_id not in (</span><br><span class="line">    -&gt;    select l_id from table_l</span><br><span class="line">    -&gt;  ) ;</span><br><span class="line">+----+--------------------+---------------+------------+----------------+---------------+--------------+---------+------+--------+----------+------------------------------------+</span><br><span class="line">| id | select_type        | table         | partitions | type           | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                              |</span><br><span class="line">+----+--------------------+---------------+------------+----------------+---------------+--------------+---------+------+--------+----------+------------------------------------+</span><br><span class="line">|  1 | PRIMARY            | table_c       | NULL       | index          | NULL          | idx_l_id     | 51      | NULL | 197037 |   100.00 | Using where; Using index           |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | table_l       | NULL       | index_subquery | idx_l_id      | idx_l_id     | 387     | func |      2 |   100.00 | Using index; Full scan on NULL key |</span><br><span class="line">+----+--------------------+---------------+------------+----------------+---------------+--------------+---------+------+--------+----------+------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h2 id="explain参数详解"><a href="#explain参数详解" class="headerlink" title="explain参数详解"></a>explain参数详解</h2><table><thead><tr><th align="left">id</th><th align="left">Columns</th><th align="left">JSON Name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">id</td><td align="left">select_id</td><td align="left">每个select子句的标识id</td></tr><tr><td align="left">2</td><td align="left">select_type</td><td align="left">None</td><td align="left">select语句的类型</td></tr><tr><td align="left">3</td><td align="left">table</td><td align="left">table_name</td><td align="left">当前表名</td></tr><tr><td align="left">4</td><td align="left">partitions</td><td align="left">partitions</td><td align="left">匹配的分区</td></tr><tr><td align="left">5</td><td align="left">type</td><td align="left">access_type</td><td align="left">当前表内访问方式 join type</td></tr><tr><td align="left">6</td><td align="left">possible_keys</td><td align="left">possible_keys</td><td align="left">可能使用到的索引</td></tr><tr><td align="left">7</td><td align="left">key</td><td align="left">key</td><td align="left">经过优化器评估最终使用的索引</td></tr><tr><td align="left">8</td><td align="left">key_len</td><td align="left">key_length</td><td align="left">使用到的索引长度</td></tr><tr><td align="left">9</td><td align="left">ref</td><td align="left">ref</td><td align="left">引用到的上一个表的列</td></tr><tr><td align="left">10</td><td align="left">rows</td><td align="left">rows</td><td align="left">rows_examined，要得到最终记录索要扫描经过的记录数</td></tr><tr><td align="left">11</td><td align="left">filtered</td><td align="left">filtered</td><td align="left">按表条件过滤行的百分比</td></tr><tr><td align="left">12</td><td align="left">Extra</td><td align="left">None</td><td align="left">额外的信息说明</td></tr></tbody></table><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>SELECT识别符。这是SELECT查询序列号。</p><p>值有以下三种情况：</p><ul><li><code>id</code>相同，执行顺序由上至下。</li><li><code>id</code>不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行。</strong></li><li><code>id</code>相同不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行。</strong></li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><a href="https://segmentfault.com/a/1190000018729502">每种类型的例子</a></p><p>select类型，它有以下几种:</p><table><thead><tr><th align="left">id</th><th align="left">select_type value</th><th align="left">JSON name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">None</td><td align="left">简单的SELECT语句（不包括UNION操作或子查询操作）</td></tr><tr><td align="left">2</td><td align="left">PRIMARY</td><td align="left">None</td><td align="left">PRIMARY：查询中最外层的SELECT（如两表做UNION或者存在子查询,外层的表操作为PRIMARY，内层的操作为UNION）</td></tr><tr><td align="left">3</td><td align="left">UNION</td><td align="left">None</td><td align="left">UNION：UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句没有依赖关系）</td></tr><tr><td align="left">4</td><td align="left">DEPENDENT UNION</td><td align="left">dependent(true)</td><td align="left">DEPENDENT UNION：UNION操作中，查询中处于内层的SELECT（内层的SELECT语句与外层的SELECT语句有依赖关系）</td></tr><tr><td align="left">5</td><td align="left">UNIOIN RESULT</td><td align="left">union_result</td><td align="left">UNION RESULT：UNION操作的结果，id值通常为NULL</td></tr><tr><td align="left">6</td><td align="left">SUBQUERY</td><td align="left">None</td><td align="left">SUBQUERY：子查询中首个SELECT（如果有多个子查询存在）</td></tr><tr><td align="left">7</td><td align="left">DEPENDENT SUBQUERY</td><td align="left">dependent(true)</td><td align="left">DEPENDENT SUBQUERY：子查询中首个SELECT，但依赖于外层的表（如果有多个子查询存在）</td></tr><tr><td align="left">8</td><td align="left">DERIVED</td><td align="left">None</td><td align="left">DERIVED：被驱动的SELECT子查询（子查询位于FROM子句）</td></tr><tr><td align="left">9</td><td align="left">MATERIALIZED</td><td align="left">materialized_form_subquery</td><td align="left">MATERIALIZED：被物化的子查询</td></tr><tr><td align="left">10</td><td align="left">UNCACHEABLE SUBQUERY</td><td align="left">cacheable(false)</td><td align="left">UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）</td></tr><tr><td align="left">11</td><td align="left">UNCACHEABLE UNION</td><td align="left">cacheable(false)</td><td align="left">UNCACHEABLE UNION：UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）</td></tr></tbody></table><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>当前表名</p><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>匹配的分区</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>当前表内访问方式（<a href="https://segmentfault.com/a/1190000018729502">每种访问方式的例子</a>）</p><p><strong>性能由好到坏排序</strong>（加粗的是比较常见的几种）：</p><table><thead><tr><th align="left">id</th><th align="left">type value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>system</strong></td><td align="left">表中只有一行</td></tr><tr><td align="left">2</td><td align="left"><strong>const</strong></td><td align="left">单表中最多有一个匹配行，primary key 或者 unique index的检索</td></tr><tr><td align="left">3</td><td align="left"><strong>eq_ref</strong></td><td align="left">多表连接中被驱动表的连接列上有primary key或者unique index的检索</td></tr><tr><td align="left">4</td><td align="left"><strong>ref</strong></td><td align="left">与eq_ref类似，但不是使用primary key或者unique index，而是普通索引。也可以是单表上non-unique索引检索</td></tr><tr><td align="left">5</td><td align="left">fulltext</td><td align="left">使用FULLTEXT索引执行连接</td></tr><tr><td align="left">6</td><td align="left">ref_or_null</td><td align="left">与ref类似，区别在于条件中包含对NULL的查询</td></tr><tr><td align="left">7</td><td align="left">index_merge</td><td align="left">索引合并优化，利用一个表里的N个索引查询,key_len表示这些索引键的和最长长度。</td></tr><tr><td align="left">8</td><td align="left">unique_subquery</td><td align="left">in的后面是一个查询primary key\unique字段的子查询</td></tr><tr><td align="left">9</td><td align="left">index_subquery</td><td align="left">in的后面是一个查询普通index字段的子查询</td></tr><tr><td align="left">10</td><td align="left"><strong>range</strong></td><td align="left">单表索引中的范围查询,使用索引查询出单个表中的一些行数据。ref列会变为null</td></tr><tr><td align="left">11</td><td align="left"><strong>index</strong></td><td align="left"><code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>ALL</code>的区别为<code>index</code>类型只遍历索引树。通常比<code>All</code>快，因为索引文件通常比数据文件小。它有两种情况：(1)覆盖索引 (2)用索引的顺序做一个全表扫描。</td></tr><tr><td align="left">12</td><td align="left"><strong>all</strong></td><td align="left">全表扫描</td></tr></tbody></table><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>key_len 说明<br>key_len: 4 // INT NOT NULL<br>key_len: 5 // INT DEFAULT NULL<br>key_len: 30 // CHAR(30) NOT NULL<br>key_len: 32 // VARCHAR(30) NOT NULL<br>key_len: 92 // VARCHAR(30) NOT NULL CHARSET=utf8</p><p>key_len大小的计算规则:<br>a、一般地，key_len 等于索引列类型字节长度，例如int类型为4-bytes，bigint为8-bytes；<br>b、如果是字符串类型，还需要同时考虑字符集因素，例如：CHAR(30) UTF8则key_len至少是90-bytes；<br>c、若该列类型定义时允许NULL，其key_len还需要再加 1-bytes；<br>d、若该列类型为变长类型，例如 VARCHAR（TEXT\BLOB不允许整列创建索引，如果创建部分索引，也被视为动态列类型），其key_len还需要再加 2-bytes;</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref列显示使用哪个列或常数与key一起从表中选择行。</p><p>常见的有：<code>const</code>，<code>func</code>，<code>null</code>，字段名。</p><ul><li>当使用常量等值查询，显示<code>const</code>，</li><li>当关联查询时，会显示相应关联表的<code>关联字段</code></li><li>如果查询条件使用了<code>表达式</code>、<code>函数</code>，或者条件列发生内部隐式转换，可能显示为<code>func</code></li><li>其他情况<code>null</code></li></ul><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows_examined，要得到最终记录索要扫描经过的记录数，这个数越小越好。</p><h3 id="filterrd"><a href="#filterrd" class="headerlink" title="filterrd"></a>filterrd</h3><p>按表条件过滤行的百分比</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Extra是对执行计划的额外说明，包含重要信息。</p><p>例如：</p><table><thead><tr><th align="left">id</th><th align="left">type value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">const row not found</td><td align="left">所要查询的表为空</td></tr><tr><td align="left">2</td><td align="left">Distinct</td><td align="left">mysql正在查询distinct值，因此当它每查到一个distinct值之后就会停止当前组的搜索，去查询下一个值</td></tr><tr><td align="left">3</td><td align="left">Impossible WHERE</td><td align="left">where条件总为false，表里没有满足条件的记录</td></tr><tr><td align="left">4</td><td align="left">Impossible WHERE noticed after reading const tables</td><td align="left">在优化器评估了const表之后，发现where条件均不满足</td></tr><tr><td align="left">5</td><td align="left">no matching row in const table</td><td align="left">当前join的表为const表，不能匹配</td></tr><tr><td align="left">6</td><td align="left">Not exists</td><td align="left">优化器发现内表记录不可能满足where条件</td></tr><tr><td align="left">7</td><td align="left">Select tables optimized away</td><td align="left">在没有group by子句时，对于MyISAM的select count(*)操作，或者当对于min(),max()的操作可以利用索引优化，优化器发现只会返回一行。</td></tr><tr><td align="left">8</td><td align="left"><strong>Using filesort</strong></td><td align="left">使用filesort来进行order by操作</td></tr><tr><td align="left">9</td><td align="left"><strong>Using index</strong></td><td align="left">覆盖索引</td></tr><tr><td align="left">10</td><td align="left">Using index for group-by</td><td align="left">对于group by列或者distinct列，可以利用索引检索出数据，而不需要去表里查数据、分组、排序、去重等等</td></tr><tr><td align="left">11</td><td align="left">Using join buffer</td><td align="left">之前的表连接在nested loop之后放进join buffer，再来和本表进行join。适用于本表的访问type为range，index或all</td></tr><tr><td align="left">12</td><td align="left">Using sort_union,using union,using intersect</td><td align="left">index_merge的三种情况</td></tr><tr><td align="left">13</td><td align="left"><strong>Using temporary</strong></td><td align="left">使用了临时表来存储中间结果集，适用于group by，distinct，或order by列为不同表的列。</td></tr><tr><td align="left">14</td><td align="left">Using where</td><td align="left">在存储引擎层检索出记录后，在server利用where条件进行过滤，并返回给客户端</td></tr></tbody></table><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><blockquote><p>慢查询日志是什么？</p></blockquote><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。</li><li><code>long_query_time</code>的默认值为10，意思是运行10秒以上的语句。</li><li>由慢查询日志来查看哪些SQL超出了我们的最大忍耐时间值，比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒钟的SQL，结合之前<code>explain</code>进行全面分析。</li></ul><blockquote><p>特别说明</p></blockquote><p><strong>默认情况下，MySQL数据库没有开启慢查询日志，</strong>需要我们手动来设置这个参数。</p><p><strong>当然，如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><blockquote><p>查看慢查询日志是否开以及如何开启</p></blockquote><ul><li>查看慢查询日志是否开启：<code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code>。</li><li>开启慢查询日志：<code>SET GLOBAL slow_query_log = 1;</code>。<strong>使用该方法开启MySQL的慢查询日志只对当前数据库生效，如果MySQL重启后会失效。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1、查看慢查询日志是否开启</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;1dcb5644392c-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 2、开启慢查询日志</span><br><span class="line">mysql&gt; SET GLOBAL slow_query_log &#x3D; 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果要使慢查询日志永久开启，需要修改<code>my.cnf</code>文件，在<code>[mysqld]</code>下增加修改参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"># 1.这个是开启慢查询。注意ON需要大写</span><br><span class="line">slow_query_log&#x3D;ON  </span><br><span class="line"></span><br><span class="line"># 2.这个是存储慢查询的日志文件。这个文件不存在的话，需要自己创建</span><br><span class="line">slow_query_log_file&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log</span><br></pre></td></tr></table></figure><blockquote><p>开启了慢查询日志后，什么样的SQL才会被记录到慢查询日志里面呢？</p></blockquote><p>这个是由参数<code>long_query_time</code>控制的，默认情况下<code>long_query_time</code>的值为10秒。</p><p>MySQL中查看<code>long_query_time</code>的时间：<code>SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看long_query_time 默认是10秒</span><br><span class="line"># 只有SQL的执行时间&gt;10才会被记录</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改<code>long_query_time</code>的时间，需要在<code>my.cnf</code>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 这个是设置慢查询的时间，我设置的为1秒</span><br><span class="line">long_query_time&#x3D;1</span><br></pre></td></tr></table></figure><p>查新慢查询日志的总记录条数：<code>SHOW GLOBAL STATUS LIKE &#39;%slow_queries%&#39;;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Slow_queries  | 3     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h2><p>日志分析工具<code>mysqldumpslow</code>：在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 1、mysqldumpslow --help 来查看mysqldumpslow的帮助信息(mac中先要在环境变量中配置相关路径&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin)</span><br><span class="line">root@1dcb5644392c:&#x2F;usr&#x2F;bin# mysqldumpslow --help</span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse and summarize the MySQL slow query log. Options are</span><br><span class="line"></span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --help       write this text to standard output</span><br><span class="line"></span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), &#39;at&#39; is default  # 按照何种方式排序</span><br><span class="line">                al: average lock time # 平均锁定时间</span><br><span class="line">                ar: average rows sent # 平均返回记录数</span><br><span class="line">                at: average query time # 平均查询时间</span><br><span class="line">                 c: count  # 访问次数</span><br><span class="line">                 l: lock time  # 锁定时间</span><br><span class="line">                 r: rows sent  # 返回记录</span><br><span class="line">                 t: query time  # 查询时间 </span><br><span class="line">  -r           reverse the sort order (largest last instead of first)</span><br><span class="line">  -t NUM       just show the top n queries  # 返回前面多少条记录</span><br><span class="line">  -a           don&#39;t abstract all numbers to N and strings to &#39;S&#39;</span><br><span class="line">  -n NUM       abstract numbers with at least n digits within names</span><br><span class="line">  -g PATTERN   grep: only consider stmts that include this string  </span><br><span class="line">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span><br><span class="line">               default is &#39;*&#39;, i.e. match all</span><br><span class="line">  -i NAME      name of server instance (if using mysql.server startup script)</span><br><span class="line">  -l           don&#39;t subtract lock time from total time</span><br><span class="line">  </span><br><span class="line"># 2、 案例</span><br><span class="line"># 2.1、得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log</span><br><span class="line"> </span><br><span class="line"># 2.2、得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log</span><br><span class="line"> </span><br><span class="line"># 2.3、得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log</span><br><span class="line"></span><br><span class="line"># 2.4、另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log | more</span><br></pre></td></tr></table></figure><h1 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h1><blockquote><p>Show Profile是什么？</p></blockquote><p><code>Show Profile</code>：MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。<strong>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</strong></p><blockquote><p>分析步骤</p></blockquote><p>1、是否支持，看看当前的MySQL版本是否支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看Show Profile功能是否开启</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;profiling&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| profiling     | OFF   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2、开启<code>Show Profile</code>功能，默认是关闭的，使用前需要开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开启Show Profile功能</span><br><span class="line">mysql&gt; SET profiling&#x3D;ON;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>3、运行SQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;emp&#96; GROUP BY &#96;id&#96;%10 LIMIT 150000;</span><br><span class="line"></span><br><span class="line">SELECT * FROM &#96;emp&#96; GROUP BY &#96;id&#96;%20 ORDER BY 5;</span><br></pre></td></tr></table></figure><p>4、查看结果，执行<code>SHOW PROFILES;</code></p><p><code>Duration</code>：持续时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">|        1 | 0.00156100 | SHOW VARIABLES LIKE &#39;profiling&#39;                   |</span><br><span class="line">|        2 | 0.56296725 | SELECT * FROM &#96;emp&#96; GROUP BY &#96;id&#96;%10 LIMIT 150000 |</span><br><span class="line">|        3 | 0.52105825 | SELECT * FROM &#96;emp&#96; GROUP BY &#96;id&#96;%10 LIMIT 150000 |</span><br><span class="line">|        4 | 0.51279775 | SELECT * FROM &#96;emp&#96; GROUP BY &#96;id&#96;%20 ORDER BY 5   |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>5、诊断SQL，<code>SHOW PROFILE cpu,block io FOR QUERY Query_ID;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 这里的3是第四步中的Query_ID。</span><br><span class="line"># 可以在SHOW PROFILE中看到一条SQL中完整的生命周期。</span><br><span class="line">mysql&gt; SHOW PROFILE cpu,block io FOR QUERY 3;</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| starting             | 0.000097 | 0.000090 |   0.000002 |            0 |             0 |</span><br><span class="line">| checking permissions | 0.000010 | 0.000009 |   0.000000 |            0 |             0 |</span><br><span class="line">| Opening tables       | 0.000039 | 0.000058 |   0.000000 |            0 |             0 |</span><br><span class="line">| init                 | 0.000046 | 0.000046 |   0.000000 |            0 |             0 |</span><br><span class="line">| System lock          | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| optimizing           | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| statistics           | 0.000023 | 0.000037 |   0.000000 |            0 |             0 |</span><br><span class="line">| preparing            | 0.000014 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| Creating tmp table   | 0.000041 | 0.000053 |   0.000000 |            0 |             0 |</span><br><span class="line">| Sorting result       | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| executing            | 0.000003 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| Sending data         | 0.520620 | 0.516267 |   0.000000 |            0 |             0 |</span><br><span class="line">| Creating sort index  | 0.000060 | 0.000051 |   0.000000 |            0 |             0 |</span><br><span class="line">| end                  | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| query end            | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| removing tmp table   | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| query end            | 0.000004 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| closing tables       | 0.000009 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| freeing items        | 0.000032 | 0.000064 |   0.000000 |            0 |             0 |</span><br><span class="line">| cleaning up          | 0.000019 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">20 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>Show Profile</code>查询参数备注：</p><ul><li><code>ALL</code>：显示所有的开销信息。</li><li><code>BLOCK IO</code>：显示块IO相关开销（通用）。</li><li><code>CONTEXT SWITCHES</code>：上下文切换相关开销。</li><li><code>CPU</code>：显示CPU相关开销信息（通用）。</li><li><code>IPC</code>：显示发送和接收相关开销信息。</li><li><code>MEMORY</code>：显示内存相关开销信息。</li><li><code>PAGE FAULTS</code>：显示页面错误相关开销信息。</li><li><code>SOURCE</code>：显示和Source_function。</li><li><code>SWAPS</code>：显示交换次数相关开销的信息。</li></ul><p>6、<code>Show Profile</code>查询列表，日常开发需要注意的结论：</p><ul><li><code>converting HEAP to MyISAM</code>：查询结果太大，内存都不够用了，往磁盘上搬了。</li><li><code>Creating tmp table</code>：创建临时表（拷贝数据到临时表，用完再删除），非常耗费数据库性能。</li><li><code>Copying to tmp table on disk</code>：把内存中的临时表复制到磁盘，危险！！！</li><li><code>locked</code>：死锁。</li></ul><h1 id="索引的创建和删除"><a href="#索引的创建和删除" class="headerlink" title="索引的创建和删除"></a>索引的创建和删除</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 基本语法 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1、创建索引 [UNIQUE]可以省略*&#x2F;</span><br><span class="line">&#x2F;* 如果只写一个字段就是单值索引，写多个字段就是复合索引 *&#x2F;</span><br><span class="line">CREATE [UNIQUE] INDEX indexName ON tabName(columnName(length));</span><br><span class="line"></span><br><span class="line">&#x2F;* 2、删除索引 *&#x2F;</span><br><span class="line">DROP INDEX [indexName] ON tabName;</span><br><span class="line"></span><br><span class="line">&#x2F;* 3、查看索引 *&#x2F;</span><br><span class="line">&#x2F;* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 *&#x2F;</span><br><span class="line">SHOW INDEX FROM tabName \G;</span><br><span class="line"></span><br><span class="line">&#x2F;*使用ALTER命令来为数据表添加或删除索引*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* 1、该语句添加一个主键，这意味着索引值必须是唯一的，并且不能为NULL *&#x2F;</span><br><span class="line">ALTER TABLE tabName ADD PRIMARY KEY(column_list);</span><br><span class="line"></span><br><span class="line">&#x2F;* 2、该语句创建索引的键值必须是唯一的(除了NULL之外，NULL可能会出现多次) *&#x2F;</span><br><span class="line">ALTER TABLE tabName ADD UNIQUE indexName(column_list);</span><br><span class="line"></span><br><span class="line">&#x2F;* 3、该语句创建普通索引，索引值可以出现多次 *&#x2F;</span><br><span class="line">ALTER TABLE tabName ADD INDEX indexName(column_list);</span><br><span class="line"></span><br><span class="line">&#x2F;* 4、该语句指定了索引为FULLTEXT，用于全文检索 *&#x2F;</span><br><span class="line">ALTER TABLE tabName ADD FULLTEXT indexName(column_list);</span><br><span class="line"></span><br><span class="line">&#x2F;* 5、该语句删除一个索引，其余删除语句类似 *&#x2F;</span><br><span class="line">ALTER TABLE tabName DROP INDEX indexName(column_list);</span><br></pre></td></tr></table></figure><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table user \G</span><br><span class="line">******************************************************</span><br><span class="line">       Table: user</span><br><span class="line">Create Table: CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(10) DEFAULT &#39;0&#39;,</span><br><span class="line">  &#96;pos&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">  &#96;phone&#96; varchar(11) DEFAULT NULL,</span><br><span class="line">  &#96;created_time&#96; datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_name_age_pos_phone&#96; (&#96;name&#96;,&#96;age&#96;,&#96;pos&#96;,&#96;phone&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure><h2 id="违反最左前缀法则"><a href="#违反最左前缀法则" class="headerlink" title="违反最左前缀法则"></a>违反最左前缀法则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果索引有多列，要遵守最左前缀法则</span><br><span class="line">即查询从索引的最左前列开始并且不跳过索引中的列</span><br><span class="line">explain select * from user where age &#x3D; 20 and phone &#x3D; &#39;18730658760&#39; and pos &#x3D; &#39;cxy&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201115.png" alt="索引失效的情况"></p><h2 id="在索引列上做任何操作"><a href="#在索引列上做任何操作" class="headerlink" title="在索引列上做任何操作"></a>在索引列上做任何操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如计算、函数、（自动or手动）类型转换等操作，会导致索引失效从而全表扫描</span><br><span class="line">explain select * from user where left(name,5) &#x3D; &#39;zhangsan&#39; and age &#x3D; 20 and phone &#x3D; &#39;18730658760&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201124.png" alt="索引失效的情况"></p><h2 id="索引范围条件右边的列"><a href="#索引范围条件右边的列" class="headerlink" title="索引范围条件右边的列"></a>索引范围条件右边的列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">索引范围条件右边的索引列会失效（但不包括 不以通配符%开头的立刻语句）</span><br><span class="line">explain select * from user where name &#x3D; &#39;zhangsan&#39; and age &gt; 20 and pos &#x3D; &#39;cxy&#39;;</span><br><span class="line">这条语句like右边索引仍有效</span><br><span class="line">explain select * from user where name like &#39;zhangsan%&#39; and age &gt; 20 ;</span><br><span class="line">这条语句like右边索引会失效</span><br><span class="line">explain select * from user where name like &#39;%zhangsan&#39; and age &gt; 20 ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201138.png" alt="索引失效的情况"></p><h2 id="尽量使用覆盖索引"><a href="#尽量使用覆盖索引" class="headerlink" title="尽量使用覆盖索引"></a>尽量使用覆盖索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只访问索引查询（索引列和查询列一致），减少select*</span><br><span class="line">explain select name,age,pos,phone from user where age &#x3D; 20;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201147.png" alt="索引失效的情况"></p><h2 id="like以通配符开头（’-abc’）"><a href="#like以通配符开头（’-abc’）" class="headerlink" title="like以通配符开头（’%abc’）"></a>like以通配符开头（’%abc’）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引失效</span><br><span class="line">explain select * from user where name like &#39;%zhangsan&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201201.png" alt="索引失效的情况"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引生效</span><br><span class="line">explain select * from user where name like &#39;zhangsan%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201215.png" alt="索引失效的情况"></p><h2 id="字符串不加单引号索引失效"><a href="#字符串不加单引号索引失效" class="headerlink" title="字符串不加单引号索引失效"></a>字符串不加单引号索引失效</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进行了隐式转换</span><br><span class="line">explain select * from user where name &#x3D; 2000;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210702201224.png" alt="索引失效的情况"></p><h2 id="or连接"><a href="#or连接" class="headerlink" title="or连接"></a>or连接</h2><p><strong>但并不是所有的or都会使索引失效，如果or连接的所有条件字段都设置了索引，那么还是会走索引的；一旦有一个条件没有建立索引，那么就会走全表扫描。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">少用or </span><br><span class="line">explain select * from user where name &#x3D; &#39;2000&#39; or age &#x3D; 20 or pos &#x3D;&#39;cxy&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000021464588" alt="索引失效的情况"></p><h2 id="关于IS-NULL、IS-NOT-NULL、"><a href="#关于IS-NULL、IS-NOT-NULL、" class="headerlink" title="关于IS NULL、IS NOT NULL、!="></a>关于IS NULL、IS NOT NULL、!=</h2><p>在WHERE子句中出现<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>!=</code>这些条件仍然可以使用索引，本质上都是优化器去计算一下对应的二级索引数量占所有记录数量的比值，如果这个条数占整个记录条数的比例特别大，那么就趋向于使用全表扫描执行查询，否则趋向于使用这个索引执行查询。</p><p><a href="https://juejin.cn/post/6844903921450745863">详细内容可参考这篇博文</a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h2><blockquote><p>优化原则：对于MySQL数据库而言，永远都是小表驱动大表。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 举个例子：可以使用嵌套的for循环来理解小表驱动大表。</span><br><span class="line">* 以下两个循环结果都是一样的，但是对于MySQL来说不一样，</span><br><span class="line">* 第一种可以理解为，和MySQL建立5次连接每次查询1000次。</span><br><span class="line">* 第一种可以理解为，和MySQL建立1000次连接每次查询5次。</span><br><span class="line">*&#x2F;</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; 5; i ++)&#123;</span><br><span class="line">    for(int j &#x3D; 1; j &lt;&#x3D; 1000; j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; 1000; i ++)&#123;</span><br><span class="line">    for(int j &#x3D; 1; j &lt;&#x3D; 5; j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IN和EXISTS</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 优化原则：小表驱动大表，即小的数据集驱动大的数据集 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* IN适合B表比A表数据小的情况*&#x2F;</span><br><span class="line">SELECT * FROM &#96;A&#96; WHERE &#96;id&#96; IN (SELECT &#96;id&#96; FROM &#96;B&#96;)</span><br><span class="line"></span><br><span class="line">&#x2F;* EXISTS适合B表比A表数据大的情况 *&#x2F;</span><br><span class="line">SELECT * FROM &#96;A&#96; WHERE EXISTS (SELECT 1 FROM &#96;B&#96; WHERE &#96;B&#96;.id &#x3D; &#96;A&#96;.id);</span><br></pre></td></tr></table></figure><p><strong>EXISTS：</strong></p><ul><li>语法：<code>SELECT....FROM tab WHERE EXISTS(subquery);</code>该语法可以理解为：</li><li>该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（<code>true</code>或是<code>false</code>）来决定主查询的数据结果是否得以保留。</li></ul><p><strong>提示：</strong></p><ul><li><code>EXISTS(subquery)</code>子查询只返回<code>true</code>或者<code>false</code>，因此子查询中的<code>SELECT *</code>可以是<code>SELECT 1 OR SELECT X</code>，它们并没有区别。</li><li><code>EXISTS(subquery)</code>子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。</li><li><code>EXISTS(subquery)</code>子查询往往也可以用条件表达式，其他子查询或者<code>JOIN</code>替代，何种最优需要具体问题具体分析。</li></ul><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p><a href="https://www.jianshu.com/p/b2963c29af0e">group by 执行过程可看此处</a></p><p><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/group-by-optimization.html">使用索引优化需满足的条件可看官方文档</a></p><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;talA&#96;(</span><br><span class="line">&#96;age&#96; INT,</span><br><span class="line">&#96;birth&#96; TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(18);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(19);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(20);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(21);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(22);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(23);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(24);</span><br><span class="line">INSERT INTO &#96;talA&#96;(&#96;age&#96;) VALUES(25);</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建索引 *&#x2F;</span><br><span class="line">CREATE INDEX idx_talA_age_birth ON &#96;talA&#96;(&#96;age&#96;, &#96;birth&#96;);</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 1.使用索引进行排序了 不会产生Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; WHERE &#96;age&#96; &gt; 20 ORDER BY &#96;age&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 2.使用索引进行排序了 不会产生Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; WHERE &#96;age&#96; &gt; 20 ORDER BY &#96;age&#96;,&#96;birth&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 3.没有使用索引进行排序 产生了Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; WHERE &#96;age&#96; &gt; 20 ORDER BY &#96;birth&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 4.没有使用索引进行排序 产生了Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; WHERE &#96;age&#96; &gt; 20 ORDER BY &#96;birth&#96;,&#96;age&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 5.没有使用索引进行排序 产生了Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; ORDER BY &#96;birth&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 6.没有使用索引进行排序 产生了Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; WHERE &#96;birth&#96; &gt; &#39;2020-08-04 07:42:21&#39; ORDER BY &#96;birth&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 7.使用索引进行排序了 不会产生Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; WHERE &#96;birth&#96; &gt; &#39;2020-08-04 07:42:21&#39; ORDER BY &#96;age&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 8.没有使用索引进行排序 产生了Using filesort *&#x2F;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;talA&#96; ORDER BY &#96;age&#96; ASC, &#96;birth&#96; DESC;</span><br></pre></td></tr></table></figure><p><code>ORDER BY</code>子句，尽量使用索引排序，避免使用<code>Using filesort</code>排序。</p><p>MySQL支持两种方式的排序，<code>FileSort</code>和<code>Index</code>，<code>Index</code>的效率高，它指MySQL扫描索引本身完成排序。<code>FileSort</code>方式效率较低。</p><p><code>ORDER BY</code>满足两情况，会使用<code>Index</code>方式排序：</p><ul><li><code>ORDER BY</code>语句使用索引最左前列(升降序要一致)。</li><li>使用<code>WHERE</code>子句与<code>ORDER BY</code>子句条件列组合满足索引最左前列(升降序要一致)。</li></ul><p><strong>结论：尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀原则。</strong></p><h3 id="File-Sort"><a href="#File-Sort" class="headerlink" title="File Sort"></a>File Sort</h3><p>如果不在索引列上，File Sort有两种算法：MySQL就要启动双路排序算法和单路排序算法</p><ul><li><p>双路排序算法：MySQL4.1之前使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和<code>ORDER BY</code>列，対他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。<strong>一句话，从磁盘取排序字段，在<code>buffer</code>中进行排序，再从磁盘取其他字段。</strong>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在MySQL4.1之后，出现了改进的算法，就是单路排序算法。</p></li><li><p>单路排序算法：从磁盘读取查询需要的所有列，按照<code>ORDER BY</code>列在<code>buffer</code>対它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p></li></ul><p>由于单路排序算法是后出的，总体而言效率好过双路排序算法。</p><p>但是单路排序算法有问题：如果<code>SortBuffer</code>缓冲区太小，导致从磁盘中读取所有的列不能完全保存在<code>SortBuffer</code>缓冲区中，这时候单路复用算法就会出现问题，反而性能不如双路复用算法。</p><p><strong>单路复用算法的优化策略：</strong></p><ul><li>增大<code>sort_buffer_size</code>参数的设置。</li><li>增大<code>max_length_for_sort_data</code>参数的设置。</li></ul><h3 id="提高ORDER-BY排序速度的方式"><a href="#提高ORDER-BY排序速度的方式" class="headerlink" title="提高ORDER BY排序速度的方式"></a>提高ORDER BY排序速度的方式</h3><ul><li><code>ORDER BY</code>时使用<code>SELECT *</code>是大忌，查什么字段就写什么字段，这点非常重要。在这里的影响是：<ul><li>当查询的字段大小总和小于<code>max_length_for_sort_data</code>而且排序字段不是<code>TEXT|BLOB</code>类型时，会使用单路排序算法，否则使用多路排序算法。</li><li>两种排序算法的数据都有可能超出<code>sort_buffer</code>缓冲区的容量，超出之后，会创建<code>tmp</code>临时文件进行合并排序，导致多次IO，但是单路排序算法的风险会更大一些，所以要增大<code>sort_buffer_size</code>参数的设置。</li></ul></li><li>尝试提高<code>sort_buffer_size</code>：不管使用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</li><li>尝试提高<code>max_length_for_sort_data</code>：提高这个参数，会增加用单路排序算法的概率。但是如果设置的太高，数据总容量<code>sort_buffer_size</code>的概率就增大，明显症状是高的磁盘IO活动和低的处理器使用率。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>MySQL两种排序方式：<code>Using filesort</code>和<code>Index</code>扫描有序索引排序。</li><li>MySQL能为排序与查询使用相同的索引，创建的索引既可以用于排序也可以用于查询。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能MySQL之高级特性</title>
      <link href="2021/06/29/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>2021/06/29/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><p>MySQL分区表的底层由多个物理子表组成，每个分区表都有一个使用#分隔命名的表文件。分区表对SQL层是透明的，，对分区表的请求会通过分区表的句柄（Handler Object）转化成对存储引擎接口的调用。每个分区表有自己的独立索引，整个表没有全局索引。查询时，优化器根据分区定义过滤不包含查询数据的分区。分区表是一种粗粒度的索引策略，单表最多1024个分区（最好不超过150），分区表无法使用外键约束。</p><p>分区表适用于以下场景：</p><ol><li>在没有合适索引时，对其中几个分区进行全表扫描</li><li>表太大，无法放入内存</li><li>部分分区是热点域（例如按时间分区时，只有最近的记录是热点域）</li><li>需要对分区表进行独立操作（清除、检查、优化、备份、恢复或者使用不同的物理设备）</li><li>使用分区表规避特殊限制（如InnoDB的单个索引互斥访问，ext3文件系统的inode锁竞争等）</li></ol><p>分区表使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table sales &#123;</span><br><span class="line">    order_date DATATIME NOT NULL,</span><br><span class="line">    ...</span><br><span class="line">&#125;ENGINE&#x3D;InnoDN PARTITION BY RANGE(YEAR(order_date)) &#123;</span><br><span class="line">    PARTITION p2012 VALUES LESS THEN(2012),</span><br><span class="line">    PARTITION p2013 VALUES LESS THEN(2013),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是一种虚拟的数据表，它的行为和数据表一样，但是并不真正包含数据，<strong>但是不能对视图创建索引和触发器</strong>。实现视图的两种方法：</p><ol><li>将SELECT语句的结果放到临时表中，即<strong>临时表算法（TEMPTABE</strong>），使用这种算法会有明显的性能问题。</li><li>重写使用视图的查询语句，将视图定义SQL合并到查询SQL中，即<strong>合并算法（MERGE）</strong>。</li></ol><p>如果视图中包含GROUP BY，DISTINCT，聚合函数，UNION，子查询等，原表记录和视图记录中无法建立一一映射，MySQL将使用临时表算法来实现视图。可以通过视图来更新视图相关数据表的视图成为<strong>可更新视图</strong>，更新视图查询也可以是关联语句，但是被更新的列必须来自同一个表，<strong>所有使用临时表算法的视图都无法被更新</strong>。</p><p>MySQL不支持物化视图（将视图结果数据存放在一个可以查看的表中，并定期从原始数据表中刷新数据到这个表中）。</p><h1 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h1><p>InnoDB是MySQL唯一支持外键的内存存储引擎，<strong>外键通常要求每次修改数据时在另外一个表中多执行一次检查操作</strong>。如果向子表中写入一条记录，需要对父表中对应记录进行加锁操作，以确保这条记录在事务完成之前没有被删除。这回导致额外的锁等待，甚至导致一些死锁。如果要维护两表之间数据的一致性，使用外键比在应用程序中检查一致性性能要高得多。</p><h1 id="MySQL内部存储代码"><a href="#MySQL内部存储代码" class="headerlink" title="MySQL内部存储代码"></a>MySQL内部存储代码</h1><p>有四种在MySQL内部存储代码的方法：存储过程、存储函数、触发器和事件。存储过程和存储函数都可以接受参数然后返回值，触发器和事件都不可以。使用内部存储代码优点如下：</p><ol><li>在服务器内部执行，离数据最近，可以节省数据传输带宽和延迟</li><li>这是一种代码复用，保证某些行为保持一致，提供一定的安全性</li><li>可以简化代码的维护和版本更新</li></ol><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是指在执行INSERT、UPDATE或者DELETE时，执行一些特定的操作。可以指定触发器在SQL执行前触发还是执行后触发。触发器本身没有返回值，不过它们可以读取或改变触发SQL语句所影响的数据。可以使用触发器实现一些强制限制，或者某些业务逻辑。</p><p>对于每个表上的每一个时间，最多只能定义一个触发器（不能在AFTER INSERT上定义两个触发器）。MySQL只支持<strong>基于行的触发</strong>，触发器始终是针对一条记录的，而不是针对整个SQL语句的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger</span><br><span class="line">BEFORE INSERT ON table</span><br><span class="line">FOR  EACH ROW</span><br><span class="line">    DECLEAR rowCnt INT DEFAULT ROW_COUNT();</span><br><span class="line">    IF rowCnt &lt;&gt; 1 THEN</span><br><span class="line">        ...</span><br><span class="line">    END IF;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>使用触发器可以减少客户端和服务器之间的通信，可以简化应用逻辑还可以提高性能。在InnoDB上的触发器是在同一个事务中完成的，它们执行的操作是原子性的。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>事件可以指定MySQL在某个时间执行一段SQL代码，或者每隔一段时间执行一段SQL代码。通常可以把复杂的SQL封装到一个存储过程中，事件在执行时，只需要一个简单的Call调用。</p><p>事件在一个独立的线程中被初始化，它与处理连接的线程没有任何关系，也不接受任何参数，没有任何返回值。事件的典型应用包括定期地维护任务、重建缓存、构建汇总表来模拟物化视图或者用于监控和诊断数据库状态等。</p><h1 id="绑定变量（prepared-statement）"><a href="#绑定变量（prepared-statement）" class="headerlink" title="绑定变量（prepared statement）"></a>绑定变量（prepared statement）</h1><p>当创建一个绑定变量SQL时，客户端向服务器发送一个SQL语句原型，服务器端收到这个SQL语句框架后，解析并存储这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄。以后每次执行这类查询，客户端都指定使用这个句柄。</p><p>绑定变量的SQL使用问号标记可以接受参数的位置，当真正需要执行具体查询时，使用具体值代替这些问号。客户端通过向服务器发送各个问号的取值和这个SQL句柄来执行一个具体的查询。MySQL在使用绑定变量的时候可以更加高效地执行执行大量的重复语句。</p><ol><li>在服务器端只需要解析一次SQL语句</li><li>在服务器端某些优化器的工作只需要执行一次，因为它会缓存一部分的执行计划</li><li>以二进制的方式只发送参数和句柄比起每次发送ASCII码文本效率更高，绑定变量的形式可以分块传输。</li><li>使用绑定变量网络开销更小而且可以节省将数据从存储原始格式转换成文本格式的开销。</li></ol><h1 id="字符集和校对规则"><a href="#字符集和校对规则" class="headerlink" title="字符集和校对规则"></a>字符集和校对规则</h1><p>MySQL的字符集和校对规则可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设定值。</p><p>创建数据库时，将根据服务器上的character_set_server设置来设定该数据库的默认字符集。创建表和列时也可以针对表和列设置特定的字符集。实际采用的字符集按照数据库-&gt;表-&gt;列的顺序，如果没有为表指定字符集，则采用它所属数据库的字符集，如果没有为列设置字符集，则采用表设置的字符集。</p><p>服务器端总是假设客户端按照character_set_client设置的字符集来传输数据和SQL语句。当服务器收到客户端的SQL语句时，先转换成字符集character_set_connection。</p><p>从服务器取数据时将数据从character_set_server转换成character_set_connection，再从character_set_connection转换成character_set_result。</p><p>选择字符集和校对规则的正确方法是：先为服务器或数据库选择一个合理的字符集。然后根据特殊情况为特定表或列指定字符集和校对规则。_cs, _ci和_bin分别表示按照大小写敏感、大小写不敏感或者直接比较字节的方式比较字符串。</p><p>为了保证缓存中有足够的空间存储字符串，MySQL使用一个定长的空间来存储字符串。例如，utf-8的char(10)需要30个字节，索引一个utf-8字符集的列时，每个字符都是三个字节，最大索引前缀的限制缩短为1/3。变长字段类型（varchar text）存储时不会采用这种方法，但是当它们存储在临时表中用来处理或排序时，也会分配最大可能长度。</p><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>MySQL查询缓存保存查询返回的完整结果，当查询命中该缓存，MySQL会立刻返回结果，跳过了解析、优化和执行阶段。查询缓存系统会跟踪查询涉及的每个表，如果这些表发生变化，那么和这个表相关的所有缓存数据都将失效。</p><p>缓存存放在一个引用表中，通过一个哈希值引用，这个哈希值包括了查询本身、当前要查询的数据库、客户端协议的版本等可能会影响返回结果的信息。</p><p>当查询语句中有一些不确定的数据时，则不会被缓存。例如包含NOW(),CURRENT(),DATE()的查询不会被缓存。如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表或者包含列级别权限的表都不会被缓存。查询缓存存在的问题：</p><ol><li>打开查询缓存对读和写操作都会带来额外的消耗，读查询在开始之前必须先检查是否命中缓存</li><li>如果读查询可以被缓存，执行完成后，如果检查到缓存中没有这个结果，则会存入查询缓存</li><li>当向某个表写入数据时，必须将所有缓存都设置失效，如果查询缓存非常大或者碎片很多，该操作可能带来很大的开销</li><li>查询缓存操作是一个加锁排他操作，锁的开销也会相当可观。如果查询缓存使用了大量的内存，对全局锁的竞争可能导致整个系统僵死。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 《高性能MySQL》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能MySQL之索引</title>
      <link href="2021/06/29/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
      <url>2021/06/29/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="关于索引使用及限制"><a href="#关于索引使用及限制" class="headerlink" title="关于索引使用及限制"></a>关于索引使用及限制</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><strong>匹配条件（复合多列的索引）</strong>：</p><ul><li>全值匹配：和索引中的所有列进行匹配</li><li>匹配最左前缀：只使用索引的第一列</li><li>匹配列前缀</li><li>匹配范围值</li><li>精确匹配第一列并范围匹配第二列【必须是第一第二列】</li><li>只访问索引的查询：查询只需要访问索引，无须访问数据行，即覆盖索引</li></ul><p><strong>限制条件（复合多列的索引）</strong>：</p><ul><li>不按最左第一个开始查找，则无法使用索引。</li><li>必须是顺序条件，不能跳过中间索引列。【第二列排序是在精确匹配第一列情况下，第三列匹配是在精确匹配到第二列的情况下，生效的】</li><li>范围查询后的所有列都无法使用索引优化。</li></ul><h3 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h3><p><a href="https://cloud.tencent.com/developer/article/1541265">两者详细内容</a></p><ul><li>聚簇索引，这个是InnoDB表的主键索引，其叶子结点中保存了数据行。╮(╯_╰)╭</li><li>二级索引，非聚簇索引，叶子结点中保存了对应的主键值</li></ul><h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><ul><li>哈希索引：Memory引擎表才支持，略过。【InnoDB有自适应哈希索引，自动的不管了】</li><li>空间数据索引R-Tree，MyISAM引擎支持，略过。</li><li>全文索引，特定需求下使用，另外再系统的学习。</li><li>覆盖索引，对InnoDB很有用的，需要索引覆盖到所有使用的数据，则会很大程度提升性能。【比如覆盖主键id，提高全表count的性能】【栗子：P171-P174】</li></ul><h3 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h3><ul><li>使用独立的列，不对列数据进行函数或其他计算处理。</li><li>对长数据做前缀索引，索引长度需要测试，限制是无法使用此索引排序与分组。</li><li>非主键顺序插入大量的数据后，使用OPTIMIZE TABLE进行一次重新组织表。</li><li>利用索引进行排序的时候，需要order by 的顺序与索引列顺序一致，即需要满足索引的最左前缀要求；若查询需要关联多张表，则order by子句引用的字段需全部为第一个表；前导列为常量时可以不满足最左前缀要求。</li></ul><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p>栗子对的是一张表 【P183】</p><p>不要建立太多个索引，重复冗余的。【一个是空间的开销，一个是选择优化的开销】<br>范围查询列尽量放在索引的最后列，避免索引无效。<br>避免多个范围查询【书上的解决是使用逻辑绕过方案，我觉得直接保留筛选率最高的在前即可，因为业务上的范围查询可能很多，无法考虑到所有的绕过方案】<br>最后总结：都是没用的东东，完全不切实际，因为通常的查询条件都呀的是动态的，有N个。╮(╯_╰)╭<br>一些其他信息<br>MySQL在5.0+ 引入了“索引合并”的策略，好像可以使用多个索引的样子 。【如果看到这个，其实说明需要优化索引了，据书上说，性能不高，使用关闭或忽略索引语句：optimizer_switch 或者 IGNORE INDEX】</p><h2 id="关于查询性能优化【干货】"><a href="#关于查询性能优化【干货】" class="headerlink" title="关于查询性能优化【干货】"></a>关于查询性能优化【干货】</h2><h3 id="一些的建议"><a href="#一些的建议" class="headerlink" title="一些的建议"></a>一些的建议</h3><ul><li><p>关联查询禁止使用*返回所有关联表字段。通常使用table.*。</p></li><li><p>大量关联查询可以进行拆分多个查询进行。【比如十几张表的关联╮(╯_╰)╭ ，最后在子查询可以有固定值的情况下拆分】</p></li><li><p>使用show full PROCESSLIST查看数据库线程状态</p></li><li><p>一个对in(…)大量数据查询的优化 (╯‵□′)╯︵┻━┻ 这个在5.6的版本已经优化了 <a href="https://www.cnblogs.com/wxw16/p/6105624.html?utm_source=itdadao&utm_medium=referral">参考文章</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">select * from table_a where table_a.col in (select col from table_b where ...)</span><br><span class="line">-- 以上这种写法，的效率会很低，因为mysql并不会先进行in内部的只查询，而是变成exists(),这样就是扫描table_a全表了。╮(╯_╰)╭  </span><br><span class="line">-- 这里的优化可以有以下两种   </span><br><span class="line">-- ****这个在5.6的版本已经优化了，已经优化为第二种写法了 (╯‵□′)╯︵┻━┻ *****</span><br><span class="line">-- ****  亲测5.7.2的版本中是一样的效果了 就都没差了各种写法*****</span><br><span class="line"></span><br><span class="line">-- 第一种这个方法据说效率更快，我还没试过</span><br><span class="line">select * from table_a where table_a.col in (select group_concat(col) from table_b where ... )</span><br><span class="line">-- 以上这种方法无法使用，in里面没办法使用group_concat，绕过的方法为分两次查询，或在以下方法</span><br><span class="line">select * from table_a where find_in_set(table_a.col,(select group_concat(col) from table_b where ... ))</span><br><span class="line"></span><br><span class="line">-- 第二种方法是常用的方法了</span><br><span class="line">select * from table_a inner join table_b on table_b.col &#x3D; table_a.col where ... </span><br><span class="line"></span><br><span class="line">-- group_concat的长度限制</span><br><span class="line"> show variables like &#39;group_concat_max_len&#39;;</span><br><span class="line"> SET GLOBAL group_concat_max_len&#x3D;4294967295 ;</span><br><span class="line"> SET SESSION group_concat_max_len&#x3D;4294967295 ;</span><br></pre></td></tr></table></figure><ul><li>获取特定条件最小id</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 第一个是正常的获取最小id值，第二个为调整后的，执行计划是一样的，真实使用的时候，确实会快一些的。如果有超大数据量测试的话，估计还是比较明显的吧。</span><br><span class="line">EXPLAIN select MIN(id) FROM merchant_trade where merchant_name &#x3D; &#39;白**&#39; </span><br><span class="line">EXPLAIN select id FROM merchant_trade use index(primary) where  merchant_name &#x3D; &#39;王**&#39;  limit 1</span><br></pre></td></tr></table></figure><ul><li><p>查询优化器提示，有很多比如：使用或忽略特定索引，是否缓存排序，等等。如没有特殊需要不要使用，因为我不会╮(╯_╰)╭ 【主要这里的版本是5.5 ，现在用的都是5.6<del>5.7+的了，谁知道有的是不是已经优化改了 ε=(´ο｀*)))唉 】【P232</del>P235】</p></li><li><p><strong>关联查询的优化</strong>：确保ON或USING子句中的列上有索引，且要考虑关联的顺序，当表A 和表B用列c关联的时候， 如果优化器的关联顺序是B、A， 那么就不需要在B表的对应列上建上索引；当表A 和表B用列c关联的时候， 如果优化器的关联顺序是B、A， 那么就不需要在B表的对应列上建上索引。【原因看下方注意点中关联执行的策略】</p></li><li><p>Limit的优化：一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。<strong>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。</strong>对于偏移量很大时，这样做的效率会提升非常大。</p></li><li><p>在做地理位置范围查询的时候（经纬度），先过滤正方形最值条件，再计算具体的距离限制。</p></li></ul><h3 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h3><ul><li><p>MySQL中的<strong>in查询</strong>会进行排序之后使用二分法进行判断，其复杂度为O(log n),而不是等价于or的写法O(n)，所以在in()列表中有大量值的时候，处理速度并不会下降很多，反而可能很快。</p></li><li><p><strong>连接关联的方式</strong>：join … on ,join…using , table a,table b where a=b 这三种写法最终所有的查询都被转成了 Theta 风格。除了写法不同外，没什么区别。【<a href="https://blog.csdn.net/smithallenyu/article/details/88426204">文章参考</a>】</p></li><li><p><strong>当前MySQL关联执行的策略</strong>：mysql对任何关联都执行嵌套循环操作，即mysql先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻打匹配的行，依次下去，直到描述到所表表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。mysql会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，mysql返回到上一层次关联表，看是否能够找到更多的匹配记录，依此类推迭代执行。按照这样的方式查找第一条表记录，再嵌套查询下一个关联表，然后回溯到上一个表。</p></li><li><p>MySQL没有全连接的语法，的原因可能就是，关联表使用的规则为“嵌套循环关联”，所有连接转换为左连接，进行循环递归嵌套查询，但外层循环值为空的情况下无法进行后续处理，所以无法完成全连接。【就是说关联必须有一个主表，保证主表是有值的】【P215】</p></li><li><p><strong>关于COUNT</strong>：按照效率排序的话，<code>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</code>，所以尽量使用<code> count(*)</code></p></li><li><p><strong>UNION</strong>默认情况下会去重的，等效于distinct，而通常使用UNION ALL 。毕竟去重也是有性能开销的。</p></li><li><p>在手动查询一些数据的情况下，可以使用<strong>自定义变量</strong>进行复杂数据的查询，还是很好用的。【P247】【虽然看着挺好用的，但是在系统中是用是做不到的，限制太多了。P244】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 这里有个用法挺不错的 </span><br><span class="line">-- union 查询，查询一个值的时候，当第一个没查到数据的时候 再查询第二个条件</span><br><span class="line">SELECT GREATEST(@found :&#x3D; -1,id) FROM &#96;app_user&#96; where id &#x3D; 666</span><br><span class="line">union all</span><br><span class="line">select id from app_user_his where @found is null and id &#x3D; 666   </span><br></pre></td></tr></table></figure></li></ul><p>原文链接：<a href="https://blog.csdn.net/xiaohangblog/article/details/106259662">https://blog.csdn.net/xiaohangblog/article/details/106259662</a></p>]]></content>
      
      
      <categories>
          
          <category> 《高性能MySQL》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全与锁优化</title>
      <link href="2021/06/19/JVM/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>2021/06/19/JVM/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ul><li><p>不可变：不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。例如final关键字带来的可见性，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的。</p><p><strong>Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义的时候用fianl关键字修饰它就可以保证它是不可变的。如果是对象，那就需要对象自行保证其行为不会对其状态产生任何影响，如<code>java.lang.String</code>类是一个典型的不可变对象，调用它的substring()等方法都不会影响其原来的值，只会返回一个新构造的字符串对象。</strong></p></li><li><p>绝对线程安全：一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”，通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p></li><li><p>相对线程安全：<strong>相对的线程安全就是我们通常意义上所讲的线程安全</strong>，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection（）方法包装的集合等。</p></li><li><p>线程兼容：线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，<strong>我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况</strong>。Java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p></li><li><p>线程对立：线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。一个线程对立的例子是Thread类的suspend（）和resume（）方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend（）中断的线程就是即将要执行resume（）的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend（）和resume（）方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System.setIn（）、Sytem.setOut（）和System.runFinalizersOnExit（）等。</p></li></ul><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul><li><strong>互斥同步（Mutual Exclusion＆Synchronization）</strong>：是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。在Java中，最基本的互斥同步手段就是synchronized关键字，还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁（ReentrantLock）来实现同步。</li><li><strong>非阻塞同步（Non-Blocking Synchronization）</strong>：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。常用的有：测试并设置（Test-and-Set）、比较并交换（Compare-and-Swap，下文称CAS）。</li><li><strong>无同步方案</strong>：要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。可重入代码（Reentrant Code）和线程本地存储（Thread Local Storage）。</li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋，不断尝试获取锁），这项技术就是所谓的自旋锁。</p><p>在JDK 1.6中引入了自适应的自旋锁。<strong>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。若自旋等待刚刚成功获得过锁，虚拟机会允许自旋等待持续相对更长的时间。反之，若对于某个锁，自旋很少成功获得过锁，那在以后要获得这个锁时将有可能直接省略掉自旋过程。</strong></p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</strong></p><p>锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是正确的，<strong>但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗</strong>。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是JDK 1.6之中加入的新型锁机制，<strong>它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的</strong>，因此传统的锁机制就称为“重量级”锁。<strong>首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p><p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始介绍。HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619205312.png" alt="image-20210619205312074" style="zoom:67%;" /><h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><p>简单地介绍了对象的内存布局后，我们返回到轻量级锁的执行过程上。在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间， 用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态。如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p><h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h4><p>它的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p><p><strong>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</strong></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。<strong>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</strong></p><p><strong>这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步</strong>。</p><p>假设当前虚拟机启用了偏向锁（启用参数-XX：+UseBiasedLocking，这是JDK 1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p><p>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619205502.png" alt="image-20210619205502443" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 线程安全 </tag>
            
            <tag> 锁优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型与线程</title>
      <link href="2021/06/19/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/06/19/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>Java内存模型主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与Java编程中的变量略有区别，它包括实例变量/静态字段和构成数组对象的元素，不包括局部变量和方法参数（线程私有）。</p><p>Java内存模型规定所有变量都存储在<strong>主存（Main Memory</strong>）中（虚拟机内存的一部分）。每条线程还有自己的<strong>工作内存（Working Memory）</strong>，线程的工作内存保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取/赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主存来完成。线程、主内存、工作内存三者的交互关系如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619192832.png" alt="image-20210619192832060" style="zoom:67%;" /><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成。</p><p>这部分具体内容请看P442。</p><h3 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h3><p>一个变量定义为volatile之后，它将具备两种特性。</p><ul><li>第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</li><li>第二是使用volatile变量通过内存屏障来禁止指令重排序优化。内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器将后面的指令重排序到内存屏障之前的位置，从而保障有序性。</li></ul><p>由于volatile变量只能保证可见性，在<strong>不符合以下两条规则</strong>的运算场景中:</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><p><strong>Java内存模型中对volatile变量定义的特殊规则</strong>：假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：</p><ul><li><p>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（<strong>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值</strong>）。</p></li><li><p>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（<strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改</strong>）。</p></li><li><p>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（<strong>这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同</strong>）。</p></li></ul><h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：</p><p>允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定（Nonatomic Treatment ofdouble and long Variables）。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，我们逐个来看一下哪些操作实现了这3个特性。</p><ul><li> <strong>原子性</strong>（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定）。</li><li><strong>可见性</strong>（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li><li><strong>有序性</strong>（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</li></ul><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>它是判断数据是否存在竞争、线程是否安全的主要依据。<strong>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到</strong>。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p><ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。</li><li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。</li><li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p><ul><li><p>使用内核线程实现：内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。</p><p>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）</p><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p><p><strong>缺点</strong>：首先由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换</p></li><li><p>使用用户线程实现：</p><p>从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程（User Thread,UT）而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。</p><p>用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型。</p><p>使用用户线程的<strong>优势</strong>在于不需要系统内核支援，<strong>劣势</strong>也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。使用用户线程实现的程序一般都比较复杂。</p></li><li><p>使用用户线程加轻量级进程混合实现</p><p>在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。</p><p>而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。</p><p>在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系。</p></li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>线程调度是指系统为线程分配处理器使用权的过程</strong>，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。</p><ul><li><strong>协同式调度</strong>：如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。</li><li><strong>抢占式调度</strong>：如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield（）可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。</li></ul><h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这5种状态分别如下。</p><ul><li>新建（New）：创建后尚未启动的线程处于这种状态。</li><li>运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</li><li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：<ul><li>没有设置Timeout参数的Object.wait（）方法。</li><li>没有设置Timeout参数的Thread.join（）方法。</li><li>LockSupport.park（）方法。</li></ul></li><li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。<ul><li>Thread.sleep（）方法。</li><li>设置了Timeout参数的Object.wait（）方法。</li><li>设置了Timeout参数的Thread.join（）方法。</li><li>LockSupport.parkNanos（）方法。</li><li>LockSupport.parkUntil（）方法。</li></ul></li><li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候       发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li><li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619200126.png" alt="image-20210619200126091" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> Java内存模型 </tag>
            
            <tag> Java线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM后端编译和优化</title>
      <link href="2021/06/18/JVM/JVM%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%92%8C%E4%BC%98%E5%8C%96/"/>
      <url>2021/06/18/JVM/JVM%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>如果我们把字节码看作是语言程序的一种中间表示形式，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。虽然无论是提前编译器还是即时编译器，都不是Java虚拟机必须的组成部分，但后端编译器编译性能的好坏、代码优化质量的高低却是衡量一款商用虚拟机优秀与否的关键指标之一。</p><h2 id="HotSpot虚拟机内的即时编译"><a href="#HotSpot虚拟机内的即时编译" class="headerlink" title="HotSpot虚拟机内的即时编译"></a>HotSpot虚拟机内的即时编译</h2><h3 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h3><p>当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为热点代码。为了提高热点代码的执行效率。在运行时虚拟机会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文中简称JIT编译器）。</p><p>HotSpot虚拟机中即时间编译器：</p><ul><li> HotSpot虚拟机中内置了两个即时编译器，分别称为<strong>客户端编译器</strong>（Client Compiler）和<strong>服务器端编译器</strong>（Server Compiler），或者简称为<strong>C1编译器</strong>和<strong>C2编译器</strong>（还有一个旨在代替C2的Graal编译器，但目前仍处于实验状态）。</li><li>在<strong>分层编译</strong>（具体请看下文）的工作模式出现之前，HotSpot虚拟机默通常是采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或Server模式。</li><li>无论采用的编译器是Client Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”（Mixed Mode），用户可以使用参数“-Xint”强制虚拟机运行于“解释模式”（Interpreted Mode），这时编译器完全不介入工作，全部代码都使用解释方式执行</li></ul><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>目前主流的商用Java虚拟机（Hotspot、OpenJ9等），内部都同时包含解释器和编译器，解释器和编译器两者各有优势：</p><ul><li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。</li><li>当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</li><li>同时，解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行。</li><li>部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器担任“逃生门”的角色，（在虚拟机中习惯将Client Compiler称为C1，将Server Compiler称为C2）。</li></ul><p>因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210618211744.png" alt="image-20210618211744581" style="zoom:67%;" /><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><p>即时编译器编译本地代码需要占用程序运行时间（通常要编译出优化程度越高的代码，所花费的时间便会越长）。而且想要编译出优化程度更高的代码，解释器可能还要替编译器搜集性能监控信息，这也会影响解释执行阶段的速度。</p><p>为了在程序响应速度和运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译功能。</p><p>分层编译根据编译器编译、优化的规模和耗时，划分出不同的编译层次：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。</li><li>第1层，使用客户端编译器将字节码编译为本地代码，进行简单、可靠的优化，不开启性能监控功能。</li><li>第2层，仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。。</li><li>第3层，仍然使用客户端编译器执行，开启全部性能监控，除了第二层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层，使用服务端编译器执行，相比起客户端编译器，它会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互、转换关系如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210618214644.png" alt="image-20210618214644579" style="zoom:67%;" /><h3 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h3><p>在运行过程中会被即时编译器编译的“热点代码”有两类，<strong>被多次调用的方法</strong>和<strong>被多次执行的循环体</strong>。</p><p>这两种情况编译的目标对象都是整个方法体，而不会是单独的循环体。对于后一种情况，虽然编译器以整个方法作为编译对象，但<strong>执行入口（从方法第几条字节码指令开始执行）会稍有不同</strong>。</p><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为<strong>热点探测（Hot Spot Detection</strong>）。目前主要的热点探测判定方式有两种，<strong>基于采样的热点探测</strong>和<strong>基于计数器的热点探测</strong></p><ul><li>采用基于采样的热点探测的虚拟机会<strong>周期性地</strong>检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>采用基于计数器的热点探测的虚拟机会为每个方法（甚至是代码块）<strong>建立计数器</strong>，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对来说更加精确和严谨。</li></ul><p>基于计数器的热点探测有两种计数器，<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><p><strong>方法调用计数器</strong>：</p><ul><li><p>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次，这个阈值可以通过虚拟机参数-XX：CompileThreshold来人为设定。</p></li><li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。</p></li><li><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619103028.png" alt="image-20210619103028104" style="zoom:33%;" /></li></ul><p><strong>回边计数器</strong>：</p><ul><li><p>它的作用是统计一个方法中循环体代码执行的次数,准确地说，<strong>应当是回边的次数而不是循环次数，因为并非所有的循环都是回边，如空循环实际上就可以视为自己跳转到自己的过程，因此并不算作控制流向后跳转，也不会被回边计数器统计</strong>。在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p></li><li><p>关于回边计数器的阈值，可以通过设置参数-XX：OnStackReplacePercentage来间接调整回边计数器的阈值，其计算公式请看P394。</p></li><li><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</p></li><li><p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619102822.png" alt="image-20210619102822230" style="zoom:67%;" /></li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>无论是方法调用产生的即时编译请求，还是OSR编译请求，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。</p><p><strong>客户端编译（Client Compiler）过程</strong>分为三个阶段，主要的关注点在于局部性的优化，而放弃了很多耗时较长全局优化手段。</p><ul><li>在第一个阶段，一个平台独立的前端将字节码构造成一种<strong>高级中间代码表示（High-Level Intermediate Representaion,HIR）</strong>。HIR使用静态单分配（Static Single Assignment,SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</li><li>在第二个阶段，一个平台相关的后端从HIR中产生<strong>低级中间代码表示（Low-Level Intermediate Representation,LIR）</strong>，而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</li><li>最后阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生<strong>机器代码</strong>。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210619103256.png" alt="image-20210619103255979" style="zoom:67%;" /><p><strong>服务端编译（Server Compiler）过程</strong>。</p><ul><li>Server Compiler则是专门面向服务端的典型应用场景，并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行大部分经典的优化动作。</li><li>Server Compiler无疑是比较缓慢的，但它的编译速度依然远远超过传统的静态优化编译器，而且它相对于Client Compiler编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以也有很多非服务端的应用选择使用Server模式的虚拟机运行。</li></ul><h3 id="提前编译"><a href="#提前编译" class="headerlink" title="提前编译"></a>提前编译</h3><p>目前提前编译产品和对其的研究有着两条明显分支：</p><ul><li>一条分支是做与传统C编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作。这是传统的提前编译应用形式，它在Java中存在的价值直指即时编译器的最大弱点：即时编译要占用程序运行时间和运算资源。</li><li>另一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时（譬如公共库代码被同一台机器其他Java进程使用）直接把它加载进来使用。其本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。</li></ul><p>尽管即时编译在时间和运算资源方面的劣势是无法忽视的，但其依然有自己的优势（P407）：</p><ul><li>性能分析制导优化</li><li>激进预测性优化</li><li>链接时优化</li></ul><h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>以编译方式执行本地代码比解释方式更快的原因是，虚拟机解释执行字节码额外消耗时间，虚拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中。</p><p>本节介绍的几种经典的代码优化技术：方法内联、逃逸分析、公共子表达式消除 、数组范围检查消除 。（更多优化技术种类请看P412）</p><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联可以去除方法调用的成本（如建立栈帧等），还可以为其他优化建立良好的基础（因此被戏称为优化之母）</p><p>Java语言中默认的实例方法是虚方法。对于一个虚方法，编译期做内联的时候根本无法确定应该使用哪个方法版本，Java虚拟机引入了一种名为“<strong>类型继承关系分析</strong>”（Class Hierarchy Analysis,<strong>CHA</strong>）的技术。</p><ul><li><p>如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标版本可供选择。</p></li><li><p>如果查询结果只有一个版本，那也可以进行内联，不过这种内联就属于激进优化，需要预留一个“逃生门”（Guard条件不成立时的Slow Path），称为守护内联（Guarded Inlining）。如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译。</p></li><li><p>如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会进行最后一次努力，使用<strong>内联缓存</strong>（Inline Cache）来完成方法内联，这是一个建立在目标方法正常入口之前的缓存.</p></li><li><p>内联缓存工作原理大致是：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本，如果以后进来的每次调用的方法接收者版本都是一样的，那这个内联还可以一直用下去。如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时才会取消内联，查找虚方法表进行方法分派。</p></li></ul><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析（Escape Analysis）不是直接优化代码的手段，是为其他优化手段提供依据的分析技术。逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，</p><ul><li>例如作为调用参数传递到其他方法中，称为<strong>方法逃逸</strong>。</li><li>甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</li></ul><p>如果能证明一个对象不会逃逸到方法或线程之外（也就是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个变量进行一些高效的优化：</p><ul><li><strong>栈上分配</strong>（Stack Allocation），如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存，对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。<strong>栈上分配可以支持方法逃逸，但不能支持线程逃逸</strong>。</li><li><strong>同步消除</strong>（Synchronization Elimination），如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。</li><li><strong>标量替换</strong>（Scalar Replacement），<strong>标量</strong>是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，那它就称作聚合量（Aggregate），Java中的对象就是最典型的聚合量。<strong>如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换</strong>。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。<strong>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围</strong>。</li></ul><h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那E的这次出现就成为了公共子表达式。 </p><p>例：int d = (c * b) * 12 + a + (a + b * c) =&gt; int d = E * 12 + a + (a + E) =&gt;int d = E * 13 + a*2。</p><h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>数组边界检查消除是即时编译器中的一项语言相关的经典优化技术。</p><p>如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，对于有大量数组访问的程序代码，无疑是一种性能负担。为了安全，数组边界检查肯定是要做的，但它是不是必须在运行期间一次不漏地进行则是可以“商量”的事情。</p><ul><li>例如，数组下标是一个常量，如foo[3]，只要在编译器根据数据流分析来确定foo.length的值，并确定“3”没有越界，执行的时候就无须判断了。</li><li>如果数组访问发生在循环之中，并且使用循环变量来进行数组的访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围在区间[0, foo.length)之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 后端编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM前端编译与优化</title>
      <link href="2021/06/16/JVM/JVM%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>2021/06/16/JVM/JVM%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210616191609.png" alt="image-20210616191609122" style="zoom:67%;" /><p>编译期的分类：</p><ul><li>前端编译器：把<code>*.java</code>文件转换为<code>*.class</code>文件。例如sun的javac、eclipseJDT中的增量编译器。</li><li>即时编译器（JIT编译器）：运行期把字节码转换成机器码。例如 HotSpot VM的C1、C2编译器。</li><li>提前编译器（AOT编译器）：静态提前编译器，直接把程序编译成与目标机器指令集相关的二进制代码，例如GCJ。</li></ul><h2 id="Javac的源码与调试"><a href="#Javac的源码与调试" class="headerlink" title="Javac的源码与调试"></a>Javac的源码与调试</h2><p>从Javac代码的总体结构来看，编译过程大致可以分为一个准备过程和3个处理过程：</p><ul><li>准备过程：初始化插入式注解处理器</li><li>解析与填充符号表的过程。</li><li>插入式注解处理器的注解过程。</li><li>分析与字节码生成的过程。</li></ul><p>上述三个过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须回到之前的解析、填充符号表的过程中重新处理这些符号。三者间的关系与顺序如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210616192945.png" alt="image-20210616192934076"></p><h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><ul><li><strong>词法分析</strong>，是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。</li><li><strong>语法分析</strong>，是根据Token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个阶段都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</li><li><strong>填充符号表</strong>，符号表是由一组符号地址和符号信息构成的数据结构。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地质分配时，符号表是地址分配的依据。填充符号表的过程由com.sun.tools.javac.comp.Enter类实现，此过程的产出物是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</li></ul><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><ul><li>JDK5之后，Java语言提供了对注解的支持，注解在设计上原本是与普通的Java代码一样，都只会在程序运行期间发挥作用的。</li><li>但在JDK1.6中实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，在这些插件里面，<strong>可以读取、修改、添加抽象语法树中的任意元素</strong>。</li><li>如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次。</li></ul><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而<strong>语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查</strong>，如进行类型审查、控制流检查、数据流检查，等等。</p><p><strong>语义分析过程</strong>分为<strong>标注检查</strong>和<strong>数据及控制流分析</strong>两个步骤。而<strong>字节码生成之前还需要解语法糖</strong>。</p><ul><li><strong>标注检查</strong>，检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。还会顺便进行一个称为<strong>常量折叠</strong>（Constant Folding）的代码优化。标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr和com.sun.tools.javac.comp.Check类。</li><li><strong>数据及控制流分析</strong>，是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</li><li><strong>解语法糖</strong>， 语法糖（System Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。java中常用的语法糖主要是泛型、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，他们在编译阶段还原回原始的基础语法结构，这个过程称为解语法糖。</li><li><strong>字节码生成</strong>，是javac编译过程的最后一个阶段，这个阶段不仅把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘里，编译器还进行了少量的代码添加和转换工作。 比如：实力构造器()方法和类构造器()方法就是在这个阶段添加到语法树中（并不是默认构造函数，如何用户代码中没有任何构造函数，添加默认构造函数是在填充符号表阶段完成）</li></ul><h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><p>语法糖可以看作是前端编译器实现的一些小把戏，这些小把戏可能会使效率得到到提升，但我们也应该去了解这些小把戏背后的真实面貌，那样才能利用好它们，而不是被它们迷惑。</p><h3 id="泛型和类型擦除"><a href="#泛型和类型擦除" class="headerlink" title="泛型和类型擦除"></a>泛型和类型擦除</h3><p>Java中的泛型只在程序源码中存在，在编译后的字节码文件中就已经替换为原来的原生类型（裸类型）（例如<code>ArrayList&lt;Integer&gt;</code>还原为<code>Arraylist</code>），并且在相应的地方插入强制转型代码。因此对于运行期的java语言来说，<code>ArrayList&lt;Integer&gt;</code>与<code>ArrayList&lt;String&gt;</code>就是同一个类，所以泛型技术就是一颗语法糖，java语言中的泛型实现方法称为类型檫除，基于这种方法实现的泛型称为伪泛型。</p><p>泛型擦除的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型擦除前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt; String , String &gt;  map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;How are you ?&quot;</span>,<span class="string">&quot;吃了吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;您好！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;Hi&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型擦除后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;How are you ?&quot;</span>, <span class="string">&quot;吃了吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;您好！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println((String)map.get(<span class="string">&quot;Hi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>擦除式泛型的缺陷</strong>（具体例子看P372）：</p><ul><li>导致对原始类型数据的支持又成了新的麻烦</li><li>运行期无法获取到泛型类型信息，会让一些代码变得相当啰嗦</li><li>丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况</li></ul><h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><p>自动装箱、拆箱与遍历循环解语法糖测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    List list = Arrays.asList(<span class="keyword">new</span> Integer[] &#123; Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    List list2 = (List)Stream.of(<span class="keyword">new</span> Integer[] &#123; Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>) &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123; <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动装箱、拆箱在变之后被转化成了对应的包装盒还原方法，如Integer.valueOf()与Integer.intValue()方法</li><li>而遍历循环则被还原成了迭代器的实现，这也是为什么遍历器循环需要被遍历的类实现Iterator接口的原因</li><li>变长参数（asList），它在调用的时候变成了一个数组类型的参数，在变长参数出来之前，程序员使用数组来完成类似功能。</li></ul><p><strong>自动装箱的陷阱</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的</span></span><br><span class="line"><span class="comment"> * 不论是基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；</span></span><br><span class="line"><span class="comment"> * 而对于引用类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoBox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Integer h = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer i = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        包装类遇到“==”号的情况下，如果不遇到算数运算符（+、-、*、……）是不会自动拆箱的.所以这里“==”比较的是对象（地址）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//true 对于Integer 类型，整型的包装类系统会自动在常量池中初始化-128至127的值，如果c和d都指向同一个对象，即同一个地址。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c==d:&quot;</span> + (c == d));</span><br><span class="line">        <span class="comment">//false 但是对于超出范围外的值就是要通过new来创建包装类型，所以内存地址也不相等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;e==f:&quot;</span> + (e == f));</span><br><span class="line">        <span class="comment">//true 因为遇到运算符自动拆箱变为数值比较，所以相等。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c==(a+b):&quot;</span> + (c == (a + b)));</span><br><span class="line">        <span class="comment">//true 包装类都重写了equals（）方法，他们进行比较时是比的拆箱后数值。但是并不会进行类型转换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c.equals(a+b)&quot;</span> + (c.equals(a + b)));</span><br><span class="line">        <span class="comment">//true ==遇到算数运算符会自动拆箱（long） 3==（int）3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;g==(a+b)&quot;</span> + (g == (a + b)));</span><br><span class="line">        <span class="comment">//false equals首先看比较的类型是不是同一个类型，如果是，则比较值是否相等，否则直接返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;g.equals(a+b):&quot;</span> + g.equals(a + b));</span><br><span class="line">        <span class="comment">//true equals首先看比较的类型是不是同一个类型，如果是，则比较值是否相等，否则直接返回false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;h.equals(i):&quot;</span> + h.equals(i));</span><br><span class="line">        <span class="comment">//false 通过new来创建包装类型，所以内存地址也不相等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;h == i:&quot;</span> + (h == i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><ul><li> java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）无须使用预处理器。</li><li>Java语言可以使用条件为常量的if语句进行条件编译，根据布尔常量的真假来将分支中不成立的代码块消除掉。由于这种条件编译的实现方式使用了if语句，所以它必须遵循最基本的Java语法，只能写在方法体内部，因此它只能实现语句基本块（Block）级别的条件编译。</li><li>只能使用if，若使用常量与其他带有条件判断能力的语句描述搭配，则可能在控制流分析中提示错误，拒绝编译。</li></ul><h2 id="实战：插入式注解处理器"><a href="#实战：插入式注解处理器" class="headerlink" title="实战：插入式注解处理器"></a>实战：插入式注解处理器</h2><p>请看P378.</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 前端编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机字节码执行引擎</title>
      <link href="2021/06/15/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>2021/06/15/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p><strong>概述</strong>：</p><ul><li>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，他是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧存储了方法的局部变量，操作数栈，动态连接和方法返回值等信息，每个方法从调用开始到执行完成的过程都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</li><li>一个线程中的方法调用链会很长，只有位于栈顶的栈帧才有效，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行所有字节码指令都只针对当前栈帧进行操作。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210615205601.png" alt="image-20210615205601356" style="zoom:50%;" /><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><ul><li><strong>局部变量表是一组变量存储空间，用于存放方法参数和方法内部定义的局部变量。</strong></li><li>在Java程序编译为class文件时就在方法的code属性的max_locals数据项中确定该方法所需要分配的局部变量表的最大容量。<strong>局部变量表的容量以变量槽为最小单位。</strong></li><li>虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0开始至局部变量表最大Slot数量。</li><li>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static的方法），那么局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</li><li><strong>局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省栈空间，在某些情况下Slot的复用会直接影响到系统的垃圾收集行为</strong>。</li><li><strong>局部变量没有默认值</strong>，需要初始化，否则这段代码在java中不能运行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//placeholder的作用域被限制在花括号之内</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不增加这行，即没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  68864K-&gt;66256K(125952K), 0.0020403 secs]</span><br><span class="line">[Full GC (System.gc())  66256K-&gt;664K(125952K), 0.0095304 secs]</span><br></pre></td></tr></table></figure><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li>也称为操作栈，<strong>他是一个后入先出栈的栈</strong>，同局部变量一样，操作数栈的最大深度也在编译的时候写入到了code属性的max_stacks数据中，在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</li><li>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。</li><li><strong>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈</strong>。</li></ul><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ul><li><strong>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</strong>。</li><li>字节码中的方法调用指令就以常量池中指向方法的符号引用为参数，<strong>这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接</strong>。</li></ul><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><ul><li>第一种退出方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</li><li>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</li><li><strong>方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息</strong>。</li><li>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</li></ul><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><ul><li>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息。</li><li>一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</li></ul><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本（即调用那一个方法）</strong>，暂时还未涉及方法内部的具体运行过程。</p><p>在程序运行时，进行方法调用是最普遍、最频繁的操作之一。</p><h3 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h3><ul><li><strong>解析就是将方法的符号引用转化成直接引用</strong>，解析的前提是方法须在方法运行前就确定一个可调用的版本，并且这个版本在运行阶段是不可改变的（编译期可知，运行期不可变）。</li><li>只有用<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都可以在解析阶段确定调用版本，符合此条件的有静态方法,私有方法,实例构造器和父类方法四类，再加上被<code>final</code>修饰的方法（尽管它使用<code>invokevirtual</code>指令调用）。它们在类加载时即把符号引用解析为该方法的直接引用，这些方法可以称为非虚方法，其他防备被称为虚方法。</li><li><strong>解析调用是一个静态过程，编译期间就可以确定，分派调用可能是静态的也可能是动态的，是实现多态性的体现。</strong></li></ul><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>为了解释静态分派和和重载（Overload），请看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello guy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello gentleman&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello  lady&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line">        sayHello(man);</span><br><span class="line"></span><br><span class="line">        sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello guy</span><br><span class="line">hello guy</span><br></pre></td></tr></table></figure><ul><li><p>对代码<code>Human man = new Man()</code>来说，“Human”称为变量的<strong>静态类型</strong>，后面的“Man”称为变量的<strong>实际类型</strong>。</p></li><li><p>虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。</p></li><li><p><strong>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。</p></li><li><p>静态分派的最典型应用表现就是<strong>方法重载</strong>。</p></li><li><p><strong>静态分派发生在编译阶段</strong>，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p></li><li><p><strong>解析与分派这两者之间的关系并不是二选一的排他关系</strong>，它们是在不同层次上去筛选、确定目标方法的过程。例如，前面说过，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的</p></li></ul><p>编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本，看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">hello char</span><br><span class="line"></span><br><span class="line">这很好理解，&#39;a&#39;是一个char类型的数据，自然会寻找参数类型为char的重载方法，如果注释掉sayHello（char arg）方法，那输出会变为：</span><br><span class="line"></span><br><span class="line">hello int</span><br><span class="line"></span><br><span class="line">这时发生了一次自动类型转换，&#39;a&#39;除了可以代表一个字符串，还可以代表数字97（字符&#39;a&#39;的Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的。我们继续注释掉sayHello（int arg）方法，那输出会变为：</span><br><span class="line"></span><br><span class="line">hello long</span><br><span class="line"></span><br><span class="line">这时发生了两次自动类型转换，&#39;a&#39;转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。笔者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照char-＞int-＞long-＞float-＞double的顺序转型进行匹配。但不会匹配到byte和short类型的重载，因为char到byte或short的转型是不安全的。我们继续注释掉sayHello（long arg）方法，那输出会变为：</span><br><span class="line"></span><br><span class="line">hello Character</span><br><span class="line"></span><br><span class="line">这时发生了一次自动装箱，&#39;a&#39;被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载，继续注释掉sayHello（Character arg）方法，那输出会变为：</span><br><span class="line"></span><br><span class="line">hello Serializable</span><br><span class="line"></span><br><span class="line">这个输出可能会让人感觉摸不着头脑，一个字符或数字与序列化有什么关系？出现hello Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable＜Character＞，如果同时出现两个参数分别为Serializable和Comparable＜Character＞的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如：sayHello（（Comparable＜Character＞）&#39;a&#39;），才能编译通过。下面继续注释掉sayHello（Serializable arg）方法，输出会变为：</span><br><span class="line"></span><br><span class="line">hello Object</span><br><span class="line"></span><br><span class="line">这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。我们把sayHello（Object arg）也注释掉，输出将会变为：</span><br><span class="line"></span><br><span class="line">hello char……</span><br><span class="line">可变长参数的重载优先级是最低的</span><br></pre></td></tr></table></figure><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>它与Java语言多态性的另一个重要体现–重写（Override）有着很密切的关联。用一个例子来讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure><p>动态分派的关键是 invokevirtual指令， 它的运行时解析过程大致分为以下几个步骤：</p><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ul><p>由于invokevirtual指令执行的第一步就是<strong>在运行期确定接收者的实际类型</strong>，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><ul><li>方法的接收者与方法的参数统称为方法的宗量</li><li>根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</li></ul><p>用一个例子来讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father choose 360</span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure><p>我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。<strong>这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Father.hardChoice（360）及Father.hardChoice（QQ）方法的符号引用</strong>。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p><p>再看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice（new QQ（））”这句代码时，更准确地说，是在执行这句代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice（QQ），虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，<strong>所以Java语言的动态分派属于单分派类型</strong>。</p><h2 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h2><ul><li>由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（Vritual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Inteface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。</li><li>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</li></ul><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210615215819.jpg" alt="img" style="zoom:67%;" /><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>请看P329的例子</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 字节码执行引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机类加载机制</title>
      <link href="2021/06/10/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>2021/06/10/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换分析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制</strong>。</p><p><strong>在java语言中，类的加载、连接、初始化过程都是在程序运行期完成的，这种策略会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的灵活性。Java是天生可以动态扩展语言特性就是依赖运行期间动态加载和动态连接这个特点实现的</strong></p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210610192417.png" alt="img"></p><p> 如上图，其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><strong>虚拟机规范严格规定了有且只有5种情况必须对类进行“初始化”</strong>，当然初始化前的三个阶段（加载、验证、准备）就必须在此之前开始执行了。关于这5种必须初始化的场景如下（P263）：</p><ol><li><strong>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先触发其初始化</strong></li><li><strong>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</strong></li><li><strong>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</strong></li><li>当虚拟机启动时，<strong>用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</strong></li><li>当<strong>使用JDK1.7的动态语言支持</strong>时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic四种类型的方法句柄，并且这个方法句柄所对应的类没有进行过初始化。则需要先触发其初始化</li><li>当一个接口种<strong>定义了JDK8新加入的默认方法</strong>（被default关键字修饰的接口方法）时，<strong>如果有这个接口的实现类发生了初始化</strong>，那该接口要在其之前被初始化</li></ol><p>对于这五种会触发类进行初始化的场景，称为对一个类进行<strong>主动引用</strong>，除此之外，所有引用类的方法都不会触发初始化，称为<strong>被动引用</strong>（具体例子可查看P264）：</p><ul><li><p>通过子类引用父类的静态变量，不会导致子类初始化</p></li><li><p>通过数组定义来引用类，不会触发此类的初始化</p></li><li><p>调用类的常量不会被初始化(static final)</p></li></ul><blockquote><p>接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明。编译器仍然会为接口生成<code>&lt;client&gt;()</code>类构造器，接口与类真正有所区别的是前面讲述的6种触发初始化场景中的第三种：当一个类初始化时，要求其父类全部都已经初始化了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p></blockquote><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载的一个阶段。在加载阶段，虚拟机需要完成三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。方法区是共享区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。在Java内存中实例化一个java.lang.Class类的对象(并没有明确是在java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，虽然是对象，但是存放在方法区中)，这样便可以通过该对象访问方法区中的这些数据。</li></ul><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果</p><p>加载阶段与连接阶段(连接包括三步，看生命周期图)的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序，也就是必须先加载才能验证。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接的第一步，验证阶段目的是为了确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证步骤1、文件格式验证</strong><br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>如： 是否以魔数0xCAFEBABE开头； 主、次版本号是否在当前虚拟机处理范围内；常量池的常量中是否有不被支持的常量类型（检查常量tag标志）；指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据; Class文件中各个部分及文件是否有被删除的或附加的其他信息…</p><p><strong>验证步骤2、元数据验证</strong><br>保证不存在不符合Java语言规范的元数据信息。<br>例如：这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）；这个类的父类是否继承了不允许被继承的类（被final修饰的类）； 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法；类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）…</p><p><strong>验证步骤3、字节码验证</strong><br>字节码验证的主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。然后，对类的方法体进行分析，保证被校验的类在运行时不会危害虚拟机安全。</p><p>例如： 保证任意时刻操作栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载如本地变量中； 保证跳转指令不会跳转到方法体以外的字节码指令上；保证方法体中的类型转换是有效的；“字节码验证”是整个验证阶段最消耗时间的，虽然如此但也不能保证绝对安全。</p><p><strong>验证步骤4、符号引用验证</strong><br>发生在虚拟机将符号引用转化为直接引用的时候。<br>符号引用中通过字符串描述的全限定名是否能找到对应的类； 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段； 在符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问；如果我们代码无法通过符号验证，例如根据全限定名无法找到对应的类，会抛出noSuchClass异常。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存设置类变量初始化值的阶段，这些变量所使用的内存都将在方法区中进行分配</strong>。</p><p>这个阶段中有两个容易产生混淆的概念需要强调一下。首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：public static int value = 123；那变量value在准备阶段过后的初始化值为0而不是123，因为这是尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后存放在类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。以下表格列出了所有基本数据类型的零值：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210610195027.png" alt="image-20210610195027747"></p><p>​        上面提到的在“通常情况”下初始值为零值，但还是会有一些特殊情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>；</span><br></pre></td></tr></table></figure><p>​        类字段的字段属性表中存在ConstantValue属性（有final修饰的字段），那在准备阶段变量value就会被初始化微ConstantValue属性所指定的值。编译时Javac将会为vaue生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。</strong></p><ul><li>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用的目标不一定加载到内存中。</li><li>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接点位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的。</li></ul><p><strong>类或接口的解析</strong>：</p><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为 一个类或接口C的直接引用，那虚拟机完成整个解析过程需要一个3个步骤：<br>  1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现接口。一旦这个加载过程出现了任何异常，解析过程宣布失败。<br>  2）如果C是一个数组类型，并且数组的元素类型是对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述如前面所假设的形式，需要加载的元素类型就是“Java.lang.Integer”，接着有虚拟机生成一个代表此数组维度和元素的数组对象：“[Ljava/lang/Integer”（数组引用可回顾上文“类加载时机-被动引用演示二”）。<br>  3）如果上述步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p><p><strong>字段解析</strong>：</p><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用，这步解析成功才会进行后续字段的搜索。对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从下往上递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。若还找不到，抛出<code>java.lang.NoSuchFieldError</code>异常。</p><p><strong>类方法解析</strong>：</p><p>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。（P276）</p><p><strong>接口方法解析</strong>：</p><p>与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>到初始化阶段，才真正开始执行类中定义的Java程序代码。</strong><br>在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：<strong>初始化阶段是执行类构造器&lt; clinit&gt;()方法的过程</strong>。</p><ul><li>&lt; clinit&gt;()方法方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</li><li>&lt; clinit&gt;()方法与实例构造器<init>()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt; clinit&gt;()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。</li><li>&lt; clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt; clinit&gt;()方法。</li><li>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&lt; clinit&gt;()方法。但是接口与类不同的是：执行接口的&lt; clinit&gt;()方法不需要先执行父接口的&lt; clinit&gt;()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt; clinit&gt;()方法。</li><li>虚拟机会保证一个类的&lt; clinit&gt;()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt; clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit&gt;()方法完毕。如果在一个类的&lt; clinit&gt;()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>通过类全限定名称获取二进制流。<br>虚拟机团队把累加载阶段中的**”通过一个类的全限定名来获取描述此类的二进制流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为”类加载器”**。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210610201954.png" alt="image-20210610201954524" style="zoom:67%;" /><p><strong>从Java虚拟机的角度看</strong>，只存在两种不同的类加载器：</p><ul><li>启动类加载器：它使用C++实现(仅限于HotSpot，因为有很多虚拟机也是由Java实现的)，是虚拟机自身的一部分。</li><li>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li></ul><p><strong>从Java开发人员的角度来看</strong>，类加载器可以划分更细致一些，可以大致划分为以下三类：</p><ul><li>启动类加载器(Bootstrap ClassLoader)：它负责加载存放在{JAVA_HOME}\lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器：Extension ClassLoader，这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载{JAVA_HOME}\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p><strong>双亲委派模型的工作流程</strong>：</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p><strong>使用双亲委派模型的好处</strong>：</p><p>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自行编写了一个java.lang.Object的类，并且放在ClassPath中，那么系统将会出现多个不同的Object类，那么Java体系中最基本的行为将无法保证。</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器与内存分配策略</title>
      <link href="2021/06/04/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>2021/06/04/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>程序计数器，虚拟机栈，本地方法栈这三个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊的执行入栈和出栈操作，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域不需要过多考虑回收的问题。而java堆和方法区的内存的分配都是动态的，故需要关注这一部分的内存回收。</p><p>垃圾收集需要考虑的三件事:</p><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul></blockquote><h2 id="如何判断对象已经死去"><a href="#如何判断对象已经死去" class="headerlink" title="如何判断对象已经死去"></a>如何判断对象已经死去</h2><h3 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h3><p>概述：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；引用失效，计数器就减1；当一个对象的引用计数器为0时，表示对象已死，可回收</p><p>优点：实现简单，并且高效</p><p>缺点：无法解决对象之间的循环引用问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>概述：解决引用计算器法的无法判断循环引用的问题，基本思路是，以一系列称为“GC Roots”的对象作为起点，从这些节点开始通过<strong>引用链（Reference Chain）</strong>的方式向下搜索。当对象A引用了对象B，那么对象A和对象B之间便有了引用链，如果对象A是“GC Roots”，那么对象B就被称为可达。当对象B引用了对象C，因为B是可达的，所以A通过B也能到达C，对象C也被称作可达。引用链：<strong>A</strong> -&gt; B -&gt; C</p><p>哪些对象可作为GC Roots的对象？</p><ul><li>虚拟机栈（栈帧中的本地变量）中引用的对象</li><li>方法区（注意：方法区这个概念，在JDK1.8便移除了，改为了元空间）中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul><p>优点：全面的分析对象是否存活</p><p>缺点：实现复杂，效率低下</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>判断对象是否存活，离不开引用。JDK1.2以前，定义<strong>引用</strong>的方法很纯粹：如果<strong>reference类型</strong>的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个<strong>引用</strong>。这就导致了引用只有两种状态，有或者无。两个对象之间，存在着引用就是有，不存在引用就是没有，没有就被垃圾收集器给回收。但是我们对于一些“食之无味，弃之可惜”的对象就显得无能为力了。当我们的内存足够时，我们并不想毁灭它，以此来避免后面的重复创建，浪费时间。所以有了以下四种定义</p><ul><li>强引用：程序代码中普遍存在，类似“Objec obj = new Object()”，个人理解为，就是GC Roots能可达的对象，这些对象之间的引用链就是强引用，只要强引用在，就永远不会被回收掉。</li><li>软引用：SoftReference，描述一些还可能有用，但是非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。当然，如果这次回收还没有收集足够的空间供新对象使用，才会抛出内存溢出的异常，导致OOM。</li><li>弱引用：WeakReference，也是用来描述一些非必需的对象，但是它比软引用更加的弱一些。每一次垃圾回收，不管内存够不够都要回收它们。只能生存在下一次垃圾回收之前。</li><li>虚引用：PhantomReference，最弱的引用，一个对象是否有虚引用，完全不会对其生存时间构成影响，唯一的目的是：能在这个对象被收集器回收时收到一个系统通知</li></ul><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>即JDK1.8后的元空间，回收对象主要有两部分内容：废弃的常量和无用的类。</p><p>判断常量是否废弃比较简单</p><p>满足三个条件才算是无用的类：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的对象</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210604211759.png" alt="image-20210604210757546"></p><ul><li>概述：算法分为两个阶段，首先标记所有需要回收的对象，在标记完成后统一回收所有标记的对象。最基础的收集算法。</li><li>缺点：效率不高，空间上会产生大量的空间碎片。如果程序遇到大对象需要分配时，无法找到足够的连续内存而不得不提前触发另一次的垃圾收集动作。</li></ul><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210604211847.png" alt="image-20210604211847364"></p><ul><li>概述：把内存分为大小相等的两块，每次只使用其中的一块。当这一块的内存快用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性的清理掉。现代的商业机都是采用的这种收集算法，但是IBM研究表明，新生代中的对象98%都是“朝生夕死”的，并不需要按1：1来分配内存空间，而是将内存分为一块较大的Eden和两块较小的Survivor1空间，每次使用Eden和其中的一块Survivor空间。当回收时，将Eden和Survivor中还存活的对象一次性的复制到另外一块Survivor上去，最后在清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。但是可能会出现复制到Survivor过程中，存活的对象太多了，装不下，Survivor空间不够用。所以还需要进行分配担保(Handle Promotion)，依赖其他内存来复制(这里指老年代)。</li><li>优点：简单高效，不用考虑内存碎片等复杂情况。</li><li>缺点：内存利用会减少一半（1:1分配内存空间时）</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210604211827.png" alt="image-20210604211827014"></p><p>适用于老年代，存活率高的对象。让所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机都是采用的“分代收集”算法，把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。新生代用复制算法，因为有大量对象死去，老年代使用“标记-清理”或者“标记整理”，因为老年代存活率高。</p><h2 id="HotSpot如何实现垃圾回收"><a href="#HotSpot如何实现垃圾回收" class="headerlink" title="HotSpot如何实现垃圾回收"></a>HotSpot如何实现垃圾回收</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从GC Roots出发，也就是根节点，进行可达性分析，这个过程非常消耗时间。而且可达性分析的话，需要保持“一致性”，一致性是指整个可达性分析期间的执行过程应该看起来是要停留在某个时间点上。不可以出现分析过程中，对象之间的引用还在发生变化。要保证可达性分析结果的正确性，准确性。所以GC会导致系统的“Stop The World”</p><p>当然由于枚举根节点消耗大量的时间，所以引入了OopMap这种数据结构。GC时，当执行系统停顿下来时，并不需要一个不漏的把所有执行上下文和全局的引用位置，虚拟机而是通过OopMap直接得知哪些地方存放着对象的引用</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>为了配合OopMap，引入了安全点。HotSpot通过OopMap确实可以快速且准确地完成GC Roots的枚举，但是OopMap内容的变化的指令非常的多，如果位每一条指令都生成对应的OopMap，那将会需要大量的额外空间。所以虚拟机只在特定的时间位置，记录了这些引用信息，并没有为每条指令都生成OopMap，这些位置便称作安全（SafePoint），即程序执行时并非能在所有的地方停下来，而是只能在达到安全点时才能暂停。</p><p>如何在GC发生时，让所有的线程都“跑”到最近的安全点去？</p><ul><li>抢先式中断：强制把所有的线程中断，如果有线程不在安全点上，就恢复线程，让它跑到安全点上，几乎没有虚拟机使用这种方法，</li><li>主动式中断：当线程需要中断时，不直接对线程操作，而是通过一个标志，各个线程执行时，主动的去轮询这个标志，需要中断时，改变这个标志。线程在轮询的时候发现中断标志为真，就自己中断挂起。轮询标志的地方和安全点是重合的。</li></ul><p>SafePoint很完美吗？不见得，safePoint关注的点是正在运行的线程，那么有些线程处于Sleep状态或者Blocked状态，这时候线程无法响应中断请求。所以引入了安全区域（Safe Region）</p><p><strong>安全区域</strong>是指：在一段代码中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。具体描述：在线程执行到safe region中的代码时，首先标识自己已经进入了safe region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为safe region状态的线程了。在线程要离开safe region时，它要检查系统是否已经完成了根节点枚举（即整个GC过程），如果完成了，那线程就继续执行，否则他就必须等待直到收到可以安全离开safe region的信号为止</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>**并行(Parallel)**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待阶段。</p><p>**并发(Concurrent)**：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>新生代收集器，单线程收集器。最基本，发展历史最悠久的收集器。特点：在他进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束，Stop The World。优点：简洁又高效。在运行在client模式下的虚拟机来说是一个很好的选择。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>是serial收集器的多线程版本。它是许多运行在Server模式下的虚拟机中首选的新生代收集器。原因很简单，目前只有它与serial收集器能与CMS收集器配合工作。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>目标是达到一个可控的吞吐量。所谓吞吐量用于运行用户代码的时间与CPU总消耗时间的比值。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。它也被称为吞吐量优先的收集器。可以设置一个参数，让虚拟机GC自适应的调节。即虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最适合的停顿时间或最大吞吐量。这是它与parnew收集器的一个重要区别。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>是serial收集器的老年代版本，同样是一个单线程收集器，使用标记_整理算法。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>是Parallel Scavenge收集器的老年代版本，使用多线程的标记_整理算法。</p><h3 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS(Concurrent Mark Sweep)"></a>CMS(Concurrent Mark Sweep)</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210604210400.png" alt="image-20210604210400117"></p><p>是一种以获取最短回收停顿时间为目标的收集器。重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。是基于标记-清除算法实现的，它的运作过程：初始标记，并发标记，重新标记，并发清除。第一步和第三步仍然需要Stop The World。</p><ul><li>初始标记：仅仅标记一下GC Roots能直接关联到的对象，速度很快。需要STW</li><li>并发标记：进行GC Roots Tracing的过程，时间较长</li><li>重新标记：则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那些对象的标记记录（增量更新），比初始标记稍微长一些，但远比并发标记的时间短。需STW</li><li>并发清除：执行sweep，时间较长</li></ul><p><strong>优点</strong>：并发收集，低停顿，又称之为并发低停顿收集器。</p><p><strong>缺点</strong>：</p><ol><li>CMS对CPU资源非常的敏感，在并发阶段虽然不会导致用户线程停顿，但是会因为占用CPU资源而导致应用程序变慢，总吞吐量会降低。多CPU的时候，可以用回收默认线程数(CPU数量+3)/4。使并发回收垃圾线程所占的CPU资源使用百分比降低。CPU越多，降的多。但是CPU很少的情况下，问题就很大，由此虚拟机提供了i-CMS增量式并发收集器，就是让GC线程，用户线程交替运行，尽量减少GC线程独占CPU的时间，这样会是整个垃圾回收时间增长，但对用户程序的影响就少些。但是效果一般，不提倡使用。</li><li>CMS无法处理浮动垃圾，由于在并发清理阶段用户线程还在运行，可能产生新的垃圾，这一部分垃圾出现在重新标记阶段之后。因此需要预留提供一部分空间给并发时的用户线程使用，以供用户程序正常运行，而不能像其他收集器一样，等到老年代几乎被填满了再进行收集。</li><li>是标记-清除算法的缺点，会有大量的空间碎片产生，碎片过多时，将会给大对象带来很大的麻烦，如果没有空间给大对象，就不得不提前触发一次fullGC。为了解决这个问题，可以设置一些参数来优化，如当FullGC执行了多少次的时候，来一次空间碎片压缩，开启内存碎片的整理过程。但是这样使得停顿时间变长了。</li></ol><h3 id="G1（Garbage-First）收集器"><a href="#G1（Garbage-First）收集器" class="headerlink" title="G1（Garbage-First）收集器"></a>G1（Garbage-First）收集器</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210604211735.png" alt="image-20210604211735296"></p><p>G1是一款面向服务端应用的垃圾收集器，它的使命是替换掉CMS，弥补CMS空间碎片等缺点。不同于其他的分代回收算法、G1将堆空间划分成了互相独立的区块。每块区域既有可能属于O区、也有可能是Y区，且每类区域空间可以是不连续的（对比CMS的O区和Y区都必须是连续的）。这种将O区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境的硬件优势，使用多个CPU来减少STW的停顿时间</li><li>分代收集：还是与其他收集器一样采用分代收集，不过older与young不再是连续的空间了</li><li>空间整合：整体是感觉采用“标记-整理”；局部之间是靠两个region基于“复制算法”；这两种策略所以不会产生空间碎片</li><li>可预测停顿：建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间不得超过N毫秒，这几乎是实时Java（RTSJ）的垃圾收集器的特征了</li></ul><p>平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：</p><ul><li>G1在压缩空间方面有优势</li><li>G1通过将内存空间分成区域（Region）的方式避免内存碎片问题</li><li>Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活</li><li>G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象</li><li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做</li><li>G1会在Young GC中使用、而CMS只能在O区使用</li></ul><p>就目前而言、CMS还是默认首选的GC策略、可能在以下场景下G1更适合：</p><ul><li>服务端多核CPU、JVM内存占用较大的应用（至少大于4G）</li><li>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li><li>想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象</li></ul><p>GC模式：G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。</p><ul><li><p><strong>young gc</strong>：发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-XX:MaxGCPauseMillis</td><td>设置G1收集过程目标时间，默认值200ms</td></tr><tr><td>-XX:G1NewSizePercent</td><td>新生代最小值，默认值5%</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>新生代最大值，默认值60%</td></tr></tbody></table></li><li><p><strong>mixed gc</strong>：当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p><p>那么mixed gc什么时候被触发？</p><p>先回顾一下cms的触发机制，如果添加了以下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;-XX:CMSInitiatingOccupancyFraction&#x3D;&#96;&#96;80&#96; &#96;-XX:+UseCMSInitiatingOccupancyOnly&#96;</span><br></pre></td></tr></table></figure><p>当老年代的使用率达到80%时，就会触发一次cms gc。相对的，mixed gc中也有一个阈值参数 <code>-XX:InitiatingHeapOccupancyPercent</code>，当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc.</p><p>mixed gc的执行过程有点类似cms，主要分为以下几个步骤：</p><ol><li>initial mark: 初始标记过程，整个过程STW，标记了从GC Root可达的对象</li><li>concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息</li><li>remark: 最终标记过程，整个过程STW（使用原始快照SATB），标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对象</li><li>clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中</li></ol></li><li><p><strong>full gc</strong>：如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</p></li></ul><h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><p>　　垃圾收集器三个重要的指标：内存占用、吞吐量和延迟。内存占用和吞吐量随着硬件性能的提升，帮助了软件不少，不需要那么关注这两点，随着硬件的提升这两项指标也会随着提升。但是延迟不一样，延迟也就是STW的时间，随着内存条的容量越来越大，Java堆可用的内存也越来越大，意味着需要回收的空间也越来越大，那么STW也就越久。</p><h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>是一款非官方的垃圾收集器，是由RedHat公司开发的项目，受到来自Sun公司的排斥，所以在正式商用版的JDK中是不支持这个收集器的，只有在OpenJDK才有。虽然没有拥有正统血脉，但是在代码上它相较于ZGC更像是G1的继承者，在很多阶段与G1高度一致，甚至共用了一部分源码，但相较于G1又有一些改进。最主要有三个改进：</p><ol><li>支持并发标记-整理算法。</li><li>默认不适用分代收集，Shennandoah和G1一样使用Region分区，但是在Shennandoah中并没有Region会去扮演新生代或者老年代</li><li>G1中存储引用关系的记忆集占用了大量的内存空间，在Shennandoah改用为连接矩阵，具体可以看P107。</li></ol><p>Shennandoah收集工作过程大概可以分为9个步骤：</p><ol><li>初识标记：与G1一样，标记处与GC Roots直接关联的对象，STW。</li><li>并发标记：与G1相同，根据上一步的对象，完整标记出可达对象。</li><li>最终标记：也与G1一样，利用原始快照的方法标记出上个阶段变动的对象，还会在这个阶段统计出回收价值最高的Region，组成一个回收集。</li><li>并发清理：这个阶段会清理整个Region区一个存活对象都没有的区域，所以可以并发进行。</li><li>并发回收：将回收集中存活的对象复制一份到其他未被使用的Region区中。</li><li>初始引用更新：并发回收阶段复制后，还需修正到复制后的新地址，但这个阶段并未做什么具体操作，只是相当于一个集合点，确保并发回收阶段所有线程都完成了自己的复制工作。</li><li>并发引用更新：这个阶段才是真正修正引用的阶段。</li><li>最终引用更新：上一步只是修正了Java堆中对象的引用，还要修正存在于GC Roots的引用，最后一次短暂的暂停，只与GC Roots数量有关。</li><li>并发清理：经过了并发回收的复制和引用修正，会收集中的Region就可以完全清理了。</li></ol><p>　　再说说Shennandoah的一个特点，也就是前面说到的并发标记-整理算法。整理阶段可以细分为5，6，7，8四个步骤。其最大的一个问题就是，在复制或者在修正引用的时候用户线程可能正在使用这个对象。原来有个解决类似问题的方案，就是保护陷阱，大概过程就是当用户线程访问到对象就地址后，会进入一个异常处理器中，由该处理器转发到新的地址。而在Shennandoah中用的是一种相对更好的方案：转发指针，就是在每个对象前面加个新的引用字段，当不处于并发移动的情况下，该引用指向自己，并发移动了的话就指向新地址。</p><h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><p>ZGC的目标和Shennandoah相似，都希望在不影响吞吐量的情况下，将停顿时间限制在10毫秒以内。ZGC也是基于Region布局的，还并未支持分代收集，但其<strong>Region有大中小三个类型</strong>：</p><ol><li>小型Region容量固定为2MB，用于放置小于256KB的小对象。</li><li>中型Region固定容量为32MB，用于放置大于等于256KB，小于4MB的对象。</li><li>大型Region容量不固定，但一定是2的整倍数，用于存放大于4MB的对象。</li></ol><p>　　ZGC在实现并发整理时用到了染色指针，之前的的收集器如果想在对象中额外存储一些信息，大多会在对象头里存储，比如转发指针。再就是之前说到的可达性分析中的三色标记，其只是表达了对象引用的情况，跟对象本身的数据没任何关系，<strong>所以染色指针就是把这些标记信息记录在引用对象的指针上。指针为什么还能存储信息呢？</strong>这就要说到系统架构了，具体看P114，染色指针只支持64位系统，而AMD64架构中只支持到了52位，而各大操作系统又有自己的限制，染色指针在Linux支持的46位指针宽度中，拿出4位存储这些标记信息，所以使用了ZGC进一步压缩了原本46位的地址空间，从而导致了ZGC能管理的内存不能超过4TB，在今天看来，4TB的内存依旧非常充足。</p><p><strong>染色指针的三大优势：</strong></p><ol><li>一旦某个Region的存活对象被移走后，这个Region立即就能被回收重新利用，而Shennandoah需要一个初始引用更新，等待所有线程复制完毕。</li><li>染色指针可以大幅度减少在垃圾收集过程中内存屏障的使用数量（后面过程中的第五步提到），一部分功能就是因为染色指针把信息存储在指针上了，还有一部分原因就是ZGC还并未支持分代收集，所以也不存在跨代引用。</li><li>染色指针在未来可以拓展，记录更多信息，前面说到在64位系统中，Linux只用到了46位，还要18位未被开发。还有一个问题就是染色指针重新定义指针中的几位，操作系统 是否支持，虚拟机也只是一个进程而已，这里就用到了虚拟内存映射，具体看P116。</li></ol><p><strong>ZGC工作过程大概可以分为以下几步：</strong></p><ol><li><strong>初始标记</strong>：与之前几个收集器一样，找到GC Roots的直接关联对象。</li><li><strong>并发标记</strong>：标记出完整的可达对象，与G1和Shennandoah不同的是，它是在指针上做更新而不是对象头。</li><li><strong>最终标记</strong>：和Shennandoah一样。</li><li><strong>并发预备重分配</strong>：这个阶段需要根据特定的查询条件统计出本次收集过程要清理哪些Region。这里的分配集不是像G1那样按收益优先的回收集，分配集只是决定了里面的对象会被复制到新的Region，这里的Region要被释放了。</li><li><strong>并发重分配</strong>：这个过程要把分配集中的对象复制到新的Region中，并为分配集中的每个Region维护一个转发表，得益于染色指针的帮助，可以仅从引用上就可以得知某个对象是否在分配集上，如果在复制时，一个用户线程访问了分配集中的对象就会被内存屏障截获，然后根据转发表将访问转发到新的对象上，并修正这个线程访问该对象的引用，这个过程称为指针的自愈。</li><li><strong>并发重映射</strong>：这个阶段要修正整个堆中指向重分配集中旧对象的所有引用。这个阶段比较特殊，因为它不是迫切需要去执行的，上个阶段的自愈过程就是针对某一对象的引用修正，所以即使没有这一步也不会出现问题，只是第一次自愈有个转发过程会稍慢一点，后面也都正常了。正因为这种不迫切，ZGC巧妙的把这步工作合并到了并发标记过程当中，因为并发标记也需要遍历所有对象，这一步也需要修正所有旧对象的引用。</li></ol><p>　　ZGC的一大问题就是其暂时还没有分代收集，这限制了它能承受的对象分配速率不会太高（ZGC每次都要对一个很大的堆做一次完整的并发收集，在这段收集时间内会创建大量对象，而这些对象大部分都是朝生夕灭的，导致产生大量浮动垃圾）。如果长时间的回收速率比不上分配速率，产生的浮动垃圾越来越多，可分配的空间也越来越小了。所以要从根本上解决这个问题还是要引入分代收集，让新生代专门去存储这些频繁回收创建的对象。</p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>主要是以下五种策略，目的都是在结合JVM实际情况下，尽可能的提高效率，且做到安全可靠</p><ul><li>对象优先在Eden分配：大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC(新生代GC)。</li><li>大对象直接进入老年代：大对象对虚拟机来说是一个很坏的消息，经常出现大对象会容易导致内存还有不少空间，但是满足不了这个大对象，所以提前触发垃圾收集以获取足够的空间来容纳安置它们。可以开启一个参数，是大对象直接进入老年代，在老年代分配，这样做的目的是避免在Eden区以及两个Survivor区之间大量的内存复制（新生代采用的是复制算法）。</li><li>长期存活的对象将进入老年代：给对象加一个年龄计数器，每熬过一次Minor GC后仍然存活，并且能够被Survivor容纳的话，对象年龄就加一。可以设置一个参数，当年龄足够就晋升老年代之中去。</li><li>动态对象年龄判定：并不一定要求，所有对象的年龄必须要达到某一个年龄值，如果Survivor空间中相同年龄所有对象的大小的总和大于Survivor空间的一半，年龄大于等于该年龄对象就可以直接进入老年代，无须一定要达到某个年龄才能进去。</li><li>空间分配担保：发生在Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，那么会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么就会继续检查老年代的最大可连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次Minor GC，虽然有风险。如果小于就进行Full GC，来回收老年代的空间。圈子虽然绕的大，但是可以避免频繁的FULL GC。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 垃圾收集与内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机运行时数据区域</title>
      <link href="2021/06/02/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>2021/06/02/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210602160638.jpg" alt="img"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h2><p>在Java虚拟机中，程序计数器是线程私有的。程序计数器是一块较少的内存区域，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机中的概念模型中，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器的执行时间的方式来实现的，在任何一个时刻，一个处理器都只会执行一条线程中的指令。因此为了线程切换后，能够恢复到正确的执行位置，每条线程都需要有一个独立的计数器，各条线程之间互不干扰、互不影响，独立存储。我们称这一类内存存储区域为“线程私有”的内存。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a><strong>Java虚拟机栈</strong></h2><p>栈帧是方法运行期的基础数据结构栈容量可由-Xss参数设定</p><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程一样。虚拟机栈的描述的就是Java方法执行的内存模型：每个方法在执行的过程中都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用至完成的过程。</p><p>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、double、long）、对象引用和returnAddress地址信息。局部变量表所存储的内存空间是在编译期间内完成分配的，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机栈中，这个区域规定了两种异常规范：如果线程请求的栈深度大于虚拟机的栈深度，将抛出StackOverFlowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemory异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h2><p>栈容量可由-Xss参数设定</p><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常类似的，它们之间的区别就是虚拟机栈是为虚拟机执行Java方法服务，而本地方法栈是为虚拟机执行Native方法服务。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h2><p>可通过参数 -Xms 和-Xmx设置 。</p><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存；Java堆是垃圾收集器管理的主要区域，也叫GC堆；java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h2><p>参数-XX:MaxPermSize可设置 .</p><p>方法区与java堆一样，是各个线程共享的内存区域，它用于存储<strong>已被虚拟机加载的类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码等数据</strong>。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h2><p>可以通过-XX:PermSize和-XX:MaxPermSize设置</p><blockquote><p>这两个参数限制的是永久代的大小，但是JDK8后用元空间代替了永久代，所以JDK8后这两个参数无用，而元空间相关参数如下(简略介绍，详情请自行查阅相关资料)：</p><ul><li>-XX:MaxMetaspaceSize   设置元空间最大值</li><li>-XX:MetaspaceSize   指定元空间的初始空间大小</li><li>-XX:MinMetaspaceFreeRatio.    在垃圾收集后控制最小的元空间剩余容量的百分比</li></ul></blockquote><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，<strong>还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，java语言并不要求常量一定只有编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a><strong>直接内存</strong></h2><p>可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常。在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在java堆和Navtive堆中来回复制数据。</p>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIP、OSPF、BGP三种路由协议</title>
      <link href="2021/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP%E3%80%81OSPF%E3%80%81BGP%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP%E3%80%81OSPF%E3%80%81BGP%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="RIP（-Routing-Information-Protocol-）路由信息协议"><a href="#RIP（-Routing-Information-Protocol-）路由信息协议" class="headerlink" title="RIP（ Routing Information Protocol ）路由信息协议"></a>RIP（ Routing Information Protocol ）路由信息协议</h2><p>RIP是在一个AS（自治系统）中使用的内部路由选择协议，是个非常简单的基于距离向量路由选择的协议。它是路由器生产商之间使用的第一个开放标准，是最广泛的路由协议，在所有IP路由平台上都可以得到。当使用RIP时，一台Cisco路由器可以与其他厂商的路由器连接。 </p><p>RIP 主要设计来利用同类技术与大小适度的网络一起工作，因此通过速度变化不大的接线连接。RIP 比较适用于简单的校园网和区域网，不适于复杂网络的情况。 </p><p>RIP的算法简单，是<strong>距离向量型协议</strong>，但在路径较多时收敛速度慢，广播路由信息时占用的带宽资源较多，它适用于网络拓扑结构相对简单且数据链路故障率极低的小型网络中，在大型网络中，一般不使用RIP。<br>RIP使用UDP数据包更新路由信息。路由器每隔30s更新一次路由信息，如果在180s内没有收到相邻路由器的回应，则认为去往该路由器的路由不可用，该路由器不可到达。如果在240s后仍未收到该路由器的应答，则把有关该路由器的路由信息从路由表中删除。 </p><p><strong>RIP具有以下特点</strong>： </p><ul><li>不同厂商的路由器可以通过RIP互联；</li><li>配置简单； </li><li>适用于小型网络（小于15跳）； </li><li>需消耗广域网带宽； </li><li>需消耗CPU、内存资源。</li></ul><h2 id="OSPF（-Open-Shortest-Path-First，开放最短路径优先）"><a href="#OSPF（-Open-Shortest-Path-First，开放最短路径优先）" class="headerlink" title="OSPF（ Open Shortest Path First，开放最短路径优先）"></a>OSPF（ Open Shortest Path First，开放最短路径优先）</h2><p>开放式最短路径优先（Open Shortest Path First，OSPF）协议是一种为IP网络开发的内部网关路由选择协议，由IETF开发并推荐使用。OSPF协议由三个子协议组成：Hello协议、交换协议和扩散协议。其中Hello协议负责检查链路是否可用，并完成指定路由器及备份指定路由器；交换协议完成“主”、“从”路由器的指定并交换各自的路由数据库信息；扩散协议完成各路由器中路由数据库的同步维护 。</p><p>OSPF 是<strong>链路状态型协议</strong><br>路由器互相发送直接相连的链路信息和它拥有的到其它路由器的链路信息。每个 OSPF 路由器维护相同自治系统拓扑结构的数据库。从这个数据库里，构造出最短路径树来计算出路由表。当拓扑结构发生变化时， OSPF 能迅速重新计算出路径，而只产生少量的路由协议流量。 此外，所有 OSPF 路由选择协议的交换都是经过身份验证的。<br><strong>OSPF协议具有以下优点</strong>：</p><ul><li>OSPF能够在自己的链路状态数据库内表示整个网络，这极大地减少了收敛时间，并且支持大型异构网络的互联，提供了一个异构网络间通过同一种协议交换网络信息的途径，并且不容易出现错误的路由信息。 OSPF支持通往相同目的的多重路径。 </li><li>OSPF使用路由标签区分不同的外部路由。</li><li>OSPF支持路由验证，只有互相通过路由验证的路由器之间才能交换路由信息；并且可以对不同的区域定义不同的验证方式，从而提高了网络的安全性。</li><li>OSPF支持费用相同的多条链路上的负载均衡。</li><li>OSPF是一个非族类路由协议，路由信息不受跳数的限制，减少了因分级路由带来的子网分离问题。</li><li>OSPF支持VLSM和非族类路由查表，有利于网络地址的有效管理 </li><li>OSPF使用AREA对网络进行分层，减少了协议对CPU处理时间和内存的需求。</li></ul><h2 id="BGP-（边界网关协议，Border-Gateway-Protocol）"><a href="#BGP-（边界网关协议，Border-Gateway-Protocol）" class="headerlink" title="BGP （边界网关协议，Border Gateway Protocol）"></a>BGP （边界网关协议，Border Gateway Protocol）</h2><p>是自治系统之间的路由选择协议。BGP用于连接Internet。作为最新的外部网关协议，现有四个版本。<br>在BGP网络中，可以将一个网络分成多个自治系统。自治系统间使用eBGP广播路由，自治系统内使用iBGP在自己的网络内广播路由。<br>BGP是<strong>路径向量型协议</strong> </p><p><strong>BGP特点</strong>：</p><ul><li>BGP是一种外部路由协议，与OSPF、RIP不同，其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最好的路由。 </li><li>BGP通过携带AS路径信息，可以彻底的解决路由循环问题。 </li><li>为了控制路由的传播和路由的选择，为路由附带属性信息。 </li><li>使用TCP作为其传输层协议，提高了协议的可靠性。端口号179。 </li><li>BGP-4支持CIDR（无类别域间选路），CIDR的引入简化了路由聚合，减化了路由表。 </li><li>BGP更新时只发送增量路由，减少了BGP传播路由占用的带宽。 </li><li>提供了丰富的路由策略。</li></ul><h2 id="三种协议的比较"><a href="#三种协议的比较" class="headerlink" title="三种协议的比较"></a>三种协议的比较</h2><p><img src="https://img-blog.csdn.net/20160517201340850" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IP协议相关技术</title>
      <link href="2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
      <url>2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS（域名解析协议）"><a href="#DNS（域名解析协议）" class="headerlink" title="DNS（域名解析协议）"></a>DNS（域名解析协议）</h2><p>TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序，但是IP地址不方便记忆，于是人们发明了一种叫主机名的东西，是一个字符串，并且使用hosts文件来描述主机名和IP地址的关系。</p><ul><li>DNS协议是将域名转换为IP地址（也可以将IP地址转换为为相应的域名地址）</li><li>DNS是应用层协议，它是一整套从域名到IP的系统。</li><li>DNS底层使用UDP进行解析；</li><li>浏览器会缓存DNS结果；</li></ul><p>我们都知道，TCP/IP中使用的是IP地址和端口号来确定网络上某一台主机上的某一个程序，那为什么不用域名来直接进行通信呢？</p><ol><li><p>因为IP地址是固定长度的，而域名是变长的，不便于计算机处理；</p></li><li><p>IP地址对于用户来说不方便记忆，但域名便于用户记忆；</p></li></ol><p>总结：IP地址是面向主机的，而域名是面向用户的；</p><blockquote><p><strong>hosts文件</strong><br>域名和IP的对应关系保存在一个叫hosts文件中；<br>最初，通过互联网信息中心来管理这个文件，如果有一个新的计算机想接入网络，或者某个计算机IP变更需要信息中心申请变更hosts文件，其他计算机也需要定期更新，才能上网。但是这样太麻烦了，就出现了DNS系统。</p></blockquote><p>域名解析过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210531211042.png" alt="这里写图片描述"></p><h2 id="ARP（地址解析协议）"><a href="#ARP（地址解析协议）" class="headerlink" title="ARP（地址解析协议）"></a>ARP（地址解析协议）</h2><p><strong>注意：ARP不是一个单纯的数据链路层协议，而是一个介于数据链路层和网路层之间的协议</strong></p><h3 id="ARP协议的概念："><a href="#ARP协议的概念：" class="headerlink" title="ARP协议的概念："></a>ARP协议的概念：</h3><blockquote><p>在以太网设备如网卡都有自己唯一的MAC地址，他们是以MAC地址传输以太网数据报的，但是他们却识别不了IP包中的IP地址，所以要在以太网进行IP通信的时候就需要一个协议来建立IP地址于MAC地址的对应关系，以使数据包能发到一个确定的地方去，这个协议就是ARP。</p><p>ARP协议是一种解决地址问题的协议，以目标IP地址为线索，用来定位下一个应该接受数据分用的网络设备对应的MAC地址。如果主机不在同一个链路上时，可以通过ARP查找吓一跳的MAC地址，不过ARP只适用于IPv4，不能用于IPv6。</p></blockquote><h3 id="ARP协议的作用："><a href="#ARP协议的作用：" class="headerlink" title="ARP协议的作用："></a>ARP协议的作用：</h3><p>ARP建立了主机IP地址和MAC地址的映射关系。</p><ul><li>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址；</li><li>数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃；</li><li>因此在通讯前必须获得目的主机的硬件地址；</li></ul><h3 id="ARP协议的工作流程："><a href="#ARP协议的工作流程：" class="headerlink" title="ARP协议的工作流程："></a>ARP协议的工作流程：</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210531210424.png" alt="img"> </p><ul><li>源主机发出ARP请求,询问“IP地址是192.168.0.1的主机的硬件地址是多少”, 并将这个请求广播到本地网段(以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播);</li><li>目的主机接收到广播的ARP请求,发现其中的IP地址与本机相符,则发送一个ARP应答数据包给源主机,将自己的硬件地址填写在应答包中;由此，可以通过ARP从IP地址获得MAC地址，实现链路的IP通信；</li><li>每台主机都维护一个ARP缓存表,可以用arp -a命令查看。缓存表中的表项有过期时间(一般为20分钟),如果20分钟内没有再次使用某个表项,则该表项失效,下次还要发ARP请求来获得目的主机的硬件地址</li></ul><h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>RARP是将ARP反过来，从MAC地址定位到IP地址的一种协议。假如将打印机服务器等小型嵌入式设备接入到网络时就会经常用到。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>架构IP网络时需要特别注意两点：确认网络是否正常工作，以及遇到异常时进行问题诊断。</p><p>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被丢弃的具体原因，改善网络设置等。有了这些功能之后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p><p>ICMP的这种通知消息会使用IP进行发送。ICMP的消息大致可以分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>如果逐一为每一台主机设置IP地址是非常繁琐的事情。特别是在移动使用电脑、智能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置IP地址。于是，为了实现自动设置IP地址、统一管理IP地址分配，就有了DHCP协议。有了DHCP，计算机只要能连接到网络，就可以进行TCP/IP通信，DHCP让即插即用变得可能。DHCP在IPv4、IPv6中都可以使用。</p>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP拥塞控制</title>
      <link href="2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。<strong>拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</strong></p><h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p>超时重传机制主要是为了解决数据包在传输过程中丢失的问题。</p><p>TCP每发送一个报文段，就会为这个报文段开启一个定时器，如果定时器溢出时仍然没有收到接收端的应答报文，那么TCP就认为这个报文段在传输过程中丢失，然后重新发送这个报文段。这便是超时重传机制</p><p>举例：客户端请求发送”and hi”报文段时启动了定时器，然而在规定的时间内没有收到对端的回复，所以重新发送”and hi”报文段，并重启定时器(重启的定时器时间会增大)。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>超时重传是为了解决数据丢失的问题，而数据丢失的原因很大程序上是由于传输路径拥塞导致的。</p><p>在正常的传输过程中，数据是从一个路由器跳到下一个路由器，每个路由器都有自己的缓冲区，新来的数据会存放在缓冲区中，与此同时路由器也在不断地将缓冲区中的数据发送给下一个路由器。但是如果某个路由器接收数据的速率大于发送数据的速率，就会导致缓冲区数据累积，最终填满缓冲区。此时如果再有数据到来，缓冲区已经无法容纳它们，只能将它们丢掉，造成数据丢失，这就是所谓的拥塞现象，本质就是传输路径上的节点不平衡。为了解决这一问题，就需要当出现拥塞现象时立即减少发送端发送的数据量，为路径上的某些节点提供清空缓冲区的时间，同时也避免了不必要的重传。</p><p>但是，发送端如何才能得知网络中发生了拥塞呢。因为由于硬件错误造成的数据丢失是很罕见的，所以发送端假定，<strong>如果出现了数据丢失，那么就可以认定发生了拥塞。</strong></p><p>发送方维持一个叫做<strong>拥塞窗口cwnd（congestion window）</strong>的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口小于拥塞窗口。</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p><p>这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。</p><p>如下图：<br><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210531203643.png" alt="img"></p><p>当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。</p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p><p>无论是在<strong>慢开始阶段</strong>还是在<strong>拥塞避免阶段</strong>，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p><p>如下图：<br><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210531203728.png" alt="img"></p><p><strong>再次提醒这里只是为了讨论方便而将拥塞窗口大小的单位改为数据报的个数，实际上应当是字节。</strong></p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的<strong>重传计时器时间</strong>到期。</p><p>如下图：<br><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210531203814.png" alt="img"></p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而<strong>执行快恢复算法</strong>；</p><ul><li><p><strong>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一般；开始执行拥塞避免算法</strong>。</p></li><li><p>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3。</p><blockquote><p>既然发送方收到3个重复的确认，就表明3个数据报文段已经离开了网络；这3个报文段不再消耗网络资源而是停留在接收方的接受缓存中；可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把拥塞窗口扩大些。</p></blockquote></li></ul><p>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210531204009.png" alt="在这里插入图片描述"></p><h2 id="与流量控制区别"><a href="#与流量控制区别" class="headerlink" title="与流量控制区别"></a>与流量控制区别</h2><p>TCP有一个叫做流量控制的机制，它与拥塞控制非常相似，但是仍然有一些差异</p><ul><li>流量控制是端对端的控制机制，两端各自通知对方允许的窗口大小以防止对端发送过多数据导致自己来不及处理造成接收缓冲区被填满</li><li>拥塞控制不是端对端的控制机制，它是为了缓解从一端到另一端这条路径上的拥堵问题</li></ul><p>不过二者都是通过限制发送方发送的数据包个数来解决问题，所以上述算法无非就是降低发送端发送速率，缓解网络压力。</p>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS安全认证流程</title>
      <link href="2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
      <url>2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>https是采用对称加密和非对称加密相结合的方式来进行安全认证的。对称加密用来加密所要发送的信息，非对称加密用来传输对称加密的秘钥算法等信息</p></blockquote><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>首先，服务器把他的公钥和个人信息用Hash算法生成一个消息摘要，这个Hash算法有个好的特点就是只要输入的数据有一点点变化，那么生成的消息摘要就会发生巨变。 这样就可以防止别人修改原始的内容。然后再将这个消息摘要通过认证中心(CA)的私钥进行加密，形成<strong>数字签名</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210515191042.png" alt="image-20210515191042198"></p><p>接着再把数字签名和原始信息(主机B得公钥和信息)合并 ，形成一个新的东西，叫做<strong>数字证书</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210515191135.png" alt="image-20210515191135320"></p><p>当服务器把这个数字证书发给客户端时，客户端用相同的Hash算法对原始信息生成消息摘要，再用CA的公钥对数字签名进行解密，得到CA创建消息摘要，然后进行对比，看有没有改变。如果一样，说明公钥没人改，也就是说此时的公钥就是服务器的公钥。</p><p>不过这样做的前提是得信任CA，这些CＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。你可以打开浏览器， 从设置中可以找到“受信任的根证书”。</p><h2 id="HTTPS-加密的过程"><a href="#HTTPS-加密的过程" class="headerlink" title="HTTPS 加密的过程"></a>HTTPS 加密的过程</h2><h3 id="将对称加密，非对称加密两者结合起来"><a href="#将对称加密，非对称加密两者结合起来" class="headerlink" title="将对称加密，非对称加密两者结合起来"></a>将对称加密，非对称加密两者结合起来</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210515191327.png" alt="img"></p><p>如上图所示</p><p>（1）第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器</p><p>（2）服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密</p><p>（3）后续两者之间信息的传输就可以使用对称加密的方式了</p><p>遇到的问题：</p><p>（1）客户端如何获得公钥</p><p>（2）如何确认服务器是真实的而不是黑客</p><h3 id="获取公钥与确认服务器身份"><a href="#获取公钥与确认服务器身份" class="headerlink" title="获取公钥与确认服务器身份"></a>获取公钥与确认服务器身份</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210515191648.png" alt="img"></p><p>1、获取公钥</p><p>（1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）</p><p>（2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）</p><p>2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？  那就需要用到终极武器了：SSL 证书</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210515191744.png" alt="img"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p><p>（1）证书的发布机构CA</p><p>（2）证书的有效期</p><p>（3）公钥</p><p>（4）证书所有者</p><p>（5）签名</p><p>3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 </p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出  颁发者CA  的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><p>4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成</p><p>  所以相比HTTP，HTTPS 传输更加安全</p><p>（1） 所有信息都是加密传播，黑客无法窃听。</p><p>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</p><p>（3） 配备身份证书，防止身份被冒充。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。</p><p><strong>HTTPS 缺点：</strong></p><p>（1）SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐</p><p>（2）HTTPS 降低用户访问速度（多次握手）</p><p>（3）网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转）</p><p>（4）HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP状态码</title>
      <link href="2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1、三至七种最基本的响应代码"><a href="#1、三至七种最基本的响应代码" class="headerlink" title="1、三至七种最基本的响应代码"></a>1、三至七种最基本的响应代码</h1><ul><li>200(“OK”)<br>一切正常。实体主体中的文档（若存在的话）是某资源的表示。</li><li>400(“Bad Request”)<br>客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。</li><li>500(“Internal Server Error”)<br>服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。</li><li>301(“Moved Permanently”)<br>当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。</li><li>404(“Not Found”) 和410(“Gone”)<br>当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。</li><li>409(“Conflict”)<br>当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。</li></ul><p>SOAP Web服务只使用响应代码200(“OK”)和500(“Internal Server Error”)。无论是你发给SOAP服务器的数据有问题，还是服务器在处理数据的过程中出现问题，或者SOAP服务器出现内部问题，SOAP服务器均发送500(“Internal Server Error”)。客户端只有查看SOAP文档主体（body）（其中包含错误的描述）才能获知错误原因。客户端无法仅靠读取响应的前三个字节得知请求成功与否。</p><h1 id="2、状态码系列。"><a href="#2、状态码系列。" class="headerlink" title="2、状态码系列。"></a>2、状态码系列。</h1><h2 id="1XX：通知"><a href="#1XX：通知" class="headerlink" title="1XX：通知"></a>1XX：通知</h2><p>1XX系列响应代码仅在与HTTP服务器沟通时使用。</p><ul><li>100(“Continue”)<br>重要程度：中等，但（写操作时）很少用。</li></ul><p>这是对HTTP LBYL（look-before-you-leap）请求的一个可能的响应。该响应代码表明：客户端应重新发送初始请求，并在请求中附上第一次请求时未提供的（可能很大或者包含敏感信息的）表示。客户端这次发送的请求不会被拒绝。对LBYL请求的另一个可能的响应是417(“Expectation Failed”)。</p><p>请求报头：要做一个LBYL请求，客户端必须把Expect请求报头设为字符串”100-continue”。除此以外，客户端还需要设置其他一些报头，服务器将根据这些报头决定是响应100还是417。</p><ul><li>101(“Switching Protocols”)<br>重要程度：非常低。</li></ul><p>当客户端通过在请求里使用Upgrade报头，以通知服务器它想改用除HTTP协议之外的其他协议时，客户端将获得此响应代码。101响应代码表示“行，我现在改用另一个协议了”。通常HTTP客户端会在收到服务器发来的101响应后关闭与服务器的TCP连接。101响应代码意味着，该客户端不再是一个HTTP客户端，而将成为另一种客户端。<br>尽管可以通过Upgrade报头从HTTP切换到HTTPS，或者从HTTP1.1切换到某个未来的版本，但实际使用Upgrade报头的情况比较少。Upgrade报头也可用于HTTP切换到一个完全不同的协议（如IRC）上，但那需要在Web服务器切换为一个IRC服务器的同时，Web客户端切换为一个IRC的客户端，因为服务器将立刻在同一个TCP连接上开始使用新的协议。</p><p>请求报头：客户端把Upgrade报头设置为一组希望使用的协议。<br>响应报头：如果服务器同意切换协议，它就返回一个Upgrade报头，说明它将切换到那个协议，并附上一个空白行。服务器不用关闭TCP链接，而是直接在该TCP连接上开始使用新的协议。</p><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX: 成功"></a>2XX: 成功</h2><p>2XX系列响应代码表明操作成功了。</p><ul><li><strong>200(“OK”)</strong><br>重要程度：非常高。</li></ul><p>一般来说，这是客户端希望看到的响应代码。它表示服务器成功执行了客户端所请求的动作，并且在2XX系列里没有其他更适合的响应代码了。</p><p>实体主体：对于GET请求，服务器应返回客户端所请求资源的一个表示。对于其他请求，服务器应返回当前所选资源的一个表示，或者刚刚执行的动作的一个描述。</p><ul><li><strong>201(“Created”)</strong><br>重要程度：高。</li></ul><p>当服务器依照客户端的请求创建了一个新资源时，发送此响应代码。</p><p>响应报头：Location报头应包含指向新创建资源的规范URI。<br>实体主体：应该给出新创建资源的描述与链接。若已经在Location报头里给出了新资源的URI，那么可以用新资源的一个表示作为实体主体。</p><ul><li>202(“Accepted”)<br>重要程度：中等。</li></ul><p>客户端的请求无法或将不被实时处理。请求稍后会被处理。请求看上去是合法的，但在实际处理它时有出现问题的可能。<br>若一个请求触发了一个异步操作，或者一个需要现实世界参与的动作，或者一个需要很长时间才能完成且没必要让Web客户端一直等待的动作时，这个相应代码是一个合适的选择。</p><p>响应报头：应该把未处理完的请求暴露为一个资源，以便客户端稍后查询其状态。Location报头可以包含指向该资源的URI。<br>实体主体：若无法让客户端稍后查询请求的状态，那么至少应该提供一个关于何时能处理该请求的估计。</p><ul><li>203(“Non-Authoritative Information”)<br>重要程度：非常低。</li></ul><p>这个响应代码跟200一样，只不过服务器想让客户端知道，有些响应报头并非来自该服务器–他们可能是从客户端先前发送的一个请求里复制的，或者从第三方得到的。</p><p>响应报头：客户端应明白某些报头可能是不准确的，某些响应报头可能不是服务器自己生成的，所以服务器也不知道其含义。</p><ul><li><strong>204(“No Content”)</strong><br>重要程度：高。</li></ul><p>若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，但其表示是空的”。注意与304(“Not Modified”)的区别。204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素。</p><p>实体主体：不允许。</p><ul><li>205(“Reset Content”)<br>重要程度：低。</li></ul><p>它与204类似，但与204不同的是，它表明客户端应重置数据源的视图或数据结构。假如你在浏览器里提交一个HTML表单，并得到响应代码204，那么表单里的各个字段值不变，可以继续修改它们；但假如得到的响应代码205，那么表单里的各个字段将被重置为它们的初始值。从数据录入方面讲：204适合对单条记录做一系列编辑，而205适于连续输入一组记录。</p><ul><li><strong>206(“Partial Content”)</strong><br>重要程度：对于支持部分GET（partial GET）的服务而言“非常高”，其他情况下“低”。</li></ul><p>它跟200类似，但它用于对部分GET请求（即使用Range请求报头的GET请求）的响应。部分GET请求常用于大型二进制文件的断点续传。</p><p>请求报头：客户端为Range请求报头设置一个值。<br>响应报头：需要提供Date报头。ETag报头与Content-Location报头的值应该跟正常GET请求相同。</p><p>若实体主体是单个字节范围（byte range），那么HTTP响应里必须包含一个Content-Range报头，以说明本响应返回的是表示的哪个部分，若实体主体是一个多部分实体（multipart entity）（即该实体主体由多个字节范围构成），那么每一个部分都要有自己的Content-Range报头。<br>实体主体：不是整个表示，而是一个或者多个字节范围。</p><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p>3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于GET请求。他们通常告诉客户端需要向另一个URI发送GET请求，才能得到所需的表示。那个URI就包含在Location响应报头里。</p><ul><li>300(“Multiple Choices”)<br>重要程度：低。</li></ul><p>若被请求的资源在服务器端存在多个表示，而服务器不知道客户端想要的是哪一个表示时，发送这个响应代码。或者当客户端没有使用Accept-*报头来指定一个表示，或者客户端所请求的表示不存在时，也发送这个响应代码。在这种情况下，一种选择是，服务器返回一个首选表示，并把响应代码设置为200，不过它也可以返回一个包含该资源各个表示的URI列表，并把响应代码设为300。</p><p>响应报头：如果服务器有首选表示，那么它可以在Location响应报头中给出这个首选表示的URI。跟其他3XX响应代码一样，客户端可以自动跟随Location中的URI。<br>实体主体：一个包含该资源各个表示的URI的列表。可以在表示中提供一些信息，以便用户作出选择。</p><ul><li><strong>301(“Moved Permanently”)</strong><br>重要程度：中等。</li></ul><p>服务器知道客户端试图访问的是哪个资源，但它不喜欢客户端用当前URI来请求该资源。它希望客户端记住另一个URI，并在今后的请求中使用那个新的URI。你可以通过这个响应代码来防止由于URI变更而导致老URI失效。</p><p>响应报头：服务器应当把规范URI放在Location响应报头里。<br>实体主体：服务器可以发送一个包含新URI的信息，不过这不是必需的。</p><ul><li><strong>302(“Found”)</strong><br>重要程度：应该了解，特别市编写客户端时。但我不推荐使用它。</li></ul><p>这个响应代码市造成大多数重定向方面的混乱的最根本原因。它应该是像307那样被处理。实际上，在HTTP 1.0中，响应代码302的名称是”Moved Temporarily”，不幸的是，在实际生活中，绝大多数客户端拿它像303一样处理。它的不同之处在于当服务器为客户端的PUT，POST或者DELETE请求返回302响应代码时，客户端要怎么做。<br>为了消除这一混淆，在HTTP 1.1中，该响应代码被重命名为”Found”，并新加了一个响应代码307。这个响应代码目前仍在广泛使用，但它的含义市混淆的，所以我建议你的服务发送307或者303，而不要发送302.除非你知道正在与一个不能理解303或307的HTTP 1.0客户端交互。</p><p>响应报头：把客户端应重新请求的那个URI放在Location报头里。<br>实体主体：一个包含指向新URI的链接的超文本文档（就像301一样）。</p><ul><li><strong>303(“See Other”)</strong><br>重要程度：高。</li></ul><p>请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的URI。该响应文档可能是一个静态的状态信息，也可能是一个更有趣的资源。对于后一种情况，303是一种令服务器可以“发送一个资源的表示，而不强迫客户端下载其所有数据”的方式。客户端可以向Location报头里的URI发送GET请求，但它不是必须这么做。<br>303响应代码是一种规范化资源URI的好办法。一个资源可以有多个URIs，但每个资源的规范URI只有一个，该资源的所有其他URIs都通过303指向该资源的规范URI，例如：303可以把一个对<a href="http://www.example.com/software/current.tar.gz%E7%9A%84%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0http://www.example.com/software/1.0.2.tar.gz%E3%80%82">http://www.example.com/software/current.tar.gz的请求重定向到http://www.example.com/software/1.0.2.tar.gz。</a></p><p>响应报头：Location报头里包含资源的URI。<br>实体主体：一个包含指向新URI的链接的超文本文档。</p><ul><li><strong>304(“Not Modified”)</strong><br>重要程度：高。</li></ul><p>这个响应代码跟204(“No Content”)类似：响应实体主体都必须为空。但204用于没有主体数据的情况，而304用于有主体数据，但客户端已拥有该数据，没必要重复发送的情况。这个响应代码可用于条件HTTP请求（conditional HTTP request).如果客户端在发送GET请求时附上了一个值为Sunday的If-Modified-Since报头，而客户端所请求的表示在服务器端自星期日（Sunday）以来一直没有改变过，那么服务器可以返回一个304响应。服务器也可以返回一个200响应，但由于客户端已拥有该表示，因此重复发送该表示只会白白浪费宽带。</p><p>响应报头：需要提供Date报头。Etag与Content-Location报头的值，应该跟返回200响应时的一样。若Expires, Cache-Control及Vary报头的值自上次发送以来已经改变，那么就要提供这些报头。<br>实体主体：不允许。</p><ul><li>305(“Use Proxy”)<br>重要程度：低。</li></ul><p>这个响应代码用于告诉客户端它需要再发一次请求，但这次要通过一个HTTP代理发送，而不是直接发送给服务器。这个响应代码使用的不多，因为服务器很少在意客户端是否使用某一特定代理。这个代码主要用于基于代理的镜像站点。现在，镜像站点（如<a href="http://www.example.com.mysite.com/%EF%BC%89%E5%8C%85%E5%90%AB%E8%B7%9F%E5%8E%9F%E5%A7%8B%E7%AB%99%E7%82%B9%EF%BC%88%E5%A6%82">http://www.example.com.mysite.com/）包含跟原始站点（如</a> <a href="http://www.example.com/%EF%BC%89%E4%B8%80%E6%A0%B7%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BD%86%E5%85%B7%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84URI%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%AB%99%E7%82%B9%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87307%E6%8A%8A%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E6%96%B0%E5%AE%9A%E5%90%91%E5%88%B0%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9%E4%B8%8A%E3%80%82%E5%81%87%E5%A6%82%E6%9C%89%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8A%8A">http://www.example.com/）一样的内容，但具有不同的URI，原始站点可以通过307把客户端重新定向到镜像站点上。假如有基于代理的镜像站点，那么你可以通过把</a> <a href="http://proxy.mysite.com/%E8%AE%BE%E4%B8%BA%E4%BB%A3%E7%90%86%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B7%9F%E5%8E%9F%E5%A7%8BURI%EF%BC%88http://www.example.com/%EF%BC%89%E4%B8%80%E6%A0%B7%E7%9A%84URI%E6%9D%A5%E8%AE%BF%E9%97%AE%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9%E3%80%82%E8%BF%99%E9%87%8C%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%AB%99%E7%82%B9example.com%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87305%E6%8A%8A%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%88%B0%E4%B8%80%E4%B8%AA%E5%9C%B0%E7%90%86%E4%B8%8A%E6%8E%A5%E8%BF%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%E3%80%82web%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E8%88%AC%E4%B8%8D%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%99%E6%98%AF%E5%AF%BC%E8%87%B4305%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81%E7%94%A8%E7%9A%84%E4%B8%8D%E5%A4%9A%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9B%A0%E3%80%82">http://proxy.mysite.com/设为代理，使用跟原始URI（http://www.example.com/）一样的URI来访问镜像站点。这里，原始站点example.com可以通过305把客户端路由到一个地理上接近客户端的镜像代理。web浏览器一般不能正确处理这个响应代码，这是导致305响应代码用的不多的另一个原因。</a></p><p>响应报头：Location报头里包含代理的URI。</p><ul><li>306 未使用<br>重要程度：无</li></ul><p>306 响应代码没有在HTTP标准中定义过。</p><ul><li><strong>307(“Temporary Redirect”)</strong><br>重要程度：高。</li></ul><p>请求还没有被处理，因为所请求的资源不在本地：它在另一个URI处。客户端应该向那个URI重新发送请求。就GET请求来说，它只是请求得到一个表示，该响应代码跟303没有区别。当服务器希望把客户端重新定向到一个镜像站点时，可以用307来响应GET请求。但对于POST，PUT及DELETE请求，它们希望服务器执行一些操作，307和303有显著区别。对POST，PUT或者DELETE请求响应303表明：操作已经成功执行，但响应实体将不随本响应一起返回，若客户端想要获取响应实体主体，它需要向另一个URI发送GET请求。而307表明：服务器尚未执行操作，客户端需要向Location报头里的那个URI重新提交整个请求。</p><p>响应报头： 把客户端应重新请求的那个URI放在Location报头里。<br>实体主体：一个包含指向新URI的链接的超文本文档。</p><h2 id="4XX：客户端错误"><a href="#4XX：客户端错误" class="headerlink" title="4XX：客户端错误"></a>4XX：客户端错误</h2><p>这些响应代码表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。</p><ul><li><strong>400(“Bad Request”)</strong><br>重要程度：高。</li></ul><p>这是一个通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400。此响应代码通常用于“服务器收到客户端通过PUT或者POST请求提交的表示，表示的格式正确，但服务器不懂它什么意思”的情况。</p><p>实体主体：可以包含一个错误的描述文档。</p><ul><li><strong>401(“Unauthorized”)</strong><br>重要程度：高。</li></ul><p>客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，也可以市一个API key，或者一个认证令牌。客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式。如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证–这将导致HTTP摘要认证无法工作。</p><p>响应报头：WWW-Authenticate报头描述服务器将接受哪种认证。<br>实体主体：一个错误的描述文档。假如最终用户可通过“在网站上注册”的方式得到证书，那么应提供一个指向该注册页面的链接。</p><ul><li>402(“Payment Required”)<br>重要程度：无。</li></ul><p>除了它的名字外，HTTP标准没有对该响应的其他方面作任何定义。因为目前还没有用于HTTP的微支付系统，所以它被留作将来使用。尽管如此，若存在一个用于HTTP的微支付系统，那么这些系统将首先出现在web服务领域。如果想按请求向用户收费，而且你与用户之间的关系允许这么做的话，那么或许用得上这个响应代码。<br>注：该书印于2008年</p><ul><li><strong>403(“Forbidden”)</strong><br>重要程度：中等。</li></ul><p>客户端请求的结构正确，但是服务器不想处理它。这跟证书不正确的情况不同–若证书不正确，应该发送响应代码401。该响应代码常用于一个资源只允许在特定时间段内访问，<br>或者允许特定IP地址的用户访问的情况。403暗示了所请求的资源确实存在。跟401一样，若服务器不想透露此信息，它可以谎报一个404。既然客户端请求的结构正确，那为什么还要把本响应代码放在4XX系列（客户端错误），而不是5XX系列（服务端错误）呢？因为服务器不是根据请求的结构，而是根据请求的其他方面（比如说发出请求的时间）作出的决定的。</p><p>实体主体：一个描述拒绝原因的文档（可选）。</p><ul><li><strong>404(“Not Found”)</strong><br>重要程度：高。</li></ul><p>这也许是最广为人知的HTTP响应代码了。404表明服务器无法把客户端请求的URI转换为一个资源。相比之下，410更有用一些。web服务可以通过404响应告诉客户端所请求的URI是空的，然后客户端就可以通过向该URI发送PUT请求来创建一个新资源了。但是404也有可能是用来掩饰403或者401.</p><ul><li>405(“Method Not Allowd”)<br>重要程度：中等。</li></ul><p>客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问。</p><p>响应报头：Allow报头列出本资源支持哪些HTTP方法，例如：Allow：GET，POST</p><ul><li>406(“Not Acceptable”)<br>重要程度：中等。</li></ul><p>当客户端对表示有太多要求，以至于服务器无法提供满足要求的表示，服务器可以发送这个响应代码。例如：客户端通过Accept头指定媒体类型为application/json+hic，但是服务器只支持application/json。服务器的另一个选择是：忽略客户端挑剔的要求，返回首选表示，并把响应代码设为200。</p><p>实体主体：一个可选表示的链接列表。</p><ul><li>407(“Proxy Authentication Required”)<br>重要程度：低。</li></ul><p>只有HTTP代理会发送这个响应代码。它跟401类似，唯一区别在于：这里不是无权访问web服务，而是无权访问代理。跟401一样，可能是因为客户端没有提供证书，也可能是客户端提供的证书不正确或不充分。</p><p>请求报头：客户端通过使用Proxy-Authorization报头（而不是Authorization）把证书提供给代理。格式跟Authrization一样。<br>响应报头：代理通过Proxy-Authenticate报头（而不是WWW-Authenticate）告诉客户端它接受哪种认证。格式跟WWW-Authenticate一样。</p><ul><li>408(“Reqeust Timeout”)<br>重要程度：低。</li></ul><p>假如HTTP客户端与服务器建立链接后，却不发送任何请求（或从不发送表明请求结束的空白行），那么服务器最终应该发送一个408响应代码，并关闭此连接。</p><ul><li><strong>409(“Conflict”)</strong><br>重要程度：高。</li></ul><p>此响应代码表明：你请求的操作会导致服务器的资源处于一种不可能或不一致的状态。例如你试图修改某个用户的用户名，而修改后的用户名与其他存在的用户名冲突了。</p><p>响应报头：若冲突是因为某个其他资源的存在而引起的，那么应该在Location报头里给出那个资源的URI。<br>实体主体：一个描述冲突的文档，以便客户端可以解决冲突。</p><ul><li>410(“Gone”)<br>重要程度：中等。</li></ul><p>这个响应代码跟404类似，但它提供的有用信息更多一些。这个响应代码用于服务器知道被请求的URI过去曾指向一个资源，但该资源现在不存在了的情况。服务器不知道<br>该资源的新URI，服务器要是知道该URI的话，它就发送响应代码301.410和310一样，都有暗示客户端不应该再请求该URI的意思，不同之处在于：410只是指出该资源不存在，但没有给出该资源的新URI。RFC2616建议“为短期的推广服务，以及属于个人但不继续在服务端运行的资源”采用410.</p><ul><li>411(“Length Required”)<br>重要程度：低到中等。</li></ul><p>若HTTP请求包含表示，它应该把Content-Length请求报头的值设为该表示的长度（以字节为单位）。对客户端而言，有时这不太方便（例如，当表示是来自其他来源的字节流时）。<br>所以HTTP并不要求客户端在每个请求中都提供Content-Length报头。但HTTP服务器可以要求客户端必须设置该报头。服务器可以中断任何没有提供Content-Length报头的请求，并要求客户端重新提交包含Content-Length报头的请求。这个响应代码就是用于中断未提供Content-Lenght报头的请求的。假如客户端提供错误的长度，或发送超过长度的表示，服务器可以中断请求并关闭链接，并返回响应代码413。</p><ul><li>412(“Precondition Failed”)<br>重要程度：中等。</li></ul><p>客户端在请求报头里指定一些前提条件，并要求服务器只有在满足一定条件的情况下才能处理本请求。若服务器不满足这些条件，就返回此响应代码。If-Unmodified-Since是一个常见的前提条件。客户端可以通过PUT请求来修改一个资源，但它要求，仅在自客户端最后一次获取该资源后该资源未被别人修改过才能执行修改操作。若没有这一前提条件，客户端可能会无意识地覆盖别人做的修改，或者导致409的产生。</p><p>请求报头：若客户但设置了If-Match，If-None-Match或If-Unmodified-Since报头，那就有可能得到这个响应代码。If-None-Match稍微特别一些。若客户端在发送GET或HEAD请求时指定了If-None-Match，并且服务器不满足该前提条件的话，那么响应代码不是412而是304，这是实现条件HTTP GET的基础。若客户端在发送PUT，POST或DELETE请求时指定了If-None-Match,并且服务器不满足该前提条件的话，那么响应代码是412.另外，若客户端指定了If-Match或If-Unmodified-Since(无论采用什么HTTP方法)，而服务器不满足该前提条件的话，响应代码也是412。</p><ul><li>413(“Request Entity Too Large”)<br>重要程度：低到中等。</li></ul><p>这个响应代码跟411类似，服务器可以用它来中断客户端的请求并关闭连接，而不需要等待请求完成。411用于客户端未指定长度的情况，而413用于客户端发送的表示太大，以至于服务器无法处理。客户端可以先做一个LBYL（look-before-you-leap）请求，以免请求被413中断。若LBYL请求获得响应代码为100，客户端再提交完整的表示。</p><p>响应报头：如果因为服务器方面临时遇到问题（比如资源不足），而不是因为客户端方面的问题而导致中断请求的话，服务器可以把Retry-After报头的值设为一个日期或一个间隔时间，以秒为单位，以便客户端可以过段时间重试。</p><ul><li>414(“Request-URI Too Long”)<br>重要程度：低。</li></ul><p>HTTP标准并没有对URI长度作出官方限制，但大部分现有的web服务器都对URI长度有一个上限，而web服务可能也一样。导致URI超长的最常见的原因是：表示数据明明是该放在实体主体里的，但客户端却把它放在了URI里。深度嵌套的数据结构也有可能引起URI过长。</p><ul><li>415(“Unsupported Media Type”)<br>重要程度：中等。</li></ul><p>当客户端在发送表示时采用了一种服务器无法理解的媒体类型，服务器发送此响应代码。比如说，服务器期望的是XML格式，而客户端发送的确实JSON格式。<br>如果客户端采用的媒体类型正确，但格式有问题，这时最好返回更通用的400。</p><ul><li>416(“Requestd Range Not Satisfiable”)<br>重要程度：低。</li></ul><p>当客户端所请求的字节范围超出表示的实际大小时，服务器发送此响应代码。例如：你请求一个表示的1-100字节，但该表示总共只用99字节大小。</p><p>请求报头：仅当原始请求里包含Range报头时，才有可能收到此响应代码。若原始请求提供的是If-Range报头，则不会收到此响应代码。<br>响应报头：服务器应当通过Content-Range报头告诉客户端表示的实际大小。</p><ul><li>417(“Expectation Failed”)<br>重要程度：中等。</li></ul><p>此响应代码跟100正好相反。当你用LBYL请求来考察服务器是否会接受你的表示时，如果服务器确认会接受你的表示，那么你将获得响应代码100，否则你将获得417。</p><h2 id="5XX-服务端错误"><a href="#5XX-服务端错误" class="headerlink" title="5XX 服务端错误"></a>5XX 服务端错误</h2><p>这些响应代码表明服务器端出现错误。一般来说，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。有时，服务器能够估计客户端应在多久之后重试。并把该信息放在Retry-After响应报头里。</p><p>5XX系列响应代码在数量上不如4XX系列多，这不是因为服务器错误的几率小，而是因为没有必要如此详细–对于服务器方面的问题，客户端是无能为力的。</p><ul><li><strong>500(“Internal Server Error”)</strong><br>重要程度：高。</li></ul><p>这是一个通用的服务器错误响应。对于大多数web框架，如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。</p><ul><li>501(“Not Implemented”)<br>重要程度：低。</li></ul><p>客户端试图使用一个服务器不支持的HTTP特性。<br>最常见的例子是：客户端试图做一个采用了拓展HTTP方法的请求，而普通web服务器不支持此请求。它跟响应代码405比较相似，405表明客户端所用的方法是一个可识别的方法，但该资源不支持，而501表明服务器根本不能识别该方法。</p><ul><li>502(“Bad Gateway”)<br>重要程度：低。</li></ul><p>只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。若代理根本无法访问上行服务器，响应代码将是504。</p><ul><li><strong>503(“Service Unavailable”)</strong><br>重要程度：中等到高。</li></ul><p>此响应代码表明HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。由于此问题多半由客户端反复发送请求造成，因此HTTP服务器可以选择拒绝接受客户端请求而不是接受它，并发送503响应代码。</p><p>响应报头：服务器可以通过Retry-After报头告知客户端何时可以重试。</p><ul><li>504(“Gateway Timeout”)<br>重要程度：低。</li></ul><p>跟502类似，只有HTTP代理会发送此响应代码。此响应代码表明代理无法连接上行服务器。</p><ul><li>505(“HTTP Version Not Supported”)<br>重要程度： 非常低。</li></ul><p>当服务器不支持客户端试图使用的HTTP版本时发送此响应代码。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven生命周期</title>
      <link href="2021/05/13/Maven/Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/05/13/Maven/Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven-构建生命周期"><a href="#Maven-构建生命周期" class="headerlink" title="Maven 构建生命周期"></a>Maven 构建生命周期</h2><p>Maven 构建生命周期就是 Maven 将一个整体任务划分为一个个的阶段，类似于流程图，按顺序依次执行。也可以指定该任务执行到中间的某个阶段结束。<br> Maven 的内部有三个构建生命周期，分别是 clean, default, site。其中 default 生命周期的核心阶段如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210513145457.png" alt="image-20210513145457707"></p><h2 id="如何使用构建生命周期来完成构建工作"><a href="#如何使用构建生命周期来完成构建工作" class="headerlink" title="如何使用构建生命周期来完成构建工作"></a>如何使用构建生命周期来完成构建工作</h2><ul><li>可以指定某个生命周期的阶段</li></ul><p>执行 mvn install 命令，将完成 validate, compile, test, package, verify, install 阶段，并将 package 生成的包发布到本地仓库中。其中某些带有连字符的阶段不能通过 shell 命令单独指定。例如：(pre-<em>, post-</em>, or process-*)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><ul><li>可以指定多个不同构建生命周期的阶段</li></ul><p>执行 mvn clean deploy 命令，首先完成的 clean lifecycle，将以前构建的文件清理，然后再执行 default lifecycle 的 validate, compile, test, package, verify, insstall, deploy 阶段，将 package 阶段创建的包发布到远程仓库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></table></figure><h2 id="阶段与插件的关系"><a href="#阶段与插件的关系" class="headerlink" title="阶段与插件的关系"></a>阶段与插件的关系</h2><p>如上所述，Maven 将构建过程定义为 default lifecycle，并将 default lifecycle 划分为一个个的阶段 phase，这一系列 phase 仅仅是规定执行顺序，至于每个阶段做什么工作？由谁来做？答案就在 插件（plugins） 中。<br> Maven 对工程的所有操作实实在在的都是由 插件 来完成的。一个插件可以支持多种功能，称之为目标（goal），例如：compiler 插件有两个目标：compile 和 testCompile，分别实现编译源代码 和 编译测试代码。<br> 如何将插件与 Maven 的构建生命周期绑定在一起呢？通过将插件的目标（goal）与 build lifecycle 中 phase 绑定到一起，这样，当要执行某个 phase 时，就调用插件来完成绑定的目标。<br> 如下图所示：从图中可以看出，每一个阶段可以绑定0 个 或 多个目标，每个插件可以提供 1 个或多个目标。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210513145523.png" alt="image-20210513145523689"></p><h2 id="如何为自己的工程创建构建生命周期"><a href="#如何为自己的工程创建构建生命周期" class="headerlink" title="如何为自己的工程创建构建生命周期"></a>如何为自己的工程创建构建生命周期</h2><ul><li>设置不同的 packaging 类型</li></ul><p>在 pom.xml 文件中，packaging 类型支持 jar, war, ear, pom 等多种类型，不同的 packaging 类型会使得不同的 phase 绑定不同的 plugin goal。下面是 packaging 类型为 jar 时，phase 与 plugin goal 的映射关系。</p><table><thead><tr><th>阶段</th><th>目标</th></tr></thead><tbody><tr><td>process-resources</td><td>resources:resources</td></tr><tr><td>compile</td><td>compiler:compile</td></tr><tr><td>process-test-resources</td><td>resources:testResources</td></tr><tr><td>test-compile</td><td>compiler:testCompile</td></tr><tr><td>test</td><td>surefire:test</td></tr><tr><td>package</td><td>jar:jar</td></tr><tr><td>install</td><td>install:install</td></tr><tr><td>deploy</td><td>deploy:deploy</td></tr></tbody></table><ul><li>配置 plugin</li></ul><p>在 pom.xml 文件中， <build> <plugins> 元素下可以添加 <plugin>，通过指定 goal 和 phase 来进行绑定。<br> 例如：将插件 modello-maven-plugin 的 java 目标绑定到 generate-sources 阶段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.modello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>modello-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">models</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">model</span>&gt;</span>src/main/mdo/maven.mdo<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">models</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>java<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="我没有在-pom-xml-指定任何-plugin，但是也能正常构建工程"><a href="#我没有在-pom-xml-指定任何-plugin，但是也能正常构建工程" class="headerlink" title="我没有在 pom.xml 指定任何 plugin，但是也能正常构建工程"></a>我没有在 pom.xml 指定任何 plugin，但是也能正常构建工程</h2><p>你可以能会疑问，默认的 pom.xml 文件并没有配置各种 plugin，但是也能正常构建工程？答案是 Maven 自己默认指定了 plugin。<br> 下面是一个没有配置任何 plugin 的 pom.xml，执行 mvn install 的输出日志，从日志中可以看到 一系列的 插件(plugin):版本号:目标(phase)，例如: maven-resources-plugin:2.6:resources (default-resources)，maven-compiler-plugin:3.1:compile (default-compile) ，maven-resources-plugin:2.6:testResources (default-testResources)，maven-compiler-plugin:3.1:testCompile (default-testCompile)，maven-surefire-plugin:2.12.4:test (default-test)，maven-jar-plugin:2.4:jar (default-jar) ，maven-install-plugin:2.4:install (default-install)，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="meta">INFO</span>] Building my-app <span class="number">1.0</span>-SNAPSHOT</span><br><span class="line">[<span class="meta">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-resources-plugin:<span class="number">2.6</span>:resources (<span class="literal">default</span>-resources) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Using <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="meta">INFO</span>] Copying <span class="number">1</span> resource</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-compiler-plugin:<span class="number">3.1</span>:compile (<span class="literal">default</span>-compile) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="meta">INFO</span>] Compiling <span class="number">1</span> source file to /Users/zhangguanghui/git/my-app/target/classes</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-resources-plugin:<span class="number">2.6</span>:testResources (<span class="literal">default</span>-testResources) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Using <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="meta">INFO</span>] skip non existing resourceDirectory /Users/zhangguanghui/git/my-app/src/test/resources</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-compiler-plugin:<span class="number">3.1</span>:testCompile (<span class="literal">default</span>-testCompile) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="meta">INFO</span>] Compiling <span class="number">1</span> source file to /Users/zhangguanghui/git/my-app/target/test-classes</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-surefire-plugin:<span class="number">2.12</span><span class="number">.4</span>:test (<span class="literal">default</span>-test) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Surefire report directory: /Users/zhangguanghui/git/my-app/target/surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.mycompany.app.AppTest</span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span>, Time elapsed: <span class="number">0.004</span> sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-jar-plugin:<span class="number">2.4</span>:jar (<span class="literal">default</span>-jar) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Building jar: /Users/zhangguanghui/git/my-app/target/my-app<span class="number">-1.0</span>-SNAPSHOT.jar</span><br><span class="line">[<span class="meta">INFO</span>]</span><br><span class="line">[<span class="meta">INFO</span>] --- maven-install-plugin:<span class="number">2.4</span>:install (<span class="literal">default</span>-install) @ my-app ---</span><br><span class="line">[<span class="meta">INFO</span>] Installing /Users/zhangguanghui/git/my-app/target/my-app<span class="number">-1.0</span>-SNAPSHOT.jar to /Users/zhangguanghui/.m2/repository/com/mycompany/app/my-app/<span class="number">1.0</span>-SNAPSHOT/my-app<span class="number">-1.0</span>-SNAPSHOT.jar</span><br><span class="line">[<span class="meta">INFO</span>] Installing /Users/zhangguanghui/git/my-app/pom.xml to /Users/zhangguanghui/.m2/repository/com/mycompany/app/my-app/<span class="number">1.0</span>-SNAPSHOT/my-app<span class="number">-1.0</span>-SNAPSHOT.pom</span><br><span class="line">[<span class="meta">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="meta">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="meta">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="meta">INFO</span>] Total time: <span class="number">1.726</span> s</span><br><span class="line">[<span class="meta">INFO</span>] Finished at: <span class="number">2016</span><span class="number">-11</span><span class="number">-20</span>T00:<span class="number">41</span>:<span class="number">11</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="meta">INFO</span>] Final Memory: <span class="number">15</span>M/<span class="number">310</span>M</span><br><span class="line">[<span class="meta">INFO</span>] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="完整的-clean-default-site-build-lifecycle"><a href="#完整的-clean-default-site-build-lifecycle" class="headerlink" title="完整的 clean, default, site build lifecycle"></a>完整的 clean, default, site build lifecycle</h2><ul><li>clean lifecycle</li></ul><table><thead><tr><th>phase</th><th>function</th></tr></thead><tbody><tr><td>pre-clean  execute</td><td>execute processes needed prior to the actual project cleaning</td></tr><tr><td>clean</td><td>remove all files generated by the previous build</td></tr><tr><td>post-clean</td><td>execute processes needed to finalize the project cleaning</td></tr></tbody></table><ul><li>default lifecycle</li></ul><table><thead><tr><th>phase</th><th>function</th></tr></thead><tbody><tr><td>validate</td><td>validate the project is correct and all necessary information is available.</td></tr><tr><td>initialize</td><td>initialize build state, e.g. set properties or create directories.</td></tr><tr><td>generate-sources</td><td>generate any source code for inclusion in compilation.</td></tr><tr><td>process-sources</td><td>process the source code, for example to filter any values.</td></tr><tr><td>generate-resources</td><td>generate resources for inclusion in the package.</td></tr><tr><td>process-resources</td><td>copy and process the resources into the destination directory, ready for packaging.</td></tr><tr><td>compile</td><td>compile the source code of the project.</td></tr><tr><td>process-classes</td><td>post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.</td></tr><tr><td>generate-test-sources</td><td>generate any test source code for inclusion in compilation.</td></tr><tr><td>process-test-sources</td><td>process the test source code, for example to filter any values.</td></tr><tr><td>generate-test-resources</td><td>create resources for testing.</td></tr><tr><td>process-test-resources</td><td>copy and process the resources into the test destination directory.</td></tr><tr><td>test-compile</td><td>compile the test source code into the test destination directory</td></tr><tr><td>process-test-classes</td><td>post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.</td></tr><tr><td>test</td><td>run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.</td></tr><tr><td>prepare-package</td><td>perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above)</td></tr><tr><td>package</td><td>take the compiled code and package it in its distributable format, such as a JAR.</td></tr><tr><td>pre-integration-test   perform</td><td>actions required before integration tests are executed. This may involve things such as setting up the required environment.</td></tr><tr><td>integration-test</td><td>process and deploy the package if necessary into an environment where integration tests can be run.</td></tr><tr><td>post-integration-test</td><td>perform actions required after integration tests have been executed. This may including cleaning up the environment.</td></tr><tr><td>verify</td><td>run any checks to verify the package is valid and meets quality criteria.</td></tr><tr><td>install</td><td>install the package into the local repository, for use as a dependency in other projects locally.</td></tr><tr><td>deploy</td><td>done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.</td></tr></tbody></table><ul><li>site lifecycle</li></ul><table><thead><tr><th>phase</th><th>function</th></tr></thead><tbody><tr><td>pre-site</td><td>execute processes needed prior to the actual project site generation</td></tr><tr><td>site</td><td>generate the project’s site documentation</td></tr><tr><td>post-site</td><td>execute processes needed to finalize the site generation, and to prepare for site deployment</td></tr><tr><td>site-deploy</td><td>deploy the generated site documentation to the specified web server</td></tr></tbody></table><p>作者：data4<br>链接：<a href="https://www.jianshu.com/p/fd43b3d0fdb0">https://www.jianshu.com/p/fd43b3d0fdb0</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 《Maven实战》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven依赖</title>
      <link href="2021/05/12/Maven/Maven%E4%BE%9D%E8%B5%96/"/>
      <url>2021/05/12/Maven/Maven%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>　　maven 的所有构件均通过坐标进行组织和管理。maven 的坐标通过 5 个元素进行定义，其中 groupId、artifactId、version 是必须的，packaging 是可选的（默认为jar），classifier 是不能直接定义的。</p><ul><li><strong>groupId</strong>：定义当前 Maven 项目所属的实际项目，跟 Java 包名类似，通常与域名反向一一对应。</li><li><strong>artifactId</strong>：定义当前 Maven 项目的一个模块，默认情况下，Maven 生成的构件，其文件名会以 artifactId 开头，如 hibernate-core-3.6.5.Final.jar。</li><li><strong>version</strong>：定义项目版本。</li><li><strong>packaging</strong>：定义项目打包方式，如 jar，war，pom，zip ……，默认为 jar。</li><li><strong>classifier</strong>：定义项目的附属构件，如 hibernate-core-3.6.6.Final-sources.jar，hibernate-core-3.6.6.Final-javadoc.jar，其中 sources 和 javadoc 就是这两个附属构件的 classifier。classifier 不能直接定义，通常由附加的插件帮助生成。</li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>　　使用 Maven 可以方便的管理依赖，如下是一段在 pom.xml 文件中声明依赖的代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">optional</span>&gt;</span>false<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>type：依赖类型，对应构件中定义的 packaging，可不声明，默认为 jar；</li><li>scope：依赖范围；</li><li>optional：依赖是否可选；</li><li>exclusions：排除传递依赖。</li></ul><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>　　执行不同的 Maven 命令（mvn package，mvn test，mvn install ……），会使用不同的 classpath，Maven 对应的有三套 classpath：编译classpath、测试classpath，运行classpath。scope 选项的值，决定了该依赖构件会被引入到哪一个 classpath 中。</p><ul><li>compile：编译依赖范围，默认值。此选项对编译、测试、运行三种 classpath 都有效，如 hibernate-core-3.6.5.Final.jar，表明在编译、测试、运行的时候都需要该依赖；</li><li>test：测试依赖范围。只对测试有效，表明只在测试的时候需要，在编译和运行时将无法使用该类依赖，如 junit；</li><li>provided：已提供依赖范围。编译和测试有效，运行无效。如 servlet-api ，在项目运行时，tomcat 等容器已经提供，无需 Maven 重复引入；</li><li>runtime：运行时依赖范围。测试和运行有效，编译无效。如 jdbc 驱动实现，编译时只需接口，测试或运行时才需要具体的 jdbc 驱动实现；</li><li>system：系统依赖范围。和 provided 依赖范围一致，需要通过 <systemPath> 显示指定，且可以引用环境变量；</li><li>import：导入依赖范围。使用该选项，通常需要 <type>pom</type>，将目标 pom 的 dependencyManagement 配置导入合并到当前 pom 的  dependencyManagement 元素。</li></ul><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210512104156.png" alt="img"></p><p>　　如上图所示，hibernate-core 依赖 hibernate-commons-annotations ，而 hibernate-commons-annotations 又依赖 slf4j-api ，hibernate-core 对 slf4j-api 的依赖就是传递依赖。我们只需要引入 hibernate-core 构件的依赖，不用考虑它还有其它的依赖， 也不用担心会引入多余或冲突的依赖，Maven 会自动为我们引入依赖及传递依赖。</p><h3 id="依赖传递和依赖范围"><a href="#依赖传递和依赖范围" class="headerlink" title="依赖传递和依赖范围"></a>依赖传递和依赖范围</h3><p>　　如上图 2.2 所示，几种依赖关系分别叫做第一直接依赖、第二直接依赖和传递性依赖，其中第一直接依赖和第二直接依赖的依赖范围，决定了传递性依赖的依赖范围。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210512104209.png" alt="img"></p><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p>　　通常我们不需要关心传递性依赖，当多个传递性依赖中有对同一构件不同版本的依赖时，如何解决呢？</p><p>有两个原则：</p><ul><li>短路径优先：假如有以下依赖：A -&gt; B -&gt; C -&gt;X(版本 1.0) 和 A -&gt; D -&gt; X(版本 2.0)，则优先解析较短路径的 X(版本 2.0)；</li><li>先声明优先：若路径长度相同，则谁先声明，谁被解析。</li></ul><h3 id="依赖排除"><a href="#依赖排除" class="headerlink" title="依赖排除"></a>依赖排除</h3><p>　　针对依赖冲突中的“短路径优先”，如果我们想使用长路径的依赖怎么办呢？这时可以使用依赖排除 <code>&lt;exclusions&gt;</code> 元素，显示排除短路径依赖。在非冲突的情况下，这种方法同样有效。</p><h3 id="依赖归类"><a href="#依赖归类" class="headerlink" title="依赖归类"></a>依赖归类</h3><p>　　通常在项目中，我们会同时依赖同一个构件的不同模块，如 spring-orm-3.2.0，spring-context-3.2.0，且多个模块版本相同，为了维护和升级方便，我们可以对其同一管理，这时可以使用到 Maven 属性，类似于变量的概念。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>3.2.0.RELEASE<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="优化依赖"><a href="#优化依赖" class="headerlink" title="优化依赖"></a>优化依赖</h3><ol><li><p>显示项目中已解析依赖，每个依赖的范围：</p><p><code>mvn dependency:list</code></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210512105241.png" alt="image-20210512105241079"></p></li><li><p>显示项目的依赖树，通过这棵树可以看到某个依赖是通过哪条传递路径引入的，方便依赖的版本的管理： </p><p><code>mvn dependency:tree</code></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210512105220.png" alt="image-20210512105220865"></p></li><li><p>分析当前项目的依赖，主要找寻一些编译过程中主代码和测试代码用不到的依赖：</p><p><code>mvn dependency:analyze</code></p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210512105649.png" alt="image-20210512105649377" style="zoom:67%;" /><p><strong>注意：</strong></p><p>Used undeclared dependencies：项目中使用到，但是没有显式声明的依赖，此时要显示声明任何项目中直接用到的依赖</p><p>Unused declared dependencies：项目中未使用的，但显式声明的依赖，这里需要仔细分析，<strong>上面的命令只会扫描编译过程中主代码和测试代码用到的依赖</strong>，对于一些执行测试和运行时需要的依赖发现不了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 《Maven实战》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8与并发</title>
      <link href="2021/05/11/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/java8%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
      <url>2021/05/11/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/java8%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="读写锁的改进：stampedlock"><a href="#读写锁的改进：stampedlock" class="headerlink" title="读写锁的改进：stampedlock"></a>读写锁的改进：stampedlock</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>StampedLock是Java8引入的一种新的所机制,简单的理解,可以认为它是读写锁的一个改进版本,读写锁虽然分离了读和写的功能,使得读与读之间可以完全并发,但是读和写之间依然是冲突的,读锁会完全阻塞写锁,它使用的依然是悲观的锁策略.如果有大量的读线程,他也有可能引起写线程的饥饿。</p><p>而StampedLock则提供了一种乐观的读策略,这种乐观策略的锁非常类似于无锁的操作,使得乐观锁完全不会阻塞写线程</p><h3 id="StampedLock的使用实例"><a href="#StampedLock的使用实例" class="headerlink" title="StampedLock的使用实例"></a>StampedLock的使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x, y;<span class="comment">//内部定义表示坐标点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock s1 = <span class="keyword">new</span> StampedLock();<span class="comment">//定义了StampedLock锁,</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = s1.writeLock();<span class="comment">//这里的含义和distanceFormOrigin方法中 s1.readLock()是类似的</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            s1.unlockWrite(stamp);<span class="comment">//退出临界区,释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFormOrigin</span><span class="params">()</span> </span>&#123;<span class="comment">//只读方法</span></span><br><span class="line">        <span class="keyword">long</span> stamp = s1.tryOptimisticRead();  <span class="comment">//试图尝试一次乐观读 返回一个类似于时间戳的邮戳整数stamp 这个stamp就可以作为这一个所获取的凭证</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x, currentY = y;<span class="comment">//读取x和y的值,这时候我们并不确定x和y是否是一致的</span></span><br><span class="line">        <span class="keyword">if</span> (!s1.validate(stamp)) &#123;<span class="comment">//判断这个stamp是否在读过程发生期间被修改过,如果stamp没有被修改过,则认为这次读取时有效的,因此就可以直接return了,反之,如果stamp是不可用的,则意味着在读取的过程中,可能被其他线程改写了数据,因此,有可能出现脏读,如果如果出现这种情况,我们可以像CAS操作那样在一个死循环中一直使用乐观锁,知道成功为止</span></span><br><span class="line">            stamp = s1.readLock();<span class="comment">//也可以升级锁的级别,这里我们升级乐观锁的级别,将乐观锁变为悲观锁, 如果当前对象正在被修改,则读锁的申请可能导致线程挂起.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                s1.unlockRead(stamp);<span class="comment">//退出临界区,释放读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StampedLock的小陷阱"><a href="#StampedLock的小陷阱" class="headerlink" title="StampedLock的小陷阱"></a>StampedLock的小陷阱</h3><p>StampedLock内部实现时，使用类似于CAS操作的死循环反复尝试的策略。在它挂起线程时，使用的是Unsafe.park()函数，而park()函数在遇到线程中断时，会直接返回（不同于Thread.sleep()，它不会抛出异常）。而在StampedLock的死循环逻辑中，没有处理有关中断的逻辑。因此，这就会导致阻塞在park()上的线程被中断后，会再次进入循环。而当退出条件得不到满足时，就会发生疯狂占用CPU的情况。下面演示了这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockCUPDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread[] holdCpuThreads = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">long</span> readLong = lock.writeLock();</span><br><span class="line">                LockSupport.parkNanos(<span class="number">6100000000L</span>);</span><br><span class="line">                lock.unlockWrite(readLong);</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;.start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            holdCpuThreads [i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldCPUReadThread());</span><br><span class="line">            holdCpuThreads [i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">            holdCpuThreads [i].interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCPUReadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lockr = lock.readLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get read lock&quot;</span>);</span><br><span class="line">        lock.unlockRead(lockr);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，首先开启线程占用写锁（第7行），为了演示效果，这里使用写线程不释放锁而一直等待。</p><p>接着，开启3个读线程，让它们请求读锁。此时，由于写锁的存在，所有读线程都会被最终挂起。读线程因为park()的操作进入了等待状态，这种情况是正常的。</p><p>而在10秒钟以后（代码在17行执行了10秒等待），系统中断了这3个读线程，之后，就会发现，CPU占用率极有可能会飙升。这是因为中断导致park()函数返回，使线程再次进入运行状态。</p><p>此时，这个线程的状态是RUNNABLE，这是我们不愿意看到的，它会一直存在并耗尽CPU资源，直到自己抢占到了锁。</p><p><strong>【重要】所以使用StampedLock一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁<code>readLockInterruptibly()</code>和写锁<code>writeLockInterruptibly()</code>！</strong></p><h3 id="有关StampedLock的实现思想"><a href="#有关StampedLock的实现思想" class="headerlink" title="有关StampedLock的实现思想"></a>有关StampedLock的实现思想</h3><p>StampedLock的内部实现是基于CLH锁的,CLH锁是一种自旋锁,它保证没有饥饿的发生,并且可以保证FIFO(先进先出)的服务顺序.</p><p>CLH锁的基本思想如下:锁维护一个等待线程队列,所有申请锁,但是没有成功的线程都记录在这个队列中,每一个节点代表一个线程,保存一个标记位(locked).用与判断当前线程是否已经释放锁;locked=true 没有获取到锁,false 已经成功释放了锁</p><p>当一个线程视图获得锁时,取得等待队列的尾部节点作为其前序节点.并使用类似如下代码判断前序节点是否已经成功释放锁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要前序节点(pred)没有释放锁,则表示当前线程还不能继续执行,因此会自旋等待,</p><p>反之,如果前序线程已经释放锁,则当前线程可以继续执行.</p><p>释放锁时,也遵循这个逻辑,线程会将自身节点的locked位置标记位false,那么后续等待的线程就能继续执行了</p><h2 id="原子类的增强"><a href="#原子类的增强" class="headerlink" title="原子类的增强"></a>原子类的增强</h2><p>无锁的原子类操作使用系统的CAS指令，有着远远超越锁的性能。在Java 8中引入了LongAddr类，这个类也在java.util.concurrent.atomic包下，因此，它也是使用了CAS指令。</p><h3 id="更快的原子类：LongAddr"><a href="#更快的原子类：LongAddr" class="headerlink" title="更快的原子类：LongAddr"></a>更快的原子类：LongAddr</h3><h4 id="数据分离（减小锁粒度）"><a href="#数据分离（减小锁粒度）" class="headerlink" title="数据分离（减小锁粒度）"></a>数据分离（减小锁粒度）</h4><p> AtomicInteger的基本实现机制，它们都是在一个死循环内，不断尝试修改目标值，知道修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的概率就很高。在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能会受到影响。</p><p>当竞争激烈的时候，为了进一步提高系统的性能，一种基本方案就是可以使用热点分离，将竞争的数据进行分解，基于这个思路，可以想到一种对传统AtomicInteger等原子类的改进方法。虽然在CAS操作中没有锁，但是像减小锁粒度这种分离热点的思想依然可以使用。一种可行的方案就是仿造ConcurrentHashMap，将热点数据分离。比如，可以将AtomicInteger的内部核心数据value分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计算，而最终的计算结果，则为这个数组的求和累加。热点value被分离成多个单元cell，每个cell独自维护内部的值，当前对象的实际值由所有的cell累计合成，这样，热点就进行了有效的分离，提高了并行度。LongAddr正是使用了这种思想。</p><p>在实际的操作中，LongAddr并不会一开始就动用数组进行处理，而是将所有数据都先记录在一个称为base的变量中。如果在多线程条件下，大家修改base都没有冲突，那么也没有必要扩展为cell数组。但是，一旦base修改发生冲突，就会初始化cell数组，使用新的策略。如果使用cell数组更新后，发现在某一个cell上的更新依然发生冲突，那么系统就会尝试创建新的cell，或者将cell的数量加倍，以减少冲突的可能。</p><p> 下面简单分析一下increment()方法（该方法会将LongAddr自增1）的内部实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="comment">//如果cell表为null，会尝试将x累加到base上。  </span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果cell表不为null或者尝试将x累加到base上失败，执行以下操作。</span></span><br><span class="line"><span class="comment">             * 如果cell表不为null且通过当前线程的probe值定位到的cell表中的Cell不为null。</span></span><br><span class="line"><span class="comment">             * 那么尝试累加x到对应的Cell上。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                    (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                    !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                <span class="comment">//或者cell表为null，或者定位到的cell为null，或者尝试失败，都会调用下面的Striped64中定义的longAccumulate方法。  </span></span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>它的核心是addd()方法。最开始cells为null，因此数据会向base增加。但是如果对base的操作冲突，则会设置冲突标记uncontended 为true。接着，如果判断cells数组不可用，或者当前线程对应的cell为null，则直接进入longAccumulate()方法。否则会尝试使用CAS方法更新对应的cell数据，如果成功，则退出，失败则进入longAccumulate()方法。</p><p>由于longAccumulate()方法比较复杂，这里不再展开讨论，其大致内容是，根据需要创建新的cell或者对cell数组进行扩容，以减少冲突。</p><h4 id="避免缓存伪共享"><a href="#避免缓存伪共享" class="headerlink" title="避免缓存伪共享"></a>避免缓存伪共享</h4><p>LongAddr的另外一个优化手段是避免了伪共存。LongAddr中并不是直接使用padding这种看起来比较碍眼的做法，而是引入了一种新的注释“@sun.misc.Contended“。</p><p>对于LongAddr中的每一个Cell，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value=x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在上述代码第1行申明了Cell类为sun.misc.Contended。这将会使得Java虚拟机自动为Cell解决伪共享问题。</p><p>当然，在我们自己的代码中也可以使用sun.misc.Contended来解决伪共享问题，但是需要额外使用虚拟机参数-XX:-RestrictContended，否则，这个注释将被忽略。</p><h3 id="LongAddr的功能增强版-LongAccumulator"><a href="#LongAddr的功能增强版-LongAccumulator" class="headerlink" title="LongAddr的功能增强版: LongAccumulator"></a>LongAddr的功能增强版: LongAccumulator</h3><p>LongAccumulator是LongAddr的亲兄弟，它们有公共的父类Striped64。因此，LongAccumulator内部的优化方式和LongAddr是一样的。它们都将一个long型整数进行分割，存储在不同的变量中，以防止多线程竞争。两者的主要逻辑类似，但是LongAccumulator是LongAddr的功能扩展，对于LongAddr来说，它只是每次对给定的整数执行一次加法，而LongAccumulator则可以实现任意函数惭怍。</p><p>可以使用下面的构造函数创建一个LongAccumulator实例：</p><p><code>public LongAccumulator(LongBinaryOperator accumulatorFunction, long identify)</code></p><p>第一个参数accumulatorFunction就是需要执行的二元函数（接收两个long形参数并返回long），第2个参数是初始值。</p><p>下面这个例子展示了LongAccurator的使用，它将通过多线程访问若干个整数，并返回遇到的最大的那个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(Long::max, Long.MIN_VALUE);</span><br><span class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        ts[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">long</span> value = random.nextLong();</span><br><span class="line">            accumulator.accumulate(value);</span><br><span class="line">        &#125;);</span><br><span class="line">       ts[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        ts[<span class="number">1000</span>].join();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(accumulator .longValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，构造了LongAccumulator实例。因为要过滤最大值，因此传入Long::max函数句柄。当有数据通过accumulate()方法传入LongAccumulator后，LongAccumulator会通过Long::max识别最大值并且保存在内部（很可能是cell数组，也可能是base）。通过longValue()函数对所有的cell进行Long::max操作，得到最大值。</p><h2 id="ConcurrentHashMap的增强"><a href="#ConcurrentHashMap的增强" class="headerlink" title="ConcurrentHashMap的增强"></a>ConcurrentHashMap的增强</h2><h4 id="批量处理数据"><a href="#批量处理数据" class="headerlink" title="批量处理数据"></a>批量处理数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java8为并发哈希映射提供了批量操作数据操作，即使在其他线程同时操作映射时也可以安全的执行。</span></span><br><span class="line"><span class="comment"> * 批量数据操作会遍历映射并对匹配的元素进行操作。在批量操作过程中，不需要冻结映射的一个快照。除非你恰好知道在这段时间</span></span><br><span class="line"><span class="comment"> * 内映射没有被修改，否则你应该将结果看作是映射状态的一个近似值。批量操作有三类</span></span><br><span class="line"><span class="comment"> * a,search会对每个键或值应用一个函数，直到函数返回一个null的结果。然后search会终止并返回该函数的结果。</span></span><br><span class="line"><span class="comment"> * b,reduce会通过提供的积累函数，将所有的键或指结合起来。</span></span><br><span class="line"><span class="comment"> * c,forEach会对所有键或值对应一个函数。</span></span><br><span class="line"><span class="comment"> * 使用这几种操作时，需要指定一个并行阈值，如果映射包含的元素数目超过了这个阈值，批量操作以并行的方式执行。如果希望批量操作数           据在一个线程执行，</span></span><br><span class="line"><span class="comment"> * 请使用Long.MAX_VALUE作为阈值。如果希望批量操作尽可能使用更多的线程，则应该使用1作为阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * search</span></span><br><span class="line"><span class="comment"> * 比如希望找到第一个出现超过1000次的的单词，我们需要搜索键和值。 返回结果为第一个匹配的元素，或者没有找到任何元素则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ConcurrentHashMap&lt;String, Long&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">map.merge(<span class="string">&quot;a&quot;</span>, <span class="number">2L</span>, Long::sum);<span class="comment">//2000</span></span><br><span class="line">map.merge(<span class="string">&quot;b&quot;</span>, <span class="number">1L</span>, Long::sum);<span class="comment">//1000</span></span><br><span class="line">&#125;</span><br><span class="line">String rs = map.search(<span class="number">1</span>, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k : <span class="keyword">null</span>);</span><br><span class="line">System.out.println(rs);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * foreach</span></span><br><span class="line"><span class="comment"> * foreach方法有两种，第一种只是对每个映射数据项简单的用一个消费者函数</span></span><br><span class="line"><span class="comment"> * 第二种是额外接受一个转换器函数，首先会应用此转换器函数，然后再将结果传递给消费者函数、</span></span><br><span class="line"><span class="comment"> * 转换器函数可以被用作一个过滤器。当转换器函数返回null时，值会被自动跳过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">map.forEach(<span class="number">1</span>, (k, v) -&gt; System.out.println(k + <span class="string">&quot;-&gt;&quot;</span> + v));</span><br><span class="line">map.forEach(<span class="number">1</span>, (k, v) -&gt; k + <span class="string">&quot;-&gt;&quot;</span> + v, System.out::println);</span><br><span class="line">map.forEach(<span class="number">1</span>, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k + <span class="string">&quot;-&gt;&quot;</span> + v : <span class="keyword">null</span>, System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * reduce</span></span><br><span class="line"><span class="comment"> * reduce操作将其输入与一个累加函数结合起来。例如下面是计算所有值的总和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Long sum = map.reduceValues(<span class="number">1</span>, Long::sum);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同forEach一样，你也可以提供一个转换器函数。比如计算长度最长的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Integer maxLength = map.reduceKeys(<span class="number">1</span>, </span><br><span class="line">String::length, <span class="comment">//转换器</span></span><br><span class="line">Integer::max);<span class="comment">//累加器</span></span><br><span class="line">System.out.println(maxLength);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 转换器函数可以作为一个过滤器，通过返回null来排除不想要的输入。</span></span><br><span class="line"><span class="comment"> * tips:如果映射是空的，或者所有的数据项都被过滤掉了，则reduce操作会返回null。如果只有一个元素，</span></span><br><span class="line"><span class="comment"> * 那么会返回它转换后的值，并且不会应用累加函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Long count = map.reduceValues(<span class="number">1</span>, </span><br><span class="line">v-&gt;v&gt;<span class="number">1000</span>?<span class="number">1L</span>:<span class="keyword">null</span>, <span class="comment">//转换器</span></span><br><span class="line">Long::sum);<span class="comment">//累加器</span></span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于int,long,double类型的输出，reduce操作提供了专门的方法，分别以ToInt,ToLong和ToDouble结尾。</span></span><br><span class="line"><span class="comment"> * 你需要将输入转换为原始类型值，并指定一个默认值和累加器函数。当映射为空时返回默认值。</span></span><br><span class="line"><span class="comment"> * tips:这几个专门的方法与用于对象的方法行为不同，它们只会考虑一个元素。与返回转换后的元素不同</span></span><br><span class="line"><span class="comment"> * ，他们会对默认值进行累加，因此。默认值必须是累加器的中立元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> sum2 = map.reduceValuesToLong(<span class="number">1</span>, </span><br><span class="line">Long::longValue, <span class="comment">//转换为原始类型</span></span><br><span class="line"><span class="number">0</span>, <span class="comment">//空映射的默认值 </span></span><br><span class="line">Long::sum);<span class="comment">//原始类型累加器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computeIfabsent"><a href="#computeIfabsent" class="headerlink" title="computeIfabsent"></a>computeIfabsent</h4><p>可以将原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">Client esClient = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (esClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//防止启动时高并发导致创建多个client,但会极大地降低方法的性能</span></span><br><span class="line">    <span class="keyword">synchronized</span> (ClientUtil.class) &#123;</span><br><span class="line">        esClient = map.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (esClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化操作</span></span><br><span class="line">            esClient = <span class="keyword">new</span> Client();</span><br><span class="line">          map.put(<span class="string">&quot;key&quot;</span>, esClient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用computeIfAbsent 代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">map.computeIfAbsent(<span class="string">&quot;key&quot;</span>,()-&gt;&#123;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Client();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="其他新方法"><a href="#其他新方法" class="headerlink" title="其他新方法"></a>其他新方法</h4><ol><li><p>mappingCount() 方法</p><p>返回Map中的条目综述。有别于size() 方法， 该方法返回的是long型数据。硬刺， 当元素总数超过整数最大值时，应该使用这个方法。同时，该方法并不返回精确值，如果在执行该方法时， 同时存在并发的插入或者删除操作，则结果是不准确的。</p></li><li><p>newKeySet() 方法</p><p>在JDK中， Set的实现依附于Map，实际上，Set时Map的一种特殊情况。如果需要一个线程安全的搞笑并发HashSet，那么基于ConcurrentHashMap的实现是最好的选择。该方法是一个静态工厂方法，返回一个线程安全的Set。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java函数式接口</title>
      <link href="2021/05/11/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>2021/05/11/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="函数式接口是什么"><a href="#函数式接口是什么" class="headerlink" title="函数式接口是什么"></a>函数式接口是什么</h3><p>有且只有一个抽象方法的接口被称为函数式接口（注意，任何被java.lang.Object实现的方法都不能视为抽象方法，例如 equals 和 toString方法），函数式接口适用于函数式编程的场景，Lambda就是Java中函数式编程的体现，可以使用Lambda表达式创建一个函数式接口的对象，一定要确保接口中有且只有一个抽象方法，这样Lambda才能顺利的进行推导。</p><h3 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h3><p>与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface 。该注解可用于一个接口的定义上,一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。但是这个注解不是必须的，只要符合函数式接口的定义，那么这个接口就是函数式接口。（但从代码编写规范考虑，最好加上该注解）</p><h3 id="static方法和default方法"><a href="#static方法和default方法" class="headerlink" title="static方法和default方法"></a>static方法和default方法</h3><p><strong>static方法：</strong></p><p>java8中为接口新增了一项功能，定义一个或者多个静态方法。用法和普通的static方法一样,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:实现接口的类或者子接口不会继承接口中的静态方法。</p><p><strong>default方法：</strong></p><p>java8在接口中新增default方法，是为了在现有的类库中中新增功能而不影响他们的实现类，试想一下，如果不增加默认实现的话，接口的所有实现类都要实现一遍这个方法，这会出现兼容性问题，如果定义了默认实现的话，那么实现类直接调用就可以了，并不需要实现这个方法。default方法怎么定义？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * default方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意：如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。不用加default关键字，</code>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImpl</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello default 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数式接口的定义中是只允许有一个抽象方法，但是可以有多个static方法和default方法。</p><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobFuntion</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Characteristic</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//jdk8之前</span></span><br><span class="line">        testJobFunction(<span class="keyword">new</span> JobFuntion() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是自定义函数接口&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//使用lambada表达式 代码更简洁</span></span><br><span class="line">        testJobFunction(() -&gt; System.out.println(<span class="string">&quot;我是自定义函数接口&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testJobFunction</span><span class="params">(JobFuntion jobFuntion)</span> </span>&#123;</span><br><span class="line">        jobFuntion.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java8中内置的四大核心函数式接口"><a href="#java8中内置的四大核心函数式接口" class="headerlink" title="java8中内置的四大核心函数式接口"></a>java8中内置的四大核心函数式接口</h2><h3 id="Consumer：消费型接口"><a href="#Consumer：消费型接口" class="headerlink" title="Consumer：消费型接口"></a>Consumer<T>：消费型接口</h3><p><code>void accept(T t)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Consumer&lt;T&gt; 消费型接口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">       con.accept(money);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Supplier：供给型接口"><a href="#Supplier：供给型接口" class="headerlink" title="Supplier：供给型接口"></a>Supplier<T>：供给型接口</h3><p><code>T get();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Supplier&lt;T&gt; 供给型接口</span></span><br><span class="line">    <span class="comment">//需求：产生一些整数，并放入集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            Integer n = sup.get();</span><br><span class="line">            list.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numList = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer num : numList)&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Function-lt-T-R-gt-：函数型接口"><a href="#Function-lt-T-R-gt-：函数型接口" class="headerlink" title="Function&lt;T, R&gt;：函数型接口"></a>Function&lt;T, R&gt;：函数型接口</h3><p><code>R apply(T t);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function&lt;T, R&gt; 函数型接口</span></span><br><span class="line">    <span class="comment">//需求：用于处理字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String, String&gt; fun)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String newStr = strHandler(<span class="string">&quot;\t\t\t e路纵横开发团队&quot;</span>, (str) -&gt; str.trim());</span><br><span class="line">        System.out.println(newStr);</span><br><span class="line"></span><br><span class="line">        String subStr = strHandler(<span class="string">&quot;e路纵横开发团队&quot;</span>, (str) -&gt; str.substring(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println(subStr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate：断言型接口"><a href="#Predicate：断言型接口" class="headerlink" title="Predicate：断言型接口"></a>Predicate<T>：断言型接口</h3><p><code>boolean test(T t);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Predicate&lt;T&gt; 断言型接口</span></span><br><span class="line">    <span class="comment">//需求：将满足条件的字符串，放入集合中去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : list)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.test(str))&#123;</span><br><span class="line">                strList.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;e路纵横&quot;</span>, <span class="string">&quot;Lambda&quot;</span>, <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strList)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发算法</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E7%AE%97%E6%B3%95/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="并行流水线"><a href="#并行流水线" class="headerlink" title="并行流水线"></a>并行流水线</h2><p>现在要生产一批小玩偶.小玩偶的制作分为四个步骤:</p><p>1.组装身体;2.在身体上安装四肢和头部;3.给组装完成的玩偶穿上一件漂亮的衣服;4.包装出 货。</p><p>为了加快制作进度,我们不可能叫四个人同时加工一个玩具,因为这四个步骤有着严 重的依赖关系。如果没有身体,就没有地方安装四肢;如果没有组装完成,就不能穿衣服; 如果没有穿上衣服,就不能包装发货。因此,找四个人来做一个玩偶是毫无意义的。</p><p>但是,如果你现在要制作的不是1个玩偶,而是1万个玩偶,那情况就不同了。你可以找四个人,第一个人只负责组装身体,完成后交给第二个人;第二个人只负责安装头部 和四肢,完成后交付第三人;第三人只负责穿衣服,完成后交付第四人:第四人只负责包 装发货。</p><p>这样所有人都可以一起工作,共同完成任务,而整个时间周期也能缩短到原来的 14左右,这就是流水线的思想。一旦流水线满载,每次只需要一步(假设一个玩偶需要四 步)就可以产生一个玩偶</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510202240.png" alt="clipboard.png"></p><p>在多核或者分布式场景中,这种设计思路可以有效地将有依赖关系的操作分配在不同的线程中进行计算,尽可能利用多核优势.</p><p><strong>示例：</strong></p><p>P1:A＝B+C     P2:D＝A×B    P3:D=D/2 。上述步骤中的P1、P2和P3均在单独的线程中计算，并且每个线程只负责自己的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信息载体</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> j;</span><br><span class="line">    <span class="keyword">public</span> String orgStr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p1加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingDeque&lt;Msg&gt; blockingDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Msg msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = blockingDeque.take();</span><br><span class="line">                msg.i = msg.j + msg.i;</span><br><span class="line">                Multiply.blockingDeque.add(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p2乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingDeque&lt;Msg&gt; blockingDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Msg msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = blockingDeque.take();</span><br><span class="line">                msg.i = msg.j * msg.i;</span><br><span class="line">                Div.blockingDeque.add(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p3除法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Div</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingDeque&lt;Msg&gt; blockingDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Msg msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = blockingDeque.take();</span><br><span class="line">                msg.i = msg.i / <span class="number">2</span>;</span><br><span class="line">                System.out.println(msg.orgStr + <span class="string">&quot;=&quot;</span> + msg.i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PStreamMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Plus()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Multiply()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Div()).start();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">                msg.i = i;</span><br><span class="line">                msg.j = j;</span><br><span class="line">                msg.orgStr = <span class="string">&quot;((&quot;</span> + i + <span class="string">&quot;+&quot;</span> + j + <span class="string">&quot;)*&quot;</span> + i + <span class="string">&quot;)/2&quot;</span>;</span><br><span class="line">                Plus.blockingDeque.add(msg);    <span class="comment">// 开启流水线的计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并性搜索"><a href="#并性搜索" class="headerlink" title="并性搜索"></a>并性搜索</h2><blockquote><p>就是将数据分段进行检索；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适用场景:有很多系统变量需要查询,或者查询redis这样数据量大得list</span></span><br><span class="line"><span class="comment"> * web适用场景比较少,但是作为平台软件是很常用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义我们需要查询的无序数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">344</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">//定义线程池数据,已经存放结果的Result</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService pool= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> thread_num=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger result=<span class="keyword">new</span> AtomicInteger(-<span class="number">1</span>);<span class="comment">//初始值定位-1</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> searchValue ,<span class="keyword">int</span> beginPos,<span class="keyword">int</span> endPos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = beginPos; j &lt;endPos ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.get()&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> result.get();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (arr[j]==searchValue)&#123;</span><br><span class="line">                <span class="comment">//如果设置失败,表示其他现场已经先找到了</span></span><br><span class="line">                <span class="keyword">if</span> (!result.compareAndSet(-<span class="number">1</span>,j))&#123;</span><br><span class="line">                    <span class="comment">//如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。</span></span><br><span class="line">                    <span class="comment">//-1当前值为-1就返回</span></span><br><span class="line">                    <span class="keyword">return</span> result.get();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin,end,searchValue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SearchTask</span><span class="params">(<span class="keyword">int</span> searchValue,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin=begin;</span><br><span class="line">            <span class="keyword">this</span>.end=end;</span><br><span class="line">            <span class="keyword">this</span>.searchValue=searchValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> re=search(searchValue,begin,end);</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">psearch</span><span class="params">(<span class="keyword">int</span> searchValue)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> subArrSize=arr.length/thread_num+<span class="number">1</span>;</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; re=<span class="keyword">new</span> ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i+=subArrSize) &#123;</span><br><span class="line">            <span class="keyword">int</span> end=i+subArrSize;</span><br><span class="line">            <span class="keyword">if</span> (end&gt;=arr.length) end=arr.length;</span><br><span class="line">            re.add(pool.submit(<span class="keyword">new</span> SearchTask(searchValue,i,end)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; fu:</span><br><span class="line">             re) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fu.get()&gt;=<span class="number">0</span>) <span class="keyword">return</span> (fu.get());</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(psearch(<span class="number">9</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><h3 id="奇偶交换排序"><a href="#奇偶交换排序" class="headerlink" title="奇偶交换排序"></a>奇偶交换排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奇偶交换排序</span></span><br><span class="line"><span class="comment"> * 奇交换：比较奇数索引以及其相邻的后续元素。</span></span><br><span class="line"><span class="comment"> * 偶交换：比较偶数索引和其相邻的后续元素。</span></span><br><span class="line"><span class="comment"> * 两种交换成对出现，保证比较和交换涉及到数组中的每一个元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年1月4日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddEvenSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr= &#123;<span class="number">25</span>,<span class="number">48</span>,<span class="number">65</span>,<span class="number">87</span>,<span class="number">123</span>,<span class="number">233</span>,<span class="number">456</span>,<span class="number">666</span>,<span class="number">777</span>,<span class="number">8999</span>,<span class="number">55555</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> exchFlag = <span class="number">1</span>;<span class="comment">//记录当前迭代是否发生了数据交换</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getExchFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exchFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setExchFlag</span><span class="params">(<span class="keyword">int</span> exchFlag)</span> </span>&#123;</span><br><span class="line">        OddEvenSort.exchFlag = exchFlag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pOddEvenSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">//记录交换类型。0为偶交换，1为奇交换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果上次比较发生了数据交换，或者当前正在进行奇交换，循环不会停止；</span></span><br><span class="line">        <span class="comment">//直到程序不再发生交换，或者当前进行的是偶交换，即奇偶交换已经成对出现。</span></span><br><span class="line">        <span class="keyword">while</span>(getExchFlag() == <span class="number">1</span> || start ==<span class="number">1</span>) &#123;</span><br><span class="line">            setExchFlag(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//偶数的数值长度，当start=1时，只有len/2-1个线程。倒计时线程数。</span></span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(arr.length/<span class="number">2</span> -(arr.length%<span class="number">2</span> == <span class="number">0</span> ? start :<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =start; i &lt; arr.length-<span class="number">1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                pool.submit(<span class="keyword">new</span> OddEvenSortTask(i,latch));</span><br><span class="line">            &#125;</span><br><span class="line">            latch.await();<span class="comment">//等待所有线程结束</span></span><br><span class="line">            start = start ==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OddEvenSortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OddEvenSortTask</span><span class="params">(<span class="keyword">int</span> i, CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i]   = arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i+<span class="number">1</span>] = temp;</span><br><span class="line">                setExchFlag(<span class="number">1</span>); <span class="comment">//数据进行了交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();<span class="comment">//结束当前线程的任务，倒计时器-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        pOddEvenSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并行情况下的希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSortS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arr= &#123;<span class="number">25</span>,<span class="number">48</span>,<span class="number">65</span>,<span class="number">87</span>,<span class="number">123</span>,<span class="number">233</span>,<span class="number">456</span>,<span class="number">666</span>,<span class="number">777</span>,<span class="number">8999</span>,<span class="number">55555</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ShellSortTask</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> h, CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i-h]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j    = i - h;</span><br><span class="line">                <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                    arr[j+h] = arr[j];</span><br><span class="line">                    j -= h;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pShellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>( h &lt;= arr.length/<span class="number">3</span>) &#123;</span><br><span class="line">            h = h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h &gt;= <span class="number">4</span>)</span><br><span class="line">                latch = <span class="keyword">new</span> CountDownLatch(arr.length - h);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(h &gt;= <span class="number">4</span>) &#123;                                              <span class="comment">// h大于4时使用并行线程</span></span><br><span class="line">                    pool.execute(<span class="keyword">new</span> ShellSortTask(i, h, latch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;                                                   <span class="comment">// h小于4时退化为传统的插入排序</span></span><br><span class="line">                    <span class="keyword">if</span>(arr[i] &lt; arr[i-h]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                        <span class="keyword">int</span> j = i -h;</span><br><span class="line">                        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                            arr[j+h] = arr[j];</span><br><span class="line">                            j -= h;</span><br><span class="line">                        &#125;</span><br><span class="line">                        arr[j+h] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.await();</span><br><span class="line">            h = (h-<span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        pShellSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i : arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 并发算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发之设计模式</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>定义</strong>: 一个类在系统中只产生一个实例 </p><p><strong>优点</strong>: 对于频繁使用的对象,可以省略new的时间,对于重量级对象来说是一比客观的系统性能提升 内存使用频率低,减少GC次数,缩短GC停顿时间</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式 </span></span><br><span class="line"><span class="comment">//优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</span></span><br><span class="line"><span class="comment">//缺点：在类加载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATUS=<span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;Singleton is create&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 懒汉式 </span></span><br><span class="line"><span class="comment">// 优点：起到了Lazy Loading的效果</span></span><br><span class="line"><span class="comment">// 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;LazySingleton is create&quot;</span>); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态内部类式，集合上述两种优势</span></span><br><span class="line"><span class="comment">// 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，而类的静态属性只会在第一次加载类的时候初始化，从而完成Singleton的实例化。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATUS;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;StaticSingleton is create&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意:另外还有一种双重检查模式来创建单例,这种模式丑陋且复杂,甚至在低版本中不能保证正确性,不推荐使用</span></span><br></pre></td></tr></table></figure><h1 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h1><p><strong>定义</strong>: 一个对象一旦被创建,内部状态永远不发生改变,故永远为线程安全的<br><strong>使用场景:</strong> 对象创建后,内部状态和数据不再发生变化，对象需要被共享,被多线程频繁访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123; <span class="comment">//父类不变,子类也必须不变,但无法保证这一点,故使用final</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intData; <span class="comment">//仅被赋值一次</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">   intData=d;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(String d)</span></span>&#123;</span><br><span class="line">   intData=Integer.valueOf(d);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> intData;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;data:&quot;</span>+intData;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>“：String 类也是不变模式,保证了在多线程下的性能</p><h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p><strong>定义</strong>: 生产者负责提交用户请求,消费者负责具体处理生产者提交的任务.生产者和消费者之间通过共享内存缓冲区进行通信.<br><strong>特点</strong>: 对生产者线程和消费者线程进行解耦,优化系统整体结构,环节性能瓶颈对系统性能的影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享数据模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123; <span class="comment">// 任务相关的数据</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intData;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">      intData=d;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(String d)</span></span>&#123;</span><br><span class="line">      intData=Integer.valueOf(d);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> intData;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;data:&quot;</span>+intData;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">private</span> BlockingQueue&lt;PCData&gt; queue;                           <span class="comment">// 内存缓冲区</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();      <span class="comment">// 总数，原子操作</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPTIME = <span class="number">1000</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;PCData&gt; queue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.queue = queue;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       PCData data = <span class="keyword">null</span>;</span><br><span class="line">       Random r = <span class="keyword">new</span> Random();</span><br><span class="line">       System.out.println(<span class="string">&quot;start producer id=&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">               Thread.sleep(r.nextInt(SLEEPTIME));</span><br><span class="line">               data = <span class="keyword">new</span> PCData(count.incrementAndGet());           <span class="comment">// 构造任务数据</span></span><br><span class="line">               System.out.println(data+<span class="string">&quot; is put into queue&quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (!queue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS)) &#123;        <span class="comment">// 提交数据到缓冲区中</span></span><br><span class="line">               System.err.println(<span class="string">&quot;failed to put data：&quot;</span> + data);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   isRunning = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> BlockingQueue&lt;PCData&gt; queue;                                        <span class="comment">// 缓冲区</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPTIME = <span class="number">1000</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;PCData&gt; queue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.queue = queue;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;start Consumer id=&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">     Random r = <span class="keyword">new</span> Random();              <span class="comment">// 随机等待时间</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">             PCData data = queue.take();                                          <span class="comment">// 提取任务</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">null</span> != data) &#123;</span><br><span class="line">               <span class="keyword">int</span> re = data.getData() * data.getData();                          <span class="comment">// 计算平方</span></span><br><span class="line">               System.out.println(MessageFormat.format(<span class="string">&quot;&#123;0&#125;*&#123;1&#125;=&#123;2&#125;&quot;</span>,</span><br><span class="line">               data.getData(), data.getData(), re));</span><br><span class="line">               Thread.sleep(r.nextInt(SLEEPTIME));</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         Thread.currentThread().interrupt();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCMain</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       BlockingQueue&lt;PCData&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;PCData&gt;(<span class="number">10</span>);</span><br><span class="line">       Producer producer1 = <span class="keyword">new</span> Producer(queue);                          <span class="comment">// 建立生产者</span></span><br><span class="line">       Producer producer2 = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">       Producer producer3 = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">       Consumer consumer1 = <span class="keyword">new</span> Consumer(queue);                          <span class="comment">// 建立消费者</span></span><br><span class="line">       Consumer consumer2 = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">       Consumer consumer3 = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">       ExecutorService service = Executors.newCachedThreadPool();         <span class="comment">// 建立线程池</span></span><br><span class="line">       service.execute(producer1);                                        <span class="comment">// 运行生产者</span></span><br><span class="line">       service.execute(producer2);</span><br><span class="line">       service.execute(producer3);</span><br><span class="line">       service.execute(consumer1);                                        <span class="comment">// 运行消费者</span></span><br><span class="line">       service.execute(consumer2);</span><br><span class="line">       service.execute(consumer3);</span><br><span class="line">       Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>); </span><br><span class="line">       producer1.stop();                                                  <span class="comment">// 停止生产者</span></span><br><span class="line">       producer2.stop();</span><br><span class="line">       producer3.stop();</span><br><span class="line">       Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">       service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生产者消费模式-无锁实现"><a href="#生产者消费模式-无锁实现" class="headerlink" title="生产者消费模式:无锁实现"></a>生产者消费模式:无锁实现</h1><blockquote><p>上述BlockingQueue基于锁和阻塞等待来实现线程同步,在高并发环境下性能有限.<br>ConcurrentLinkedQueue是一个高性能的队列,基于CAS来实现生产者消费者模式.<br>CAS编程相对比较困难,我们可以使用Disruptor框架来实现.</p></blockquote><h2 id="无锁缓存框架Disruptor"><a href="#无锁缓存框架Disruptor" class="headerlink" title="无锁缓存框架Disruptor"></a>无锁缓存框架Disruptor</h2><p><strong>特点</strong>: 环形队列,队列大小需要事先指定,无法动态扩展,数组大小需设置为2的整数次方.内存复用度高,减少GC等消耗 </p><p><strong>结构</strong>: RingBuffer的结构在写入和读取的操作时,均使用CAS进行数据保护.</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510194011.png" alt="在这里插入图片描述"></p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该示例代码使用的版本是 disruptor-3.3.2</span></span><br><span class="line"><span class="comment">//数据模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者 需要事先WorkHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">WorkHandler</span>&lt;<span class="title">PCData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(PCData event)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//框架的回调方法</span></span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:Event: --&quot;</span></span><br><span class="line">                + event.get() * event.get() + <span class="string">&quot;--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据对象工厂类,Disruptor框架初始化时构造所有对象实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCDataFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">PCData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PCData <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PCData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;PCData&gt; ringBuffer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(RingBuffer&lt;PCData&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">(ByteBuffer bb)</span> </span>&#123; <span class="comment">//提取bytebuffer中的数据,装载到环形数组中</span></span><br><span class="line">        <span class="keyword">long</span> sequence = ringBuffer.next(); <span class="comment">// 获取下一个序列号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PCData event = ringBuffer.get(sequence); <span class="comment">// 取得环形数组中的PCdata</span></span><br><span class="line">            event.set(bb.getLong(<span class="number">0</span>)); <span class="comment">// 设置pcdata</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence); <span class="comment">//必须发布,只有发布后的数据才能被消费者看见</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Executor executor = Executors.newCachedThreadPool();</span><br><span class="line">        PCDataFactory factory = <span class="keyword">new</span> PCDataFactory();</span><br><span class="line">        <span class="comment">// Specify the size of the ring buffer, must be power of 2.</span></span><br><span class="line">        <span class="keyword">int</span> bufferSize = <span class="number">1024</span>; <span class="comment">//缓冲区设置 为2^10</span></span><br><span class="line">        Disruptor&lt;PCData&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;PCData&gt;(factory, <span class="comment">//创建disruptor对象</span></span><br><span class="line">                bufferSize,</span><br><span class="line">                executor,</span><br><span class="line">                ProducerType.MULTI,</span><br><span class="line">                <span class="keyword">new</span> BlockingWaitStrategy()   <span class="comment">//消费者监控缓存区的策略</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// Connect the handler</span></span><br><span class="line"><span class="comment">// disruptor.handleEventsWith(new LongEventHandler());</span></span><br><span class="line">        disruptor.handleEventsWithWorkerPool( <span class="comment">//用于消费者,设置4个消费者,并把每个消费者映射到一个线程中</span></span><br><span class="line">                <span class="keyword">new</span> Consumer(),</span><br><span class="line">                <span class="keyword">new</span> Consumer(),</span><br><span class="line">                <span class="keyword">new</span> Consumer(),</span><br><span class="line">                <span class="keyword">new</span> Consumer());</span><br><span class="line">        disruptor.start(); <span class="comment">//启动并初始化disruptor系统</span></span><br><span class="line">        RingBuffer&lt;PCData&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(ringBuffer);</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; <span class="keyword">true</span>; l++) &#123; <span class="comment">//生产者不断地写入缓冲区</span></span><br><span class="line">            bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">            producer.pushData(bb);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;add data &quot;</span> + l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Disruptor中消费者监控缓存区的策略"><a href="#Disruptor中消费者监控缓存区的策略" class="headerlink" title="Disruptor中消费者监控缓存区的策略"></a>Disruptor中消费者监控缓存区的策略</h2><p>消费者如何监控缓冲区中的信息呢,以下给出了4种策略,这些策略由WaitStrategy接口进行封装</p><ol><li><strong>BlcokingWaitStrategy</strong>: 默认策略,类似BlockingQueue,利用锁和条件(Condition)进行数据的监控和线程的唤醒, 最节省CPU,但高并发下性能最差</li><li><strong>SleepingWaitStrategy</strong>: 与上述类似.它会在循环中不断等待,先进行自旋等待,若不成功,则会使用Thread.yield()方法让出cpu,并最终使用LockSupport.parkNanos进行线程休眠.因此这个策略对数据处理可能会产生较高的平均延迟,适合对延时要求不高的场合,且对生产者线程的影响最小.典型场景为异步日志.</li><li><strong>YieldingWaitingStrategy</strong>: 这个策略用于低延时的场合。消费者线程会不断循环监控缓冲区的变化，在循环内部，它会使用Thread.yield方法让出CPU给别的线程执行时间。如果你需要一个高性能的系统，并且对延时有较为严格的要求，则可以考虑这种策略。使用这种策略时，相当于消费者线程变成了一个内部执行了Thread.yield方法的死循环。因此，你最好有多于消费者线程数量的逻辑CPU数量（这里的逻辑CPU指的是“双核四线程”中的那个四线程，否则，整个应用程序恐怕都会受到影响）.</li><li><strong>BusySpinWaitStrategy</strong> : 这个是最疯狂的等待策略了。它就是一个死循环！消费者线程会尽最大努力疯狂监控缓冲区的变化。因此，它会吃掉所有的CPU资源。只有对延迟非常苛刻的场合可以考虑使用它（或者说，你的系统真的非常繁忙）。因为使用它等于开启了一个死循环监控，所以你的物理CPU数量必须要大于消费者的线程数。注意，我这里说的是物理CPU，如果你在一个物理核上使用超线程技术模拟两个逻辑核，另外一个逻辑核显然会受到这种超密集计算的影响而不能正常工作。</li></ol><h2 id="Disruptor中cpu-cache的优化-解决伪共享问题"><a href="#Disruptor中cpu-cache的优化-解决伪共享问题" class="headerlink" title="Disruptor中cpu cache的优化: 解决伪共享问题"></a>Disruptor中cpu cache的优化: 解决伪共享问题</h2><p>什么是伪共享问题呢？我们知道，为了提高CPU的速度，CPU有一个高速缓存Cache。在高速缓存中，读写数据的最小单位为缓存行（Cache Line），它是从主存（Memory）复制到缓存（Cache）的最小单位，一般为32字节到128字节。</p><p>当两个变量存放在一个缓存行时，在多线程访问中，可能会影响彼此的性能。在图5.4中，假设变量X和Y在同一个缓存行，运行在CPU1上的线程更新了变量X，那么CPU2上的缓存行就会失效，同一行的变量Y即使没有修改也会变成无效，导致Cache无法命中。接着，如果在CPU2上的线程更新了变量Y，则导致CPU1上的缓存行失效（此时，同一行的变量X变得无法访问）。这种情况反复发生，无疑是一个潜在的性能杀手。如果CPU经常不能命中缓存，那么系统的吞吐量就会急剧下降。</p><p>为了避免这种情况发生，一种可行的做法就是在变量X的前后空间都先占据一定的位置（把它叫作padding，用来填充用的）。这样，当内存被读入缓存时，这个缓存行中，只有变量X一个变量实际是有效的，因此就不会发生多个线程同时修改缓存行中不同变量而导致变量全体失效的情况，如图5.5所示。(即x占一个缓存行,Y占一个缓存行)。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510194831.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510194915.png" alt="img"></p><h1 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Future模式是多线程开发中非常常见的一种设计模式，它的核心思想是异步调用。当我们需要调用一个函数方法时，如果这个函数执行得很慢，那么我们就要进行等待。但有时候，我们可能并不急着要结果。因此，我们可以让被调者立即返回，让它在后台慢慢处理这个请求。对于调用者来说，则可以先处理一些其他任务，在真正需要数据的场合再去尝试获得需要的数据。</p><p>对于Future模式来说，虽然它无法立即给出你需要的数据，但是它会返回一个契约给你，将来你可以凭借这个契约去重新获取你需要的信息。</p><h2 id="Future的简单实现"><a href="#Future的简单实现" class="headerlink" title="Future的简单实现"></a>Future的简单实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心接口Data: 客户端希望获得的数据.</span></span><br><span class="line"><span class="comment">//RealData : 真实数据,最终希望获得的数据</span></span><br><span class="line"><span class="comment">//FutureData : 提取RealData的凭证,可立刻返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> RealData realdata = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realdata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isReady) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.realdata = realdata;</span><br><span class="line">        isReady = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();        <span class="comment">//等realdata注入完后,通知getresult()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;    <span class="comment">//等待realdata构造完成</span></span><br><span class="line">        <span class="keyword">while</span> (!isReady) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();        <span class="comment">//当调用result时,为准备好数据时阻塞住线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> realdata.result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//RealData的构造可能很慢，需要用户等待很久</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sb.append(para);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String queryStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line">        <span class="comment">// RealData的构建很慢</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;                                      </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                             </span><br><span class="line">                RealData realdata = <span class="keyword">new</span> RealData(queryStr);</span><br><span class="line">                future.setRealData(realdata);</span><br><span class="line">            &#125;                                               </span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        Data data = client.request(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请求完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里可以用一个sleep代替了对其它业务逻辑的处理</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//使用真实的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据 = &quot;</span> + data.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK中的Future"><a href="#JDK中的Future" class="headerlink" title="JDK中的Future"></a>JDK中的Future</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">future.get();    <span class="comment">//需要等待任务完成,get()会阻塞住</span></span><br><span class="line">System.out.println(<span class="string">&quot;处理完毕&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Guava对Future的支持"><a href="#Guava对Future的支持" class="headerlink" title="Guava对Future的支持"></a>Guava对Future的支持</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutrueDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(<span class="number">10</span>));</span><br><span class="line">        ListenableFuture&lt;String&gt; task = service.submit(<span class="keyword">new</span> RealData(<span class="string">&quot;x&quot;</span>));</span><br><span class="line">        Futures.addCallback(task, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;异步处理成功,result=&quot;</span> + o);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;        <span class="comment">//对异常的处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;异步处理失败,e=&quot;</span> + throwable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, MoreExecutors.newDirectExecutorService());</span><br><span class="line">        System.out.println(<span class="string">&quot;main task done.....&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Atomic总结</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Java-Atomic%E6%80%BB%E7%BB%93/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/Java-Atomic%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所谓 <code>Atomic</code>，翻译过来就是原子。原子被认为是操作中最小的单位，一段代码如果是原子的，则表示这段代码在执行过程中，要么执行成功，要么执行失败。原子操作一般都是底层通过 <code>CPU</code> 的指令来实现。而 <code>atomic</code> 包下的这些类，则可以让我们在多线程环境下，通过一种无锁的原子操作来实现线程安全。</p><p><code>atomic</code> 包下的类基本上都是借助 <code>Unsafe</code> 类，通过 <code>CAS</code> 操作来封装实现的。<code>Unsafe</code> 这个类不属于 <code>Java</code> 标准，或者说这个类是 <code>Java</code> 预留的一个后门类，<code>JDK</code> 中，有关提升性能的 <code>concurrent</code> 或者 <code>NIO</code> 等操作，大部分都是借助于这个类来封装操作的。<br><code>Java</code> 是种编译型语言，不像 <code>C</code> 语言能支持操作内存，正常情况下都是由 <code>JVM</code> 进行内存的创建回收等操作，但这个类提供了一些直接操作内存相关的底层操作，使得我们也可以手动操作内存，但从类的名字就可以看出，这个类不是安全的，官方也是不建议我们使用的。</p></blockquote><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p><code>CAS</code> 包含 <code>3</code> 个参数 <code>CAS(V,E,N)</code>. <code>V</code> 表示要更新的变量, <code>E</code> 表示预期值, <code>N</code> 表示新值.</p><p>仅当<code>V</code>值等于<code>E</code>值时, 才会将<code>V</code>的值设为<code>N</code>, 如果<code>V</code>值和<code>E</code>值不同, 则说明已经有其他线程做了更新, 则当前线程什么都不做. 最后, <code>CAS</code>返回当前<code>V</code>的真实值. <code>CAS</code>操作是抱着乐观的态度进行的, 它总是认为自己可以成功完成操作.</p><p>当多个线程同时使用<code>CAS</code>操作一个变量时, 只有一个会胜出, 并成功更新, 其余均会失败.失败的线程不会被挂起,仅是被告知失败, 并且允许再次尝试, 当然也允许失败的线程放弃操作.基于这样的原理, <code>CAS</code>操作即时没有锁,也可以发现其他线程对当前线程的干扰, 并进行恰当的处理.</p><p>在 <code>JDK8</code> 的 <code>atomic</code> 包下，大概有 <code>16</code> 个类，按照原子的更新方式，大概可以分为 <code>4</code> 类：<strong>原子更新普通类型</strong>，<strong>原子更新数组</strong>，<strong>原子更新引用</strong>，<strong>原子更新字段</strong>。</p><h2 id="原子更新普通类型"><a href="#原子更新普通类型" class="headerlink" title="原子更新普通类型"></a>原子更新普通类型</h2><p><code>atomic</code> 包下提供了三种基本类型的原子更新，分别是 <code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>，这几个原子类对应于基础类型的布尔，整形，长整形，至于 <code>Java</code> 中其他的基本类型，如 <code>float</code> 等，如果需要，可以参考这几个类的源码自行实现。</p><h3 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h3><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">boolean</span> newValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span></span>;</span><br></pre></td></tr></table></figure><p>这里面的操作都很正常，主要都是用到了 <code>CAS</code>。这个类中的方法不多，基本上上面都介绍了，而内部的计算则是先将布尔转换为数字<code>0/1</code>，然后再进行后续计算。</p><h3 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h3><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> newValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">long</span> newValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">long</span> newValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndDecrement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">long</span> delta)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">decrementAndGet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">long</span> delta)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndUpdate</span><span class="params">(LongUnaryOperator updateFunction)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">updateAndGet</span><span class="params">(LongUnaryOperator updateFunction)</span></span>;</span><br></pre></td></tr></table></figure><p>这个和下面要讲的 <code>AtomicInteger</code> 类似，下面具体说下。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设置当前值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"><span class="comment">// 设置新值，并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"><span class="comment">// 如果当前值为expect，则设置为u</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> u)</span></span>;</span><br><span class="line"><span class="comment">// 当前值加1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 当前值减1，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 当前值增加delta，返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span></span>;</span><br><span class="line"><span class="comment">// 当前值加1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 当前值减1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 当前值增加delta，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装了一个int对其加减</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">.......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过unsafe 基于CPU的CAS指令来实现, 可以认为无阻塞.</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line">.......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 当前值</span></span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">    <span class="comment">// 预期值</span></span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) &#123;</span><br><span class="line">    <span class="comment">// 如果加成功了, 则返回当前值</span></span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果加失败了, 说明其他线程已经修改了数据, 与期望不相符,</span></span><br><span class="line">    <span class="comment">// 则继续无限循环, 直到成功. 这种乐观锁, 理论上只要等两三个时钟周期就可以设值成功</span></span><br><span class="line">    <span class="comment">// 相比于直接通过synchronized独占锁的方式操作int, 要大大节约等待时间.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个简单的例子测试下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">System.out.println(atomicInteger.incrementAndGet());                       <span class="comment">// 2</span></span><br><span class="line">System.out.println(atomicInteger.getAndIncrement());                       <span class="comment">// 2</span></span><br><span class="line">System.out.println(atomicInteger.getAndAccumulate(<span class="number">2</span>, (i, j) -&gt; i + j));    <span class="comment">// 3</span></span><br><span class="line">System.out.println(atomicInteger.get());                                   <span class="comment">// 5</span></span><br><span class="line">System.out.println(atomicInteger.addAndGet(<span class="number">5</span>));                            <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p><code>atomic</code> 包下提供了三种数组相关类型的原子更新，分别是 <code>AtomicIntegerArray</code>，<code>AtomicLongArray</code>，<code>AtomicReferenceArray</code>，对应于整型，长整形，引用类型，要说明的一点是，这里说的更新是指更新数组中的某一个元素的操作。</p><p>由于方法和更新基本类型方法相同，这里只简单看下 <code>AtomicIntegerArray</code> 这个类的几个方法，其他的方法类似。</p><h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得数组第i个下标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 获得数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将数组第i个下标设置为newValue，并返回旧的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"><span class="comment">// 进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素加1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 将第i个下标的元素增加delta（delta可以是负数）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组本身基地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了一个数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 数组中对象的宽度, int类型, 4个字节, scale = 4;</span></span><br><span class="line">    <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">    <span class="comment">// 前导0 : 一个数字转为二进制后, 他前面0的个数</span></span><br><span class="line">    <span class="comment">// 对于4来讲, 他就是00000000 00000000 00000000 00000100, 他的前导0 就是29</span></span><br><span class="line">    <span class="comment">// 所以shift = 2</span></span><br><span class="line">    shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第i个元素, 在数组中的偏移量是多少</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base : 数组基地址, i &lt;&lt; shift, 其实就是i * 4, 因为这边是int array.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i * 4 + base</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据偏移量从数组中获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个简单的例子测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicIntegerArray array = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">5</span>);</span><br><span class="line">array.set(<span class="number">0</span>, <span class="number">1</span>);                                        <span class="comment">// 设置数组第一个值为1</span></span><br><span class="line">System.out.println(array.getAndDecrement(<span class="number">0</span>));         <span class="comment">// 1</span></span><br><span class="line">System.out.println(array.addAndGet(<span class="number">0</span>, <span class="number">5</span>));      <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><p>更新引用类型的原子类包含了<code>AtomicReference</code>（更新引用类型），<code>AtomicReferenceFieldUpdater</code>（抽象类，更新引用类型里的字段），<code>AtomicMarkableReference</code>（更新带有标记的引用类型）这三个类，这几个类能同时更新多个变量。</p><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>与 <code>AtomicInteger</code> 类似, 只是里面封装了一个对象, 而不是 <code>int</code>, 对引用进行修改。</p><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>测试</strong><br>使用 <code>10</code> 个线程, 同时尝试修改 <code>AtomicReference</code> 中的 <code>String</code>, 最终只有一个线程可以成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicReference&lt;String&gt; attxnicStr = <span class="keyword">new</span> AtomicReference&lt;String&gt;(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(Math.abs((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>)));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (attxnicStr.compareAndSet(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; change value to &quot;</span> + attxnicStr.get());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; change failed!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子更新字段"><a href="#原子更新字段" class="headerlink" title="原子更新字段"></a>原子更新字段</h2><p>如果更新的时候只更新对象中的某一个字段，则可以使用 <code>atomic</code> 包提供的更新字段类型：<code>AtomicIntegerFieldUpdater</code>，<code>AtomicLongFieldUpdater</code> 和 <code>AtomicStampedReference</code>，前两个顾名思义，就是更新 <code>int</code> 和 <code>long</code> 类型，最后一个是更新引用类型，该类提供了版本号，用于解决通过 <code>CAS</code> 进行原子更新过程中，可能出现的 <code>ABA</code> 问题。<br>前面这两个类和上面介绍的 <code>AtomicReferenceFieldUpdater</code> 有些相似，都是抽象类，都需要通过 <code>newUpdater</code> 方法进行实例化，并且对字段的要求也是一样的。</p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><p><strong>ABA问题</strong></p><p>线程一准备用 <code>CAS</code> 将变量的值由 <code>A</code> 替换为 <code>B</code>, 在此之前线程二将变量的值由 <code>A</code> 替换为 <code>C</code>, 线程三又将 <code>C</code> 替换为<code>A</code>, 然后线程一执行 <code>CAS</code> 时发现变量的值仍然为 <code>A</code>, 所以线程一 <code>CAS</code> 成功.</p><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectedReference,V newReference,<span class="keyword">int</span> expectedStamp,<span class="keyword">int</span> newStamp)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得当前对象引用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得当前时间戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置当前对象引用和时间戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部封装了一个Pair对象, 每次对对象操作的时候, stamp + 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行cas操作的时候, 会对比stamp的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p>要求：后台使用多个线程对用户充值, 要求只能充值一次.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> staticvoid <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟多个线程同时更新后台数据库，为用户充值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timestamp=money.getStamp();</span><br><span class="line">            newThread() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                           Integerm=money.getReference();</span><br><span class="line">                            <span class="keyword">if</span>(m&lt;<span class="number">20</span>)&#123;</span><br><span class="line">                         <span class="keyword">if</span>(money.compareAndSet(m,m+<span class="number">20</span>,timestamp,timestamp+<span class="number">1</span>))&#123;</span><br><span class="line">          　　　　　　　　　　　　　　　 System.out.println(<span class="string">&quot;余额小于20元，充值成功，余额:&quot;</span>+money.getReference()+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                               <span class="comment">//System.out.println(&quot;余额大于20元，无需充值&quot;);</span></span><br><span class="line">                                <span class="keyword">break</span> ;</span><br><span class="line">                             &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;.start();</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//用户消费线程，模拟消费行为</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123; </span><br><span class="line">             <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> timestamp=money.getStamp();</span><br><span class="line">                        Integer m=money.getReference();</span><br><span class="line">                        <span class="keyword">if</span>(m&gt;<span class="number">10</span>)&#123;</span><br><span class="line">                             System.out.println(<span class="string">&quot;大于10元&quot;</span>);</span><br><span class="line">                          　　<span class="keyword">if</span>(money.compareAndSet(m, m-<span class="number">10</span>,timestamp,timestamp+<span class="number">1</span>))&#123;</span><br><span class="line">                      　　　　　　 System.out.println(<span class="string">&quot;成功消费10元，余额:&quot;</span>+money.getReference());</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                           System.out.println(<span class="string">&quot;没有足够的金额&quot;</span>);</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">100</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;.start(); </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><p>能够让普通变量也能够进行原子操作。</p><p><strong>主要接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">AtomicIntegerFieldUpdater&lt;U&gt; <span class="title">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String fieldName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(T obj)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>Updater</code>只能修改它可见范围内的变量。因为<code>Updater</code>使用反射得到这个变量。如果变量不可见，就会出错。比如如果<code>score</code>申明为<code>private</code>，就是不可行的。</li><li>为了确保变量被正确的读取，它必须是<code>volatile</code>类型的。如果我们原有代码中未申明这个类型，那么简单得申明一下就行。</li><li>由于<code>CAS</code>操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持<code>static</code>字段（<code>Unsafe.objectFieldOffset()</code>不支持静态变量）。</li></ul><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="comment">// 如果直接把int改成atomicinteger, 可能对代码破坏比较大</span></span><br><span class="line">        <span class="comment">// 因此使用AtomicIntegerFieldUpdater对score进行封装</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查Updater是否工作正确, allScore的结果应该跟score一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allScore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Candidate stu = <span class="keyword">new</span> Candidate();</span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">                        scoreUpdater.incrementAndGet(stu);</span><br><span class="line">                        allScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;score=&quot;</span> + stu.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;allScore=&quot;</span> + allScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8之后引入的类型"><a href="#JDK8之后引入的类型" class="headerlink" title="JDK8之后引入的类型"></a>JDK8之后引入的类型</h2><p>在<code>JDK8</code>之前，针对原子操作，我们基本上可以通过上面提供的这些类来完成我们的多线程下的原子操作，不过在并发高的情况下，上面这些单一的 <code>CAS</code> + 自旋操作的性能将会是一个问题，所以上述这些类一般用于低并发操作。<br>而针对这个问题，<code>JDK8</code>又引入了下面几个类：<code>DoubleAdder</code>，<code>LongAdder</code>，<code>DoubleAccumulator</code>，<code>LongAccumulator</code>，这些类是对<code>AtomicLong</code>这些类的改进与增强，这些类都继承自<code>Striped64</code>这个类。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510171858.png" alt="Java Atomic.png"></p>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的基本使用及原理</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ThreadLocal%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ThreadLocal%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>ThreadLocal是一个线程的局部变量，只有当前线程可以访问，因为只有当前线程可以访问，所以是线程安全的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>举例<br>多线程环境中使用SimpleDateFormat 解析日期</p></li><li><p>代码</p><p>public class SimpleDateFormatTest {</p><pre><code>// SimpleDateFormat 实例private static final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析日期任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">this</span>.i = i;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date date = sdf.parse(<span class="string">&quot;2020-10-06 19:21:&quot;</span> + i % <span class="number">60</span>);</span><br><span class="line">            System.out.println(i + <span class="string">&quot; : &quot;</span> + date);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池，解析日期</span></span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行结果</p></li></ol><p><code>Exception in thread &quot;pool-1-thread-2&quot; Exception in thread &quot;pool-1-thread-1&quot; java.lang.NumberFormatException: multiple points</code></p><p>可以看到执行后抛出异常，所以SimpleDateFormat.parse()方法不是线程安全的</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>方案一：在parse方法前后加锁</strong>（这里不讨论）<br><strong>方案二：使用ThreadLocal</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">x02ParseDate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SimpleDateFormat 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日期解析任务类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果ThreadLocal中没有SimpleDateFormat实例，那就初始化一个</span></span><br><span class="line">                <span class="keyword">if</span> (tl.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tl.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                Date date = tl.get().parse(<span class="string">&quot;2020-10-06 19:21:&quot;</span> + i % <span class="number">60</span>);</span><br><span class="line">                System.out.println(i + <span class="string">&quot; : &quot;</span> + date);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池，解析日期</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>为每一个线程分配不同的对象，需要在应用层进行保证；ThreadLocal只是起到了容器的作用</p></blockquote><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set() 方法"></a>set() 方法</h2><p>我们来看看 set() 方法的内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2、获取当前线程对象的 ThreadlLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 3、将值存入 ThreadlLcaolMap 中</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简单地把ThreadlLocalMap看作是一个Map（但请注意，它不是HashMap，而是存储 key-value 结构的 Entry）。</p><p>ThreadlLocalMap 是定义在Thread类中地成员，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;<span class="comment">// Thread 类中</span></span><br></pre></td></tr></table></figure><p>我们设置的数据写入了 threadLocals 中，其中 key 为 ThreadLocal 当前对象，value 就是我们设置的值。threadLocals 保存了当前自己线程所有的“局部变量”，也就是一个ThreadLocal变量的集合。</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、获取当前线程 </span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2、获取当前线程的 ThreadLocalMap 对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 3、将自己作为 key 取得内部的数据</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 中的一些变量是维护在Thread类内部的，所以：<strong>只要线程不退出，对象的引用就一直存在，无法被GC回收</strong>。<br>当线程退出时，Thread类会进行一些清理操作（包括清理ThreadLocalMap）。通过将引用置为null，使得JVM将其当作垃圾并进行回收,详细内容见下小节.</p><h2 id="ThreadLocal-导致内存泄漏"><a href="#ThreadLocal-导致内存泄漏" class="headerlink" title="ThreadLocal 导致内存泄漏"></a>ThreadLocal 导致内存泄漏</h2><ol><li><strong>问题</strong><br>如上面所说，线程不退出，对象引用就一直存在，这在线程池中可能会导致内存泄漏。<br>例如固定大小的线程池(FixThreadPool)，其线程总是存在。如果将一些大对象设置进了 ThreadLocal 中，使用了几次后就不再使用，同时也没有清理它，这会导致大对象无法被回收，最终导致内存泄露。</li><li><strong>如何解决</strong><ul><li>使用 ThreadLocal.remove() 方法移除这个变量</li><li>使用类似于 obj = null 的代码</li></ul></li><li>*为何使用类似于 obj = null 的代码可以防止内存泄漏**</li></ol><p>ThreadLocalMap使用了弱引用（弱引用就是：在垃圾回收时，JVM 发现弱引用，就直接将其回收）。<br>ThreadLocalMap 内部由一系列 Entry 构成，每个Entry都继承了弱引用 WeakRefefence，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 k 是 ThreadLocal 实例，作为弱引用使用。super(k)就是调用了 WeakReference 的构造函数；<br>因此虽然使用 ThreadLocal 作为 Entry 的 k，但实际上它并不持有 ThreadLocal 的引用。<br>当 ThreadLocal 的外部强引用被回收时，Entry 中的 k 就会变成 null。<br>当系统进行ThreadLocalMap清理时（比如将新的变量加入表中，就会进行一次清理，虽然JDK不一定会进行一次彻底的扫描），就会将这些垃圾数据回收。ThreadLocal的回收机制如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510163926.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高锁性能的几种方式</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E6%8F%90%E9%AB%98%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E6%8F%90%E9%AB%98%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    mutextMethod();</span><br><span class="line">    othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>syncMethod()方法中,假设只有mutextMethod()方法是有同步需要的,如果othercode1()和othercode2()分别是重量级的方法,则会花费较长的CPU时间.</p><p>一个较为优化的解决方案是,只在必要时进行同步,这样就能明显减少线程持有锁的时间,提高系统的吞吐量;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    othercode1();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      mutextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    othercode2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力</p></blockquote><h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h2><p>这种技术典型的使用场景就是ConcurrentHashMap.</p><p>对于HashMap来说,最重要的两个方法就是get() 和put(),一种最自然的想法就是对整个HashMap加锁,必然可以得到一个线程安全的对象.但是这样做,我们就认为加锁粒度太大.对于ConcurrentHashMap,它内部进一步细分了若干个小的hashMap,称之为段(SEGMENT).默认的情况下,一个ConcurrentHashMap被进一步细分为16个段</p><p>如果需要在ConcurrentHashMap中增加一个新的表项,并不是整个HashMap加锁,而是首先根据hashcode得到该表项应该被存放到哪个段中,然后对该段加锁,并完成put()操作.在多线程环境中,如果多个线程同时进行put()操作,只要被加入的表项不存放在同一个段中,则线程间便可以做到真正的并行</p><blockquote><p><strong>注意：</strong></p><p>所谓减小锁粒度，就是指缩小锁定对象的范围，从而降低锁冲突的可能性，进而提高系统的并发能力。</p><p>但减小锁粒度会引入一个新的问题,<strong>当需要获取全局锁的时候,其消耗的资源会较多</strong>,不如concurrenthashMap的size()方法.事实上计算size的时候会先使用无锁的方式计算,如果失败会采用这个方法,但是在高并发的场合concurrenthashmap的size依然要差于同步的hashmap.<strong>因此在类似于size获取全局信息方法调用不频繁的情况下,这种减小粒度的的方法才是真正意义上的提高系统并发量</strong></p></blockquote><h3 id="读写分离锁来替换独占锁"><a href="#读写分离锁来替换独占锁" class="headerlink" title="读写分离锁来替换独占锁"></a>读写分离锁来替换独占锁</h3><p>使用读写分离锁来替代独占锁是减少锁粒度的一种特殊情况。如果说上述的减小锁粒度是通过分割数据结构实现的，那么读写分离锁则是对系统功能点的分割。</p><blockquote><p><strong>注意：</strong>在读多写少的场合,使用读写锁可以有效提升系统的并发能力</p></blockquote><h3 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h3><p>如果将读写锁的思想进一步的延伸,就是锁分离.读写锁根据读写锁操作功能上的不同,进行了有效的锁分离.使用类似的思想,也可以对独占锁进行分离.以LinkedBlockingQueue为例,take函数和put函数分别实现了冲队列取和往队列加数据，虽然两个方法都对队列进项了修改，但是LinkedBlockingQueue是基于链表的所以一个操作的是头，一个是队列尾端，从理论情况下将并不冲突。</p><p>如果使用独占锁则take和put就不能完成真正的并发，所以jdk并没有采用这种方式取而代之的是两把不同的锁分离了put和take的操作，下面看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//take函数需要持有takeLock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//put函数需要持有putLock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>凡事都有一个度,如果对同一个锁不停地进行请求,同步和释放,其本身也会消耗系统宝贵的资源,反而不利于性能的优化</p><p>为此,虚拟机在遇到一连串连续地对同一锁不断进行请求和释放的操作时,便会把所有的锁操作整合成对锁的一次请求,从而减少对锁的请求同步次数,这个操作叫做锁的粗化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做其他不需要的同步的工作,但能很快执行完毕</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//do sth.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会被整合成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">//do sth</span></span><br><span class="line">      <span class="comment">//做其他不需要的同步的工作,但能很快执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发过程中,大家也应该有意识地在合理地场合进行锁的粗化,尤其当在循环内请求锁时.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CIRCLE; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种更加合理地做法应该是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CIRCLE; i++) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 性能优化就是根据运行时的真实情况对各个资源点进行权衡折中的过程,锁粗话的思想和减少锁持有时间是相反的,但是在不同的场合,他们的效果并不相同,所以大家要根据实际情况,进行权衡</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JMH进行性能测试</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8JMH%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8JMH%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JMH比较典型的应用场景有：</p><p>想准确的知道某个方法需要执行多长时间，以及执行时间和输入之间的相关性；<br>对比接口不同实现在给定条件下的吞吐量，找到最优实现<br>查看多少百分比的请求在多长时间内完成1 JMH入门案例</p></blockquote><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><p>JMH是 被作为JDK9而自带的，但是我们可以通过导入相关依赖或者jar包来使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JMH--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJMH</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串拼接StringBuilder基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            str.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String s = str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串拼接直接相加基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            str = str + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options options = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(HelloJMH.class.getSimpleName())  <span class="comment">//包含的方法</span></span><br><span class="line">                .forks(<span class="number">1</span>)   <span class="comment">//分出几个进程单独测试</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(options).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  @Benchmark注解表示该方法是需要进行benchmark测试的方法。<br>  @BenchmarkMode表示JMH测量方式和角度，本次是测量平均时间。<br>  @OutputTimeUnit表示benchmark 结果所使用的时间单位，可用于类或者方法注解，使用java.util.concurrent.TimeUnit中的标准时间单位。<br>  在 Main 方法中，通过Runner 类去运行Options 实例即可。官方提供了一个OptionsBuilder对象去流式构建。OptionsBuilder的其他配置信息在下面讲。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">1)# JMH version: 1.21</span><br><span class="line">2)# VM version: JDK 1.8.0_144, Java HotSpot(TM) 64-Bit Server VM, 25.144-b01</span><br><span class="line">3)# VM invoker: C:\Program Files\Java\jdk1.8.0_144\jre\bin\java.exe</span><br><span class="line">4)# VM options: -javaagent:D:\soft\IntelliJ IDEA 2019.3\lib\idea_rt.jar&#x3D;61956:D:\soft\IntelliJ IDEA 2019.3\bin -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">5)# Warmup: 5 iterations, 10 s each</span><br><span class="line">6)# Measurement: 5 iterations, 10 s each</span><br><span class="line">7)# Timeout: 10 min per iteration</span><br><span class="line">8)# Threads: 1 thread, will synchronize iterations</span><br><span class="line">9)# Benchmark mode: Average time, time&#x2F;op</span><br><span class="line">10)# Benchmark: com.thread.test.JMH.HelloJMH.testStringAdd</span><br><span class="line"></span><br><span class="line">11)# Run progress: 0.00% complete, ETA 00:03:20</span><br><span class="line">12)# Fork: 1 of 1</span><br><span class="line">13)# Warmup Iteration   1: 506360.123 ns&#x2F;op</span><br><span class="line">14)# Warmup Iteration   2: 460295.578 ns&#x2F;op</span><br><span class="line">15)# Warmup Iteration   3: 492550.630 ns&#x2F;op</span><br><span class="line">16)# Warmup Iteration   4: 482141.558 ns&#x2F;op</span><br><span class="line">17)# Warmup Iteration   5: 469897.660 ns&#x2F;op</span><br><span class="line">18)Iteration   1: 443427.726 ns&#x2F;op</span><br><span class="line">19)Iteration   2: 456970.538 ns&#x2F;op</span><br><span class="line">20)Iteration   3: 440686.491 ns&#x2F;op</span><br><span class="line">21)Iteration   4: 451894.998 ns&#x2F;op</span><br><span class="line">22)Iteration   5: 432889.165 ns&#x2F;op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">23)Result &quot;com.thread.test.JMH.HelloJMH.testStringAdd&quot;:</span><br><span class="line">a)445173.784 ±(99.9%) 36450.901 ns&#x2F;op [Average]</span><br><span class="line">b)(min, avg, max) &#x3D; (432889.165, 445173.784, 456970.538), stdev &#x3D; 9466.183</span><br><span class="line">c)CI (99.9%): [408722.883, 481624.685] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">24)# JMH version: 1.21</span><br><span class="line">25)# VM version: JDK 1.8.0_144, Java HotSpot(TM) 64-Bit Server VM, 25.144-b01</span><br><span class="line">26)# VM invoker: C:\Program Files\Java\jdk1.8.0_144\jre\bin\java.exe</span><br><span class="line">27)# VM options: -javaagent:D:\soft\IntelliJ IDEA 2019.3\lib\idea_rt.jar&#x3D;61956:D:\soft\IntelliJ IDEA 2019.3\bin -Dfile.encoding&#x3D;UTF-8</span><br><span class="line">28)# Warmup: 5 iterations, 10 s each    &#x2F;&#x2F;预热次数</span><br><span class="line">29)# Measurement: 5 iterations, 10 s each   &#x2F;&#x2F;度量次数</span><br><span class="line">30)# Timeout: 10 min per iteration</span><br><span class="line">31)# Threads: 1 thread, will synchronize iterations</span><br><span class="line">32)# Benchmark mode: Average time, time&#x2F;op</span><br><span class="line">33)# Benchmark: com.thread.test.JMH.HelloJMH.testStringBuilder</span><br><span class="line"></span><br><span class="line">34)# Run progress: 50.00% complete, ETA 00:01:40</span><br><span class="line">35)# Fork: 1 of 1</span><br><span class="line">36)# Warmup Iteration   1: 10372.126 ns&#x2F;op</span><br><span class="line">37)# Warmup Iteration   2: 10301.755 ns&#x2F;op</span><br><span class="line">38)# Warmup Iteration   3: 10006.275 ns&#x2F;op</span><br><span class="line">39)# Warmup Iteration   4: 9778.343 ns&#x2F;op</span><br><span class="line">40)# Warmup Iteration   5: 9868.092 ns&#x2F;op</span><br><span class="line">41)Iteration   1: 9641.269 ns&#x2F;op</span><br><span class="line">42)Iteration   2: 10259.971 ns&#x2F;op</span><br><span class="line">43)Iteration   3: 9844.944 ns&#x2F;op</span><br><span class="line">44)Iteration   4: 9704.533 ns&#x2F;op</span><br><span class="line">45)Iteration   5: 9711.980 ns&#x2F;op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">46)Result &quot;com.thread.test.JMH.HelloJMH.testStringBuilder&quot;:</span><br><span class="line">a)9832.539 ±(99.9%) 963.347 ns&#x2F;op [Average]</span><br><span class="line">b)(min, avg, max) &#x3D; (9641.269, 9832.539, 10259.971), stdev &#x3D; 250.178</span><br><span class="line">c)CI (99.9%): [8869.193, 10795.886] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">47)# Run complete. Total time: 00:03:21</span><br><span class="line"></span><br><span class="line">48)REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">49)why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">50)experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">51)the benchmarking environment is safe on JVM&#x2F;OS&#x2F;HW level, ask for reviews from the domain experts.</span><br><span class="line">52)Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">53)Benchmark                       Mode  Cnt       Score       Error  Units</span><br><span class="line">54)JMH.HelloJMH.testStringAdd      avgt    5  445173.784 ± 36450.901  ns&#x2F;op</span><br><span class="line">55)JMH.HelloJMH.testStringBuilder  avgt    5    9832.539 ±   963.347  ns&#x2F;op</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>第1-10行表示测试的基本信息，比如，使用的Java路径，预热代码的迭代次数，测量代码的迭代次数，使用的线程数量，测试的统计单位等。</li><li>从第13行开始显示了每次预热迭代的结果，预热迭代不会作为最终的统计结果。预热的目的是让Java虚拟机对被测代码进行足够多的优化，比如，在预热后被测代码应该得到了充分的JIT编译和优化。</li><li>从第18行开始显示每次基准测试迭代的结果，每一次迭代都显示了当前的执行速率，即一个操作所花费的时间。</li><li>在进行5次迭代后，进行统计，结果在Result后。Result第一段结果告诉了我们最大值、最小值、平均值的信息。第二段是最主要的信息。在本例中，第54、55行显示了testStringBuilder和testStringAdd函数的平均执行花费时间和误差时间。从结果可以看出，大量字符串拼接式时，使用StringBuilder效率更高。</li></ul><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score</th><th>Error</th><th align="left">Units</th></tr></thead><tbody><tr><td>基准测试执行的方法</td><td>模式模式</td><td>运行多少次</td><td>分数</td><td>错误</td><td align="left">单位</td></tr></tbody></table><h2 id="JMH的基本概念和配置"><a href="#JMH的基本概念和配置" class="headerlink" title="JMH的基本概念和配置"></a>JMH的基本概念和配置</h2><p> <a href="https://blog.csdn.net/weixin_43767015/article/details/104758415">详细配置请参考原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMH </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDk并发容器</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/JDk%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/JDk%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>1.ConcurrentHashMap</p><p>对应的非并发容器：HashMap</p><p>目标：代替Hashtable、synchronizedMap，支持复合操作</p><p>原理：<strong>JDK6中采用一种更加细粒度的加锁机制Segment“分段锁”，JDK8中采用CAS无锁算法。</strong></p><p>2.CopyOnWriteArrayList</p><p>对应的非并发容器：ArrayList</p><p>目标：代替Vector、synchronizedList</p><p>原理：<strong>利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile 保证其可见性，当然写操作的锁是必不可少的了。</strong></p><p>3.CopyOnWriteArraySet</p><p>对应的非并发容器：HashSet</p><p>目标：代替synchronizedSet</p><p>原理：<strong>基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法，其遍历当前Object数组，如Object数组中已有了当前元素，则直接返回，如果没有则放入Object数组的尾部，并返回。</strong></p><p>4.ConcurrentSkipListMap</p><p>对应的非并发容器：TreeMap</p><p>目标：代替synchronizedSortedMap(TreeMap)</p><p>原理：<strong>Skip list（跳表）是一种可以代替平衡树的数据结构，默认是按照Key值升序的。</strong></p><p>5.ConcurrentSkipListSet</p><p>对应的非并发容器：TreeSet</p><p>目标：代替synchronizedSortedSet</p><p>原理：<strong>内部基于ConcurrentSkipListMap实现</strong></p><p>6.ConcurrentLinkedQueue</p><p>不会阻塞的队列</p><p>对应的非并发容器：Queue</p><p>原理：<strong>基于链表实现的FIFO队列（LinkedList的并发版本）</strong></p><p>7.LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue</p><p>对应的非并发容器：BlockingQueue</p><p>特点：拓展了Queue，增加了可阻塞的插入和获取等操作</p><p>原理：<strong>通过ReentrantLock实现线程安全，通过Condition实现阻塞和唤醒</strong></p><p>实现类：</p><ul><li> LinkedBlockingQueue：基于链表实现的可阻塞的FIFO队列</li><li> ArrayBlockingQueue：基于数组实现的可阻塞的FIFO队列</li><li> PriorityBlockingQueue：按优先级排序的队列</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分而治之：Fork/Join框架</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%EF%BC%9AFork-Join%E6%A1%86%E6%9E%B6/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%EF%BC%9AFork-Join%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><p>主要有两步：</p><ul><li>第一、任务切分；</li><li>第二、结果合并</li></ul><p>它的模型大致是这样的：线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510143331.png" alt="img"></p><h2 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h2><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510142709.png" alt="img"></p><p>那么为什么需要使用工作窃取算法呢？</p><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p><strong>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</strong></p><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p>该<em>ForkJoinPool</em>是框架的心脏。它是*<a href="https://www.baeldung.com/java-executor-service-tutorial">ExecutorService</a>的*一个实现，它管理工作线程（ForkJoinWorkerThread）并为我们提供工具来获取有关线程池状态和性能的信息。</p><p><strong>实例化</strong></p><p>在Java 8中，访问<em>ForkJoinPool</em>实例的最方便方法是使用其静态方法*<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--">commonPool</a>()。<em>顾名思义，这将提供对公共池的引用，公共池是每个</em>ForkJoinTask*的默认线程池。</p><p>根据<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">Oracle的文档</a>，使用预定义的公共池可以减少资源消耗，因为这会阻止为每个任务创建单独的线程池</p><p><code>ForkJoinPool commonPool = ForkJoinPool.commonPool();</code></p><p>当然，我们也可以新建线程池</p><p><code>public static ForkJoinPool forkJoinPool = new ForkJoinPool(2);</code></p><p>使用<em>ForkJoinPool的</em>构造函数，可以创建具有特定级别的并行性，线程工厂和异常处理程序的自定义线程池。在上面的示例中，池的并行度为2.这意味着池将使用2个处理器核心。</p><h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask "></a>ForkJoinTask <V></h2><p><em>orkJoinTask</em>是<em>ForkJoinPool</em>中执行的任务的基本类型<em>。</em></p><p>在实践中，它的两个子类之一应该被继承：*RecursiveAction返回值为空，RecursiveTask <V>*有返回值。 </p><p>它们都有一个抽象方法*compute()*，其中定义了任务的逻辑,也就是要覆写的方法。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> arr[];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arr = arr;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 小计</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Integer <span class="title">subtotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Integer sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: ∑(&quot;</span> + start + <span class="string">&quot;~&quot;</span> + end + <span class="string">&quot;)=&quot;</span> + sum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((end - start) &lt;= THRESHOLD) &#123;</span><br><span class="line">                <span class="keyword">return</span> subtotal();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">                SumTask left = <span class="keyword">new</span> SumTask(arr, start, middle);</span><br><span class="line">                SumTask right = <span class="keyword">new</span> SumTask(arr, middle, end);</span><br><span class="line">                left.fork();</span><br><span class="line">                right.fork();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; result = pool.submit(<span class="keyword">new</span> ForkJoinTaskDemo().<span class="function">new <span class="title">SumTask</span><span class="params">(arr, <span class="number">0</span>, arr.length)</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终计算结果: &quot;</span> + result.invoke());</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>: ∑(<span class="number">50</span>~<span class="number">62</span>)=<span class="number">678</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>: ∑(<span class="number">62</span>~<span class="number">75</span>)=<span class="number">897</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>: ∑(<span class="number">75</span>~<span class="number">87</span>)=<span class="number">978</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>: ∑(<span class="number">87</span>~<span class="number">100</span>)=<span class="number">1222</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>: ∑(<span class="number">0</span>~<span class="number">12</span>)=<span class="number">78</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>: ∑(<span class="number">12</span>~<span class="number">25</span>)=<span class="number">247</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>: ∑(<span class="number">25</span>~<span class="number">37</span>)=<span class="number">378</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>: ∑(<span class="number">37</span>~<span class="number">50</span>)=<span class="number">572</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>: ∑(<span class="number">75</span>~<span class="number">87</span>)=<span class="number">978</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>: ∑(<span class="number">50</span>~<span class="number">62</span>)=<span class="number">678</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">5</span>: ∑(<span class="number">62</span>~<span class="number">75</span>)=<span class="number">897</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">7</span>: ∑(<span class="number">0</span>~<span class="number">12</span>)=<span class="number">78</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">3</span>: ∑(<span class="number">37</span>~<span class="number">50</span>)=<span class="number">572</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span>: ∑(<span class="number">87</span>~<span class="number">100</span>)=<span class="number">1222</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>: ∑(<span class="number">25</span>~<span class="number">37</span>)=<span class="number">378</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">5</span>: ∑(<span class="number">12</span>~<span class="number">25</span>)=<span class="number">247</span></span><br><span class="line">最终计算结果: <span class="number">5050</span></span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用fork / join框架可以加速处理大型任务，但要实现这一结果，应遵循一些指导原则：</p><ul><li>使用尽可能少的线程池 - 在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池</li><li>如果不需要特定调整，请使用默认的公共线程池</li><li>使用合理的阈值将<em>ForkJoingTask</em>拆分为子任务</li><li>避免在 <em>ForkJoingTasks中出现</em>任何阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之同步控制</title>
      <link href="2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/"/>
      <url>2021/05/10/%E3%80%8A%E5%AE%9E%E6%88%98java%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="ReentrantLock（重入锁-synchronized的功能扩展）"><a href="#ReentrantLock（重入锁-synchronized的功能扩展）" class="headerlink" title="ReentrantLock（重入锁, synchronized的功能扩展）"></a>ReentrantLock（重入锁, synchronized的功能扩展）</h2><blockquote><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</p></blockquote><p><strong>构造函数</strong></p><p>public ReentrantLock(boolean fair): fair为true时表示创建的锁是公平的（锁先到先得）</p><p><strong>重要方法</strong></p><ul><li><strong>lock()</strong>: 获得锁，如果锁已经被占用，则等待。</li><li><strong>lockInterruptibly()</strong>: 获得锁，但优先响应中断。</li><li><strong>tryLock()</strong>: 尝试获得锁，如果成功，则返回true， 失败则返回false。该方法不等待，立即返回。</li><li><strong>tryLock(Long time, TimeUnit unit)</strong>: 在给定时间内尝试获得锁。</li><li><strong>unLock()</strong>: 释放锁。</li></ul><p><strong>重入锁的实现</strong></p><ul><li>原子状态。原子状态使用CAS操作来存储当前锁的状态，判断锁是否已经被别的线程持有了。</li><li>等待队列。所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。</li><li>阻塞原语park()和unpark()，用来挂起和恢复线程。</li></ul><h2 id="重入锁的搭档：Condition"><a href="#重入锁的搭档：Condition" class="headerlink" title="重入锁的搭档：Condition"></a>重入锁的搭档：Condition</h2><p><strong>基本方法：</strong></p><ol><li><strong>await()</strong> ：造成当前线程在接到信号或被中断之前一直处于等待状态。</li><li><strong>boolean await(long time, TimeUnit unit)</strong> ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态—》是否超时，超时异常</li><li><strong>awaitNanos(long nanosTimeout)</strong> ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</li><li><strong>awaitUninterruptibly()</strong> ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</li><li><strong>awaitUntil(Date deadline)</strong> ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</li><li><strong>signal()</strong> ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</li><li><strong>signalAll()</strong> ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * condition使用示例：</span></span><br><span class="line"><span class="comment"> * 1、condition的使用必须要配合锁使用，调用方法时必须要获取锁</span></span><br><span class="line"><span class="comment"> * 2、condition的创建依赖于Lock lock.newCondition()；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionUseCase</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Lock readLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Condition condition = readLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConditionUseCase useCase = <span class="keyword">new</span> ConditionUseCase();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取锁进行等待</span></span><br><span class="line">            useCase.conditionWait();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取锁进行唤起读锁</span></span><br><span class="line">            useCase.conditionSignal();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到锁了&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;等待信号&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到信号&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤起线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠5s 线程1启动</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到锁了&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;发出信号&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 pool-1-thread-1拿到锁了</span><br><span class="line">2 pool-1-thread-1等待信号 ---释放锁-线程等待 t1</span><br><span class="line">3 pool-1-thread-2拿到锁了</span><br><span class="line">4 pool-1-thread-2发出信号 --- 唤起线程t2释放锁</span><br><span class="line">5 pool-1-thread-1拿到信号---t1继续执行</span><br></pre></td></tr></table></figure><blockquote><p>如示例所示，<br>一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p></blockquote><h2 id="允许多个线程同时访问：信号量（Semaphere）"><a href="#允许多个线程同时访问：信号量（Semaphere）" class="headerlink" title="允许多个线程同时访问：信号量（Semaphere）"></a>允许多个线程同时访问：信号量（Semaphere）</h2><p><strong>构造函数</strong></p><ul><li>public Semaphore(int permits)：创建具有给定的许可数和非公平的公平设置的 Semaphore。  <ul><li>permits - 初始的可用许可数目。此值可能为负数，在这种情况下，必须在授予任何获取前进行释放。</li></ul></li><li>public Semaphore(int permits, boolean fair)：创建具有给定的许可数和给定的公平设置的 Semaphore。 <ul><li>permits - 初始的可用许可数目。此值可能为负数，在这种情况下，必须在授予任何获取前进行释放。 </li><li>fair - 如果此信号量保证在争用时按先进先出的顺序授予许可，则为 true；否则为 false。</li></ul></li></ul><p><strong>基本方法</strong></p><ul><li>void acquire()：从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</li><li>void release()：释放一个许可，将其返回给信号量。</li><li>int availablePermits()：返回此信号量中当前可用的许可数。</li><li>boolean hasQueuedThreads()：查询是否有线程正在等待获取。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span>  Semaphore sp = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sp.acquire();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + </span><br><span class="line">                            <span class="string">&quot;进入，当前已有&quot;</span> + (<span class="number">3</span>-sp.availablePermits()) + <span class="string">&quot;个并发&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + </span><br><span class="line">                            <span class="string">&quot;即将离开&quot;</span>);                    </span><br><span class="line">                    sp.release();</span><br><span class="line">                    <span class="comment">//下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + </span><br><span class="line">                            <span class="string">&quot;已离开，当前已有&quot;</span> + (<span class="number">3</span>-sp.availablePermits()) + <span class="string">&quot;个并发&quot;</span>);                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程pool-1-thread-1进入，当前已有3个并发</span><br><span class="line">线程pool-1-thread-3进入，当前已有3个并发</span><br><span class="line">线程pool-1-thread-2进入，当前已有3个并发</span><br><span class="line">线程pool-1-thread-1即将离开</span><br><span class="line">线程pool-1-thread-1已离开，当前已有2个并发</span><br><span class="line">线程pool-1-thread-4进入，当前已有3个并发</span><br><span class="line">线程pool-1-thread-3即将离开</span><br><span class="line">线程pool-1-thread-3已离开，当前已有2个并发</span><br><span class="line">线程pool-1-thread-5进入，当前已有3个并发</span><br><span class="line">...(之后的输出省略)</span><br></pre></td></tr></table></figure><h2 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h2><p><strong>接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类ReetrantReadWriteLock"><a href="#实现类ReetrantReadWriteLock" class="headerlink" title="实现类ReetrantReadWriteLock"></a>实现类ReetrantReadWriteLock</h3><p><strong>支持的功能</strong></p><ol><li>支持公平和非公平的获取锁的方式；</li><li>支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li><li><strong>还允许从写入锁降级为读取锁</strong>，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</li><li>读取锁和写入锁都支持锁获取期间的中断；</li><li>Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </li></ol><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;    <span class="comment">//缓存是否有效</span></span><br><span class="line">    ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();    <span class="comment">//获取读锁</span></span><br><span class="line">        <span class="comment">//如果缓存无效，更新cache;否则直接使用data</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">            <span class="comment">//获取写锁前须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="comment">// Recheck state because another thread might have acquired</span></span><br><span class="line">            <span class="comment">//   write lock and changed state before we did.</span></span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                data = ...</span><br><span class="line">                cacheValid = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">            <span class="comment">//锁降级，在释放写锁前获取读锁</span></span><br><span class="line">            rwl.readLock().lock();</span><br><span class="line">            rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        use(data);</span><br><span class="line">        rwl.readLock().unlock();    <span class="comment">//释放读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="倒计数器：CountDownLatch"><a href="#倒计数器：CountDownLatch" class="headerlink" title="倒计数器：CountDownLatch"></a>倒计数器：CountDownLatch</h2><p><strong>使用场景</strong></p><p>想要做当前事情之前，必须具备前期的若干事件都准备完毕，当前事件才能进行。用程序来说，就是：当前线程处于阻塞状态，必须等到其它的若干线程都运行完毕之后，当前线程才被唤醒得以执行。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrepareEvent</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> CountDownLatch c ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrepareEvent</span><span class="params">(CountDownLatch c)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.c = c ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = (<span class="keyword">long</span>)(Math.random() * <span class="number">5000</span>); <span class="comment">//模拟前期准备事件耗时</span></span><br><span class="line">Thread.sleep(time); </span><br><span class="line">String tName = Thread.currentThread().getName();</span><br><span class="line">System.out.println(tName+<span class="string">&quot;&#x27; working time is: &quot;</span>+time);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">c.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">5</span> ;<span class="comment">//计数5</span></span><br><span class="line">CountDownLatch c = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line"> </span><br><span class="line">Thread[] ts = <span class="keyword">new</span> Thread[count];</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;CountDownLatch init, now count is: &quot;</span>+c.getCount()+<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;because Of await(), main blocking...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=count-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">ts[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrepareEvent(c),<span class="string">&quot;T&quot;</span>+i);</span><br><span class="line">ts[i].start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">c.await();<span class="comment">//这里阻塞,直至计数降为零</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;     \n\rafter await(), main continue...\n\r&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;CountDownLatch used, now count is: &quot;</span>+c.getCount()+<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h2><p><strong>概述：</strong></p><p>CyclicBarrier和CountDownLatch很相似，都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；<strong>而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行</strong>。</p><p>故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每调用一次await()方法都将使阻塞的线程数+1，只有阻塞的线程数达到设定值时屏障才会打开，允许阻塞的所有线程继续执行。除此之外，<strong>CyclicBarrier还有几点需要注意的地方</strong>:</p><ul><li><p>CyclicBarrier的计数器可以重置而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障循环二字的语义所在。</p></li><li><p>CyclicBarrier允许用户自定义barrierAction操作，这是个可选操作，可以在创建CyclicBarrier对象时指定</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &amp;lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦用户在创建CyclicBarrier对象时设置了barrierAction参数，则在阻塞线程数达到设定值屏障打开前，会调用barrierAction的run()方法完成用户自定义的操作。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sleep;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">(String name, <span class="keyword">int</span> sleep)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                <span class="keyword">long</span> starTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="keyword">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> T(<span class="string">&quot;员工&quot;</span> + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">9000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">1000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">2001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">3001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">4001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">6000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">5000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">7999</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">7000</span>(ms),开始吃饭了！</span><br></pre></td></tr></table></figure><blockquote><p>代码中模拟了10个员工上桌吃饭的场景，等待所有员工都到齐了才能开发，可以看到第10个员工最慢，前面的都在等待第10个员工，员工1等待了9秒，上面代码中调用cyclicBarrier.await();会让当前线程等待。当10个员工都调用了cyclicBarrier.await();之后，所有处于等待中的员工都会被唤醒，然后继续运行。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="线程阻塞工具类：LockSupport"><a href="#线程阻塞工具类：LockSupport" class="headerlink" title="线程阻塞工具类：LockSupport"></a>线程阻塞工具类：LockSupport</h2><p><strong>基本方法</strong></p><p>基于Unsafe类中的park和unpark方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park()方法，调用native方法阻塞当前线程</span></span><br><span class="line"><span class="comment">// unpark()方法，唤醒处于阻塞状态的线程Thrread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">      UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadParkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.setName(<span class="string">&quot;mt&quot;</span>);</span><br><span class="line">        mt.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">            mt.park();</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">            mt.unPark();</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">            mt.park();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isPark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; Enter Thread running.....&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPark) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;Thread is Park.....&quot;</span>);</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt; is running&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isPark = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unPark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isPark = <span class="keyword">false</span>;</span><br><span class="line">            LockSupport.unpark(<span class="keyword">this</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is unpark.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enter Thread running.....</span><br><span class="line">mt&gt;&gt; is running</span><br><span class="line">...(省略部分)</span><br><span class="line">mt&gt;&gt; is running</span><br><span class="line">mtThread is Park.....</span><br><span class="line">Thread is unpark.....</span><br><span class="line">mt&gt;&gt; is running</span><br><span class="line">...(省略部分)</span><br><span class="line">mt&gt;&gt; is running</span><br><span class="line">mtThread is Park</span><br></pre></td></tr></table></figure><h2 id="Guava和Ratelimiter限流"><a href="#Guava和Ratelimiter限流" class="headerlink" title="Guava和Ratelimiter限流"></a>Guava和Ratelimiter限流</h2><p>常见的限流算法有：</p><ul><li><p>桶漏算法：漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510112306.jpg" alt="img"></p></li><li><p>令牌桶算法：以规定的速率往令牌桶中存入Token，用户请求必须获取到令牌中的Token才可以处理请求，如果没有从令牌桶中获取到令牌则丢失该请求或让该请求等待。桶的容量是有限的，比如，当令牌没有被消耗掉时，只能累积有限单位时间内的令牌数量。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210510112503.png" alt="img"></p></li></ul><p><strong>两者的区别：</strong></p><p>漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。漏桶算法与令牌桶算法的区别在于：漏桶算法能够强行限制数据的传输速率。令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。</p><p>需要说明的是：在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制</p><p><strong>基于谷歌RateLimiter实现限流</strong></p><blockquote><p>Google的Guava工具包中就提供了一个限流工具类——RateLimiter，本文也是通过使用该工具类来实现限流功能。RateLimiter是基于“令牌通算法”来实现限流的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 表示每秒往令牌桶中存入1个token， 具体根据服务器配置设置</span></span><br><span class="line">  <span class="keyword">private</span> RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 每秒中限制1个请求  0:表示等待超时时间，设置0表示不等待，直接拒绝请求</span></span><br><span class="line"><span class="keyword">boolean</span> tryAcquire = rateLimiter.tryAcquire(<span class="number">0</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire) &#123; <span class="comment">// 如果tryAcquire:false表示没有获取到token</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;现在抢购的人数过多，请稍等一下下哦！&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《实战java高并发》阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口幂等性</title>
      <link href="2021/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>2021/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们实际系统中有很多操作，是不管做多少次，都应该产生一样的效果或返回一样的结果。</p><p>例如：</p><ol><li>前端重复提交选中的数据，应该后台只产生对应这个数据的一个反应结果。</li><li>我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱；</li><li>发送消息，也应该只发一次，同样的短信发给用户，用户会哭的；</li><li>创建业务订单，一次业务请求只能创建一个，创建多个就会出大问题。</li></ol><p>等等很多重要的情况，这些逻辑都需要幂等的特性来支持。</p><h1 id="幂等性概念"><a href="#幂等性概念" class="headerlink" title="幂等性概念"></a>幂等性概念</h1><p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</p><p>这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.</p><p>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><p>我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</p><h1 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h1><p><strong>1. 查询操作</strong> 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p><p><strong>2. 删除操作</strong> 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p><p><strong>3.唯一索引，防止新增脏数据</strong> 比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p><p><strong>要点：</strong> 唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</p><p><strong>4. token机制，防止页面重复提交</strong></p><p>业务要求：</p><p>页面的数据只能被点击提交一次</p><p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p><p>解决办法：集群环境：采用token加redis（redis单线程的，处理需要排队） 单JVM环境：采用token加redis或token加jvm内存</p><p>处理流程：</p><ol><li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li><li>提交后后台校验token，同时删除token，生成新的token返回</li></ol><p>token特点：</p><p>要申请，一次有效性，可以限流</p><p>注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用</p><p><strong>5. 悲观锁</strong> 获取数据的时候加锁获取</p><p>select * from table_xxx where id=’xxx’ for update;</p><p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</p><p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p><p><strong>6. 乐观锁</strong> 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p><p>乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p><p>1、通过版本号实现</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_xxx set name=#name#,version=version+1 where version=#version#</span><br></pre></td></tr></table></figure><p>如下图(来自网上)：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210424181808.jpg" alt="img"></p><p>2、通过条件限制</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tablexxx set avaiamount=avaiamount-#subAmount# where avaiamount-#subAmount# &gt;= 0</span><br></pre></td></tr></table></figure><p>要求：quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高</p><p>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update tablexxx set name=#name#,version=version+1 where id=#id# and version=#version#</span><br><span class="line"></span><br><span class="line">update tablexxx set avaiamount=avaiamount-#subAmount# where id=#id# and avai_amount-#subAmount# &gt;= 0</span><br></pre></td></tr></table></figure><p><strong>7. 分布式锁</strong> 还是拿插入数据的例子，如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定</p><p>这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁</p><p>这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。</p><p>要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</p><p><strong>8. select + insert</strong> 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p><p>注意：核心高并发流程不要用这种方法</p><p><strong>9. 状态机幂等</strong> 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机</p><p>如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p><p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p><p><strong>10. 对外提供接口的api如何保证幂等</strong></p><p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号</p><p>source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p><p><strong>重点</strong>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引</p><p>这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p><p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案</title>
      <link href="2021/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2021/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p>严格意义上的事务实现应该是<strong>具备原子性、一致性、隔离性和持久性</strong>，简称 ACID。</p><ul><li>原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。</li><li>一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有400，我账上有100，你给我打200块，此时你账上的钱应该是200，我账上的钱应该是300，不会存在我账上钱加了，你账上钱没扣的<strong>中间状态</strong>。</li><li>隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。</li><li>持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。</li></ul><p>而通俗意义上事务就是为了使得一些更新操作要么都成功，要么都失败。</p></blockquote><h1 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2PC（Two-phase commit protocol），中文叫二阶段提交。 <strong>二阶段提交是一种强一致性设计</strong>，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。(注意这只是协议或者说是理论指导，只阐述了大方向，具体落地还是有会有差异的)</p><p>两个阶段的具体流程:</p><ul><li><strong>准备阶段</strong>协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完了。</li><li>同步等待所有资源的响应之后就进入第二阶段即<strong>提交阶段</strong>（注意提交阶段不一定是提交事务，也可能是回滚事务）。</li></ul><p>假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。</p><p>流程图：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210424165044.jpg" alt="img"  /><p>假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210424165404.jpg" alt="img"></p><blockquote><p>那可能就有人问了，那第二阶段提交失败的话呢？</p><p>这里有两种情况。</p><p>第一种是<strong>第二阶段执行的是回滚事务操作</strong>，那么答案是不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会一直阻塞着。</p><p>第二种是<strong>第二阶段执行的是提交事务操作</strong>，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。</p><p>大体上二阶段提交的流程就是这样，<strong>我们再来看看细节</strong>。</p><p>首先 2PC 是一个<strong>同步阻塞协议</strong>，像第一阶段协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的<strong>协调者有超时机制</strong>，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令。</p><p>在第二阶段协调者的没法超时，因为按照我们上面分析只能不断重试！</p></blockquote><h2 id="协调者故障分析"><a href="#协调者故障分析" class="headerlink" title="协调者故障分析"></a>协调者故障分析</h2><p>具体查看参考文献<a href="https://zhuanlan.zhihu.com/p/183753774">面试必问：分布式事务六种解决方案</a></p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li><p>2PC 是一种<strong>尽量保证强一致性</strong>的分布式事务，因此它是<strong>同步阻塞</strong>的， 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p></li><li><p>单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</p></li><li><p>数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p></li><li><p>太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制</p></li><li><p>2PC 适用于<strong>数据库层面的分布式事务场景</strong>，而我们业务需求有时候不仅仅关乎数据库，也有可能是上传一张图片或者发送一条短信。</p><p>而且像 Java 中的 JTA 只能解决一个应用下多数据库的分布式事务问题，跨服务了就不能用了。</p></li></ul><h1 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在<strong>参与者中也引入了超时机制</strong>，并且<strong>新增了一个阶段</strong>使得参与者可以利用这一个阶段统一各自的状态。</p><p>3PC 包含了三个阶段，分别是<strong>准备阶段、预提交阶段和提交阶段</strong>，对应的英文就是：<code>CanCommit、PreCommit 和 DoCommit</code>。</p><p>看起来是<strong>把 2PC 的提交阶段变成了预提交阶段和提交阶段</strong>，但是 3PC 的准备阶段协调者只是询问参与者的自身状况，比如你现在还好吗？负载重不重？这类的。</p><p>而预提交阶段就是和 2PC 的准备阶段一样，除了事务的提交该做的都做了。</p><p>提交阶段和 2PC 的一样，让我们来看一下图。</p><p><img src="https://pic3.zhimg.com/80/v2-885daf4ba34102d6e1047b0b67910652_720w.jpg" alt="img"></p><blockquote><p>不管哪一个阶段有参与者返回失败都会宣布事务失败，这和 2PC 是一样的（当然到最后的提交阶段和 2PC 一样只要是提交请求就只能不断重试）。</p></blockquote><h2 id="3PC-的阶段变更带来的影响"><a href="#3PC-的阶段变更带来的影响" class="headerlink" title="3PC 的阶段变更带来的影响"></a>3PC 的阶段变更带来的影响</h2><p>首先<strong>准备阶段的变更成不会直接执行事务</strong>，而是会先去询问此时的参与者是否有条件接这个事务，因此<strong>不会一来就干活直接锁资源</strong>，使得在某些资源不可用的情况下所有参与者都阻塞着。</p><p>而<strong>预提交阶段的引入起到了一个统一状态的作用</strong>，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。</p><p>假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。</p><p>但是多引入一个阶段也多一个交互，因此<strong>性能会差一些</strong>，而且<strong>绝大部分的情况下资源应该都是可用的</strong>，这样等于每次明知可用执行还得询问一次。</p><h2 id="参与者超时能带来的影响"><a href="#参与者超时能带来的影响" class="headerlink" title="参与者超时能带来的影响"></a>参与者超时能带来的影响</h2><p>我们知道 2PC 是同步阻塞的，上面我们已经分析了协调者挂在了提交请求还未发出去的时候是最伤的，所有参与者都已经锁定资源并且阻塞等待着。</p><p>那么引入了超时机制，参与者就不会傻等了，<strong>如果是等待提交命令超时，那么参与者就会提交事务了</strong>，因为都到了这一阶段了大概率是提交的，<strong>如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干</strong>。</p><p>然而超时机制也会带来数据不一致的问题，比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是<strong>有可能执行的是回滚操作，这样一来数据就不一致了</strong>。</p><p>当然 3PC 协调者超时还是在的，具体不分析了和 2PC 是一样的。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。新协调者来的时候发现有一个参与者处于预提交或者提交阶段，那么表明已经经过了所有参与者的确认了，所以此时执行的就是提交命令。所以说 3PC 就是通过引入预提交阶段来使得参与者之间的状态得到统一，也就是留了一个阶段让大家同步一下。</p><p>但是这也只能让协调者知道该如果做，但不能保证这样做一定对，这其实和上面 2PC 分析一致，因为挂了的参与者到底有没有执行事务无法断定。所以说 3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但是不能保证数据一致，除非挂了的那个参与者恢复。</p><p><strong>总结</strong>， 3PC 相对于 2PC 做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。</p><p>所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。</p><p>3PC 只是纯的理论上的东西，而且可以看到相比于 2PC 它是做了一些努力但是效果甚微，所以只做了解即可。</p><h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><strong>2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务</strong>，就像我前面说的分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了！</p><p>TCC 指的是<code>Try - Confirm - Cancel</code>。</p><ul><li>Try 指的是预留，即资源的预留和锁定，<strong>注意是预留</strong>。</li><li>Confirm 指的是确认操作，这一步其实就是真正的执行了。</li><li>Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。</li></ul><p>其实从思想上看和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。</p><p>比如说一个事务要执行A、B、C三个操作，那么先对三个操作执行预留动作。如果都预留成功了那么就执行确认操作，如果有一个预留失败那就都执行撤销动作。</p><p>我们来看下流程，TCC模型还有个事务管理者的角色，用来记录TCC全局事务状态并提交或者回滚事务。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210424171526.jpg" alt="img"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>可以看到流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应<code>Try - Confirm - Cancel</code>。</p><p>因此 <strong>TCC 对业务的侵入较大和业务紧耦合</strong>，需要根据特定的场景和业务逻辑来设计相应的操作。</p><p>还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证<strong>操作的幂等</strong>。</p><p>相对于 2PC、3PC ，TCC 适用的范围更大，但是开发量也更大，毕竟都在业务上实现，而且有时候你会发现这三个方法还真不好写。不过也因为是在业务上实现的，所以<strong>TCC可以跨数据库、跨不同的业务系统来实现事务</strong>。</p><h1 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>本地消息表其实就是利用了 <strong>各系统本地的事务</strong>来实现分布式事务。</p><p>本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 <strong>将业务的执行和将消息放入消息表中的操作放在同一个事务中</strong>，这样就能保证消息放入本地表中业务肯定是执行成功的。</p><p>然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。</p><p>如果调用失败也没事，会有 <strong>后台任务定时去读取本地消息表</strong>，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。</p><p>这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。</p><p>可以看到本地消息表其实实现的是<strong>最终一致性</strong>，容忍了数据暂时不一致的情况。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</p><p>缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><h1 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。</p><p>第一步先给 Broker 发送事务消息即半消息，<strong>半消息不是说一半消息，而是这个消息对消费者来说不可见</strong>，然后<strong>发送成功后发送方再执行本地事务</strong>。</p><p>再根据<strong>本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令</strong>。</p><p>并且 RocketMQ 的发送方会提供一个<strong>反查事务状态接口</strong>，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。</p><p>如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。</p><p>如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。</p><p>可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210424172028.jpg" alt="img"></p><p>可以看到消息事务实现的也是最终一致性。</p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点： 实现了最终一致性，不需要依赖本地数据库事务。</p><p>缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。</p><blockquote><p>本地消息表 和 消息事务 更详细的说明可参考该链接<a href="https://blog.csdn.net/hosaos/article/details/108644527">https://blog.csdn.net/hosaos/article/details/108644527</a></p></blockquote><h1 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h1><p>其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。</p><p>就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。</p><p>事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。</p><p>所以<strong>最大努力通知其实只是表明了一种柔性事务的思想</strong>：我已经尽力我最大的努力想达成事务的最终一致了。</p><p>适用于对时间不敏感的业务，例如短信通知。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。</p><p>而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。</p><p>本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/183753774">面试必问：分布式事务六种解决方案</a></p><p><a href="https://www.cnblogs.com/mayundalao/p/11798502.html">分布式事务的四种解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot事务失效的原因和解决方案</title>
      <link href="2021/04/24/spring/Springboot%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2021/04/24/spring/Springboot%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="Transactional介绍"><a href="#Transactional介绍" class="headerlink" title="@Transactional介绍"></a>@Transactional介绍</h2><ul><li><code>@Transactional</code>是声明式事务的注解，可以被标记在<code>类上</code>、<code>接口</code>、<code>方法</code>上。</li><li>该注解中有很多值得深入了解的几种属性，我们来看一下。</li></ul><h3 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h3><ul><li>指定事务管理器，值为<code>bean</code>的名称，这个主要用于多事务管理器情况下指定。比如多数据源配置的情况下。</li></ul><h3 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h3><ul><li>事务的隔离级别，默认是<code>Isolation.DEFAULT</code>。</li><li>几种值的含义如下：<ul><li><code>Isolation.DEFAULT</code>：事务默认的隔离级别，使用数据库默认的隔离级别。</li><li><code>Isolation.READ_UNCOMMITTED</code>：这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。</li><li><code>Isolation.READ_COMMITTED</code>：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。</li><li><code>Isolation.REPEATABLE_READ</code>：这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。</li><li><code>Isolation.SERIALIZABLE</code>：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。</li></ul></li></ul><h3 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h3><ul><li>代表事务的传播行为，默认值为<code>Propagation.REQUIRED</code>。</li><li><code>Propagation.REQUIRED</code>：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。比如A方法内部调用了B方法，此时B方法将会使用A方法的事务。</li><li><code>Propagation.MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常。</li><li><code>Propagation.NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>Propagation.REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起。比如A方法使用默认的事务传播属性，B方法使用<code>REQUIRES_NEW</code>，此时A方法在内部调用B方法，一旦A方法出现异常，A方法中的事务回滚了，但是B方法并没有回滚，因为A和B方法使用的不是同一个事务，B方法新建了一个事务。</li><li><code>Propagation.NESTED</code>：支持当前事务，新增<code>Savepoint</code>点，也就是在进入子事务之前，父事务建立一个回滚点，与当前事务同步提交或回滚。 子事务是父事务的一部分，在父事务还未提交时，子事务一定没有提交。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</li></ul><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul><li>事务的超时时间，单位为秒。</li></ul><h3 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h3><ul><li>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。如果一个事务只涉及到只读，可以设置为true。</li></ul><h3 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h3><ul><li>用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</li><li>默认是在<code>RuntimeException</code>和<code>Error</code>上回滚。</li></ul><h3 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a>noRollbackFor</h3><ul><li>抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</li></ul></blockquote><h1 id="问题1-方法中调用同类的方法"><a href="#问题1-方法中调用同类的方法" class="headerlink" title="问题1-方法中调用同类的方法"></a>问题1-方法中调用同类的方法</h1><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><ul><li>简单的说就是<strong>一个类中</strong>的<code>A方法</code>（未标注声明式事务）在内部调用了<code>B方法</code>(标注了声明式事务)，这样会导致B方法中的事务失效。</li><li>代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入一条数据</span></span><br><span class="line">    <span class="comment">//调用B方法</span></span><br><span class="line">    B();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>为什么会失效呢？</strong>：其实原因很简单，Spring在扫描Bean的时候会自动为标注了<code>@Transactional</code>注解的类生成一个代理类（proxy）,当有注解的方法被调用的时候，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务的操作，但是同类中的方法互相调用，相当于<code>this.B()</code>，此时的B方法并非是代理类调用，而是直接通过原有的Bean直接调用，所以注解会失效。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>知道原因之后就好解决了，想办法获取该类的代理类，通过代理类来调用B方法就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入一条数据</span></span><br><span class="line">    <span class="comment">//调用B方法</span></span><br><span class="line">    ((FileService)AopContext.currentProxy()).B();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>加入后运行会报个错，需要你设置exposeProxy = true<br>在该类上加个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span>  <span class="comment">//暴露代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就能正常回滚</p><h1 id="问题2-异常被捕获了"><a href="#问题2-异常被捕获了" class="headerlink" title="问题2-异常被捕获了"></a>问题2-异常被捕获了</h1><h2 id="问题概述-1"><a href="#问题概述-1" class="headerlink" title="问题概述"></a>问题概述</h2><p>在整个事务的方法中使用<code>try-catch</code>，导致异常无法抛出，自然会导致事务失效。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//插入一条数据</span></span><br><span class="line">    <span class="comment">//更改一条数据</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题3-在非public修饰的方法使用"><a href="#问题3-在非public修饰的方法使用" class="headerlink" title="问题3-在非public修饰的方法使用"></a>问题3-在非public修饰的方法使用</h1><h2 id="问题概述-2"><a href="#问题概述-2" class="headerlink" title="问题概述"></a>问题概述</h2><p>@Transactional注解使用的是AOP，在使用动态代理的时候只能针对<code>public</code>方法进行代理，源码依据在<code>AbstractFallbackTransactionAttributeSource</code>类中的<code>computeTransactionAttribute</code>方法中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题4-propagation属性设置错误"><a href="#问题4-propagation属性设置错误" class="headerlink" title="问题4-propagation属性设置错误"></a>问题4-propagation属性设置错误</h1><h2 id="问题概述-3"><a href="#问题概述-3" class="headerlink" title="问题概述"></a>问题概述</h2><p>事务的传播属性在上面已经介绍了，默认的事务传播属性是<code>Propagation.REQUIRED</code>，但是一旦配置了错误的传播属性，也是会导致事务失效，如下三种配置将会导致事务失效：</p><ul><li>Propagation.SUPPORTS</li><li>Propagation.NOT_SUPPORTED</li><li>Propagation.NEVER</li></ul><blockquote><p><strong>propagation</strong></p><ul><li>代表事务的传播行为，默认值为<code>Propagation.REQUIRED</code>。</li><li><code>Propagation.REQUIRED</code>：如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。比如A方法内部调用了B方法，此时B方法将会使用A方法的事务。</li><li><code>Propagation.MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常。</li><li><code>Propagation.NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>Propagation.REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起。比如A方法使用默认的事务传播属性，B方法使用<code>REQUIRES_NEW</code>，此时A方法在内部调用B方法，一旦A方法出现异常，A方法中的事务回滚了，但是B方法并没有回滚，因为A和B方法使用的不是同一个事务，B方法新建了一个事务。</li><li><code>Propagation.NESTED</code>：支持当前事务，新增<code>Savepoint</code>点，也就是在进入子事务之前，父事务建立一个回滚点，与当前事务同步提交或回滚。 子事务是父事务的一部分，在父事务还未提交时，子事务一定没有提交。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</li></ul></blockquote><h1 id="问题5-rollbackFor属性或noRollbackFor属性设置错误"><a href="#问题5-rollbackFor属性或noRollbackFor属性设置错误" class="headerlink" title="问题5-rollbackFor属性或noRollbackFor属性设置错误"></a>问题5-rollbackFor属性或noRollbackFor属性设置错误</h1><h2 id="问题概述-4"><a href="#问题概述-4" class="headerlink" title="问题概述"></a>问题概述</h2><ul><li>rollbackFor很容易理解，指定异常触发回滚，一旦设置错误，导致一些异常不能触发回滚，此时的声明式事务不就失效了吗。</li><li>这个和rollbackFor属性设置错误类似，一旦设置错误，也会导致异常不能触发回滚，此时的声明式事务会失效。</li></ul><h1 id="问题6-底层数据库引擎不支持事务"><a href="#问题6-底层数据库引擎不支持事务" class="headerlink" title="问题6-底层数据库引擎不支持事务"></a>问题6-底层数据库引擎不支持事务</h1><h2 id="问题概述-5"><a href="#问题概述-5" class="headerlink" title="问题概述"></a>问题概述</h2><p>如果数据库引擎不支持事务，则Spring自然无法支持事务。</p><h1 id="问题7-本地事务在分布式情况下的问题"><a href="#问题7-本地事务在分布式情况下的问题" class="headerlink" title="问题7-本地事务在分布式情况下的问题"></a>问题7-本地事务在分布式情况下的问题</h1><h2 id="问题概述-6"><a href="#问题概述-6" class="headerlink" title="问题概述"></a>问题概述</h2><p>假设服务A一个添加了@Transactional注解的服务类中存在两个远程调用服务B和C（先调用B，后调用C）的方法（该方法本身也标记了@Transactional注解，也是事务）</p><ul><li>B运行成功但是由于网络故障等原因没有返回，导致A认为B运行失败，则A回滚但是B已经运行成功不会回滚，造成数据不一致</li><li>B运行成功且成功返回，但是在调用C的时候出现问题，这时C因为本身的事务性回滚，A中因为C出现问题导致远程调用失败也回滚，但是B由于是远程调用是不会回滚的，导致出现数据不一致问题</li></ul><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://icbtbo.github.io/2021/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">使用分布式事务的解决方案</a>，例如可以使用基于2pc的seata。</p>]]></content>
      
      
      <categories>
          
          <category> spirngboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Apache 的 FastDateFormat 代替 JDK 的 SimpleDateFormat，提升性能</title>
      <link href="2021/04/22/java/%E4%BD%BF%E7%94%A8Apache%E7%9A%84FastDateFormat%E4%BB%A3%E6%9B%BFJDK%E7%9A%84%20SimpleDateFormat%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD/"/>
      <url>2021/04/22/java/%E4%BD%BF%E7%94%A8Apache%E7%9A%84FastDateFormat%E4%BB%A3%E6%9B%BFJDK%E7%9A%84%20SimpleDateFormat%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="SimpleDateFormat-的问题"><a href="#SimpleDateFormat-的问题" class="headerlink" title="SimpleDateFormat 的问题"></a>SimpleDateFormat 的问题</h2><p>在 Java 中，格式化日期通常使用 SimpleDateFormat 这个类(JDK提供的)。</p><p>我们知道，SimpleDateFormat 是线程不安全的，<strong>SimpleDateFormat</strong>在对时间进行格式化的方法format中，会先对<strong>calendar</strong>对象进行setTime的赋值，若是有多个线程同时操作一个SimpleDateFormat实例的话，就会对calendar的赋值进行覆盖，进而产生问题。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(date, <span class="keyword">new</span> StringBuffer(), DontCareFieldPosition.INSTANCE).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called from Format after creating a FieldDelegate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo, FieldDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Convert input date to time field list</span></span><br><span class="line">    calendar.setTime(date);</span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法：</p><ol><li>线程1调用format方法，改变了calendar这个字段。</li><li>中断来了。</li><li>线程2开始执行，它也改变了calendar。</li><li>又中断了。</li><li>线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。</li></ol><p>​       分析一下format的实现，我们不难发现，用到成员变量calendar，唯一的好处，就是在调用subFormat时，少了一个参数，却带来了这许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。<br>　　这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的</p><p>所以，大部分时候则是在方法内部 new 出新的 DateFormat 对象再做格式化，如：<code>DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</code>。但在高访问量的情况下，频繁创建实例也会导致内存开销大和 GC 频繁问题。</p><h2 id="FastDateFormat"><a href="#FastDateFormat" class="headerlink" title="FastDateFormat"></a>FastDateFormat</h2><p>Apache 的 commons-lang 包下有个 FastDateFormat 可以方便的解决上述问题。</p><p>查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FastDatePrinter#format</span></span><br><span class="line"><span class="comment">  可以看到底层用的是Calendar</span></span><br><span class="line"><span class="comment">  因为是在方法体内定义了了Calendar，而方法体内的局部变量是属于栈的</span></span><br><span class="line"><span class="comment">  而栈是线程独享的，不存在线程安全问题</span></span><br><span class="line"><span class="comment">  而SimpleDateFormat 用到的Calendar是成员变量，可以被多个线程共享，所以存在线程安全问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">    Calendar c = <span class="keyword">new</span> GregorianCalendar(mTimeZone, mLocale);</span><br><span class="line">    c.setTime(date);</span><br><span class="line">    <span class="keyword">return</span> applyRules(c, <span class="keyword">new</span> StringBuffer(mMaxLengthEstimate)).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的版本（3.0 以上）中 getInstance 方法内更加使用 ConcurrentMap 做缓存提高并发性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.0 版本源码</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatCache</span>&lt;<span class="title">F</span> <span class="keyword">extends</span> <span class="title">Format</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;MultipartKey, F&gt; cInstanceCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;MultipartKey, String&gt; cDateTimeInstanceCache;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FormatCache&lt;FastDateFormat&gt; cache = <span class="keyword">new</span> FormatCache() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FastDateFormat <span class="title">createInstance</span><span class="params">(String pattern, TimeZone timeZone, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastDateFormat(pattern, timeZone, locale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FastDateFormat <span class="title">getInstance</span><span class="params">(String pattern, TimeZone timeZone, Locale locale)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (FastDateFormat)cache.getInstance(pattern, timeZone, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DateFormatUtils"><a href="#DateFormatUtils" class="headerlink" title="DateFormatUtils"></a>DateFormatUtils</h2><p>基于上面 FastDateFormat 类，commons-lang 包还提供了 DateFormatUtils 工具类，提供了两方面的功能：</p><ol><li>提供静态的 format 方法，实现一行代码格式化日期。</li><li>内部初始化了一些 final 的 FastDateFormat，方便开发者直接调用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日期格式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot-定时任务Schedule</title>
      <link href="2021/04/22/spring/springboot-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Schedule/"/>
      <url>2021/04/22/spring/springboot-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Schedule/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在日常项目运行中，我们总会有需求在某一时间段周期性的执行某个动作。比如每天在某个时间段导出报表，或者每隔多久统计一次现在在线的用户量。在springboot中可以有很多方案去帮我们完成定时器的工作，有Java自带的java.util.Timer类，也有强大的调度器Quartz，还有SpringBoot自带的Scheduled，今天主要介绍Scheduled和Springboot整合quartz。</p></blockquote><h1 id="Spring-Schedule-实现定时任务"><a href="#Spring-Schedule-实现定时任务" class="headerlink" title="Spring Schedule 实现定时任务"></a>Spring Schedule 实现定时任务</h1><p>Spring Schedule 实现定时任务有两种方式 1. 使用XML配置定时任务， 2. 使用 @Scheduled 注解。 因为是Spring Boot 项目 ，要尽量避免使用XML配置的形式，因此主要说注解的形式。</p><p>三种定时方式演示代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、fixedDelay控制方法执行的间隔时间，是以上一次方法执行完开始算起，如上一次方法执行阻塞住了，那么直到上一次执行完，</span></span><br><span class="line"><span class="comment">并间隔给定的时间后，执行下一次。</span></span><br><span class="line"><span class="comment">2、fixedRate是按照一定的速率执行，是从上一次方法执行开始的时间算起，如果上一次方法阻塞住了，下一次也是不会执行，</span></span><br><span class="line"><span class="comment">但是在阻塞这段时间内累计应该执行的次数，当不再阻塞时，一下子把这些全部执行掉，而后再按照固定速率继续执行。</span></span><br><span class="line"><span class="comment">3、cron表达式可以定制化执行任务，但是执行的方式是与fixedDelay相近的，也是会按照上一次方法结束时间开始算起。</span></span><br><span class="line"><span class="comment">4、initialDelay 。如： <span class="doctag">@Scheduled</span>(initialDelay = 10000,fixedRate = 15000,这个定时器就是在上一个的基础上加了一个</span></span><br><span class="line"><span class="comment">initialDelay = 10000 意思就是在容器启动后,延迟10秒后再执行一次定时器,以后每15秒再执行一次该定时器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SECOND = <span class="number">1000</span>;</span><br><span class="line">    FastDateFormat fdf = FastDateFormat.getInstance(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定等待时间 <span class="doctag">@Scheduled</span>(fixedDelay = 时间间隔 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = SECOND*2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedDelayJob</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[FixedRateJob Execute]&quot;</span>+fdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 固定间隔时间 <span class="doctag">@Scheduled</span>(fixedRate = 时间间隔 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = SECOND * 4)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedRateJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[FixedRateJob Execute]&quot;</span>+fdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Corn表达式 <span class="doctag">@Scheduled</span>(cron = Corn表达式)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/4 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cronJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[CronJob Execute]&quot;</span>+fdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类上添加注解 <code>@EnableScheduling</code>然后运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[FixedRateJob Execute]2021-04-22 14:35:15</span><br><span class="line">[FixedDelayJob Execute]2021-04-22 14:35:17</span><br><span class="line">[CronJob Execute]2021-04-22 14:35:19</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:21</span><br><span class="line">[FixedDelayJob Execute]2021-04-22 14:35:23</span><br><span class="line">[CronJob Execute]2021-04-22 14:35:25</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:27</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:29</span><br><span class="line">[FixedDelayJob Execute]2021-04-22 14:35:31</span><br><span class="line">[CronJob Execute]2021-04-22 14:35:33</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:35</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:37</span><br><span class="line">[FixedDelayJob Execute]2021-04-22 14:35:39</span><br><span class="line">[CronJob Execute]2021-04-22 14:35:41</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:43</span><br><span class="line">[FixedRateJob Execute]2021-04-22 14:35:45</span><br></pre></td></tr></table></figure><h1 id="Springboot-整合-quartz"><a href="#Springboot-整合-quartz" class="headerlink" title="Springboot 整合 quartz"></a>Springboot 整合 quartz</h1><h2 id="quartz-简介"><a href="#quartz-简介" class="headerlink" title="quartz 简介"></a>quartz 简介</h2><ol><li><p>Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，完全由Java开发，可以用来执行定时任务，类似于java.util.Timer。但是相较于Timer， Quartz增加了很多功能：</p><ul><li>持久性作业 - 就是保持调度定时的状态;</li><li>作业管理 - 对调度作业进行有效的管理;</li></ul></li><li><p>Quartz有3个核心要素：调度器(Scheduler)、任务(Job)、触发器(Trigger)</p><ul><li>Job（任务）：是一个接口，有一个方法void execute()，可以通过实现该接口来定义需要执行的任务（具体的逻辑代码）。</li><li>JobDetail:Quartz每次执行job时，都重新创建一个Job实例，会接收一个Job实现类，以便运行的时候通过newInstance()的反射调用机制去实例化Job.JobDetail是用来描述Job实现类以及相关静态信息，比如任务在scheduler中的组名等信息。</li><li>Trigger（触发器）：描述触发Job执行的时间触发规则实现类SimpleTrigger和CronTrigger可以通过crom表达式定义出各种复杂的调度方案。</li><li>Calendar：是一些日历特定时间的集合。一个Trigger可以和多个 calendar关联,比如每周一早上10:00执行任务，法定假日不执行，则可以通过calendar进行定点排除。</li><li>Scheduler（调度器）：代表一个Quartz的独立运行容器。Trigger和JobDetail可以注册到Scheduler中。Scheduler可以将Trigger绑定到某一JobDetail上，这样当Trigger被触发时，对应的Job就会执行。一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job.</li></ul></li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring boot集成quartz--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为了使用FastDateFormat, jdk自带的dataformat是线程不安全的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>项目结构</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210422152644.png" alt="image-20210422152644251"></p></li><li><p>DateTimeJob.java(具体的业务逻辑代码写在这里)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException</span>&#123;</span><br><span class="line">        <span class="comment">//获取JobDetail中关联的数据</span></span><br><span class="line">        String msg = (String) jobExecutionContext.getJobDetail().getJobDataMap().get(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;current time :&quot;</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()) + <span class="string">&quot;---&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>QuartzConfig.java（配置类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">printTimeJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(DateTimeJob.class)<span class="comment">//PrintTimeJob我们的业务类</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;DateTimeJob&quot;</span>)<span class="comment">//可以给该JobDetail起一个id</span></span><br><span class="line">                <span class="comment">//每个JobDetail内都有一个Map，包含了关联到这个Job的数据，在Job类中可以通过context获取</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello Quartz&quot;</span>)<span class="comment">//关联键值对</span></span><br><span class="line">                .storeDurably()<span class="comment">//即使没有Trigger关联时，也不需要删除该JobDetail</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">printTimeJobTrigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/1 * * * * ?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(printTimeJobDetail())<span class="comment">//关联上述的JobDetail</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;quartzTaskService&quot;</span>)<span class="comment">//给Trigger起个名字</span></span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210422152447.png" alt="image-20210422152447097"></p></li></ol><h1 id="cron-详细说明"><a href="#cron-详细说明" class="headerlink" title="cron 详细说明"></a>cron 详细说明</h1><p>cron表达式，有专门的语法，而且感觉有点绕人，不过我们只要记住一些常用的用法即可</p><p>cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：</p><ul><li>第一位，表示秒，取值0-59</li><li>第二位，表示分，取值0-59</li><li>第三位，表示小时，取值0-23</li><li>第四位，日期天/日，取值1-31</li><li>第五位，日期月份，取值1-12</li><li>第六位，星期，取值1-7，星期一，星期二…，注：不是第1周，第二周的意思 另外：1表示星期天，2表示星期一。</li><li>第七位，年份，可以留空，取值1970-2099</li></ul><blockquote><p><strong>注意</strong>：此处介绍的是quartz中cron的语法。 而Spring Schedule 中的cron语法有一些不同的地方，主要有两点：</p><ol><li>Spring Schedule  中 cron 表达式必须由6位组成，也就是没有year着一位</li><li>Spring Schedule  中 cron 表达式中第六位其值 1，2，3，4，5，6，7分别表示 “MON,TUE,WED,THU,FRI,SAT,SUN”；0也表示SUN</li></ol><p>其他地方一致</p></blockquote><p>cron 中还有一些特殊符号，含义如下：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...</span><br><span class="line">(?)问号：问号只能出现在日期和星期这两个位置，表示这个位置的值不确定，每天3点执行，所以第六位星期的位置，我们是不需要关注的，就是不确定的值。同时：日期和星期是两个相互排斥的元素，通过问号来表明不指定值。比如，1月10日，比如是星期1，如果在星期的位置是另指定星期二，就前后冲突矛盾了。</span><br><span class="line">(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12</span><br><span class="line">(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四</span><br><span class="line">(&#x2F;)斜杠：如：x&#x2F;y，x是开始值，y是步长，比如在第一位（秒） 0&#x2F;15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*&#x2F;y，等同于0&#x2F;y</span><br></pre></td></tr></table></figure></blockquote><p>一些样例：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&quot;0 0 12 * * ?&quot; 每天中午12点触发 </span><br><span class="line">&gt;&quot;0 15 10 ? * *&quot; 每天上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 * * ?&quot; 每天上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 * * ? *&quot; 每天上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 </span><br><span class="line">&gt;&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 </span><br><span class="line">&gt;&quot;0 0&#x2F;5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 </span><br><span class="line">&gt;&quot;0 0&#x2F;5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </span><br><span class="line">&gt;&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 </span><br><span class="line">&gt;&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 </span><br><span class="line">&gt;&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 </span><br><span class="line">&gt;&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">&gt;&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发 </span><br><span class="line">&gt;每隔5秒执行一次：*&#x2F;5 * * * * ?</span><br><span class="line">&gt;每隔1分钟执行一次：0 *&#x2F;1 * * * ?</span><br><span class="line">&gt;每天23点执行一次：0 0 23 * * ?</span><br><span class="line">&gt;每天凌晨1点执行一次：0 0 1 * * ?</span><br><span class="line">&gt;每月1号凌晨1点执行一次：0 0 1 1 * ?</span><br><span class="line">&gt;每月最后一天23点执行一次：0 0 23 L * ?</span><br><span class="line">&gt;每周星期天凌晨1点实行一次：0 0 1 ? * L</span><br></pre></td></tr></table></figure></blockquote><p><a href="https://tool.lu/crontab/">cron表达式在线生成网站</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发下应关注的点</title>
      <link href="2021/04/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%BA%94%E5%85%B3%E6%B3%A8%E7%9A%84%E7%82%B9/"/>
      <url>2021/04/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%BA%94%E5%85%B3%E6%B3%A8%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210421204815.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210421204825.png"></p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在企业发展初期，企业使用的系统很少，通常一个或者两个，每个系统都有自己的登录模块，运营人员每天用自己的账号登录，很方便。</p><p>但随着企业的发展，用到的系统随之增多，运营人员在操作不同的系统时，需要多次登录，而且每个系统的账号都不一样，这对于运营人员来说，很不方便。于是，就想到是不是可以在一个系统登录，其他系统就不用登录了呢？这就是单点登录要解决的问题。</p><p>单点登录英文全称Single Sign On，简称就是SSO。它的解释是：**在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417100441.png" alt="image-20210417100441837"></p><p>如图所示，图中有4个系统，分别是Application1、Application2、Application3、和SSO。Application1、Application2、Application3没有登录模块，而SSO只有登录模块，没有其他的业务模块，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了。这完全符合我们对单点登录（SSO）的定义。</p><h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><p>在说单点登录（SSO）的技术实现之前，我们先说一说普通的登录认证机制。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417100605.png" alt="image-20210417100605716"></p><p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p><h2 id="同域下的单点登录"><a href="#同域下的单点登录" class="headerlink" title="同域下的单点登录"></a>同域下的单点登录</h2><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p><p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p><ul><li>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</li><li>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417100843.png" alt="image-20210417100843913"></p><p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。<strong>我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</strong></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p><p>同域下的单点登录就实现了，但这还不是真正的单点登录。</p><h2 id="不同域下的单点登录"><a href="#不同域下的单点登录" class="headerlink" title="不同域下的单点登录"></a>不同域下的单点登录</h2><p>同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？</p><p>这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417101814.webp"></p><p>上图是CAS官网上的标准流程，具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统，<strong>以后图中的CAS Server我们统一叫做SSO系统。</strong> SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。</li><li>app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。</li><li>验证通过后，app系统将登录状态写入session并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO。</li><li>由于SSO已经登录了（第一次在CAS server登录成功后在浏览器写入了相关的cookie），不需要重新登录认证。</li><li>SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。</li><li>app2拿到ST，后台访问SSO，验证ST是否有效。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。</p><p><strong>有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？</strong></p><p><strong>其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li><strong>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</strong></li><li><strong>各个业务系统获得的信息是，这个用户能不能访问我的资源。</strong></li><li><strong>单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</strong></li></ul><p>原文链接：<a href="https://www.jianshu.com/p/75edcc05acfd">https://www.jianshu.com/p/75edcc05acfd</a></p>]]></content>
      
      
      <categories>
          
          <category> 登录认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单点登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转发和重定向的区别和使用</title>
      <link href="2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在Servlet中实现页面的跳转有两种方式：转发和重定向</p><h1 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>由服务器端进行的页面跳转</p><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417095250.png" alt="在这里插入图片描述"></p><p>转发的方法：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417095353.png" alt="在这里插入图片描述"></p><h2 id="转发的特点"><a href="#转发的特点" class="headerlink" title="转发的特点"></a>转发的特点</h2><ol><li>地址栏不发生变化，显示的是上一个页面的地址</li><li>请求次数：只有1次请求</li><li>根目录：<a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80/%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80">http://localhost:8080/项目地址/，包含了项目的访问地址</a></li><li>请求域中数据不会丢失</li></ol><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>由浏览器端进行的页面跳转</p><h2 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h2><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417095610.png" alt="在这里插入图片描述"></p><p>重定向方法：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417095626.png" alt="在这里插入图片描述"></p><h2 id="重定向的特点"><a href="#重定向的特点" class="headerlink" title="重定向的特点"></a>重定向的特点</h2><ol><li>地址栏：显示新的地址</li><li>请求次数：2次</li><li>根目录：<a href="http://localhost:8080/">http://localhost:8080/</a> 没有项目的名字</li><li>请求域中的数据会丢失，因为是2次请求</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="重定向和转发的区别"><a href="#重定向和转发的区别" class="headerlink" title="重定向和转发的区别"></a>重定向和转发的区别</h2><table><thead><tr><th><strong>区别</strong></th><th><strong>转发forward()</strong></th><th><strong>重定向sendRedirect()</strong></th></tr></thead><tbody><tr><td><strong>根目录</strong></td><td>包含项目访问地址</td><td>没有项目访问地址</td></tr><tr><td><strong>地址栏</strong></td><td>不会发生变化</td><td>会发生变化</td></tr><tr><td><strong>哪里跳转</strong></td><td>服务器端进行的跳转</td><td>浏览器端进行的跳转</td></tr><tr><td><strong>请求域中数据</strong></td><td>不会丢失</td><td>会丢失</td></tr></tbody></table><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li><p>问：什么时候使用转发，什么时候使用重定向？</p><p>如果要保留请求域中的数据，使用转发，否则使用重定向。</p><p>以后访问数据库，增删改使用重定向，查询使用转发。</p></li><li><p>问：转发或重定向后续的代码是否还会运行？</p><p>无论转发或重定向后续的代码都会执行</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转发和重定向 </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式session解决方案</title>
      <link href="2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8Fsession%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2021/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8Fsession%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>cookie和session的区别和联系</strong></p><p>cookie是本地客户端用来存储少量数据信息的，保存在客户端，用户能够很容易的获取，安全性不高，存储的数据量小，通常用来存储一些不敏感的信息<br>session是服务器用来存储部分数据信息，保存在服务器，用户不容易获取，安全性高，储存的数据量相对大，存储在服务器，会占用一些服务器资源，但是对于它的优点来说，这个缺点可以忽略了</p><p><strong>session有什么用</strong></p><p>在一次客户端和服务器为之间的会话中，客户端(浏览器)向服务器发送请求，首先cookie会自动携带上次请求存储的数据(JSESSIONID)到服务器，服务器根据请求参数中的JSESSIONID到服务器中的session库中查询是否存在此JSESSIONID的信息，如果存在，那么服务器就知道此用户是谁，如果不存在，就会创建一个JSESSIONID，并在本次请求结束后将JSESSIONID返回给客户端，同时将此JSESSIONID在客户端cookie中进行保存</p><p>客户端和服务器之间是通过http协议进行通信，但是http协议是无状态的，不同次请求会话是没有任何关联的，但是优点是处理速度快</p><p>session是一次浏览器和服务器的交互的会话，当浏览器关闭的时候，会话就结束了，但是会话session还在，默认session是还保留30分钟的</p><p><strong>分布式session一致性</strong><br>客户端发送一个请求，经过负载均衡后该请求会被分配到服务器中的其中一个，由于不同服务器含有不同的web服务器(例如Tomcat)，不同的web服务器中并不能发现之前web服务器保存的session信息，就会再次生成一个JSESSIONID，之前的状态就会丢失</p></blockquote><h1 id="4种分布式session解决方案"><a href="#4种分布式session解决方案" class="headerlink" title="4种分布式session解决方案"></a>4种分布式session解决方案</h1><h2 id="方案一：客户端存储"><a href="#方案一：客户端存储" class="headerlink" title="方案一：客户端存储"></a>方案一：客户端存储</h2><p>直接将信息存储在cookie中</p><p><strong>缺点</strong>：数据存储在客户端，存在安全隐患<br>cookie存储大小、类型存在限制<br>数据存储在cookie中，如果一次请求cookie过大，会给网络增加更大的开销</p><h2 id="方案二：session复制"><a href="#方案二：session复制" class="headerlink" title="方案二：session复制"></a>方案二：session复制</h2><p>session复制是小型架构使用较多的一种服务器集群session管理机制，在真正的开发使用的并不是很多。应用服务器开启Web容器的session复制功能，<strong>在集群中的几台服务器之间同步session对象</strong>，使每台服务器上都保存了所有用户的session信息。</p><p><strong>缺点</strong>：session同步的原理是在同一个局域网里面通过发送广播来异步同步session的，一旦服务器多了，并发上来了，session需要同步的数据量就大了，需要将其他服务器上的session全部同步到本服务器上，会带来一定的网路开销，在用户量特别大的时候，会出现内存不足的情况<br><strong>优点</strong>：服务器之间的session信息都是同步的，任何一台服务器宕机的时候不会影响另外服务器中session的状态，配置相对简单<br>Tomcat内部已经支持分布式架构开发管理机制，可以对tomcat修改配置来支持session复制，在集群中的几台服务器之间同步session对象，使每台服务器上都保存了所有用户的session信息，这样任何一台本机宕机都不会导致session数据的丢失，而服务器使用session时，也只需要在本机获取即可<br>如何配置：<br>在Tomcat安装目录下的config目录中的server.xml文件中，将注释打开，tomcat必须在同一个网关内，要不然收不到广播，同步不了session</p><h2 id="方案三：session绑定："><a href="#方案三：session绑定：" class="headerlink" title="方案三：session绑定："></a>方案三：session绑定：</h2><blockquote><p>Nginx介绍：<br>Nginx是一款自由的、开源的、高性能的http服务器和反向代理服务器</p><p>Nginx能做什么：<br>反向代理、负载均衡、http服务器（动静代理）、正向代理</p></blockquote><p>如何使用nginx进行session绑定<br>我们利用nginx的反向代理和负载均衡，之前是客户端会被分配到其中一台服务器进行处理，具体分配到哪台服务器进行处理还得看服务器的负载均衡算法(轮询、随机、ip-hash、权重等)，但是我们可以基于nginx的ip-hash策略，可以对客户端和服务器进行绑定（将来源于同一个IP的请求分发到同一台服务器上），同一个客户端就只能访问该服务器，无论客户端发送多少次请求都被同一个服务器处理</p><p>在nginx安装目录下的conf目录中的nginx.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream aaa &#123;</span><br><span class="line">Ip_hash;</span><br><span class="line">server 39.105.59.4:8080;</span><br><span class="line">Server 39.105.59.4:8081;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.wanyingjing.cn;</span><br><span class="line">#root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html;</span><br><span class="line">#index index.html index.htm;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass http:39.105.59.4;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：容易造成单点故障，如果有一台服务器宕机，那么该台服务器上的session信息将会丢失<br>前端不能有负载均衡，如果有，session绑定将会出问题<br><strong>优点</strong>：配置简单</p><h2 id="方案四：基于redis存储session方案"><a href="#方案四：基于redis存储session方案" class="headerlink" title="方案四：基于redis存储session方案"></a>方案四：基于redis存储session方案</h2><p>基于redis存储session方案流程示意图</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210417092733.png" alt="在这里插入图片描述"></p><p>引入pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-data-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置redis</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis数据库索引(默认是0)</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#默认密码为空</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#连接池最大连接数(负数表示没有限制)</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment">#连接池最大阻塞等待时间(负数表示没有限制)</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">2</span></span><br><span class="line"><span class="comment">#连接超时时间(毫秒)</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">500ms</span></span><br></pre></td></tr></table></figure><p>配置spring-session：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// redis的json序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> songjiancheng</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> cookie配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2:03 下午 2021/4/21</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultCookieSerializer serializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">// cookie的键</span></span><br><span class="line">        serializer.setCookieName(<span class="string">&quot;GULISESSIONID&quot;</span>);</span><br><span class="line">        <span class="comment">// 扩大session作用域，也就是cookie的有效域</span></span><br><span class="line">        serializer.setDomainName(<span class="string">&quot;gulimall.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：这是企业中使用的最多的一种方式<br>spring为我们封装好了spring-session，直接引入依赖即可<br>数据保存在redis中，无缝接入，不存在任何安全隐患<br>redis自身可做集群，搭建主从，同时方便管理<br><strong>缺点</strong>：多了一次网络调用，web容器需要向redis访问<br><strong>总结</strong>：一般会将web容器所在的服务器和redis所在的服务器放在同一个机房，减少网络开销，走内网进行连接</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程池和异步编排</title>
      <link href="2021/04/13/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/"/>
      <url>2021/04/13/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="java线程池"><a href="#java线程池" class="headerlink" title="java线程池"></a>java线程池</h1><h2 id="java创建线程的四种方式"><a href="#java创建线程的四种方式" class="headerlink" title="java创建线程的四种方式"></a>java创建线程的四种方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i:  &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().run();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这说明一下run()方法和start()方法的区别</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * run()</span></span><br><span class="line"><span class="comment">     *      Runnable接口中的抽象方法，而Thread实现了Runnable接口，需要重写run()方法</span></span><br><span class="line"><span class="comment">     *      而在Thread类重写的run()方法的源码中，只是调用了Runnable接口的run()方法</span></span><br><span class="line"><span class="comment">     *      如果直接调用run方法，并不会启动新线程，程序中只有当前线程线程，</span></span><br><span class="line"><span class="comment">     *      程序还是顺序执行，等待run方法体执行完毕后才可继续执行下面的代码，没有达到多线程的目的</span></span><br><span class="line"><span class="comment">     * start()方法</span></span><br><span class="line"><span class="comment">     *      启动新线程，处于就绪(可运行)状态，并没有运行，一旦得到cpu时间片，</span></span><br><span class="line"><span class="comment">     *      就开始执行相应线程的run()方法，这里run()称为线程体，它包含了要执行的这个线程的内容，</span></span><br><span class="line"><span class="comment">     *      run()方法运行结束，此线程随即终止。</span></span><br><span class="line"><span class="comment">     *      start()无需等待run()执行完毕，即可继续执行下面的代码，进行了线程切换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写Runnable接口实现多线程"><a href="#重写Runnable接口实现多线程" class="headerlink" title="重写Runnable接口实现多线程"></a>重写Runnable接口实现多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i:  &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Runnable的实例</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//该实例作为Thread的target，创建后这个thread对象才是真正的线程对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写Callable接口-不常用"><a href="#重写Callable接口-不常用" class="headerlink" title="重写Callable接口(不常用)"></a>重写Callable接口(不常用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main--start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</span><br><span class="line"> </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 等待线程执行完，获取返回结果：注意：获取返回结果是个阻塞的操作！！</span></span><br><span class="line">        Integer integer = futureTask.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回的结果：&quot;</span> + integer);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;main--end.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过线程池"><a href="#通过线程池" class="headerlink" title="通过线程池"></a>通过线程池</h3><blockquote><p><strong>使用线程池创建线程的优势：</strong></p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，会消耗系统资源，还会降低系统的稳定性</li></ul><p>但是要做到合理的利用线程池，必须对其原理了如指掌。java可以通过Executors来创建线程池，它提供了5种线程池：</p><ul><li><p>newFixedThreadPool：固定线程池大小，可控制线程最大并发数，超出的线程会在队列中等待</p></li><li><p>newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p></li><li><p>newCachedThreadPool：可缓存线程池，如果线程池长度超过处理需要，可回收空闲线程，若无需回收，则新建线程</p></li><li><p>newScheduledThreadPool：创建一个定长线程池，支持定时(scheduleWithFixedDelay()函数的initdelay参数)及周期(delay 参数)任务执行</p></li><li><p>newWorkStealingPool：创建一个单线程化的支持定时的线程池，可以用一个线程周期性执行任务(比如周期7天，一次任务才用1小时,使用多线程就会浪费资源)</p></li></ul><p>  <strong>但是线程池最好不要使用Executors创建，最好通过ThreadPoolExecutor的方式手动创建，这样的处理方式让我们更加明确线程池的运行规则，规避资源耗尽的风险。</strong></p></blockquote><h4 id="使用ThreadPoolExecutor创建线程池"><a href="#使用ThreadPoolExecutor创建线程池" class="headerlink" title="使用ThreadPoolExecutor创建线程池"></a>使用ThreadPoolExecutor创建线程池</h4><p>（1）方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>（2）参数简介</p><blockquote><ul><li>corePoolSize                  线程池核心池的大小</li><li>maximumPoolSize        线程池的最大线程数</li><li>keepAliveTime               当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间</li><li>unit                                  keepAliveTime 的时间单位</li><li>workQueue                     用来储存等待执行任务的队列</li><li>threadFactory                线程工厂</li><li>handler                           拒绝策略</li></ul></blockquote><ul><li><p><strong>corePoolSize</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p></li><li><p><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。(如果使用了无界队列，这个参数无效)</p><blockquote><p>在创建了线程池后，线程池中并没有任何线程(默认)，等到有任务来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者</p><p>prestartCoreThread()方法<br>当创建的线程数等于 corePoolSize 时，会加入阻塞队列。当队列满时，会创建线程执行任务直到线程池中的数量等于maximumPoolSize</p></blockquote></li><li><p><strong>keepAliveTime</strong>：线程池的工作线程空闲后，保持存活的时间。如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率</p></li><li><p><strong>TimeUnit</strong>：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)</p></li><li><p><strong>runnableTaskQueue</strong>：用于保存等待执行的任务的阻塞队列。有5种可选择</p><blockquote><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。<br>LinkedBlockingQueue：一个基于链表结构的无界阻塞队列，此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。<br>SynchronousQueue：默认。一个不存储元素的阻塞队列。每个线程的插入必须等另一个线程的移除，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br>DelayQueue： 一个使用优先级队列实现的无界阻塞队列。</p></blockquote></li><li><p><strong>ThreadFactory</strong>：通过线程工厂给每个创建出来的线程设置名字，帮助Debug和定位问题。可以使用默认线程工厂<code>Executors.defaultThreadFactory()</code></p></li><li><p><strong>RejectedExecutionHandler</strong>：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。jdk提供4种策略</p><blockquote><p>ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常(默认)<br>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务(重复此过程)<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </p></blockquote></li></ul><p>（3）示例</p><p>连接池配置类：ThreadPoolConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean(value = &quot;myThreadPool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildMyThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 例如，&quot;rpc-pool-%d&quot;会产生像线程名称 &quot;rpc-pool-0&quot;，&quot;rpc-pool-1&quot;，&quot;rpc-pool-2&quot;</span></span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;my-thread-%d&quot;</span>).build();</span><br><span class="line"> </span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">15</span></span><br><span class="line">                ,<span class="number">30</span></span><br><span class="line">                ,<span class="number">0</span></span><br><span class="line">                ,TimeUnit.MILLISECONDS</span><br><span class="line">                ,<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>)</span><br><span class="line">                ,threadFactory</span><br><span class="line">                ,<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Resource(name = &quot;myThreadPool&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService myThreadPool;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            myThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;index:  &quot;</span>+index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        myThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任务提交给线程池之后的处理策略（主要有4点）"><a href="#任务提交给线程池之后的处理策略（主要有4点）" class="headerlink" title="任务提交给线程池之后的处理策略（主要有4点）"></a>任务提交给线程池之后的处理策略（主要有4点）</h4><ul><li><p>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</p></li><li><p>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</p></li><li><p>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</p></li><li><p>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210413210052.png" alt="82214e045b8f08f9050d3de180c428c2dce.jpg"></p><h1 id="CompletableFuture-异步编排"><a href="#CompletableFuture-异步编排" class="headerlink" title="CompletableFuture 异步编排"></a>CompletableFuture 异步编排</h1><h2 id="runAsync-和-supplyAsync方法"><a href="#runAsync-和-supplyAsync方法" class="headerlink" title="runAsync 和 supplyAsync方法"></a>runAsync 和 supplyAsync方法</h2><p>CompletableFuture 提供了四个静态方法来创建一个异步操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>没有指定Executor的方法会使用<code>ForkJoinPool.commonPool()</code> 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。</p><ul><li>runAsync方法不支持返回值。</li><li>supplyAsync方法可以支持返回值。</li></ul><p>runAsync方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xieh;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line">        <span class="comment">// 没有返回值</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        <span class="comment">// 什么都不返回，调用get方法，就变成了阻塞操作！</span></span><br><span class="line">        <span class="comment">// future.get();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main---end&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414195132.png" alt="img"></p><p>supplyAsync方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 有返回值</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取返回结果，调用get方法，就变成了阻塞操作！</span></span><br><span class="line">        Integer integer = future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span> + integer);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414195246.png" alt="img"></p><h2 id="计算结果完成时的回调方法"><a href="#计算结果完成时的回调方法" class="headerlink" title="计算结果完成时的回调方法"></a>计算结果完成时的回调方法</h2><p>当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure><p>可以看到Action的类型是BiConsumer&lt;? super T,? super Throwable&gt;它可以处理正常的计算结果，或者异常情况。</p><p><strong>whenComplete 和 whenCompleteAsync 的区别</strong>：<br>whenComplete：是执行当前任务的线程继续执行 whenComplete 的任务。<br>whenCompleteAsync：是把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。</p><p><strong>runAsync方法计算结果完成时的后续操作示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line"> </span><br><span class="line">        &#125;, executorService);</span><br><span class="line">        </span><br><span class="line">        future.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Void, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Void t, Throwable action)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;whenComplete执行完成！&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        future.whenCompleteAsync(<span class="keyword">new</span> BiConsumer&lt;Void, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Void t, Throwable action)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;whenCompleteAsync执行完成！&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        future.exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">apply</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行失败！&quot;</span> + t.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取返回结果，调用get方法，就变成了阻塞操作！</span></span><br><span class="line">        <span class="comment">// future.get();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414195550.png" alt="img"></p><p><strong>supplyAsync方法计算结果完成时的后续操作示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executorService).whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 虽然能得到异常信息，但是无法修改返回数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;whenComplete异步任务完成了，结果是：&quot;</span> + result + <span class="string">&quot;;异常是：&quot;</span> + exception);</span><br><span class="line">        &#125;).whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;whenCompleteAsync异步任务完成了，结果是：&quot;</span> + result + <span class="string">&quot;;异常是：&quot;</span> + exception);</span><br><span class="line">        &#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果执行失败，可以设置默认返回值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取返回结果</span></span><br><span class="line">        Integer integer = future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span> + integer);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414195622.png" alt="img"></p><h2 id="handle-方法"><a href="#handle-方法" class="headerlink" title="handle 方法"></a>handle 方法</h2><p>handle 是执行任务完成时对结果的处理。<br>handle 方法和 thenApply 方法处理方式基本一样。不同的是 handle 是在任务完成后再执行，还可以处理异常的任务。thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executorService).whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 虽然能得到异常信息，但是无法修改返回数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;whenComplete异步任务完成了，结果是：&quot;</span> + result + <span class="string">&quot;;异常是：&quot;</span> + exception);</span><br><span class="line">        &#125;).whenCompleteAsync((result, exception) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;whenCompleteAsync异步任务完成了，结果是：&quot;</span> + result + <span class="string">&quot;;异常是：&quot;</span> + exception);</span><br><span class="line">        &#125;).handle((result, throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 注意：handle与exceptionally都可以控制返回值，谁先被调用就以谁的为准（先被调用者的返回值为准）</span></span><br><span class="line">        &#125;).exceptionally(throwable -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果执行失败，可以设置默认返回值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 获取返回结果</span></span><br><span class="line">        Integer integer = future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span> + integer);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414195714.png" alt="img"></p><h2 id="线程串行化"><a href="#线程串行化" class="headerlink" title="线程串行化"></a>线程串行化</h2><ul><li><p>thenApply 方法：当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。获取上一个任务返回的结果，并返回当前任务的返回值</p></li><li><p>thenAccept 消费处理结果：接收任务的处理结果，并消费处理，无返回结果。</p></li><li><p>thenRun 方法：跟 thenAccept 方法不一样的是，不关心任务的处理结果。只要上面的任务执行完成，就开始执行 thenRun 。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="thenRun代码示例"><a href="#thenRun代码示例" class="headerlink" title="thenRun代码示例"></a>thenRun代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// thenRun不能获取上一步的执行结果</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executorService).thenRunAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务2启动了...&quot;</span>);</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414195947.png" alt="img"></p><h3 id="thenAccept代码示例"><a href="#thenAccept代码示例" class="headerlink" title="thenAccept代码示例"></a>thenAccept代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// thenAccept能获取到上一步的结果，但是无返回值</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executorService).thenAcceptAsync((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务2启动了，上一步的结果是：&quot;</span> + result);</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414200238.png" alt="img"></p><h3 id="thenApply代码示例"><a href="#thenApply代码示例" class="headerlink" title="thenApply代码示例"></a>thenApply代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">3L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">1000</span>), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main---start&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// thenApply能获取到上一步的结果，可以有返回值</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;, executorService).thenApplyAsync(result -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务2开启了，上一步的结果是：&quot;</span> + result);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;thenApplyAsync的新结果&quot;</span>;</span><br><span class="line">        &#125;, executorService);</span><br><span class="line"> </span><br><span class="line">        String string = future.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main---end：&quot;</span> + string);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210414200308.png" alt="img"></p><h2 id="任务合并"><a href="#任务合并" class="headerlink" title="任务合并"></a>任务合并</h2><ul><li><p>thenCombine：thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p></li><li><p>thenAcceptBoth：当两个CompletionStage都执行完成后，把结果一块交给thenAcceptBoth来进行消耗。</p></li><li><p>thenCompose：thenCompose 方法允许你对两个 CompletionStage 进行流水线操作，第一个操作完成时，将其结果作为参数传递给第二个操作。</p></li><li><p>applyToEither：两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的转化操作。</p></li><li><p>acceptEither：两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的消耗操作。</p></li><li><p>runAfterEither：两个CompletionStage，任何一个完成了都会执行下一步的操作（Runnable）。</p></li><li><p>runAfterBoth：两个CompletionStage，都完成了计算才会执行下一步的操作（Runnable）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action,     Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn,Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="thenCombine代码示例"><a href="#thenCombine代码示例" class="headerlink" title="thenCombine代码示例"></a>thenCombine代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; result = future1.thenCombine(future2, <span class="keyword">new</span> BiFunction&lt;String, String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String t, String u)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t+<span class="string">&quot; &quot;</span>+u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="thenAcceptBoth代码示例"><a href="#thenAcceptBoth代码示例" class="headerlink" title="thenAcceptBoth代码示例"></a>thenAcceptBoth代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptBoth</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    f1.thenAcceptBoth(f2, <span class="keyword">new</span> BiConsumer&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t, Integer u)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1=&quot;</span>+t+<span class="string">&quot;;f2=&quot;</span>+u+<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="thenCompose代码示例"><a href="#thenCompose代码示例" class="headerlink" title="thenCompose代码示例"></a>thenCompose代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCompose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1=&quot;</span>+t);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).thenCompose(<span class="keyword">new</span> Function&lt;Integer, CompletionStage&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CompletionStage&lt;Integer&gt; <span class="title">apply</span><span class="params">(Integer param)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">int</span> t = param *<span class="number">2</span>;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2=&quot;</span>+t);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;thenCompose result : &quot;</span>+f.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="applyToEither-代码示例"><a href="#applyToEither-代码示例" class="headerlink" title="applyToEither 代码示例"></a>applyToEither 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyToEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    CompletableFuture&lt;Integer&gt; result = f1.applyToEither(f2, <span class="keyword">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            <span class="keyword">return</span> t * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acceptEither代码示例"><a href="#acceptEither代码示例" class="headerlink" title="acceptEither代码示例"></a>acceptEither代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    f1.acceptEither(f2, <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runAfterEither代码示例"><a href="#runAfterEither代码示例" class="headerlink" title="runAfterEither代码示例"></a>runAfterEither代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    f1.runAfterEither(f2, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上面有一个已经完成了。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runAfterBoth代码示例"><a href="#runAfterBoth代码示例" class="headerlink" title="runAfterBoth代码示例"></a>runAfterBoth代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterBoth</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2=&quot;</span>+t);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    f1.runAfterBoth(f2, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上面两个任务都执行完成了。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allof代码示例"><a href="#allof代码示例" class="headerlink" title="allof代码示例"></a>allof代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;f1&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        f1.whenCompleteAsync(<span class="keyword">new</span> BiConsumer&lt;String, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;f2&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        f2.whenCompleteAsync(<span class="keyword">new</span> BiConsumer&lt;String, Throwable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(f1, f2);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//阻塞，直到所有任务结束。</span></span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;:阻塞&quot;</span>);</span><br><span class="line">        all.join();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;:阻塞结束&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//一个需要耗时2秒，一个需要耗时3秒，只有当最长的耗时3秒的完成后，才会结束。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务均已完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">37.400</span> <span class="number">31142</span>-<span class="number">31142</span>/zhangphil.test I/System.out: <span class="number">1528805797400</span>:阻塞</span><br><span class="line"><span class="number">06</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">39.406</span> <span class="number">31142</span>-<span class="number">31171</span>/zhangphil.test I/System.out: <span class="number">1528805799406</span>:f2</span><br><span class="line"><span class="number">06</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">40.404</span> <span class="number">31142</span>-<span class="number">31170</span>/zhangphil.test I/System.out: <span class="number">1528805800404</span>:f1</span><br><span class="line"><span class="number">06</span>-<span class="number">12</span> <span class="number">20</span>:<span class="number">16</span>:<span class="number">40.404</span> <span class="number">31142</span>-<span class="number">31142</span>/zhangphil.test I/System.out: <span class="number">1528805800404</span>:阻塞结束 </span><br><span class="line">  任务均已完成。</span><br></pre></td></tr></table></figure><h2 id="任务超时"><a href="#任务超时" class="headerlink" title="任务超时"></a>任务超时</h2><p>JDK 9带来了两种新方法，可以为每个人提供渴望的功能 - 这对于确保在使用异步处理时的正确弹性至关重要。</p><h3 id="orTimeout"><a href="#orTimeout" class="headerlink" title="orTimeout"></a><strong>orTimeout</strong></h3><p>简单地说，在调用上述方法之后，如果未在指定的超时内完成，将来会抛出ExecutionException。</p><p>一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(<span class="keyword">this</span>::computeEndlessly)</span><br><span class="line">  .orTimeout(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">future.get(); <span class="comment">// java.util.concurrent.ExecutionException after waiting for 1 second</span></span><br></pre></td></tr></table></figure><p>由于设置了timeout为1秒，那么在get那里等待1秒后抛错</p><h3 id="completeOnTimeout"><a href="#completeOnTimeout" class="headerlink" title="completeOnTimeout"></a><strong>completeOnTimeout</strong></h3><p>在这种情况下，我们可以在达到超时后返回默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(<span class="keyword">this</span>::computeEndlessly)</span><br><span class="line">  .completeOnTimeout(<span class="number">42</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">Integer result = future.get(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>超时1秒后不是报错，而是返回了预设的42这个值，前提条件是你必须预设默认值。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 异步编排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用笔记</title>
      <link href="2021/04/10/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/10/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、打开文件"><a href="#一、打开文件" class="headerlink" title="一、打开文件"></a><strong>一、打开文件</strong></h1><p>①打开单个文件</p><p>vim file</p><p>②同时打开多个文件（切换文件ctrl+ww）</p><ol><li>vim -o filename1 filename2 … 水平分割窗口</li><li>vim -O filename1 filename2 … 垂直分割窗口</li></ol><ul><li>对于垂直并排的文件：使用ctrl+w+上、下方向，表示上、下切换文件；</li><li>对于水平并排的文件：使用Ctrl+w+左、右方向，表示左、右切换文件；</li></ul><p>退出文件的话可以使用q、q!、wq或者ZZ(shift+z+z)。</p><p>但是如果同时打开三四个文件，这样子却不得不退出三四次才行。太麻烦….</p><p>办法是有的！！！</p><p>只需要在退出命令的后边加上小写的a，则表示退出动作是针对所有的（ALL）：qa、qa!、 wqa</p><p>如果想将一个文件的内容全部复制到另一个文件中，则可以输入命令”:r被复制的文件名”，即可将导入文件的全部内容复制到当前光标所在行下面。</p><h1 id="二、-插入命令"><a href="#二、-插入命令" class="headerlink" title="二、 插入命令"></a><strong>二、 插入命令</strong></h1><p>i 在当前位置生前插入<br>I 在当前行首插入<br>a 在当前位置后插入<br>A 在当前行尾插入<br>o 在当前行之后插入一行<br>O 在当前行之前插入一行在行下面。</p><h1 id="三、翻屏"><a href="#三、翻屏" class="headerlink" title="三、翻屏"></a><strong>三、翻屏</strong></h1><p>ctrl+f: 下翻一屏。<br>ctrl+b: 上翻一屏。<br>ctrl+d: 下翻半屏。<br>ctrl+u: 上翻半屏。<br>ctrl+e: 向下滚动一行。<br>ctrl+y: 向上滚动一行。<br>n%: 到文件n%的位置。</p><p>ctrl+y: 向上滚动一行。</p><p>n%: 到文件n%的位置。</p><h1 id="四、基本移动"><a href="#四、基本移动" class="headerlink" title="四、基本移动"></a>四、基本移动</h1><p>h或退格: 左移一个字符；<br>l或空格: 右移一个字符；<br>j: 下移一行；<br>k: 上移一行；<br>gj: 移动到一段内的下一行；<br>gk: 移动到一段内的上一行；</p><p>H: 把光标移到屏幕最顶端一行。<br>M: 把光标移到屏幕中间一行。<br>L: 把光标移到屏幕最底端一行。<br>gg: 到文件头部。<br>G: 到文件尾部。</p><h1 id="五、标记"><a href="#五、标记" class="headerlink" title="五、标记"></a>五、标记</h1><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的后退和前进。</p><p>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。<br>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。<br><code>&#123;a-z&#125;: 移动到标记位置。 ‘&#123;a-z&#125;: 移动到标记行的行首。 </code>{0-9}：回到上[2-10]次关闭vim时最后离开的位置。<br>:marks 显示所有标记。<br>:delmarks a b – 删除标记a和b。<br>:delmarks a c-f – 删除标记a、c、d、e、f。<br>:delmarks! – 删除当前缓冲区的所有标记</p><h1 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a><strong>六、查找</strong></h1><p>/：命令从光标处开始向后寻找字符串 string。<br>?： 命令从光标处开始向前寻找字符串 string。</p><h1 id="七、删除"><a href="#七、删除" class="headerlink" title="七、删除"></a><strong>七、删除</strong></h1><p>删除文本的命令可以分为删除单个字符和删除多个字符两类。其中，删除单个字符的命令包括下面两种情况。<br>x 命令：删除光标处的字符。若在 x 之前加上一个数字 n，则删除从光标所在位置开始向右的 n 个字符。<br>X 命令：删除光标前面的字符。若在 X 之前加上一个数字 n，则删除从光标前面那个字符开始向左的 n 个字符。</p><p>删除多个字符的命令包括下面几种情况。<br>dd 命令：该命令删除光标所在的整行。在 dd 前可加上一个数字 n，表示删除当前行及其后 n-1 行的内容。<br>D 命令或 d$ 命令：两个命令功能一样，都是删除从光标所在处开始到行尾的内容。<br>d0 命令：该命令删除从光标前一个字符开始到行首的内容。<br>dw 命令：该命令删除一个单词。若光标处在某个词的中间，则从光标所在位置开始删至词尾。同 dd 命令一样，可在 dw 之前加一个数字n，表示删除 n 个指定的单词。<br>d( 命令：该命令删除到上一句开始的所有字符。<br>d) 命令：该命令删除到下一句开始的所有字符。<br>d} 命令：该命令删除到上一段开始的所有字符。<br>d{ 命令：该命令删除到下一段开始的所有字符。</p><p>以字符为单位删除<br>x 删除当前字符<br>3x 删除当前字符3次<br>X 删除当前字符的前一个字符。<br>3X 删除当前光标向前三个字符<br>dl 删除当前字符， dl=x<br>dh 删除前一个字符，X=dh<br>d$ 删除当前字符至行尾<br>d^ 删除当前字符之前至行首<br>daw 删除当前字符所在单词<br>dj 删除下一行<br>dk 删除上一行<br>dgg 删除当前行至文档首部<br>d1G 删除当前行至文档首部<br>dG 删除当前行至文档尾部<br>kdgg 删除当前行之前所有行（不包括当前行）<br>jdG 删除当前行之后所有行（不包括当前行）<br>10d 删除当前行开始的10行。<br>:1,10d 删除1-10行<br>:11,$d 删除11行及以后所有的行<br>:1,$d 删除所有行<br>J　　 删除两行之间的空行，实际上是合并两行</p><h1 id="八、复制"><a href="#八、复制" class="headerlink" title="八、复制"></a>八、复制</h1><p>yy 命令：复制光标所在的整行。在 yy 前可加一个数字 n，表示复制当前行及其后 n-1 行的内容。<br>Y 或 y$ 命令：两命令功能一样，都是复制从光标所在处开始到行尾的内容。<br>yw 命令：复制一个单词。若光标处在某个词的中间，则从光标所在位置开始复制至词尾。同 yy 命令一样，可在 yw 之前加一个数字 n，表示复制 n 个指定的单词。<br>y) 命令：复制到下一句幵始的所有字符。<br>y} 命令：复制到下一段开始的所有字符。<br>y<CR> 命令（<CR> 表示回车）：复制包括当前行在内的两行内容。</p><p>y^ 复制至行首，或y0。不含光标所在处字符。<br>y$ 复制至行尾。含光标所在处字符。<br>y2w 复制两个单词。<br>yG 复制至文本末。<br>y1G 复制至文本开头。 </p><h1 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a><strong>九、撤销</strong></h1><p>u 命令：该命令撤销上一次所做的操作。多次使用 u 命令会一步一步依次撤销之前做过的操作（在一次切换到文本输入模式中输入的所有文本算一次操作）。<br>U 命令：该命令会一次性撤销自上次移动到当前行以来做过的所有操作，再使用一次 U 命令则撤销之前的 U 命令所做的操作，恢复被撤销的内容。</p><p>Ctrl + r 重做（Redo），即撤销的撤销。</p><h1 id="十、替换命令"><a href="#十、替换命令" class="headerlink" title="十、替换命令"></a><strong>十、替换命令</strong></h1><p>~ 反转游标字母大小写<br>r&lt;字母&gt; 将当前字符替换为所写字母<br>R&lt;字母&gt;&lt;字母&gt;… 连续替换字母<br>cc 替换整行（就是删除当前行，并在下一行插入）<br>cw 替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）<br>C (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）<br>:s/old/new/ 用old替换new，替换当前行的第一个匹配<br>:s/old/new/g 用old替换new，替换当前行的所有匹配<br>:%s/old/new/ 用old替换new，替换所有行的第一个匹配<br>:%s/old/new/g 用old替换new，替换整个文件的所有匹配<br>:10,20 s/^/ /g 在第10行至第20行每行前面加个空格，用于缩进。<br>ddp 交换光标所在行和其下紧邻的一行。<br>xp　　交换相邻两个字母的顺序</p><h1 id="十一、剪切粘贴"><a href="#十一、剪切粘贴" class="headerlink" title="十一、剪切粘贴"></a><strong>十一、剪切粘贴</strong></h1><p>普通模式中使用p粘贴</p><p>p(小写)：代表粘贴至光标后（下边，右边）<br>P(大写)：代表粘贴至光标前（上边，左边）</p><p>dd 其实就是剪切命令，剪切当前行<br>ddp 剪切当前行并粘贴，可实现当前行和下一行调换位置</p><p>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴<br>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。<br>:1, 10 m 20 将第1-10行移动到第20行之后。</p><h1 id="十二、注释命令"><a href="#十二、注释命令" class="headerlink" title="十二、注释命令"></a>十二、注释命令</h1><p>进入命令行模式，按ctrl + v进入 visual block模式，然后按j, 或者k选中多行，把需要注释的行标记起来，按大写字母I，再插入注释符，例如//，再按esc键就会全部注释了<br>取消多行注释<br>进入命令行模式，按ctrl + v进入 visual block模式，按字母l横向选中列的个数，例如 // 需要选中2列，按字母j，或者k选中注释符号，按d键就可全部取消注释</p><p>:3,5 s/^/#/g 注释第3-5行<br>:3,5 s/^#//g 解除3-5行的注释</p><h1 id="十三、区域选择"><a href="#十三、区域选择" class="headerlink" title="十三、区域选择"></a><strong>十三、区域选择</strong></h1><p>要进行区域选择，要先进入可视模式<br>v 以字符为单位，上下左右选择<br>V 以行为单位，上下选择</p><p>选择后可进行操作<br>d 剪切/删除<br>y 复制</p><p>ggVG 选择全文</p><h1 id="十四、窗口控制"><a href="#十四、窗口控制" class="headerlink" title="十四、窗口控制"></a><strong>十四、窗口控制</strong></h1><p># 打开两个文件分属两个窗口</p><p>vim -o 1.txt 2.txt<br># 假设现在已经打开了1.txt<br>:sp 2.txt 开启一个横向的窗口，编辑2.txt<br>:vsp 2.txt 开启一个竖向的窗口，编辑2.txt<br>:split 将当前窗口再复制一个窗口出来，内容同步，游标可以不同<br>:split 2.txt 在新窗口打开2.txt的横向窗口<br># 需要注意：内容同步，但是游标位置是独立的<br>Ctrl-w s 将当前窗口分成水平窗口<br>Ctrl-w v 将当前窗口分成竖直窗口<br>Ctrl-w q 等同:q 结束分割出来的视窗。<br>Ctrl-w q! 等同:q! 结束分割出来的视窗。<br>Ctrl-w o 打开一个视窗并且隐藏之前的所有视窗、<br># 特别说明：Ctrl w &lt;字母&gt; 不需要同时按<br>Ctrl-w h 切换到左边窗口<br>Ctrl-w l 切换到右边窗口<br>Ctrl-w j 切换到下边窗口<br>Ctrl-w k 切换到上边窗口</p><p>:close 关闭当前窗口<br>:close! 强制关闭当前窗口<br>:q 退出，不保存<br>:q! 强制退出，不保存<br>:x 保存退出<br>:wq 保存退出<br>:wq! 强制保存退出<br>ZZ 保存并退出。<br>:only 关闭所有窗口，只保留当前窗口(前提：其他窗口内容有改变的话都要先保存)<br>:only! 关闭所有窗口，只保留当前窗口<br>:qall 放弃所有操作并退出<br>:wall 保存所有，<br>:wqall 保存所有并退出。</p><h1 id="十五、文档加密"><a href="#十五、文档加密" class="headerlink" title="十五、文档加密"></a><strong>十五、文档加密</strong></h1><p>vim -x file_name<br>然后输入密码，再确认密码<br>如果不修改内容也要保存。:wq，不然密码设定不会生效。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存、Redisson和SpringCache</title>
      <link href="2021/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E3%80%81Redisson%E5%92%8CSpringCache/"/>
      <url>2021/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E3%80%81Redisson%E5%92%8CSpringCache/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>本地缓存问题</strong>：每个微服务都要有缓存服务、数据更新时只更新自己的缓存，造成缓存数据不一致</p><p><strong>解决方案</strong>：分布式缓存，微服务共用 缓存中间件（例如redis）</p><h2 id="高并发下缓存失效问题–缓存击穿、穿透、雪崩"><a href="#高并发下缓存失效问题–缓存击穿、穿透、雪崩" class="headerlink" title="高并发下缓存失效问题–缓存击穿、穿透、雪崩"></a>高并发下缓存失效问题–缓存击穿、穿透、雪崩</h2><p><strong>缓存穿透</strong></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210421143611.png" alt="img"></p><p><strong>缓存雪崩</strong></p><p><img src="https://img-blog.csdnimg.cn/20201109092203425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d0czU2MzU0MA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>缓存击穿</strong></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210421143655.png" alt="img"></p><blockquote><p><strong>简单来说：缓存穿透是指查询一个永不存在的数据；缓存雪崩是值大面积key同时失效问题；缓存击穿是指高频key失效问题；</strong></p></blockquote><p>我们可以通过加锁来解决缓存击穿问题。但是本地锁只在当前进程（一台设备）上有效，无法实现在分布式环境下锁住其他设备的相同操作。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210421144400.png" alt="img"></p><p>这个时候我们就需要使用分布式锁</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210421144429.png" alt="img"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><blockquote><p> 在分布式项目中，本地锁只能锁住当前服务，需要分布式锁</p></blockquote><p>redis分布式锁的原理：setnx，同一时刻只能设置成功一个。前提，锁的key是一定的，value可以变。没获取到锁阻塞或者sleep一会</p><ul><li><p><strong>问题</strong>1：设置好了锁，如果服务出现宕机，没有执行删除锁逻辑，这就造成了死锁</p><p><strong>解决方案</strong>：设置过期时间</p></li><li><p><strong>问题2</strong>:业务还没执行完锁就过期了，别人拿到锁，自己执行完去删了别人的锁</p><p><strong>解决方案</strong>：锁续期（redisson有看门狗）</p></li><li><p><strong>问题3</strong>: 删锁的时候明确是自己的锁。如uuid，判断uuid对了，但是将要删除的时候锁过期了，别人设置了新值，那删除了别人的锁</p><p><strong>解决方案</strong>：删除锁必须保证原子性（保证判断和删锁是原子的）。使用redis+Lua脚本完成，脚本是原子的</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stringRedisTemplate.execute(</span><br><span class="line">    <span class="keyword">new</span> DefaultRedisScript&lt;Long返回值类型&gt;(script脚本, Long.class返回值类型), </span><br><span class="line">    Arrays.asList(<span class="string">&quot;lock&quot;</span>), <span class="comment">// 键key的集合</span></span><br><span class="line">    lockValue);</span><br></pre></td></tr></table></figure><p><a href="http://redis.cn/commands/set.html">官方文档</a> </p><p>gulimall项目中获取二三级分类json数据的分布式锁demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithRedisLock() &#123;</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">    Boolean lock = ops.setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid,<span class="number">500</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        Map&lt;String, List&lt;Catalog2Vo&gt;&gt; categoriesDb = getCategoryMap();</span><br><span class="line">        String lockValue = ops.get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="comment">// get和delete原子操作</span></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1] then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        stringRedisTemplate.execute(</span><br><span class="line">            <span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class), <span class="comment">// 脚本和返回类型</span></span><br><span class="line">            Arrays.asList(<span class="string">&quot;lock&quot;</span>), <span class="comment">// 参数</span></span><br><span class="line">            lockValue); <span class="comment">// 参数值，锁的值</span></span><br><span class="line">        <span class="keyword">return</span> categoriesDb;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 睡眠0.1s后，重新调用 //自旋</span></span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonDbWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><p>上面的lua脚本写法每次用分布式锁时比较麻烦，我们可以采用redisson现有框架</p><p><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p><p>Redisson<br><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p>本文我们仅关注分布式锁的实现，更多请参考官方文档</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个用作练习，后面可以使用redisson-spring-boot-starter</p><p>开启配置<a href="https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;ipAddr&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String ipAddr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// redission通过redissonClient对象使用 // 如果是多个redis集群，可以配置</span></span><br><span class="line">  <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Config config = <span class="keyword">new</span> Config();</span><br><span class="line">      <span class="comment">// 创建单例模式的配置</span></span><br><span class="line">      config.useSingleServer().setAddress(<span class="string">&quot;redis://&quot;</span> + ipAddr + <span class="string">&quot;:6379&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h2><p>分布式锁：<a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">文档</a></p><p>A调用B。AB都需要同一锁，此时可重入锁就可以重入，A就可以调用B。不可重入锁时，A调用B将死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为锁名字</span></span><br><span class="line">RLock lock = redissonClient.getLock(<span class="string">&quot;CatalogJson-Lock&quot;</span>);<span class="comment">//该锁实现了JUC.locks.lock接口</span></span><br><span class="line">lock.lock();<span class="comment">//阻塞等待</span></span><br><span class="line"><span class="comment">// 解锁放到finally // 如果这里宕机：有看门狗，不用担心</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>基于Redis的Redisson分布式可重入锁RLock Java对象实现了<code>java.util.concurrent.locks.Lock</code>接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><p><strong>锁的续期</strong>：大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟（每到20s就会自动续借成30s，是1/3的关系），也可以通过修改Config.lockWatchdogTimeout来另行指定。</p><p>另外Redisson还通过加锁的方法提供了<code>leaseTime</code>的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁以后10秒钟自动解锁，看门狗不续命</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="keyword">boolean</span> res = lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果传递了锁的超时时间，就执行脚本，进行占锁;<br>如果没传递锁时间，使用看门狗的时间，占锁。如果返回占锁成功future，调用future.onComplete();<br>没异常的话调用scheduleExpirationRenewal(threadId);<br>重新设置过期时间，定时任务;<br>看门狗的原理是定时任务：重新给锁设置过期时间，新的过期时间就是看门狗的默认时间;<br>锁时间/3是定时任务周期;</p></blockquote><p>Redisson同时还为分布式锁提供了异步执行的相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">lock.lockAsync();</span><br><span class="line">lock.lockAsync(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res = lock.tryLockAsync(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出IllegalMonitorStateException错误。但是如果遇到需要其他进程也能解锁的情况，请使用分布式信号量Semaphore 对象.</p><p>gulimall项目中获取二三级分类json数据的分布式锁demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithRedisson() &#123;</span><br><span class="line">    Map&lt;String, List&lt;Catalog2Vo&gt;&gt; categoryMap=<span class="keyword">null</span>;</span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">&quot;CatalogJson-Lock&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        categoryMap = getCategoryMap();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> categoryMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳实战：自己指定锁时间，时间长点即可</p><h2 id="读写锁（ReadWriteLock）"><a href="#读写锁（ReadWriteLock）" class="headerlink" title="读写锁（ReadWriteLock）"></a>读写锁（ReadWriteLock）</h2><p>基于Redis的Redisson分布式可重入读写锁<code>RReadWriteLock</code> Java对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了RLock接口。</p><p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RReadWriteLock rwlock = redisson.getReadWriteLock(<span class="string">&quot;anyRWLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">rwlock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="keyword">boolean</span> res = rwlock.readLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">boolean</span> res = rwlock.writeLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>信号量为存储在redis中的一个数字，当这个数字大于0时，即可以调用acquire()方法增加数量，也可以调用release()方法减少数量，但是当调用release()之后小于0的话方法就会阻塞，直到数字大于0</p><p>基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与<code>java.util.concurrent.Semaphore</code>相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RSemaphore semaphore = redisson.getSemaphore(<span class="string">&quot;semaphore&quot;</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.acquireAsync();</span><br><span class="line">semaphore.acquire(<span class="number">23</span>);</span><br><span class="line">semaphore.tryAcquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync();</span><br><span class="line">semaphore.tryAcquire(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line">semaphore.release(<span class="number">10</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.releaseAsync();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>spring项目demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/park&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RSemaphore park = redissonClient.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        park.acquire(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;停进2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/go&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RSemaphore park = redissonClient.getSemaphore(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">    park.release(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;开走2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h2><p>基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与<code>java.util.concurrent.CountDownLatch</code>相似的接口和用法。</p><p>以下代码只有offLatch()被调用5次后 setLatch()才能继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RCountDownLatch latch = redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.trySetCount(<span class="number">5</span>);</span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他线程或其他JVM里</span></span><br><span class="line">RCountDownLatch latch = redisson.getCountDownLatch(<span class="string">&quot;anyCountDownLatch&quot;</span>);</span><br><span class="line">latch.countDown();</span><br></pre></td></tr></table></figure><h1 id="缓存和数据库一致性"><a href="#缓存和数据库一致性" class="headerlink" title="缓存和数据库一致性"></a>缓存和数据库一致性</h1><p><strong>解决一致性的两种模式</strong>：</p><ul><li><p>双写模式：写数据库后，写缓存<br>问题：并发时，2写进入，写完DB后都写缓存。有暂时的脏数据</p><p>解决方案：缓存设置过期时间，定期更新</p></li><li><p>失效模式：写完数据库后，删缓存<br>问题：还没存入数据库呢，线程2又读到旧的DB了</p><p>解决方案：写数据写时，加分布式的读写锁。</p></li></ul><p><strong>一致性解决方案</strong>：</p><ul><li>如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题（一致性），缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li><li>如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式（参见下图）</li><li>缓存数据+过期时间也足够解决大部分业务对于缓存的要求。</li><li>通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）；</li></ul><p><strong>总结</strong>：</p><p>我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。<br>我们不应该过度设计，增加系统的复杂性。遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210409211047.png" alt="img"></p><h1 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h1><p>每次都像之前说的那样直接调用redisclient操作缓存太麻烦了，spring从3.1开始定义了Cache、CacheManager接口来统一不同的缓存技术。并支持使用JCache(JSR-107)注解简化我们的开发</p><p>Cache接口的实现包括RedisCache、EhCacheCache、ConcurrentMapCache等</p><p>每次调用需要缓存功能的方法时，spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p><p>使用Spring缓存抽象时我们需要关注以下两点：</p><p>1、确定方法需要缓存以及他们的缓存策略<br>2、从缓存中读取之前缓存存储的数据</p><h2 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.b oot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定缓存类型并在主配置类上加上注解@EnableCaching</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">  <span class="comment">#指定缓存类型为redis</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">time-to-live:</span> <span class="number">360000</span> <span class="comment"># 设置缓存过期时间(单位：毫秒)</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">true</span> <span class="comment"># 设置是否缓存空值</span></span><br></pre></td></tr></table></figure><p>springcache默认使用jdk进行序列化（可读性差），默认ttl为-1永不过期，自定义序列化方式需要编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span></span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">//设置缓存中键和值的序列化方式</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()));</span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CacheProperties.Redis redisProperties = cacheProperties.getRedis();</span><br><span class="line">        <span class="comment">//设置配置文件中的各项配置，如过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="springcache的自动配置"><a href="#springcache的自动配置" class="headerlink" title="springcache的自动配置"></a>springcache的自动配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存自动配置源码</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(CacheManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(CacheAspectSupport.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = CacheManager.class, name = &quot;cacheResolver&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">                     HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123; CacheConfigurationImportSelector.class, // 看导入什么CacheConfiguration</span></span><br><span class="line"><span class="meta">         CacheManagerEntityManagerFactoryDependsOnPostProcessor.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManagerCustomizers <span class="title">cacheManagerCustomizers</span><span class="params">(ObjectProvider&lt;CacheManagerCustomizer&lt;?&gt;&gt; customizers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizers(customizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManagerValidator <span class="title">cacheAutoConfigurationValidator</span><span class="params">(CacheProperties cacheProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                 ObjectProvider&lt;CacheManager&gt; cacheManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheManagerValidator(cacheProperties, cacheManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheManagerEntityManagerFactoryDependsOnPostProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">EntityManagerFactoryDependsOnPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CacheManagerEntityManagerFactoryDependsOnPostProcessor() &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="string">&quot;cacheManager&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RedisAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(CacheManager.class)</span></span><br><span class="line"><span class="meta">@Conditional(CacheCondition.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 放入缓存管理器</span></span><br><span class="line">    <span class="function">RedisCacheManager <span class="title">cacheManager</span><span class="params">(CacheProperties cacheProperties, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   CacheManagerCustomizers cacheManagerCustomizers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(</span><br><span class="line">            determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));</span><br><span class="line">        List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();</span><br><span class="line">        <span class="keyword">if</span> (!cacheNames.isEmpty()) &#123;</span><br><span class="line">            builder.initialCacheNames(<span class="keyword">new</span> LinkedHashSet&lt;&gt;(cacheNames));</span><br><span class="line">        &#125;</span><br><span class="line">        redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));</span><br><span class="line">        <span class="keyword">return</span> cacheManagerCustomizers.customize(builder.build());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存使用-Cacheable-CacheEvict"><a href="#缓存使用-Cacheable-CacheEvict" class="headerlink" title="缓存使用@Cacheable@CacheEvict"></a>缓存使用@Cacheable@CacheEvict</h2><p>第一个方法存放缓存，第二个方法清空缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该方法时会将结果缓存，缓存名为category，key为方法名</span></span><br><span class="line"><span class="comment">//  value等同于cacheNames // key如果是字符串&quot;&#x27;&#x27;&quot;sync表示该方法的缓存被读取时会加锁(该锁是本地锁，只会锁住本地服务或进程)</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;category&quot;&#125;,key = &quot;#root.methodName&quot;,sync = true)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonDbWithSpringCache() &#123;</span><br><span class="line">    <span class="keyword">return</span> getCategoriesDb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法会删除缓存category下的所有cache，如果要删除某个具体，用key=&quot;&#x27;&#x27;&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &#123;&quot;category&quot;&#125;,allEntries = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCascade</span><span class="params">(CategoryEntity category)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.updateById(category);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(category.getName())) &#123;</span><br><span class="line">        categoryBrandRelationService.updateCategory(category);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果要清空多个缓存，用<span class="meta">@Caching(evict=&#123;@CacheEvict(value=&quot;&quot;)&#125;)</span></span><br><span class="line">或使用<span class="meta">@CacheEvict(value = &#123;&quot;category&quot;&#125;, allEntries = true)</span>，该注解能让该方法清除名称为category的缓存下的所有缓存</span><br></pre></td></tr></table></figure><h2 id="SpringCache原理与不足"><a href="#SpringCache原理与不足" class="headerlink" title="SpringCache原理与不足"></a>SpringCache原理与不足</h2><h3 id="读模式"><a href="#读模式" class="headerlink" title="读模式"></a>读模式</h3><ul><li>缓存穿透：查询一个null数据。解决方案：缓存空数据，可通过spring.cache.redis.cache-null-values=true</li><li>缓存击穿：大量并发进来同时查询一个正好过期的数据。解决方案：加锁 ? 默认是无加锁的;<br>使用sync = true来解决击穿问题</li><li>缓存雪崩：大量的key同时过期。解决：加随机时间。</li></ul><h3 id="写模式：（缓存与数据库一致）"><a href="#写模式：（缓存与数据库一致）" class="headerlink" title="写模式：（缓存与数据库一致）"></a>写模式：（缓存与数据库一致）</h3><ul><li>读写加锁。</li><li>引入Canal，感知到MySQL的更新去更新Redis</li><li>读多写多，直接去数据库查询就行</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用Spring-Cache）：</p><p>写模式(只要缓存的数据有过期时间就足够了)</p><p>特殊数据：特殊设计</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redisson </tag>
            
            <tag> 分布式缓存 </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发下缓存失效问题</title>
      <link href="2021/04/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>2021/04/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="高并发下缓存失效"><a href="#高并发下缓存失效" class="headerlink" title="高并发下缓存失效"></a>高并发下缓存失效</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p><strong>解决：</strong>缓存空对象、布隆过滤器、mvc拦截器</p><h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><p>缓存雪崩是指在我们设置缓存时key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><p><strong>解决方案：</strong></p><ul><li>规避雪崩：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>如果缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中。</li><li>设置热点数据永远不过期。</li><li>出现雪崩：降级 熔断<br>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。<br>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉<br>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><p>缓存雪崩和缓存击穿不同的是：</p><p>缓存击穿 指 并发查同一条数据。缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力<br>缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p><strong>解决方案：</strong></p><ul><li>设置热点数据永远不过期。</li><li>加互斥锁：业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db去数据库加载，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</li></ul><p><em>缓存击穿:加锁</em><br>不好的方法是synchronized(this)，在分布式情况下锁不住所有服务，这是本地锁，只能锁住所在的服务机。最好的是使用分布式锁。</p><p>锁时序问题：之前的逻辑是查缓存没有，然后取竞争锁查数据库，这样就造成多次查数据库。</p><p>解决方法：竞争到锁后，再次确认缓存中没有，再去查数据库。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理</title>
      <link href="2021/04/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>2021/04/08/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="正向代理和反向代理区别"><a href="#正向代理和反向代理区别" class="headerlink" title="正向代理和反向代理区别"></a>正向代理和反向代理区别</h1><h2 id="一-、什么是代理"><a href="#一-、什么是代理" class="headerlink" title="一 、什么是代理"></a>一 、什么是代理</h2><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内</p><h2 id="二-、正向代理"><a href="#二-、正向代理" class="headerlink" title="二 、正向代理"></a>二 、正向代理</h2><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210408165616.png"></p><p><strong>正向代理的用途：</strong></p><p>　　（1）访问原来无法访问的资源，如google</p><p>​       （2） 可以做缓存，加速访问资源</p><p>　　（3）对客户端访问授权，上网进行认证</p><p>　　（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h2 id="三、-反向代理"><a href="#三、-反向代理" class="headerlink" title="三、 反向代理"></a>三、 反向代理</h2><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210408165706.png" alt="fanxiangdaili"> </p><h4 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h4><p>（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h2 id="四-、总结"><a href="#四-、总结" class="headerlink" title="四 、总结"></a>四 、总结</h2><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong></p><p><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><h4 id="看图理解一"><a href="#看图理解一" class="headerlink" title="看图理解一"></a>看图理解一</h4><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210408165252.png"></p><h4 id="看图理解二"><a href="#看图理解二" class="headerlink" title="看图理解二"></a>看图理解二</h4><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210408165246.png" alt="img"></p><p>正向代理中，proxy和client同属一个LAN，对server透明；<br>反向代理中，proxy和server同属一个LAN，对client透明。<br>实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>正向代理: 买票的黄牛</p><p>反向代理: 租房的代理</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot整合Elasticsearch</title>
      <link href="2021/04/07/spring/Springboot%E6%95%B4%E5%90%88Elasticsearch/"/>
      <url>2021/04/07/spring/Springboot%E6%95%B4%E5%90%88Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot整合ElasticSearch"><a href="#SpringBoot整合ElasticSearch" class="headerlink" title="SpringBoot整合ElasticSearch"></a>SpringBoot整合ElasticSearch</h2><h3 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h3><p>这里的版本要和所按照的ELK版本匹配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在spring-boot-dependencies中所依赖的ELK版本位6.8.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;elasticsearch.version&gt;6.8.7&lt;&#x2F;elasticsearch.version&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407172737.png" alt="image-20200511074437763"></p><p>如果你使用Maven进行一个直接或间接继承spring-boot-dependencies（比如spring-boot-starter-parent）的构建，并想覆盖一个特定的第三方依赖，那你可以添加合适的<properties>元素。浏览spring-boot-dependencies POM可以获取一个全面的属性列表。例如，想要选择一个不同的elasticsearch版本，你可以添加以下内容将它改为7.6.2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 但是这只在你的Maven项目继承（直接或间接）自<code>spring-boot-dependencies</code>才有用。</p><p>如果你使用<code>&lt;scope&gt;import&lt;/scope&gt;</code>，将<code>spring-boot-dependencies</code>添加到自己的<code>dependencyManagement</code>片段，那你必须自己重新定义artifact而不是覆盖属性。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210408102141.png" alt="image.png"></p><p>需要在 <code>&lt;dependencyManagement&gt;</code> 下重新定义 artifact</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、编写测试类"><a href="#2、编写测试类" class="headerlink" title="2、编写测试类"></a>2、编写测试类</h3><p> <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-document-index.html">官方文档</a></p><h4 id="1）测试保存数据"><a href="#1）测试保存数据" class="headerlink" title="1）测试保存数据"></a>1）测试保存数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest (<span class="string">&quot;users&quot;</span>);</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    String jsonString = JSON.toJSONString(user);</span><br><span class="line">    <span class="comment">//设置要保存的内容</span></span><br><span class="line">    indexRequest.source(jsonString, XContentType.JSON);</span><br><span class="line">    <span class="comment">//执行创建索引和保存数据</span></span><br><span class="line">    IndexResponse index = client.index(indexRequest, GulimallElasticSearchConfig.COMMON_OPTIONS);</span><br><span class="line"></span><br><span class="line">    System.out.println(index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试前：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407172745.png" alt="image-20200511111618183"></p><p>测试后：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407172752.png" alt="image-20200511112025327"></p><h4 id="2）测试获取数据"><a href="#2）测试获取数据" class="headerlink" title="2）测试获取数据"></a>2）测试获取数据</h4><p> <a href="https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.json%EF%BC%88%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%AC%EF%BC%89">https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.json（官方数据样本）</a></p><p>查询state=”AK”的文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;state.keyword&quot;</span>: <span class="string">&quot;AK&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchState</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建检索条件</span></span><br><span class="line">  SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">  <span class="comment">//制定索引</span></span><br><span class="line">  searchRequest.indices(<span class="string">&quot;bank&quot;</span>);</span><br><span class="line">  <span class="comment">//指定DSL</span></span><br><span class="line">  SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">  <span class="comment">//构造检索条件</span></span><br><span class="line">  searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;state.keyword&quot;</span>, <span class="string">&quot;AK&quot;</span>));</span><br><span class="line"></span><br><span class="line">  searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">  SearchResponse search = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">  System.out.println(search.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索address中包含mill的所有人的年龄分布以及平均年龄，平均薪资</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;Mill&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ageAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;age&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ageAvg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;age&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;balanceAvg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;balance&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复杂检索:在bank中搜索address中包含mill的所有人的年龄分布以及平均年龄，平均薪资</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建检索请求</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.1）指定索引</span></span><br><span class="line">    searchRequest.indices(<span class="string">&quot;bank&quot;</span>);</span><br><span class="line">    <span class="comment">//1.2）构造检索条件</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;Mill&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2.1)按照年龄分布进行聚合</span></span><br><span class="line">    TermsAggregationBuilder ageAgg=AggregationBuilders.terms(<span class="string">&quot;ageAgg&quot;</span>).field(<span class="string">&quot;age&quot;</span>).size(<span class="number">10</span>);</span><br><span class="line">    sourceBuilder.aggregation(ageAgg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.2.2)计算平均年龄</span></span><br><span class="line">    AvgAggregationBuilder ageAvg = AggregationBuilders.avg(<span class="string">&quot;ageAvg&quot;</span>).field(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    sourceBuilder.aggregation(ageAvg);</span><br><span class="line">    <span class="comment">//1.2.3)计算平均薪资</span></span><br><span class="line">    AvgAggregationBuilder balanceAvg = AggregationBuilders.avg(<span class="string">&quot;balanceAvg&quot;</span>).field(<span class="string">&quot;balance&quot;</span>);</span><br><span class="line">    sourceBuilder.aggregation(balanceAvg);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;检索条件：&quot;</span>+sourceBuilder);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    <span class="comment">//2. 执行检索</span></span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(<span class="string">&quot;检索结果：&quot;</span>+searchResponse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 将检索结果封装为Bean</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    SearchHit[] searchHits = hits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        String sourceAsString = searchHit.getSourceAsString();</span><br><span class="line">        Account account = JSON.parseObject(sourceAsString, Account.class);</span><br><span class="line">        System.out.println(account);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 获取聚合信息</span></span><br><span class="line">    Aggregations aggregations = searchResponse.getAggregations();</span><br><span class="line"></span><br><span class="line">    Terms ageAgg1 = aggregations.get(<span class="string">&quot;ageAgg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : ageAgg1.getBuckets()) &#123;</span><br><span class="line">        String keyAsString = bucket.getKeyAsString();</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span>+keyAsString+<span class="string">&quot; ==&gt; &quot;</span>+bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">    Avg ageAvg1 = aggregations.get(<span class="string">&quot;ageAvg&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;平均年龄：&quot;</span>+ageAvg1.getValue());</span><br><span class="line"></span><br><span class="line">    Avg balanceAvg1 = aggregations.get(<span class="string">&quot;balanceAvg&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;平均薪资：&quot;</span>+balanceAvg1.getValue());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>可以尝试对比打印的条件和执行结果，和前面的ElasticSearch的检索语句和检索结果进行比较；</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch基本使用</title>
      <link href="2021/04/07/Elasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2021/04/07/Elasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-elasticsearch基本操作"><a href="#1-elasticsearch基本操作" class="headerlink" title="1. elasticsearch基本操作"></a>1. elasticsearch基本操作</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1.   基本概念"></a>1.1.   基本概念</h2><p>Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。</p><p>对比关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">索引（indices）----------------------Databases 数据库</span><br><span class="line"></span><br><span class="line">  类型（type）--------------------------Table 数据表</span><br><span class="line"></span><br><span class="line">     文档（Document）----------------------Row 行</span><br><span class="line"></span><br><span class="line">    字段（Field）-------------------------Columns 列 </span><br></pre></td></tr></table></figure><p>要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。</p><h2 id="1-2-索引操作（indeces）"><a href="#1-2-索引操作（indeces）" class="headerlink" title="1.2.   索引操作（indeces）"></a>1.2.   索引操作（indeces）</h2><h3 id="1-2-1-查询索引"><a href="#1-2-1-查询索引" class="headerlink" title="1.2.1.    查询索引"></a>1.2.1.    查询索引</h3><p>查看es中有哪些索引库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;indices?v</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407100232.png" alt="image-20210407100231912"></p><p>es 中会默认存在一个名为.kibana和.kibana_task_manager的索引</p><p>表头的含义</p><table><thead><tr><th align="center">字段名</th><th align="left">含义说明</th></tr></thead><tbody><tr><td align="center">health</td><td align="left">green(集群完整) yellow(单点正常、集群不完整) red(单点不正常)</td></tr><tr><td align="center">status</td><td align="left">是否能使用</td></tr><tr><td align="center">index</td><td align="left">索引名</td></tr><tr><td align="center">uuid</td><td align="left">索引统一编号</td></tr><tr><td align="center">pri</td><td align="left">主节点几个</td></tr><tr><td align="center">rep</td><td align="left">从节点几个</td></tr><tr><td align="center">docs.count</td><td align="left">文档数</td></tr><tr><td align="center">docs.deleted</td><td align="left">文档被删了多少</td></tr><tr><td align="center">store.size</td><td align="left">整体占空间大小</td></tr><tr><td align="center">pri.store.size</td><td align="left">主节点占</td></tr></tbody></table><h3 id="1-2-2-创建索引"><a href="#1-2-2-创建索引" class="headerlink" title="1.2.2.   创建索引"></a>1.2.2.   创建索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;索引名</span><br></pre></td></tr></table></figure><p>参数可选：指定分片及副本，默认分片为3，副本为2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: 3,</span><br><span class="line">        &quot;number_of_replicas&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示：说明索引创建成功</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407100357.png" alt="image-20210407100356885"></p><p>再次查询，可以看到刚刚创建的索引：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407100438.png" alt="image-20210407100438739" style="zoom:80%;" /><h3 id="1-2-3-查看索引具体信息"><a href="#1-2-3-查看索引具体信息" class="headerlink" title="1.2.3.    查看索引具体信息"></a>1.2.3.    查看索引具体信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;索引名</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407100644.png" alt="image-20210407100643922"></p><p>或者，我们可以使用*来查询所有索引具体信息(<strong>已被弃用)</strong></p><h3 id="1-2-4-删除索引"><a href="#1-2-4-删除索引" class="headerlink" title="1.2.4.    删除索引"></a>1.2.4.    删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;索引库名</span><br></pre></td></tr></table></figure><p>演示：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407100747.png" alt="image-20210407100747633"></p><p>查看test:</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407100804.png" alt="image-20210407100804308"></p><h2 id="1-3-映射配置（-mapping）"><a href="#1-3-映射配置（-mapping）" class="headerlink" title="1.3.   映射配置（_mapping）"></a>1.3.   映射配置（_mapping）</h2><p>索引有了，接下来肯定是添加数据。但是，在添加数据之前必须定义映射。</p><p>什么是映射？</p><blockquote><p>映射是定义文档的过程，文档包含哪些字段，这些字段是否保存，是否索引，是否分词等</p></blockquote><p>只有配置清楚，Elasticsearch才会帮我们进行索引库的创建（不一定）</p><h3 id="1-3-1-创建映射字段"><a href="#1-3-1-创建映射字段" class="headerlink" title="1.3.1.    创建映射字段"></a>1.3.1.    创建映射字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;索引库名</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;类型&quot;,</span><br><span class="line">        &quot;index&quot;: true，</span><br><span class="line">        &quot;store&quot;: true，</span><br><span class="line">        &quot;analyzer&quot;: &quot;分词器&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型名称：就是前面将的type的概念，类似于数据库中的不同表</p><p>字段名：类似于列名，properties下可以指定许多字段。</p><p>每个字段可以有很多属性。例如：</p><ul><li>type：类型，可以是text、long、short、date、integer、object等</li><li>index：是否索引，默认为true</li><li>store：是否存储，默认为false</li><li>analyzer：分词器，这里使用ik分词器：<code>ik_max_word</code>或者<code>ik_smart</code></li></ul><blockquote><p>示例</p></blockquote><p>发起请求：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /atguigu</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;images&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-2-查看映射关系"><a href="#1-3-2-查看映射关系" class="headerlink" title="1.3.2.    查看映射关系"></a>1.3.2.    查看映射关系</h3><blockquote><p>语法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;索引库名&#x2F;_mapping</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;atguigu&#x2F;_mapping</span><br></pre></td></tr></table></figure><blockquote><p>响应：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;atguigu&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;images&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span> : <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type：字段类型。String（text  keyword） Numeric（long integer float double） date boolean</p><p>index：是否创建索引</p><p>analyzer：分词器（ik_max_word）</p><h2 id="1-4-新增文档（document）"><a href="#1-4-新增文档（document）" class="headerlink" title="1.4.   新增文档（document）"></a>1.4.   新增文档（document）</h2><p>有了索引、类型和映射，就可以对文档做增删改查操作了。</p><h3 id="1-4-1-基本玩法"><a href="#1-4-1-基本玩法" class="headerlink" title="1.4.1.    基本玩法"></a>1.4.1.    基本玩法</h3><p>如果我们想要自己新增的时候指定id，可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;索引库名&#x2F;_doc&#x2F;id值</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /atguigu/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;price&quot;</span>: <span class="number">3999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询得到结果：小米手机的id是我们指定的id</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407102853.png" alt="image-20210407102853367" style="zoom:67%;" /><ul><li><code>_source</code>：源文档信息，所有的数据都在里面。</li><li><code>_id</code>：这条文档的唯一标示，与文档自己的id字段没有关联</li></ul><h3 id="1-4-2-智能判断"><a href="#1-4-2-智能判断" class="headerlink" title="1.4.2.    智能判断"></a>1.4.2.    智能判断</h3><p>事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。</p><p>测试一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /atguigu/_doc/2  //type已被弃用，同一索引下只有_doc一个type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span>:<span class="number">2899</span>,</span><br><span class="line">    <span class="attr">&quot;stock&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;saleable&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;attr&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;小米&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们额外添加了stock库存，saleable是否上架，attr其他属性几个字段。</p><p>来看结果：<code>GET /atguigu/_search</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;atguigu&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span> : <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;price&quot;</span> : <span class="number">3999</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;atguigu&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;title&quot;</span> : <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;images&quot;</span> : <span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;price&quot;</span> : <span class="number">2899</span>,</span><br><span class="line">          <span class="attr">&quot;stock&quot;</span> : <span class="number">200</span>,</span><br><span class="line">          <span class="attr">&quot;saleable&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;attr&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;category&quot;</span> : <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;小米&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下索引库的映射关系: <code>GET /atguigu/_mapping</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;atguigu&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;attr&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;brand&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;category&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">                  <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;images&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;index&quot;</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;price&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;saleable&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;boolean&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;stock&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;title&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span> : <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stock，saleable，attr都被成功映射了。</p><p>如果是字符串类型的数据，会添加两种类型：text + keyword。如上例中的category 和 brand</p><h2 id="1-5-删除数据"><a href="#1-5-删除数据" class="headerlink" title="1.5.   删除数据"></a>1.5.   删除数据</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><blockquote><p>语法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;索引库名&#x2F;_doc&#x2F;id值</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;atguigu&#x2F;_doc&#x2F;3</span><br></pre></td></tr></table></figure><blockquote><p>结果：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;atguigu&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;goods&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;deleted&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-查询"><a href="#2-查询" class="headerlink" title="2. 查询"></a>2. 查询</h1><p>之前已经见识了查询功能</p><p>查询所有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;index&#125;&#x2F;_search</span><br></pre></td></tr></table></figure><p>根据id查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;index&#125;&#x2F;&#123;type&#125;&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure><p>除了上述简单查询之外。elasticsearch作为搜索引擎，最复杂最强大的功能就是搜索查询功能。包括：匹配查询、词条查询、模糊查询、组合查询、范围查询、高亮、排序、分页等等查询功能。</p><p>基本查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;查询类型&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;查询条件&quot;</span>:<span class="string">&quot;查询条件值&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的query代表一个查询对象，里面可以有不同的查询属性</p><ul><li>查询类型：<ul><li>例如：<code>match_all</code>， <code>match</code>，<code>term</code> ， <code>range</code> 等等</li></ul></li><li>查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解</li></ul><p>查询结果：</p><ul><li>took：查询花费时间，单位是毫秒</li><li>time_out：是否超时</li><li>_shards：分片信息</li><li>hits：搜索结果总览对象<ul><li>total：搜索到的总条数</li><li>max_score：所有结果中文档得分的最高分</li><li>hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息<ul><li>_index：索引库</li><li>_type：文档类型</li><li>_id：文档id</li><li>_score：文档得分</li><li>_source：文档的源数据</li></ul></li></ul></li></ul><h2 id="2-1-数据准备"><a href="#2-1-数据准备" class="headerlink" title="2.1.   数据准备"></a>2.1.   数据准备</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST /atguigu/_bulk</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;小米手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">1999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">200</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;小米&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">&quot;title&quot;</span>:<span class="string">&quot;超米手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">2999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">300</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;小米&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">3</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;小米电视&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">3999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">400</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;电视&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;小米&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">4</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;小米笔记本&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">4999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">200</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;笔记本&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;小米&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">5</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;华为手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">3999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">400</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">6</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;华为笔记本&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">5999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">200</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;笔记本&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">7</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;荣耀手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">2999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">300</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">8</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;oppo手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">2799</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">400</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;oppo&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">9</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;vivo手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">2699</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">300</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;vivo&quot;</span> &#125; &#125;</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_id&quot;</span>:<span class="number">10</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;华为nova手机&quot;</span>, <span class="attr">&quot;images&quot;</span>:<span class="string">&quot;http://image.jd.com/12479122.jpg&quot;</span>, <span class="attr">&quot;price&quot;</span>:<span class="number">2999</span>, <span class="attr">&quot;stock&quot;</span>: <span class="number">300</span>, <span class="attr">&quot;attr&quot;</span>: &#123; <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;手机&quot;</span>, <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-匹配查询（match）"><a href="#2-2-匹配查询（match）" class="headerlink" title="2.2.   匹配查询（match）"></a>2.2.   匹配查询（match）</h2><blockquote><p>匹配所有</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>query</code>：代表查询对象</li><li><code>match_all</code>：代表查询所有</li></ul><blockquote><p>条件匹配</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询出很多数据，不仅包括<code>小米手机</code>，而且与<code>小米</code>或者<code>手机</code>相关的都会查询到，说明多个词之间是<code>or</code>的关系。</p><p>某些情况下，我们需要更精确查找，我们希望这个关系变成<code>and</code>，可以这样做：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;小米手机&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 26,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 2,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;max_score&quot; : 1.7037868,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;atguigu&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;goods&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.7037868,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;title&quot; : &quot;小米手机&quot;,</span><br><span class="line">          &quot;images&quot; : &quot;http:&#x2F;&#x2F;image.jd.com&#x2F;12479122.jpg&quot;,</span><br><span class="line">          &quot;price&quot; : 1999,</span><br><span class="line">          &quot;stock&quot; : 200,</span><br><span class="line">          &quot;attr&quot; : &#123;</span><br><span class="line">            &quot;category&quot; : &quot;手机&quot;,</span><br><span class="line">            &quot;brand&quot; : &quot;小米&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子属性匹配</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;attr.brand&quot;</span>: <span class="string">&quot;小米&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多字段匹配</p></blockquote><p><code>match</code>只能根据一个字段匹配查询，如果要根据多个字段匹配查询可以使用<code>multi_match</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;attr.brand.keyword&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-词条查询（term）"><a href="#2-3-词条查询（term）" class="headerlink" title="2.3.   词条查询（term）"></a>2.3.   词条查询（term）</h2><p><code>term</code> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些<strong>未分词</strong>的字符串。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: <span class="number">4999</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-范围查询（range）"><a href="#2-4-范围查询（range）" class="headerlink" title="2.4.   范围查询（range）"></a>2.4.   范围查询（range）</h2><p><code>range</code> 查询找出那些落在指定区间内的数字或者时间</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;gte&quot;</span>:  <span class="number">1000</span>,</span><br><span class="line">                <span class="attr">&quot;lt&quot;</span>:   <span class="number">3000</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询允许以下字符：</p><table><thead><tr><th align="center">操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">gt</td><td align="center">大于</td></tr><tr><td align="center">gte</td><td align="center">大于等于</td></tr><tr><td align="center">lt</td><td align="center">小于</td></tr><tr><td align="center">lte</td><td align="center">小于等于</td></tr></tbody></table><h2 id="2-5-布尔组合（bool"><a href="#2-5-布尔组合（bool" class="headerlink" title="2.5.   布尔组合（bool)"></a>2.5.   布尔组合（bool)</h2><p>布尔查询又叫<strong>组合查询</strong></p><p><code>bool</code>把各种其它查询通过<code>must</code>（与）、<code>must_not</code>（非）、<code>should</code>（或）的方式进行组合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;gte&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">                <span class="attr">&quot;lte&quot;</span>: <span class="number">3000</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;gte&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">                <span class="attr">&quot;lte&quot;</span>: <span class="number">4000</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一个组合查询里面只能出现一种组合，不能混用</p><h2 id="2-6-过滤（filter）"><a href="#2-6-过滤（filter）" class="headerlink" title="2.6.   过滤（filter）"></a>2.6.   过滤（filter）</h2><p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用<code>filter</code>方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;gt&quot;</span>: <span class="number">2000</span>, <span class="attr">&quot;lt&quot;</span>: <span class="number">3000</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>filter</code>中还可以再次进行<code>bool</code>组合条件过滤。</p><h2 id="2-7-排序（sort）"><a href="#2-7-排序（sort）" class="headerlink" title="2.7.   排序（sort）"></a>2.7.   排序（sort）</h2><p><code>sort</code> 可以让我们按照不同的字段进行排序，并且通过<code>order</code>指定排序的方式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span>: &#123; <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-分页（from-size）"><a href="#2-8-分页（from-size）" class="headerlink" title="2.8.   分页（from/size）"></a>2.8.   分页（from/size）</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米手机&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>from：从那一条开始</p><p>size：取多少条</p><h2 id="2-9-高亮（highlight）"><a href="#2-9-高亮（highlight）" class="headerlink" title="2.9.   高亮（highlight）"></a>2.9.   高亮（highlight）</h2><p>高亮的本质是给关键字添加了<em>标签，在前端再给该标签添加样式即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;小米&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;<span class="attr">&quot;title&quot;</span>: &#123;&#125;&#125;, </span><br><span class="line">    <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;em&gt;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/em&gt;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields：高亮字段</p><p>pre_tags：前置标签</p><p>post_tags：后置标签</p><p>查询结果如下：</p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210407104420.png" alt="image-20210407104420074" style="zoom:80%;" /><h2 id="2-10-结果过滤（-source）"><a href="#2-10-结果过滤（-source）" class="headerlink" title="2.10.   结果过滤（_source）"></a>2.10.   结果过滤（_source）</h2><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在<code>_source</code>的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，可以添加<code>_source</code>的过滤</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;title&quot;</span>,<span class="string">&quot;price&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="number">2699</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果，只有两个字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">9</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;atguigu&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;goods&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;9&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;price&quot;</span> : <span class="number">2699</span>,</span><br><span class="line">          <span class="attr">&quot;title&quot;</span> : <span class="string">&quot;vivo手机&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-聚合（aggregations）"><a href="#3-聚合（aggregations）" class="headerlink" title="3. 聚合（aggregations）"></a>3. 聚合（aggregations）</h1><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。</p><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫<code>桶</code>，一个叫<code>度量</code>：</p><blockquote><p><strong>桶（bucket）</strong></p></blockquote><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个<code>桶</code>，例如我们根据国籍对人划分，可以得到<code>中国桶</code>、<code>英国桶</code>，<code>日本桶</code>……或者我们按照年龄段对人进行划分：0<del>10,10</del>20,20<del>30,30</del>40等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li><li>……</li></ul><p>bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><blockquote><p><strong>度量（metrics）</strong></p></blockquote><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为<code>度量</code></p><p>比较常用的一些度量聚合方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li><li>……</li></ul><h2 id="3-2-聚合为桶"><a href="#3-2-聚合为桶" class="headerlink" title="3.2 聚合为桶"></a>3.2 聚合为桶</h2><p>首先，我们按照手机的品牌<code>attr.brand.keyword</code>来划分<code>桶</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">        <span class="attr">&quot;brands&quot;</span> : &#123; </span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; </span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;attr.brand.keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率</li><li>aggs：声明这是一个聚合查询，是aggregations的缩写<ul><li>brands：给这次聚合起一个名字，任意。<ul><li>terms：划分桶的方式，这里是根据词条划分<ul><li>field：划分桶的字段</li></ul></li></ul></li></ul></li></ul><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">124</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;brands&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;华为&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;oppo&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;vivo&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>brands：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的品牌字段值都会形成一个桶<ul><li>key：这个桶对应的品牌字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul><h2 id="3-3-桶内度量"><a href="#3-3-桶内度量" class="headerlink" title="3.3 桶内度量"></a>3.3 桶内度量</h2><p>前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种品牌手机的平均价格是多少？</p><p>因此，我们需要告诉Elasticsearch<code>使用哪个字段</code>，<code>使用何种度量方式</code>进行运算，这些信息要嵌套在<code>桶</code>内，<code>度量</code>的运算会基于<code>桶</code>内的文档进行</p><p>现在，我们为刚刚的聚合结果添加 求价格平均值的度量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">        <span class="attr">&quot;brands&quot;</span> : &#123; </span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; </span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;attr.brand.keyword&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span>: &#123; </span><br><span class="line">                   <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>aggs：我们在上一个aggs(brands)中添加新的aggs。可见<code>度量</code>也是一个聚合</li><li>avg_price：聚合的名称</li><li>avg：度量的类型，这里是求平均值</li><li>field：度量运算的字段</li></ul><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">41</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;brands&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;华为&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">4</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">3999.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">4</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">3499.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;oppo&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">2799.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;vivo&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">2699.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到每个桶中都有自己的<code>avg_price</code>字段，这是度量聚合的结果</p><h2 id="3-4-桶内嵌套桶"><a href="#3-4-桶内嵌套桶" class="headerlink" title="3.4 桶内嵌套桶"></a>3.4 桶内嵌套桶</h2><p>刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。</p><p>比如：我们想统计每个品牌都生产了那些产品，按照<code>attr.category.keyword</code>字段再进行分桶</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET /atguigu/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;size&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span> : &#123; </span><br><span class="line">        <span class="attr">&quot;brands&quot;</span> : &#123; </span><br><span class="line">            <span class="attr">&quot;terms&quot;</span> : &#123; </span><br><span class="line">              <span class="attr">&quot;field&quot;</span> : <span class="string">&quot;attr.brand.keyword&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">                <span class="attr">&quot;avg_price&quot;</span>: &#123; </span><br><span class="line">                   <span class="attr">&quot;avg&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;price&quot;</span> </span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;categorys&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attr.category.keyword&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">19</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;brands&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;华为&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">4</span>,</span><br><span class="line">          <span class="attr">&quot;categorys&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">3</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;笔记本&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">3999.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;小米&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">4</span>,</span><br><span class="line">          <span class="attr">&quot;categorys&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">2</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;电视&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;笔记本&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">3499.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;oppo&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;categorys&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">2799.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;vivo&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;categorys&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;手机&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;avg_price&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : <span class="number">2699.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我们可以看到，新的聚合<code>categorys</code>被嵌套在原来每一个<code>brands</code>的桶中。</li><li>每个品牌下面都根据 <code>attr.category.keyword</code>字段进行了分组</li><li>我们能读取到的信息：<ul><li>华为有4中产品</li><li>华为产品的平均售价是 3999.0美元。</li><li>其中3种手机产品，1种笔记本产品</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR303校验</title>
      <link href="2021/03/29/java/JSR303%E6%A0%A1%E9%AA%8C/"/>
      <url>2021/03/29/java/JSR303%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JSR303校验"><a href="#1-JSR303校验" class="headerlink" title="1. JSR303校验"></a>1. JSR303校验</h2><h3 id="步骤1：使用校验注解"><a href="#步骤1：使用校验注解" class="headerlink" title="步骤1：使用校验注解"></a>步骤1：使用校验注解</h3><p>在Java中提供了一系列的校验方式，它这些校验方式在“javax.validation.constraints”包中，提供了如@Email，@NotNull等注解。</p><p>在非空处理方式上提供了@NotNull，@Blank和@</p><p>（1）@NotNull</p><p>The annotated element must not be null. Accepts any type.<br>注解元素禁止为null，能够接收任何类型</p><p>（2）@NotEmpty</p><p>the annotated element must not be null nor empty.</p><p>该注解修饰的字段不能为null或””</p><p>Supported types are:</p><p>支持以下几种类型</p><p>CharSequence (length of character sequence is evaluated)</p><p>字符序列（字符序列长度的计算）</p><p>Collection (collection size is evaluated)<br>集合长度的计算</p><p>Map (map size is evaluated)<br>map长度的计算</p><p>Array (array length is evaluated)<br>数组长度的计算</p><p>（3）@NotBlank</p><p>The annotated element must not be null and must contain at least one non-whitespace character. Accepts CharSequence.<br>该注解不能为null，并且至少包含一个非空白字符。接收字符序列。</p><h3 id="步骤2：在请求方法种，使用校验注解-Valid，开启校验，"><a href="#步骤2：在请求方法种，使用校验注解-Valid，开启校验，" class="headerlink" title="步骤2：在请求方法种，使用校验注解@Valid，开启校验，"></a>步骤2：在请求方法种，使用校验注解@Valid，开启校验，</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand)</span></span>&#123;</span><br><span class="line">brandService.save(brand);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> R.ok();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试： <a href="http://localhost:88/api/product/brand/save">http://localhost:88/api/product/brand/save</a> </p><p>在postman种发送上面的请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2020-04-29T09:20:46.383+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;NotBlank.brandEntity.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.java.lang.String&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;arguments&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;brandEntity.name&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">&quot;arguments&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;不能为空&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;objectName&quot;</span>: <span class="string">&quot;brandEntity&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;rejectedValue&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;bindingFailure&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Validation failed for object=&#x27;brandEntity&#x27;. Error count: 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/product/brand/save&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够看到”defaultMessage”: “不能为空”，这些错误消息定义在“hibernate-validator”的“\org\hibernate\validator\ValidationMessages_zh_CN.properties”文件中。在该文件中定义了很多的错误规则：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">javax.validation.constraints.AssertFalse.message</span>     = <span class="string">只能为false</span></span><br><span class="line"><span class="meta">javax.validation.constraints.AssertTrue.message</span>      = <span class="string">只能为true</span></span><br><span class="line"><span class="meta">javax.validation.constraints.DecimalMax.message</span>      = <span class="string">必须小于或等于&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.DecimalMin.message</span>      = <span class="string">必须大于或等于&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Digits.message</span>          = <span class="string">数字的值超出了允许范围(只允许在&#123;integer&#125;位整数和&#123;fraction&#125;位小数范围内)</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Email.message</span>           = <span class="string">不是一个合法的电子邮件地址</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Future.message</span>          = <span class="string">需要是一个将来的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.FutureOrPresent.message</span> = <span class="string">需要是一个将来或现在的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Max.message</span>             = <span class="string">最大不能超过&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Min.message</span>             = <span class="string">最小不能小于&#123;value&#125;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Negative.message</span>        = <span class="string">必须是负数</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NegativeOrZero.message</span>  = <span class="string">必须是负数或零</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NotBlank.message</span>        = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NotEmpty.message</span>        = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">javax.validation.constraints.NotNull.message</span>         = <span class="string">不能为null</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Null.message</span>            = <span class="string">必须为null</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Past.message</span>            = <span class="string">需要是一个过去的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.PastOrPresent.message</span>   = <span class="string">需要是一个过去或现在的时间</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Pattern.message</span>         = <span class="string">需要匹配正则表达式&quot;&#123;regexp&#125;&quot;</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Positive.message</span>        = <span class="string">必须是正数</span></span><br><span class="line"><span class="meta">javax.validation.constraints.PositiveOrZero.message</span>  = <span class="string">必须是正数或零</span></span><br><span class="line"><span class="meta">javax.validation.constraints.Size.message</span>            = <span class="string">个数必须在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.CreditCardNumber.message</span>        = <span class="string">不合法的信用卡号码</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Currency.message</span>                = <span class="string">不合法的货币 (必须是&#123;value&#125;其中之一)</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.EAN.message</span>                     = <span class="string">不合法的&#123;type&#125;条形码</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Email.message</span>                   = <span class="string">不是一个合法的电子邮件地址</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Length.message</span>                  = <span class="string">长度需要在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.CodePointLength.message</span>         = <span class="string">长度需要在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.LuhnCheck.message</span>               = <span class="string">$&#123;validatedValue&#125;的校验码不合法, Luhn模10校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Mod10Check.message</span>              = <span class="string">$&#123;validatedValue&#125;的校验码不合法, 模10校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Mod11Check.message</span>              = <span class="string">$&#123;validatedValue&#125;的校验码不合法, 模11校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.ModCheck.message</span>                = <span class="string">$&#123;validatedValue&#125;的校验码不合法, $&#123;modType&#125;校验和不匹配</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.NotBlank.message</span>                = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.NotEmpty.message</span>                = <span class="string">不能为空</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.ParametersScriptAssert.message</span>  = <span class="string">执行脚本表达式&quot;&#123;script&#125;&quot;没有返回期望结果</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.Range.message</span>                   = <span class="string">需要在&#123;min&#125;和&#123;max&#125;之间</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.SafeHtml.message</span>                = <span class="string">可能有不安全的HTML内容</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.ScriptAssert.message</span>            = <span class="string">执行脚本表达式&quot;&#123;script&#125;&quot;没有返回期望结果</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.URL.message</span>                     = <span class="string">需要是一个合法的URL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.time.DurationMax.message</span>        = <span class="string">必须小于$&#123;inclusive == true ? &#x27;或等于&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days += &#x27;天&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours += &#x27;小时&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes += &#x27;分钟&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds += &#x27;秒&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis += &#x27;毫秒&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos += &#x27;纳秒&#x27;&#125;</span></span><br><span class="line"><span class="meta">org.hibernate.validator.constraints.time.DurationMin.message</span>        = <span class="string">必须大于$&#123;inclusive == true ? &#x27;或等于&#x27; : &#x27;&#x27;&#125;$&#123;days == 0 ? &#x27;&#x27; : days += &#x27;天&#x27;&#125;$&#123;hours == 0 ? &#x27;&#x27; : hours += &#x27;小时&#x27;&#125;$&#123;minutes == 0 ? &#x27;&#x27; : minutes += &#x27;分钟&#x27;&#125;$&#123;seconds == 0 ? &#x27;&#x27; : seconds += &#x27;秒&#x27;&#125;$&#123;millis == 0 ? &#x27;&#x27; : millis += &#x27;毫秒&#x27;&#125;$&#123;nanos == 0 ? &#x27;&#x27; : nanos += &#x27;纳秒&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要自定义错误消息，可以覆盖默认的错误提示信息，如@NotBlank的默认message是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotBlank &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;</span>&#123;javax.validation.constraints.NotBlank.message&#125;<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure><p>可以在添加注解的时候，修改message：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名必须非空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><p>当再次发送请求时，得到的错误提示信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2020-04-29T09:36:04.125+0000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;errors&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;NotBlank.brandEntity.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank.java.lang.String&quot;</span>,</span><br><span class="line">                <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;arguments&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;codes&quot;</span>: [</span><br><span class="line">                        <span class="string">&quot;brandEntity.name&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">&quot;arguments&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defaultMessage&quot;</span>: <span class="string">&quot;品牌名必须非空&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;objectName&quot;</span>: <span class="string">&quot;brandEntity&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;rejectedValue&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;bindingFailure&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;NotBlank&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Validation failed for object=&#x27;brandEntity&#x27;. Error count: 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/product/brand/save&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种返回的错误结果并不符合我们的业务需要。</p><h3 id="步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。"><a href="#步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。" class="headerlink" title="步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。"></a>步骤3：给校验的Bean后，紧跟一个BindResult，就可以获取到校验的结果。拿到校验的结果，就可以自定义的封装。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> BrandEntity brand, BindingResult result)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( result.hasErrors())&#123;</span><br><span class="line">           Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           <span class="comment">//1.获取错误的校验结果</span></span><br><span class="line">           result.getFieldErrors().forEach((item)-&gt;&#123;</span><br><span class="line">               <span class="comment">//获取发生错误时的message</span></span><br><span class="line">               String message = item.getDefaultMessage();</span><br><span class="line">               <span class="comment">//获取发生错误的字段</span></span><br><span class="line">               String field = item.getField();</span><br><span class="line">               map.put(field,message);</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;提交的数据不合法&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">brandService.save(brand);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> R.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种是针对于该请求设置了一个内容校验，如果针对于每个请求都单独进行配置，显然不是太合适，实际上可以统一的对于异常进行处理。</p><h3 id="步骤4：统一异常处理"><a href="#步骤4：统一异常处理" class="headerlink" title="步骤4：统一异常处理"></a>步骤4：统一异常处理</h3><p>可以使用SpringMvc所提供的@ControllerAdvice，通过“basePackages”能够说明处理哪些路径下的异常。</p><p>（1）抽取一个异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.gulimall.product.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bigdata.common.utils.R;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集中处理所有异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.bigdata.gulimall.product.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallExceptionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">handleValidException</span><span class="params">(MethodArgumentNotValidException exception)</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        BindingResult bindingResult = exception.getBindingResult();</span><br><span class="line">        bindingResult.getFieldErrors().forEach(fieldError -&gt; &#123;</span><br><span class="line">            String message = fieldError.getDefaultMessage();</span><br><span class="line">            String field = fieldError.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;数据校验出现问题&#123;&#125;,异常类型&#123;&#125;&quot;</span>,exception.getMessage(),exception.getClass());</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="number">400</span>,<span class="string">&quot;数据校验出现问题&quot;</span>).put(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）测试： <a href="http://localhost:88/api/product/brand/save">http://localhost:88/api/product/brand/save</a> </p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210329105731.png" alt="image-20200429183334783"></p><p>（3）默认异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> R <span class="title">handleException</span><span class="params">(Throwable throwable)</span></span>&#123;</span><br><span class="line">     log.error(<span class="string">&quot;未知异常&#123;&#125;,异常类型&#123;&#125;&quot;</span>,throwable.getMessage(),throwable.getClass());</span><br><span class="line">     <span class="keyword">return</span> R.error(BizCodeEnum.UNKNOW_EXEPTION.getCode(),BizCodeEnum.UNKNOW_EXEPTION.getMsg());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（4）错误状态码</p><p>上面代码中，针对于错误状态码，是我们进行随意定义的，然而正规开发过程中，错误状态码有着严格的定义规则，如该在项目中我们的错误状态码定义</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210329105739.png" alt="image-20200429183748249"></p><p>为了定义这些错误状态码，我们可以单独定义一个常量类，用来存储这些错误状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.common.exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 错误码和错误信息定义类</span></span><br><span class="line"><span class="comment"> * 1. 错误码定义规则为5为数字</span></span><br><span class="line"><span class="comment"> * 2. 前两位表示业务场景，最后三位表示错误码。例如：100001。10:通用 001:系统未知异常</span></span><br><span class="line"><span class="comment"> * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式</span></span><br><span class="line"><span class="comment"> * 错误码列表：</span></span><br><span class="line"><span class="comment"> *  10: 通用</span></span><br><span class="line"><span class="comment"> *      001：参数格式校验</span></span><br><span class="line"><span class="comment"> *  11: 商品</span></span><br><span class="line"><span class="comment"> *  12: 订单</span></span><br><span class="line"><span class="comment"> *  13: 购物车</span></span><br><span class="line"><span class="comment"> *  14: 物流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BizCodeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UNKNOW_EXEPTION(<span class="number">10000</span>,<span class="string">&quot;系统未知异常&quot;</span>),</span><br><span class="line"></span><br><span class="line">    VALID_EXCEPTION( <span class="number">10001</span>,<span class="string">&quot;参数格式校验失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    BizCodeEnum(<span class="keyword">int</span> code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（5）测试： <a href="http://localhost:88/api/product/brand/save">http://localhost:88/api/product/brand/save</a> </p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210329105753.png" alt="image-20200429191830967" style="zoom:67%;" /><h2 id="2-分组校验功能（完成多场景的复杂校验）"><a href="#2-分组校验功能（完成多场景的复杂校验）" class="headerlink" title="2. 分组校验功能（完成多场景的复杂校验）"></a>2. 分组校验功能（完成多场景的复杂校验）</h2><h3 id="1、给校验注解，标注上groups，指定什么情况下才需要进行校验"><a href="#1、给校验注解，标注上groups，指定什么情况下才需要进行校验" class="headerlink" title="1、给校验注解，标注上groups，指定什么情况下才需要进行校验"></a>1、给校验注解，标注上groups，指定什么情况下才需要进行校验</h3><p>如：指定在更新和添加的时候，都需要进行校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty</span></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名必须非空&quot;,groups = &#123;UpdateGroup.class,AddGroup.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><p>在这种情况下，没有指定分组的校验注解，默认是不起作用的。想要起作用就必须要加groups。</p><h3 id="2、业务方法参数上使用-Validated注解"><a href="#2、业务方法参数上使用-Validated注解" class="headerlink" title="2、业务方法参数上使用@Validated注解"></a>2、业务方法参数上使用@Validated注解</h3><p>@Validated的value方法：</p><p>Specify one or more validation groups to apply to the validation step kicked off by this annotation.<br> 指定一个或多个验证组以应用于此注释启动的验证步骤。 </p><p>JSR-303 defines validation groups as custom annotations which an application declares for the sole purpose of using<br>them as type-safe group arguments, as implemented in SpringValidatorAdapter.</p><p> JSR-303 将验证组定义为自定义注释，应用程序声明的唯一目的是将它们用作类型安全组参数，如 SpringValidatorAdapter 中实现的那样。 </p><p>Other SmartValidator implementations may support class arguments in other ways as well.</p><p> 其他SmartValidator 实现也可以以其他方式支持类参数。 </p><h3 id="3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。"><a href="#3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。" class="headerlink" title="3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。"></a>3、默认情况下，在分组校验情况下，没有指定指定分组的校验注解，将不会生效，它只会在不分组的情况下生效。</h3><h2 id="3-自定义校验功能"><a href="#3-自定义校验功能" class="headerlink" title="3. 自定义校验功能"></a>3. 自定义校验功能</h2><h3 id="1、编写一个自定义的校验注解"><a href="#1、编写一个自定义的校验注解" class="headerlink" title="1、编写一个自定义的校验注解"></a>1、编写一个自定义的校验注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ListValueConstraintValidator.class&#125;)</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;</span>&#123;com.bigdata.common.valid.ListValue.message&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] value() default &#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2、编写一个自定义的校验器"><a href="#2、编写一个自定义的校验器" class="headerlink" title="2、编写一个自定义的校验器"></a>2、编写一个自定义的校验器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ListValue</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ListValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] value = constraintAnnotation.value();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : value) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  set.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、关联自定义的校验器和自定义的校验注解"><a href="#3、关联自定义的校验器和自定义的校验注解" class="headerlink" title="3、关联自定义的校验器和自定义的校验注解"></a>3、关联自定义的校验器和自定义的校验注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ListValueConstraintValidator.class&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="4、使用实例"><a href="#4、使用实例" class="headerlink" title="4、使用实例"></a>4、使用实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示状态[0-不显示；1-显示]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ListValue(value = &#123;0,1&#125;,groups =&#123;AddGroup.class&#125;)</span></span><br><span class="line"><span class="keyword">private</span> Integer showStatus;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulimall项目 </tag>
            
            <tag> JSR303 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8stream的详细用法</title>
      <link href="2021/03/24/java/Java8stream%E7%9A%84%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/"/>
      <url>2021/03/24/java/Java8stream%E7%9A%84%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>特点：</p><p> 1 . 不是数据结构，不会保存数据。</p><ol start="2"><li>不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）</li><li>惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。</li></ol><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210324211334.png" alt="img"></p><p>无状态：指元素的处理不受之前元素的影响；</p><p>有状态：指该操作只有拿到所有元素之后才能继续下去。</p><p>非短路操作：指必须处理所有元素才能得到最终结果；</p><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果</p><h2 id="三、具体用法"><a href="#三、具体用法" class="headerlink" title="三、具体用法"></a>三、具体用法</h2><h3 id="3-1流的常用创建方法"><a href="#3-1流的常用创建方法" class="headerlink" title="3.1流的常用创建方法"></a>3.1流的常用创建方法</h3><h4 id="1）使用Collection下的-stream-和-parallelStream-方法"><a href="#1）使用Collection下的-stream-和-parallelStream-方法" class="headerlink" title="1）使用Collection下的 stream() 和 parallelStream() 方法"></a>1）使用Collection下的 stream() 和 parallelStream() 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br></pre></td></tr></table></figure><h4 id="2）使用Arrays-中的-stream-方法，将数组转成流"><a href="#2）使用Arrays-中的-stream-方法，将数组转成流" class="headerlink" title="2）使用Arrays 中的 stream() 方法，将数组转成流"></a>2）使用Arrays 中的 stream() 方法，将数组转成流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(nums);</span><br></pre></td></tr></table></figure><h4 id="3）使用Stream中的静态方法：of-、iterate-、generate"><a href="#3）使用Stream中的静态方法：of-、iterate-、generate" class="headerlink" title="3）使用Stream中的静态方法：of()、iterate()、generate()"></a>3）使用Stream中的静态方法：of()、iterate()、generate()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">stream2.forEach(System.out::println); <span class="comment">// 0 2 4 6 8 10</span></span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="4）使用-BufferedReader-lines-方法，将每行内容转成流"><a href="#4）使用-BufferedReader-lines-方法，将每行内容转成流" class="headerlink" title="4）使用 BufferedReader.lines() 方法，将每行内容转成流"></a>4）使用 BufferedReader.lines() 方法，将每行内容转成流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\test_stream.txt&quot;</span>));</span><br><span class="line">Stream&lt;String&gt; lineStream = reader.lines();</span><br><span class="line">lineStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="5）-使用-Pattern-splitAsStream-方法，将字符串分隔成流"><a href="#5）-使用-Pattern-splitAsStream-方法，将字符串分隔成流" class="headerlink" title="5） 使用 Pattern.splitAsStream() 方法，将字符串分隔成流"></a>5） 使用 Pattern.splitAsStream() 方法，将字符串分隔成流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="string">&quot;a,b,c,d&quot;</span>);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="3-2-流的中间操作"><a href="#3-2-流的中间操作" class="headerlink" title="3.2 流的中间操作"></a>3.2 流的中间操作</h3><h4 id="1）筛选与切片"><a href="#1）筛选与切片" class="headerlink" title="1）筛选与切片"></a>1）筛选与切片</h4><p>​        filter：过滤流中的某些元素<br>​        limit(n)：获取n个元素<br>​        skip(n)：跳过n元素，配合limit(n)可实现分页<br>​        distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct() <span class="comment">//6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>) <span class="comment">//9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>); <span class="comment">//9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="2）-映射"><a href="#2）-映射" class="headerlink" title="2） 映射"></a>2） 映射</h4><p>​        map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<br>​        flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将每个元素转成一个新的且不带逗号的元素</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">s1.forEach(System.out::println); <span class="comment">// abc  123</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="comment">//将每个元素转换成一个stream</span></span><br><span class="line">    String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;);</span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// a b c 1 2 3</span></span><br></pre></td></tr></table></figure><h4 id="3）排序"><a href="#3）排序" class="headerlink" title="3）排序"></a>3）排序</h4><p>​        sorted()：自然排序，流中元素需实现Comparable接口<br>​        sorted(Comparator com)：定制排序，自定义Comparator排序器  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ff&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//String 类自身已实现Compareable接口</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);<span class="comment">// aa dd ff</span></span><br><span class="line"></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">30</span>);</span><br><span class="line">Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;dd&quot;</span>, <span class="number">40</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2, s3, s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序：先按姓名升序，姓名相同则按年龄升序</span></span><br><span class="line">studentList.stream().sorted(</span><br><span class="line">        (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="4）消费"><a href="#4）消费" class="headerlink" title="4）消费"></a>4）消费</h4><p>​        peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line"></span><br><span class="line">studentList.stream()</span><br><span class="line">        .peek(o -&gt; o.setAge(<span class="number">100</span>))</span><br><span class="line">        .forEach(System.out::println);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;    </span><br></pre></td></tr></table></figure><p>​        </p><h3 id="3-3-流的终止操作"><a href="#3-3-流的终止操作" class="headerlink" title="3.3 流的终止操作"></a>3.3 流的终止操作</h3><h4 id="1）匹配、聚合操作"><a href="#1）匹配、聚合操作" class="headerlink" title="1）匹配、聚合操作"></a>1）匹配、聚合操作</h4><p>​        allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false<br>​        noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false<br>​        anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false<br>​        findFirst：返回流中第一个元素<br>​        findAny：返回流中的任意元素<br>​        count：返回流中元素的总个数<br>​        max：返回流中元素最大值<br>​        min：返回流中元素最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allMatch = list.stream().allMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">boolean</span> noneMatch = list.stream().noneMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(e -&gt; e &gt; <span class="number">4</span>);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer findFirst = list.stream().findFirst().get(); <span class="comment">//1</span></span><br><span class="line">Integer findAny = list.stream().findAny().get(); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = list.stream().count(); <span class="comment">//5</span></span><br><span class="line">Integer max = list.stream().max(Integer::compareTo).get(); <span class="comment">//5</span></span><br><span class="line">Integer min = list.stream().min(Integer::compareTo).get(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="2）规约操作"><a href="#2）规约操作" class="headerlink" title="2）规约操作"></a>2）规约操作</h4><p>Optional<T> reduce(BinaryOperator<T> accumulator)：第一次执行时，accumulator函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。<br>T reduce(T identity, BinaryOperator<T> accumulator)：流程跟上面一样，只是第一次执行时，accumulator函数的第一个参数为identity，而第二个参数为流中的第一个元素。<br><U> U reduce(U identity,BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator<U> combiner)：在串行流(stream)中，该方法跟第二个方法一样，即第三个参数combiner不会起作用。在并行流(parallelStream)中,我们知道流被fork join出多个线程进行执行，此时每个线程的执行流程就跟第二个方法reduce(identity,accumulator)一样，而第三个参数combiner函数，则是将每个线程的执行结果当成一个新的流，然后使用第一个方法reduce(accumulator)流程进行规约。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经过测试，当元素个数小于24时，并行时线程数等于元素个数，当大于等于24时，并行时线程数为16</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">Integer v = list.stream().reduce((x1, x2) -&gt; x1 + x2).get();</span><br><span class="line">System.out.println(v);   <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">Integer v1 = list.stream().reduce(<span class="number">10</span>, (x1, x2) -&gt; x1 + x2);</span><br><span class="line">System.out.println(v1);  <span class="comment">//310</span></span><br><span class="line"></span><br><span class="line">Integer v2 = list.stream().reduce(<span class="number">0</span>,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 - x2;</span><br><span class="line">        &#125;,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 * x2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(v2); <span class="comment">// -300</span></span><br><span class="line"></span><br><span class="line">Integer v3 = list.parallelStream().reduce(<span class="number">0</span>,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;parallelStream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 - x2;</span><br><span class="line">        &#125;,</span><br><span class="line">        (x1, x2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;parallelStream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">            <span class="keyword">return</span> x1 * x2;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(v3); <span class="comment">//197474048</span></span><br></pre></td></tr></table></figure><h4 id="3-收集操作"><a href="#3-收集操作" class="headerlink" title="3)  收集操作"></a>3)  收集操作</h4><p> collect：接收一个Collector实例，将流中元素收集成另外一个数据结构。<br> Collector&lt;T, A, R&gt; 是一个接口，有以下5个抽象方法：<br> Supplier<A> supplier()：创建一个结果容器A<br> BiConsumer&lt;A, T&gt; accumulator()：消费型接口，第一个参数为容器A，第二个参数为流中元素T。<br> BinaryOperator<A> combiner()：函数接口，该参数的作用跟上一个方法(reduce)中的combiner参数一样，将并行流中各                                                                   个子进程的运行结果(accumulator函数操作后的容器A)进行合并。<br> Function&lt;A, R&gt; finisher()：函数式接口，参数为：容器A，返回类型为：collect方法最终想要的结果R。<br> Set<Characteristics> characteristics()：返回一个不可变的Set集合，用来表明该Collector的特征。有以下三个特征：<br> CONCURRENT：表示此收集器支持并发。（官方文档还有其他描述，暂时没去探索，故不作过多翻译）<br> UNORDERED：表示该收集操作不会保留流中元素原有的顺序。<br> IDENTITY_FINISH：表示finisher参数只是标识而已，可忽略。<br> 注：如果对以上函数接口不太理解的话，可参考另外一篇文章：<a href="https://blog.csdn.net/y_k_y/article/details/84632889">Java 8 函数式接口</a></p><ul><li>Collector 工具库：Collectors</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>,<span class="number">2</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;cc&quot;</span>, <span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;Student&gt; list = Arrays.asList(s1, s2, s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//装成list</span></span><br><span class="line">List&lt;Integer&gt; ageList = list.stream().map(Student::getAge).collect(Collectors.toList()); <span class="comment">// [10, 20, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转成set</span></span><br><span class="line">Set&lt;Integer&gt; ageSet = list.stream().map(Student::getAge).collect(Collectors.toSet()); <span class="comment">// [20, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转成map,注:key不能相同，否则报错</span></span><br><span class="line">Map&lt;String, Integer&gt; studentMap = list.stream().collect(Collectors.toMap(Student::getName, Student::getAge)); <span class="comment">// &#123;cc=10, bb=20, aa=10&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串分隔符连接</span></span><br><span class="line">String joinName = list.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)); <span class="comment">// (aa,bb,cc)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//聚合操作</span></span><br><span class="line"><span class="comment">//1.学生总数</span></span><br><span class="line">Long count = list.stream().collect(Collectors.counting()); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//2.最大年龄 (最小的minBy同理)</span></span><br><span class="line">Integer maxAge = list.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compare)).get(); <span class="comment">// 20</span></span><br><span class="line"><span class="comment">//3.所有人的年龄</span></span><br><span class="line">Integer sumAge = list.stream().collect(Collectors.summingInt(Student::getAge)); <span class="comment">// 40</span></span><br><span class="line"><span class="comment">//4.平均年龄</span></span><br><span class="line">Double averageAge = list.stream().collect(Collectors.averagingDouble(Student::getAge)); <span class="comment">// 13.333333333333334</span></span><br><span class="line"><span class="comment">// 带上以上所有方法</span></span><br><span class="line">DoubleSummaryStatistics statistics = list.stream().collect(Collectors.summarizingDouble(Student::getAge));</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span> + statistics.getCount() + <span class="string">&quot;,max:&quot;</span> + statistics.getMax() + <span class="string">&quot;,sum:&quot;</span> + statistics.getSum() + <span class="string">&quot;,average:&quot;</span> + statistics.getAverage());</span><br><span class="line"></span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; ageMap = list.stream().collect(Collectors.groupingBy(Student::getAge));</span><br><span class="line"><span class="comment">//多重分组,先根据类型分再根据年龄分</span></span><br><span class="line">Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; typeAgeMap = list.stream().collect(Collectors.groupingBy(Student::getType, Collectors.groupingBy(Student::getAge)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区</span></span><br><span class="line"><span class="comment">//分成两部分，一部分大于10岁，一部分小于等于10岁</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partMap = list.stream().collect(Collectors.partitioningBy(v -&gt; v.getAge() &gt; <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//规约</span></span><br><span class="line">Integer allAge = list.stream().map(Student::getAge).collect(Collectors.reducing(Integer::sum)).get(); <span class="comment">//40</span></span><br></pre></td></tr></table></figure><ul><li>Collectors.toList() 解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//toList 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">            (left, right) -&gt; &#123;</span><br><span class="line">                left.addAll(right);</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;, CH_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了更好地理解，我们转化一下源码中的lambda表达式</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    Supplier&lt;List&lt;T&gt;&gt; supplier = () -&gt; <span class="keyword">new</span> ArrayList();</span><br><span class="line">    BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator = (list, t) -&gt; list.add(t);</span><br><span class="line">    BinaryOperator&lt;List&lt;T&gt;&gt; combiner = (list1, list2) -&gt; &#123;</span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;;</span><br><span class="line">    Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher = (list) -&gt; list;</span><br><span class="line">    Set&lt;Collector.Characteristics&gt; characteristics = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Supplier <span class="title">supplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> BiConsumer <span class="title">accumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> accumulator;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> BinaryOperator <span class="title">combiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> combiner;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Function <span class="title">finisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> finisher;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> characteristics;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「旅行者yky」的原创文章<br>原文链接：<a href="https://blog.csdn.net/y_k_y/article/details/84633001">https://blog.csdn.net/y_k_y/article/details/84633001</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java-api </tag>
            
            <tag> 集合处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus逻辑删除</title>
      <link href="2021/03/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/mybatis-plus%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4/"/>
      <url>2021/03/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/mybatis-plus%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h1><p>说明:</p><p>只对自动注入的sql起效:</p><ul><li>插入: 不作限制</li><li>查找: 追加where条件过滤掉已删除数据,且使用 wrapper.entity 生成的where条件会忽略该字段</li><li>更新: 追加where条件防止更新到已删除数据,且使用 wrapper.entity 生成的where条件会忽略该字段</li><li>删除: 转变为 更新</li></ul><p>例如:</p><ul><li>删除: <code>update user set deleted=1 where id = 1 and deleted=0</code></li><li>查找: <code>select id,name,deleted from user where deleted=0</code></li></ul><p>字段类型支持说明:</p><ul><li>支持所有数据类型(推荐使用 <code>Integer</code>,<code>Boolean</code>,<code>LocalDateTime</code>)</li><li>如果数据库字段使用<code>datetime</code>,逻辑未删除值和已删除值支持配置为字符串<code>null</code>,另一个值支持配置为函数来获取值如<code>now()</code></li></ul><p>附录:</p><ul><li>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</li><li>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</li></ul><h2 id="1）使用方法："><a href="#1）使用方法：" class="headerlink" title="1）使用方法："></a>1）使用方法：</h2><h3 id="步骤1-配置com-baomidou-mybatisplus-core-config-GlobalConfig-DbConfig"><a href="#步骤1-配置com-baomidou-mybatisplus-core-config-GlobalConfig-DbConfig" class="headerlink" title="步骤1: 配置com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig"></a>步骤1: 配置<code>com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig</code></h3><ul><li>例: application.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">flag</span>  <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><h3 id="步骤2-实体类字段上加上-TableLogic注解"><a href="#步骤2-实体类字段上加上-TableLogic注解" class="headerlink" title="步骤2: 实体类字段上加上@TableLogic注解"></a>步骤2: 实体类字段上加上<code>@TableLogic</code>注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure><h2 id="2）常见问题"><a href="#2）常见问题" class="headerlink" title="2）常见问题:"></a>2）常见问题:</h2><h4 id="1-如何-insert"><a href="#1-如何-insert" class="headerlink" title="1. 如何 insert ?"></a>1. 如何 insert ?</h4><blockquote><ol><li>字段在数据库定义默认值(推荐)</li><li>insert 前自己 set 值</li><li>使用自动填充功能</li></ol></blockquote><h4 id="2-删除接口自动填充功能失效"><a href="#2-删除接口自动填充功能失效" class="headerlink" title="2. 删除接口自动填充功能失效"></a>2. 删除接口自动填充功能失效</h4><blockquote><ol><li>使用 <code>update</code> 方法并: <code>UpdateWrapper.set(column, value)</code>(推荐)</li><li>使用 <code>update</code> 方法并: <code>UpdateWrapper.setSql(&quot;column=value&quot;)</code></li><li>使用<a href="https://mp.baomidou.com/guide/sql-injector.html">Sql注入器</a>注入<code>com.baomidou.mybatisplus.extension.injector.methods.LogicDeleteByIdWithFill</code>并使用(推荐)</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> gulimall项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传及对象存储（oss）</title>
      <link href="2021/03/23/os/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%EF%BC%88oss%EF%BC%89/"/>
      <url>2021/03/23/os/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%EF%BC%88oss%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="1-添加上传"><a href="#1-添加上传" class="headerlink" title="1.添加上传"></a>1.添加上传</h3><p>和传统的单体应用不同，这里我们选择将数据上传到分布式文件服务器上。</p><p>这里我们选择将图片放置到阿里云上，使用对象存储。</p><p>阿里云上使使用对象存储方式：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323165922.png" alt="image-20200428182755992"></p><p>创建Bucket</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323165934.png" alt="image-20200428183041570"></p><p>上传文件：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170142.png" alt="image-20200428183213694"></p><p>上传成功后，取得图片的URL</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170149.png" alt="image-20200428183644020"></p><p>这种方式是手动上传图片，实际上我们可以在程序中设置自动上传图片到阿里云对象存储。</p><p>查看阿里云关于文件上传的帮助： <a href="https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.768.549d59aaWuZMGJ">https://help.aliyun.com/document_detail/32009.html?spm=a2c4g.11186623.6.768.549d59aaWuZMGJ</a> </p><h4 id="1）添加依赖包"><a href="#1）添加依赖包" class="headerlink" title="1）添加依赖包"></a>1）添加依赖包</h4><p>在Maven项目中加入依赖项（推荐方式）</p><p>在 Maven 工程中使用 OSS Java SDK，只需在 pom.xml 中加入相应依赖即可。以 3.8.0 版本为例，在 <dependencies> 内加入如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）上传文件流"><a href="#2）上传文件流" class="headerlink" title="2）上传文件流"></a>2）上传文件流</h4><p>以下代码用于上传文件流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">String endpoint = <span class="string">&quot;http://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。</span></span><br><span class="line">String accessKeyId = <span class="string">&quot;&lt;yourAccessKeyId&gt;&quot;</span>;</span><br><span class="line">String accessKeySecret = <span class="string">&quot;&lt;yourAccessKeySecret&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件流。</span></span><br><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&lt;yourlocalFile&gt;&quot;</span>);</span><br><span class="line">ossClient.putObject(<span class="string">&quot;&lt;yourBucketName&gt;&quot;</span>, <span class="string">&quot;&lt;yourObjectName&gt;&quot;</span>, inputStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭OSSClient。</span></span><br><span class="line">ossClient.shutdown();</span><br></pre></td></tr></table></figure><p>endpoint的取值：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170157.png" alt="image-20200428190553350"></p><p>accessKeyId和accessKeySecret需要创建一个RAM账号：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170201.png" alt="image-20200428190532924"></p><p>创建用户完毕后，会得到一个“AccessKey ID”和“AccessKeySecret”，然后复制这两个值到代码的“AccessKey ID”和“AccessKeySecret”。</p><p>另外还需要添加访问控制权限：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170210.png" alt="image-20200428191518591"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">        String endpoint = <span class="string">&quot;oss-cn-shanghai.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。</span></span><br><span class="line">        String accessKeyId = <span class="string">&quot;LTAI4G4W1RA4JXz2QhoDwHhi&quot;</span>;</span><br><span class="line">        String accessKeySecret = <span class="string">&quot;R99lmDOJumF2x43ZBKT259Qpe70Oxw&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传文件流。</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Administrator\\Pictures\\timg.jpg&quot;</span>);</span><br><span class="line">        ossClient.putObject(<span class="string">&quot;gulimall-images&quot;</span>, <span class="string">&quot;time.jpg&quot;</span>, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传成功.&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更为简单的使用方式，是使用SpringCloud Alibaba</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170218.png" alt="image-20200428195507730"></p><p>详细使用方法，见： <a href="https://help.aliyun.com/knowledge_detail/108650.html">https://help.aliyun.com/knowledge_detail/108650.html</a>  </p><p>（1）添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）创建“AccessKey ID”和“AccessKeySecret”</p><p>（3）配置key，secret和endpoint相关信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">access-key:</span> <span class="string">LTAI4G4W1RA4JXz2QhoDwHhi</span></span><br><span class="line"><span class="attr">secret-key:</span> <span class="string">R99lmDOJumF2x43ZBKT259Qpe70Oxw</span></span><br><span class="line"><span class="attr">oss:</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">oss-cn-shanghai.aliyuncs.com</span></span><br></pre></td></tr></table></figure><p>（4）注入OSSClient并进行文件上传下载等操作</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170228.png" alt="image-20200428224840535"></p><p>但是这样来做还是比较麻烦，如果以后的上传任务都交给gulimall-product来完成，显然耦合度高。最好单独新建一个Module来完成文件上传任务。</p><h3 id="2-其他方式"><a href="#2-其他方式" class="headerlink" title="2. 其他方式"></a>2. 其他方式</h3><h4 id="1）新建gulimall-third-party"><a href="#1）新建gulimall-third-party" class="headerlink" title="1）新建gulimall-third-party"></a>1）新建gulimall-third-party</h4><h4 id="2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中"><a href="#2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中" class="headerlink" title="2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中"></a>2）添加依赖，将原来gulimall-common中的“spring-cloud-starter-alicloud-oss”依赖移动到该项目中</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">&lt;!--oss--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.gulimail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gulimail-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 另外也需要在“pom.xml”文件中，添加如下的依赖管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3）在主启动类中开启服务的注册和发现"><a href="#3）在主启动类中开启服务的注册和发现" class="headerlink" title="3）在主启动类中开启服务的注册和发现"></a>3）在主启动类中开启服务的注册和发现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure><h4 id="4）在nacos中注册"><a href="#4）在nacos中注册" class="headerlink" title="4）在nacos中注册"></a>4）在nacos中注册</h4><p>（1）创建命名空间“ gulimall-third-party ”</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170239.png" alt="image-20200429075831984"></p><p>（2）在“ gulimall-third-party”命名空间中，创建“ gulimall-third-party.yml”文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不同版本的aliyun-oss-spring-boot-starte配置格式不同</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alicloud:</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">LTAI4G4W1RA4JXz2QhoDwHhi</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">R99lmDOJumF2x43ZBKT259Qpe70Oxw</span></span><br><span class="line">      <span class="attr">oss:</span></span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">oss-cn-shanghai.aliyuncs.com</span></span><br></pre></td></tr></table></figure><h4 id="5）编写配置文件"><a href="#5）编写配置文件" class="headerlink" title="5）编写配置文件"></a>5）编写配置文件</h4><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gulimall-third-party</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.137</span><span class="number">.14</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.bigdata.gulimall.product:</span> <span class="string">debug</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bootstrap.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.name</span>=<span class="string">gulimall-third-party</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">192.168.137.14:8848</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">f995d8ee-c53a-4d29-8316-a1ef54775e00</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">gulimall-third-party.yml</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h4 id="6）-编写测试类"><a href="#6）-编写测试类" class="headerlink" title="6） 编写测试类"></a>6） 编写测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.gulimall.thirdparty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClient;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GulimallThirdPartyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OSSClient ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Endpoint以杭州为例，其它Region请按实际情况填写。</span></span><br><span class="line">        String endpoint = <span class="string">&quot;oss-cn-shanghai.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 云账号AccessKey有所有API访问权限，建议遵循阿里云安全最佳实践，创建并使用RAM子账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建。</span></span><br><span class="line">        String accessKeyId = <span class="string">&quot;LTAI4G4W1RA4JXz2QhoDwHhi&quot;</span>;</span><br><span class="line">        String accessKeySecret = <span class="string">&quot;R99lmDOJumF2x43ZBKT259Qpe70Oxw&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//上传文件流。</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Administrator\\Pictures\\timg.jpg&quot;</span>);</span><br><span class="line">        ossClient.putObject(<span class="string">&quot;gulimall-images&quot;</span>, <span class="string">&quot;time3.jpg&quot;</span>, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;上传成功.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-oss服务端签名后直传"><a href="#3-oss服务端签名后直传" class="headerlink" title="3. oss服务端签名后直传"></a>3. oss服务端签名后直传</h3><p> <a href="https://help.aliyun.com/document_detail/31926.html?spm=a2c4g.11186623.6.1527.228d74b8V6IZuT">https://help.aliyun.com/document_detail/31926.html?spm=a2c4g.11186623.6.1527.228d74b8V6IZuT</a></p><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1) 背景"></a>1) 背景</h4><p>采用JavaScript客户端直接签名（参见<a href="https://help.aliyun.com/document_detail/31925.html#concept-frd-4gy-5db">JavaScript客户端签名直传</a>）时，AccessKeyID和AcessKeySecret会暴露在前端页面，因此存在严重的安全隐患。因此，OSS提供了服务端签名后直传的方案。</p><h4 id="2-原理介绍"><a href="#2-原理介绍" class="headerlink" title="2) 原理介绍"></a>2) 原理介绍</h4><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170337.png" alt="img"></p><p>服务端签名后直传的原理如下：</p><ol><li>用户发送上传Policy请求到应用服务器。</li><li>应用服务器返回上传Policy和签名给用户。</li><li>用户直接上传数据到OSS。</li></ol><h4 id="3-接口编写"><a href="#3-接口编写" class="headerlink" title="3) 接口编写"></a>3) 接口编写</h4><p>编写“com.bigdata.gulimall.thirdparty.controller.OssController”类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bigdata.gulimall.thirdparty.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.common.utils.BinaryUtil;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.model.MatchMode;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.model.PolicyConditions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OSS ossClient;</span><br><span class="line">    <span class="meta">@Value</span> (<span class="string">&quot;$&#123;spring.cloud.alicloud.oss.endpoint&#125;&quot;</span>)</span><br><span class="line">    String endpoint ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.oss.bucket&#125;&quot;)</span></span><br><span class="line">    String bucket ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.access-key&#125;&quot;)</span></span><br><span class="line">    String accessId ;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.cloud.alicloud.secret-key&#125;&quot;)</span></span><br><span class="line">    String accessKey ;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/oss/policy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">policy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String host = <span class="string">&quot;https://&quot;</span> + bucket + <span class="string">&quot;.&quot;</span> + endpoint; <span class="comment">// host的格式为 bucketname.endpoint</span></span><br><span class="line"></span><br><span class="line">        String format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String dir = format; <span class="comment">// 用户上传文件时指定的前缀。</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; respMap=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> expireTime = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="number">1000</span>;</span><br><span class="line">            Date expiration = <span class="keyword">new</span> Date(expireEndTime);</span><br><span class="line">            PolicyConditions policyConds = <span class="keyword">new</span> PolicyConditions();</span><br><span class="line">            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="number">0</span>, <span class="number">1048576000</span>);</span><br><span class="line">            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);</span><br><span class="line"></span><br><span class="line">            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);</span><br><span class="line">            <span class="keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            String encodedPolicy = BinaryUtil.toBase64String(binaryData);</span><br><span class="line">            String postSignature = ossClient.calculatePostSignature(postPolicy);</span><br><span class="line"></span><br><span class="line">            respMap= <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">            respMap.put(<span class="string">&quot;accessid&quot;</span>, accessId);</span><br><span class="line">            respMap.put(<span class="string">&quot;policy&quot;</span>, encodedPolicy);</span><br><span class="line">            respMap.put(<span class="string">&quot;signature&quot;</span>, postSignature);</span><br><span class="line">            respMap.put(<span class="string">&quot;dir&quot;</span>, dir);</span><br><span class="line">            respMap.put(<span class="string">&quot;host&quot;</span>, host);</span><br><span class="line">            respMap.put(<span class="string">&quot;expire&quot;</span>, String.valueOf(expireEndTime / <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Assert.fail(e.getMessage());</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试： <a href="http://localhost:30000/oss/policy">http://localhost:30000/oss/policy</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;accessid&quot;:&quot;LTAI4G4W1RA4JXz2QhoDwHhi&quot;,&quot;policy&quot;:&quot;eyJleHBpcmF0aW9uIjoiMjAyMC0wNC0yOVQwMjo1ODowNy41NzhaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMTA0ODU3NjAwMF0sWyJzdGFydHMtd2l0aCIsIiRrZXkiLCIyMDIwLTA0LTI5LyJdXX0&#x3D;&quot;,&quot;signature&quot;:&quot;s42iRxtxGFmHyG40StM3d9vOfFk&#x3D;&quot;,&quot;dir&quot;:&quot;2020-04-29&#x2F;&quot;,&quot;host&quot;:&quot;https:&#x2F;&#x2F;gulimall-images.oss-cn-shanghai.aliyuncs.com&quot;,&quot;expire&quot;:&quot;1588129087&quot;&#125;</span><br></pre></td></tr></table></figure><p>以后在上传文件时的访问路径为“ <a href="http://localhost:18090/api/thirdparty/oss/policy%E2%80%9D%EF%BC%8C">http://localhost:18090/api/thirdparty/oss/policy”，</a></p><p>在“gulimall-gateway”中配置路由规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">third_party_route</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://gulimall-gateway</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/api/third-party/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">RewritePath=/api/third-party/(?&lt;segment&gt;/?.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>测试是否能够正常跳转： <a href="http://localhost:88/api/thirdparty/oss/policy">http://localhost:88/api/thirdparty/oss/policy</a> </p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170357.png" alt="image-20200429111408164"></p><h3 id="4-前端上传组件"><a href="#4-前端上传组件" class="headerlink" title="4. 前端上传组件"></a>4. 前端上传组件</h3><p>放置项目提供的upload文件夹到components目录下，一个是单文件上传，另外一个是多文件上传</p><p><a href="https://github.com/icbtbo/gulimail">gulimall项目地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Project\gulimall\renren-fast-vue\src\components\upload&gt; ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\Project\gulimall\renren-fast-vue\src\components\upload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----  2020/4/29 星期三     12:0           3122 multiUpload.vue</span><br><span class="line">                                2</span><br><span class="line">-a----  2019/11/11 星期一     21:            343 policy.js</span><br><span class="line">                               20</span><br><span class="line">-a----  2020/4/29 星期三     12:0           3053 singleUpload.vue</span><br><span class="line">                                1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\Project\gulimall\renren-fast-vue\src\components\upload&gt;</span><br></pre></td></tr></table></figure><p>修改这两个文件的配置后</p><p>开始执行上传，但是在上传过程中，出现了如下的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170403.png" alt="image-20200429124629150"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;gulimall-images.oss-cn-shanghai.aliyuncs.com&#x2F;&#39; from origin &#39;http:&#x2F;&#x2F;localhost:8001&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>这又是一个跨域的问题，解决方法就是在阿里云上开启跨域访问：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210323170408.png" alt="image-20200429124940091"></p><p>再次执行文件上传。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulimall项目 </tag>
            
            <tag> oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring中跨域问题</title>
      <link href="2021/03/22/spring/spring%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>2021/03/22/spring/spring%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>跨域：浏览器对于javascript的同源策略的限制 。</p><p>以下情况都属于跨域：</p><table><thead><tr><th>跨域原因说明</th><th>示例</th></tr></thead><tbody><tr><td>域名不同</td><td><code>www.jd.com</code> 与 <code>www.taobao.com</code></td></tr><tr><td>域名相同，端口不同</td><td><code>www.jd.com:8080</code> 与 <code>www.jd.com:8081</code></td></tr><tr><td>二级域名不同</td><td><code>item.jd.com</code> 与 <code>miaosha.jd.com</code></td></tr></tbody></table><p>如果<strong>域名和端口都相同，但是请求路径不同</strong>，不属于跨域，如：</p><p><code>www.jd.com/item</code> </p><p><code>www.jd.com/goods</code></p><p>http和https也属于跨域</p><p>而我们刚才是从<code>manager.gmall.com</code>去访问<code>api.gmall.com</code>，这属于端口不同，跨域了。</p><h2 id="1-为什么有跨域问题？"><a href="#1-为什么有跨域问题？" class="headerlink" title="1. 为什么有跨域问题？"></a>1. 为什么有跨域问题？</h2><p>跨域不一定都会有跨域问题。</p><p>因为跨域问题是浏览器对于ajax请求的一种安全限制：<strong>一个页面发起的ajax请求，只能是与当前页域名相同的路径</strong>，这能有效的阻止跨站攻击。</p><p>因此：<strong>跨域问题 是针对ajax的一种限制</strong>。</p><p>但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？</p><h2 id="2-解决跨域问题的方案"><a href="#2-解决跨域问题的方案" class="headerlink" title="2. 解决跨域问题的方案"></a>2. 解决跨域问题的方案</h2><p>目前比较常用的跨域解决方案有3种：</p><ul><li><p>Jsonp</p><p>最早的解决方案，利用script标签可以跨域的原理实现。</p><p>限制：</p><ul><li>需要服务的支持</li><li>只能发起GET请求</li></ul></li><li><p>nginx反向代理</p><p>思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式</p><p>缺点：需要在nginx进行额外配置，语义不清晰 </p></li><li><p>CORS</p><p>规范化的跨域请求解决方案，安全可靠。</p><p>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul></li></ul><p>我们这里会采用cors的跨域方案。</p><h2 id="3-什么是cors"><a href="#3-什么是cors" class="headerlink" title="3. 什么是cors"></a>3. 什么是cors</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><ul><li><p>浏览器端：</p><p>目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。</p></li><li><p>服务端：</p><p>CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</p></li></ul><h2 id="4-原理有点复杂"><a href="#4-原理有点复杂" class="headerlink" title="4. 原理有点复杂"></a>4. 原理有点复杂</h2><blockquote><p>预检请求</p></blockquote><p>跨域请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>一个“预检”请求的样板：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://localhost:1000</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: GET</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><ul><li><p>Origin：会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。</p></li><li><p>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</p></li><li><p>Access-Control-Request-Headers：会额外用到的头信息</p></li></ul><blockquote><p>预检请求的响应</p></blockquote><p>服务的收到预检请求，如果许可跨域，会发出响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://miaosha.jd.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>如果服务器允许跨域，需要在返回的响应头中携带下面信息：</p><ul><li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li><li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true</li><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的ajax请求就无需再次进行预检了</strong></li></ul><blockquote><p>有关cookie：</p></blockquote><p>要想操作cookie，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax需要指定withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><h2 id="5-实现非常简单"><a href="#5-实现非常简单" class="headerlink" title="5. 实现非常简单"></a>5. 实现非常简单</h2><p>虽然原理比较复杂，但是前面说过：</p><ul><li>浏览器端都有浏览器自动完成，我们无需操心</li><li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li></ul><p>事实上，Spring已经帮我们写好了CORS的跨域过滤器，内部已经实现了刚才所讲的判定逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring-webmvc：CorsFilter</span><br><span class="line">spring-webflux：CorsWebFilter</span><br></pre></td></tr></table></figure><p>springcloud-gateway集成的是webflux，所以这里使用的是CorsWebFilter</p><p>在<code>gmall-gateway</code>中编写一个配置类，并且注册CorsWebFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化CORS配置对象</span></span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">// 允许的域,不要写*，否则cookie就无法使用了</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://manager.gmall.com&quot;</span>);</span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;http://www.gmall.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的头信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否允许携带Cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加映射路径，我们拦截一切请求</span></span><br><span class="line">        UrlBasedCorsConfigurationSource corsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(corsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：完美解决！</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 跨域问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务网关Gateway</title>
      <link href="2021/03/18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Gateway/"/>
      <url>2021/03/18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Gateway/</url>
      
        <content type="html"><![CDATA[<h1 id="1-服务网关Gateway"><a href="#1-服务网关Gateway" class="headerlink" title="1. 服务网关Gateway"></a>1. 服务网关Gateway</h1><p>API 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：</p><ol><li><p>破坏了服务无状态特点。</p><p>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</p><pre><code>  从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</code></pre></li><li><p>无法直接复用既有接口。</p><p>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</p></li></ol><p>以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性，典型的架构图如图所示：</p><p> <img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318104916.jpg" alt="img"></p><h2 id="1-1-快速开始"><a href="#1-1-快速开始" class="headerlink" title="1.1. 快速开始"></a>1.1. 快速开始</h2><p>创建网关module：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318105318.png" alt="image-20210318105317902" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318105506.png" style="zoom:67%;" /></p><h3 id="1-1-1-引入依赖"><a href="#1-1-1-引入依赖" class="headerlink" title="1.1.1. 引入依赖"></a>1.1.1. 引入依赖</h3><p>已引入，如下。pom.xml中的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-编写路由规则"><a href="#1-1-2-编写路由规则" class="headerlink" title="1.1.2. 编写路由规则"></a>1.1.2. 编写路由规则</h3><p>为了演示路由到不同服务，这里把消费者和生产者都配置在网关中</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-consumer</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:7000</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/hi</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-provider</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:8000</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/hello</span></span><br></pre></td></tr></table></figure><h3 id="1-1-3-启动测试"><a href="#1-1-3-启动测试" class="headerlink" title="1.1.3. 启动测试"></a>1.1.3. 启动测试</h3><p>通过网关路径访问消费者或者生产者。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318143941.png" alt="image-20210318143941722"></p><h2 id="1-2-路由规则详解"><a href="#1-2-路由规则详解" class="headerlink" title="1.2. 路由规则详解"></a>1.2. 路由规则详解</h2><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318144019.png" alt="image-20210318144019221" style="zoom:67%;" /><p>基本概念：</p><ul><li><strong>Route</strong>：路由网关的基本构建块。它由ID，目的URI，断言（Predicate）集合和过滤器（filter）集合组成。如果断言聚合为真，则匹配该路由。</li><li><strong>Predicate</strong>：这是一个 Java 8函数式断言。允许开发人员匹配来自HTTP请求的任何内容，例如请求头或参数。</li><li><strong>过滤器</strong>：可以在发送下游请求之前或之后修改请求和响应。</li></ul><p><strong>路由根据断言进行匹配，匹配成功就会转发请求给URI，在转发请求之前或者之后可以添加过滤器。</strong></p><h3 id="1-2-1-断言工厂"><a href="#1-2-1-断言工厂" class="headerlink" title="1.2.1. 断言工厂"></a>1.2.1. 断言工厂</h3><p>Spring Cloud Gateway包含许多内置的Route Predicate工厂。所有这些断言都匹配HTTP请求的不同属性。多路由断言工厂通过<code>and</code>组合。</p><p>官方提供的路由工厂：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318144109.png" alt="image-20210318144109196"></p><p>这些断言工厂的配置方式，参照官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p><p>这里重点掌握请求路径路由断言的配置方式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">host_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/foo/&#123;segment&#125;,/bar/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>这个路由匹配以/foo或者/bar开头的路径，转发到http:example.org。例如 <code>/foo/1</code> or <code>/foo/bar</code> or <code>/bar/baz</code>.</p><h3 id="1-2-2-过滤器工厂"><a href="#1-2-2-过滤器工厂" class="headerlink" title="1.2.2. 过滤器工厂"></a>1.2.2. 过滤器工厂</h3><p>路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路径过滤器的范围限定为特定路由。Spring Cloud Gateway包含许多内置的GatewayFilter工厂。</p><p>这些过滤器工厂的配置方式，同样参照官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><p>过滤器 有 20 多个 实现类,根据过滤器工厂的用途来划分，可以分为以下几种：Header、Parameter、Path、Body、Status、Session、Redirect、Retry、RateLimiter和Hystrix</p><p>这里重点掌握PrefixPath GatewayFilter Factory：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">prefixpath_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">PrefixPath=/mypath</span></span><br></pre></td></tr></table></figure><p>这将在所有匹配请求的路径上加上/mypath前缀。因此，对/hello的请求将被发送到/mypath/hello。</p><p><code>RewritePath</code> <code>GatewayFilter</code> factory   同样很有用：</p><p>​        在开发中由于所有微服务的访问都要经过网关，为了区分不同的微服务，通常会在路径前加上一个标识，例如：访问服务提供方：<code>http://localhost:18090/provider/hello</code> ；访问服务消费方：<code>http://localhost:18090/consumer/hi</code>  如果不重写地址，直接转发的话，转发后的路径为：<code>http://localhost:18070/provider/hello</code>和<code>http://localhost:18080/consumer/hi</code>明显多了一个provider或者consumer，导致转发失败。</p><p>这时，我们就用上了路径重写，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-consumer</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:7000</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/consumer/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/consumer/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-provider</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:8000</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/provider/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/provider/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>Path=/consumer/**</code>及<code>Path=/provider/**</code>的变化</p><p>测试：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318150731.png" alt="image-20210318150731271"></p><h2 id="1-3-面向服务的路由"><a href="#1-3-面向服务的路由" class="headerlink" title="1.3. 面向服务的路由"></a>1.3. 面向服务的路由</h2><p>如果要做到负载均衡，则必须把网关工程注册到nacos注册中心，然后通过服务名访问。</p><h3 id="1-3-1-把网关服务注册到nacos"><a href="#1-3-1-把网关服务注册到nacos" class="headerlink" title="1.3.1. 把网关服务注册到nacos"></a>1.3.1. 把网关服务注册到nacos</h3><ol><li><p>引入nacos的相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在依赖管理中加入springCloud-alibaba组件的依赖,注意和springcloud及springboot的版本依赖关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置nacos服务地址及服务名：</p><p>bootstrap.yml中的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway-demo</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p>application.yml中的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-consumer</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:7000</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/consumer/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/consumer/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-provider</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://127.0.0.1:8000</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/provider/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/provider/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>把网关注入到nacos</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GatewayDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-2-修改配置，通过服务名路由"><a href="#1-3-2-修改配置，通过服务名路由" class="headerlink" title="1.3.2. 修改配置，通过服务名路由"></a>1.3.2. 修改配置，通过服务名路由</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18090</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-consumer</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://gulimail-coupon</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/consumer/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/consumer/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">nacos-provider</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://gulimail-member</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/provider/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RewritePath=/provider/(?&lt;segment&gt;.*),/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>语法：lb://服务名</p><p>lb：LoadBalance，代表负载均衡的方式</p><p>服务名取决于nacos的服务列表中的服务名</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210318151343.png" alt="image-20210318151343359"></p><h2 id="1-4-路由的java代码配置方式（了解）"><a href="#1-4-路由的java代码配置方式（了解）" class="headerlink" title="1.4. 路由的java代码配置方式（了解）"></a>1.4. 路由的java代码配置方式（了解）</h2><p>参见官方文档：<a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) &#123;</span><br><span class="line">    return builder.routes()</span><br><span class="line">            .route(r -&gt; r.host(&quot;**.abc.org&quot;).and().path(&quot;&#x2F;image&#x2F;png&quot;)</span><br><span class="line">                .filters(f -&gt;</span><br><span class="line">                        f.addResponseHeader(&quot;X-TestHeader&quot;, &quot;foobar&quot;))</span><br><span class="line">                .uri(&quot;http:&#x2F;&#x2F;httpbin.org:80&quot;)</span><br><span class="line">            )</span><br><span class="line">            .route(r -&gt; r.path(&quot;&#x2F;image&#x2F;webp&quot;)</span><br><span class="line">                .filters(f -&gt;</span><br><span class="line">                        f.addResponseHeader(&quot;X-AnotherHeader&quot;, &quot;baz&quot;))</span><br><span class="line">                .uri(&quot;http:&#x2F;&#x2F;httpbin.org:80&quot;)</span><br><span class="line">            )</span><br><span class="line">            .route(r -&gt; r.order(-1)</span><br><span class="line">                .host(&quot;**.throttle.org&quot;).and().path(&quot;&#x2F;get&quot;)</span><br><span class="line">                .filters(f -&gt; f.filter(throttle.apply(1,</span><br><span class="line">                        1,</span><br><span class="line">                        10,</span><br><span class="line">                        TimeUnit.SECONDS)))</span><br><span class="line">                .uri(&quot;http:&#x2F;&#x2F;httpbin.org:80&quot;)</span><br><span class="line">            )</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spring全家桶 </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud-alibaba </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos</title>
      <link href="2021/03/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/nacos/"/>
      <url>2021/03/17/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/nacos/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nacos概述"><a href="#1-Nacos概述" class="headerlink" title="1. Nacos概述"></a>1. Nacos概述</h1><p>官方地址：<a href="https://nacos.io/">https://nacos.io</a></p><p>github地址：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>面试题：微服务间远程交互的过程？</p><ol><li>先去注册中心查询服务的服务器地址</li><li>调用方给对方发送http请求</li></ol><h2 id="1-1-什么是-Nacos"><a href="#1-1-什么是-Nacos" class="headerlink" title="1.1.   什么是 Nacos"></a>1.1.   什么是 Nacos</h2><p>Nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><h2 id="1-2-为什么是Nacos"><a href="#1-2-为什么是Nacos" class="headerlink" title="1.2.   为什么是Nacos"></a>1.2.   为什么是Nacos</h2><p>常见的注册中心：</p><ol><li>Eureka（原生，2.0遇到性能瓶颈，停止维护）</li><li>Zookeeper（支持，专业的独立产品。例如：dubbo）</li><li>Consul（原生，GO语言开发）</li><li>Nacos</li></ol><p>相对于 Spring Cloud Eureka 来说，Nacos 更强大。</p><p><strong>Nacos = Spring Cloud Eureka + Spring Cloud Config</strong></p><p>Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。</p><ul><li><p>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。</p></li><li><p>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。</p></li></ul><h2 id="1-3-可以干什么"><a href="#1-3-可以干什么" class="headerlink" title="1.3.   可以干什么"></a>1.3.   可以干什么</h2><p>Nacos是以服务为主要服务对象的中间件，Nacos支持所有主流的服务发现、配置和管理。</p><p>Nacos主要提供以下四大功能：</p><ol><li>服务发现和服务健康监测</li><li>动态配置服务</li><li>动态DNS服务</li><li>服务及其元数据管理</li></ol><h1 id="2-Nacos快速开始"><a href="#2-Nacos快速开始" class="headerlink" title="2.  Nacos快速开始"></a>2.  Nacos快速开始</h1><p>结构图：</p><p><img src="/Users/songjiancheng/Desktop/assets/1542119181336-b6dc0fc1-ed46-43a7-9e5f-68c9ca344d60.png" alt="echo service"></p><p>Nacos 依赖 Java 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 Maven环境，请确保是在以下版本环境中安装使用:</p><ol><li>64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。</li><li>64 bit JDK 1.8+</li><li>Maven 3.2.x+</li></ol><h2 id="2-1-下载及安装"><a href="#2-1-下载及安装" class="headerlink" title="2.1.   下载及安装"></a>2.1.   下载及安装</h2><p>你可以通过源码和发行包两种方式来获取 Nacos。</p><p>您可以从 <a href="https://github.com/alibaba/nacos/releases">最新稳定版本</a> 下载 <code>nacos-server-$version.zip</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip nacos-server-<span class="variable">$version</span>.zip 或者 tar -xvf nacos-server-<span class="variable">$version</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nacos/bin</span><br></pre></td></tr></table></figure><h2 id="2-2-启动nacos服务"><a href="#2-2-启动nacos服务" class="headerlink" title="2.2.   启动nacos服务"></a>2.2.   启动nacos服务</h2><p><strong>Linux/Unix/Mac</strong></p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><p><strong>Windows</strong></p><p>启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd startup.cmd</span><br></pre></td></tr></table></figure><p>或者双击startup.cmd运行文件。</p><p>访问：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p><p>用户名密码：nacos/nacos</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210316160522.png" alt="image-20210316160522018"></p><h2 id="2-3-注册中心"><a href="#2-3-注册中心" class="headerlink" title="2.3.   注册中心"></a>2.3.   注册中心</h2><p>首先创建两个工程：gulimail-coupon（提供者）、gulimail-member(消费者)</p><h3 id="2-3-1-生产者基本代码"><a href="#2-3-1-生产者基本代码" class="headerlink" title="2.3.1.   生产者基本代码"></a>2.3.1.   生产者基本代码</h3><p>ProviderController代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义参数</span></span><br><span class="line"><span class="attr">myName</span>=<span class="string">nacos</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-生产者注册到nacos"><a href="#2-3-2-生产者注册到nacos" class="headerlink" title="2.3.2.   生产者注册到nacos"></a>2.3.2.   生产者注册到nacos</h3><p>生产者注册到nacos注册中心，步骤：</p><ol><li><p>添加依赖：spring-cloud-starter-alibaba-nacos-discovery及springCloud</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> <a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">spring-cloud-alibaba 和 spring-cloud、spring-boot的版本关系</a></p></blockquote></li><li><p>在 <code>application.properties</code> 中配置nacos服务地址和应用名（也可在application.yml中配置，自定义参数myName除外）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">7000</span></span><br><span class="line"><span class="comment"># 应用名（一定要配置，否则无法注册）</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos-provider</span></span><br><span class="line"><span class="comment"># nacos服务地址</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"># 自定义参数</span></span><br><span class="line"><span class="attr">myName</span>=<span class="string">nacos</span></span><br></pre></td></tr></table></figure></li><li><p>通过Spring Cloud原生注解 <code>@EnableDiscoveryClient</code> 开启服务注册发现功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210316162932.png" alt="image-20210316162932208"></p><h3 id="2-3-3-消费端基本代码"><a href="#2-3-3-消费端基本代码" class="headerlink" title="2.3.3.   消费端基本代码"></a>2.3.3.   消费端基本代码</h3><p>ConsumerController代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi provider!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8000</span></span><br></pre></td></tr></table></figure><h3 id="2-3-4-消费者注册到nacos"><a href="#2-3-4-消费者注册到nacos" class="headerlink" title="2.3.4.   消费者注册到nacos"></a>2.3.4.   消费者注册到nacos</h3><p>消费者注册到nacos跟生产者差不多，也分3步：</p><ol><li><p>添加依赖：同生产者</p></li><li><p>在application.properties中配置nacos的服务名及服务地址：同生产者</p></li><li><p>在引导类（NacosConsumerApplication.java）中添加@EnableDiscoveryClient注解：同生产者</p></li></ol><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210316163238.png" alt="image-20210316163237875"></p><h3 id="2-3-5-使用feign调用服务（在消费者模块中）"><a href="#2-3-5-使用feign调用服务（在消费者模块中）" class="headerlink" title="2.3.5.   使用feign调用服务（在消费者模块中）"></a>2.3.5.   使用feign调用服务（在消费者模块中）</h3><p>以前我们使用feign来远程调用，这里也一样。引入feign的依赖（gulimail-member中）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- openfeign的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在NacosConsumerApplication类上添加@EnableFeignClients注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.atguigu.gulimail.member.feign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NacosConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建feign包，并在包中编写feignClient：</p><p>ProviderFeign内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;nacos-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProviderFeign</span> </span>&#123;</span><br><span class="line"><span class="comment">// 被调用服务的函数签名</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Controller中使用feignClient：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProviderFeign providerFeign;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.providerFeign.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试访问：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210316171242.png" alt="image-20210316171242367"></p><h2 id="2-4-配置中心"><a href="#2-4-配置中心" class="headerlink" title="2.4.   配置中心"></a>2.4.   配置中心</h2><p>​        在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。</p><p>如果微服务架构中没有使用统一配置中心时，所存在的问题：</p><ul><li>配置文件分散在各个项目里，不方便维护</li><li>配置内容安全与权限</li><li>更新配置后，项目需要重启</li></ul><p>nacos配置中心：<strong>系统配置的集中管理</strong>（编辑、存储、分发）、<strong>动态更新不重启</strong>、<strong>回滚配置</strong>（变更管理、历史版本管理、变更审计）等所有与配置相关的活动。</p><h3 id="2-4-1-nacos中创建统一配置"><a href="#2-4-1-nacos中创建统一配置" class="headerlink" title="2.4.1.   nacos中创建统一配置"></a>2.4.1.   nacos中创建统一配置</h3><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210316210321.png" alt="6D59C88C-743B-4637-9DAA-2F8CD26359AC"></p><ol><li><p><code>dataId</code> 的完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure><ul><li><code>prefix</code> 默认为所属工程配置<code>spring.application.name</code> 的值（即：nacos-provider），也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li><li><code>spring.profile.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles">Spring Boot文档</a>。 <strong>注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></strong></li><li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。<strong>目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</strong></li></ul><p>总结：配置所属工程的spring.application.name的值 + “.” + properties/yml</p></li><li><p>配置内容：</p><p>项目中易变的内容。例如：myName</p></li></ol><p><strong>当前案例中，gulimail-coupon工程的spring.application.name=gulimail-coupon，没有配置spring.profiles.active。所以这里的dataId填写的是gulimail-coupon.properties</strong></p><h3 id="2-4-2-从配置中心读取配置"><a href="#2-4-2-从配置中心读取配置" class="headerlink" title="2.4.2.   从配置中心读取配置"></a>2.4.2.   从配置中心读取配置</h3><p>从配置中心读取配置，分以下3步：</p><ol><li><p>引入依赖</p><p>在生产者中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 <strong><code>bootstrap.properties</code></strong> 中配置 Nacos server 的地址和应用名</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId，之前已经配置过</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">nacos-provider</span></span><br></pre></td></tr></table></figure><p>说明：之所以需要配置 <code>spring.application.name</code> ，是因为它是构成 Nacos 配置管理 <code>dataId</code>字段的一部分。</p><p>在springboot工程中，bootstrap.properties的加载优先级更高。</p></li><li><p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果配置中心与application.properties有相同的配置项，配置中心的优先级更高</p></blockquote></li></ol><h3 id="2-4-3-名称空间切换环境"><a href="#2-4-3-名称空间切换环境" class="headerlink" title="2.4.3.   名称空间切换环境"></a>2.4.3.   名称空间切换环境</h3><p>在实际开发中，通常有多套不同的环境（默认只有public），那么这个时候可以根据指定的环境来创建不同的 namespce，例如，开发、测试和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。以此来实现多环境的隔离。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317091812.png" alt="image-20210317091812207"></p><p>切换到配置列表：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210316215224.png" alt="test"></p><p>可以发现有四个名称空间：public（默认）以及我们自己添加的3个名称空间（prod、dev、test），可以点击查看每个名称空间下的配置文件，当然现在只有public下有一个配置。</p><p>默认情况下，项目会到public下找 <code>服务名.properties</code>文件。</p><p>接下来，在dev名称空间中也添加一个gulimail-coupon.properties配置。这时有两种方式：</p><ol><li>切换到dev名称空间，添加一个新的配置文件。缺点：每个环境都要重复配置类似的项目</li><li><strong>直接通过clone方式添加配置，并修改即可。推荐</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317092052.png" alt="A5423842-5089-4D51-958D-E0A55A3F1A7D"></p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317092140.png" alt="D01F6CA9-E542-4950-9208-1C3874EDF346"></p><p>点击编辑：修改配置内容，以作区分</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317092222.png" alt="D23C387F-4393-43E5-BAB1-2087231EC3FB"></p><p>在服务提供方gulimail-coupon中切换命名空间，修改bootstrap.properties添加如下配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">6084d387-8cd7-4dfe-8345-f62b49fb7713</span></span><br></pre></td></tr></table></figure><p>namespace的值为：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317092337.png" alt="8A248CFD-F5B9-4C35-A6F2-8BF92B354CB9"></p><p>重启服务提供方服务，在浏览器中访问测试：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317092534.png" alt="FF585EA2-6756-4895-8114-39AB90912D17"></p><h3 id="2-4-4-回滚配置（了解）"><a href="#2-4-4-回滚配置（了解）" class="headerlink" title="2.4.4.   回滚配置（了解）"></a>2.4.4.   回滚配置（了解）</h3><p><strong>目前版本该功能有bug，回滚之后配置消失。</strong></p><p>回滚配置只需要两步：</p><ol><li>查看历史版本</li><li>回滚到某个历史版本</li></ol><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317101134.png" alt="B510E0DB-0423-4892-A81F-FA895D43759D"></p><h3 id="2-4-5-加载多配置文件"><a href="#2-4-5-加载多配置文件" class="headerlink" title="2.4.5.   加载多配置文件"></a>2.4.5.   加载多配置文件</h3><p>偶尔情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：gulimail-coupon.properties、redis.properties、jdbc.properties。</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317095524.png" alt="image-20210317095524608"></p><p>jdbc.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span>=<span class="string">xxxxxx</span></span><br></pre></td></tr></table></figure><p>redis.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis.url</span>=<span class="string">yyyy</span></span><br></pre></td></tr></table></figure><p>gulimail-coupon.properties默认加载，怎么加载另外两个配置文件？</p><p>在bootstrap.properties文件中添加如下配置：</p><blockquote><p>spring.cloud.nacos.config.ext-config 方式已弃用</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[0].data-id</span>=<span class="string">redis.properties</span></span><br><span class="line"><span class="comment"># 开启动态刷新配置，否则配置文件修改，工程无法感知</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[1].data-id</span>=<span class="string">jdbc.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 还可使用 spring.cloud.nacos.config.shared-configs[0].group 确定分组</span></span><br></pre></td></tr></table></figure><p>修改ProviderController使用redis.properties和jdbc.properties配置文件中的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;redis.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name + <span class="string">&quot;, redis-url=&quot;</span> + redisUrl + <span class="string">&quot;, jdbc-url=&quot;</span> + jdbcUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317100651.png" alt="image-20210317100651080"></p><p>问题：</p><p>​    修改一下配置中心中redis.properties中的配置，不重启服务。能否动态加载配置信息</p><p>​    删掉<code>spring.cloud.nacos.config.shared-configs[0].refresh=true</code>，再修改redis.properties中的配置试试（测试后发现删掉后不能动态加载配置信息）</p><h3 id="2-4-6-配置的分组"><a href="#2-4-6-配置的分组" class="headerlink" title="2.4.6.   配置的分组"></a>2.4.6.   配置的分组</h3><p>在实际开发中，除了不同的环境外。不同的微服务或者业务功能，可能有不同的redis及mysql数据库。</p><p>区分不同的环境我们使用名称空间（namespace），区分不同的微服务或功能，使用分组（group）。</p><p>当然，你也可以反过来使用，名称空间和分组只是为了更好的区分配置，提供的两个维度而已。</p><p>新增一个redis.properties，所属分组为provider：</p><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20210317093737.png" alt="02C8CE83-E07A-4CE2-B156-8682DEBCDC10"></p><p>现在开发环境中有两个redis.properties配置文件，一个是默认分组（DEFAULT_GROUP），一个是provider组</p><p>默认情况下从DEFAULT_GROUP分组中读取redis.properties，如果要切换到provider分组下的redis.properties，需要添加如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[0].data-id</span>=<span class="string">redis.properties</span></span><br><span class="line"><span class="comment"># 开启动态刷新配置，否则配置文件修改，工程无法感知</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定分组</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.shared-configs[0].group</span>=<span class="string">provider</span></span><br></pre></td></tr></table></figure><p>缺点：</p><p>​        将来每个分组下会有太多的配置文件，不利于维护。</p><p>最佳实践：</p><p>​        <strong>命名空间区分业务功能，分组区分环境。</strong></p>]]></content>
      
      
      <categories>
          
          <category> spring全家桶 </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud-alibaba </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合mybatis-plus</title>
      <link href="2021/03/13/spring/springboot%E6%95%B4%E5%90%88mybatis-plus/"/>
      <url>2021/03/13/spring/springboot%E6%95%B4%E5%90%88mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="#快速开始"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">#</a>快速开始</h1><p>我们将通过一个简单的 Demo 来阐述 MyBatis-Plus 的强大功能，在此之前，我们假设您已经：</p><ul><li>拥有 Java 开发环境以及相应 IDE</li><li>熟悉 Spring Boot</li><li>熟悉 Maven</li></ul><hr><p>现有一张 <code>User</code> 表，其表结构如下：</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>Jone</td><td>18</td><td><a href="mailto:&#x74;&#x65;&#115;&#x74;&#49;&#64;&#98;&#x61;&#111;&#109;&#105;&#x64;&#111;&#117;&#46;&#x63;&#x6f;&#x6d;">&#x74;&#x65;&#115;&#x74;&#49;&#64;&#98;&#x61;&#111;&#109;&#105;&#x64;&#111;&#117;&#46;&#x63;&#x6f;&#x6d;</a></td></tr><tr><td>2</td><td>Jack</td><td>20</td><td><a href="mailto:&#x74;&#101;&#115;&#116;&#50;&#x40;&#98;&#97;&#x6f;&#109;&#x69;&#x64;&#111;&#x75;&#x2e;&#99;&#111;&#109;">&#x74;&#101;&#115;&#116;&#50;&#x40;&#98;&#97;&#x6f;&#109;&#x69;&#x64;&#111;&#x75;&#x2e;&#99;&#111;&#109;</a></td></tr><tr><td>3</td><td>Tom</td><td>28</td><td><a href="mailto:&#116;&#x65;&#115;&#116;&#51;&#x40;&#98;&#97;&#x6f;&#x6d;&#105;&#x64;&#111;&#x75;&#46;&#x63;&#111;&#x6d;">&#116;&#x65;&#115;&#116;&#51;&#x40;&#98;&#97;&#x6f;&#x6d;&#105;&#x64;&#111;&#x75;&#46;&#x63;&#111;&#x6d;</a></td></tr><tr><td>4</td><td>Sandy</td><td>21</td><td><a href="mailto:&#x74;&#x65;&#115;&#x74;&#x34;&#64;&#98;&#x61;&#111;&#x6d;&#105;&#100;&#111;&#117;&#x2e;&#99;&#x6f;&#x6d;">&#x74;&#x65;&#115;&#x74;&#x34;&#64;&#98;&#x61;&#111;&#x6d;&#105;&#100;&#111;&#117;&#x2e;&#99;&#x6f;&#x6d;</a></td></tr><tr><td>5</td><td>Billie</td><td>24</td><td><a href="mailto:&#x74;&#x65;&#x73;&#116;&#x35;&#x40;&#x62;&#x61;&#x6f;&#x6d;&#105;&#100;&#111;&#117;&#46;&#x63;&#111;&#x6d;">&#x74;&#x65;&#x73;&#116;&#x35;&#x40;&#x62;&#x61;&#x6f;&#x6d;&#105;&#100;&#111;&#117;&#46;&#x63;&#111;&#x6d;</a></td></tr></tbody></table><p>其对应的数据库 Schema 脚本如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其对应的数据库 Data 脚本如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (<span class="keyword">id</span>, <span class="keyword">name</span>, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><p>Question</p><p>如果从零开始用 MyBatis-Plus 来实现该表的增删改查我们需要做什么呢？</p><h2 id="初始化工程"><a href="#初始化工程" class="headerlink" title="#初始化工程"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">#</a>初始化工程</h2><p>创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示）</p><blockquote><p>TIP</p><p>可以使用 <a href="https://start.spring.io/">Spring Initializer (opens new window)</a>快速初始化一个 Spring Boot 工程</p></blockquote><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="#添加依赖"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">#</a>添加依赖</h2><p>引入 Spring Boot Starter 父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 <code>spring-boot-starter</code>、<code>spring-boot-starter-test</code>、<code>mybatis-plus-boot-starter</code>、<code>h2</code> 依赖：</p><blockquote><p>Latest Version: [<img src="https://img.shields.io/maven-central/v/com.baomidou/mybatis-plus.svg" alt="Maven Central">(opens new window)](<a href="https://search.maven.org/search?q=g:com.baomidou">https://search.maven.org/search?q=g:com.baomidou</a> a:mybatis-*)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Latest Version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="#配置"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E9%85%8D%E7%BD%AE">#</a>配置</h2><p>在 <code>application.yml</code> 配置文件中添加 H2 数据库的相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Config</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">classpath:db/schema-h2.sql</span></span><br><span class="line">    <span class="attr">data:</span> <span class="string">classpath:db/data-h2.sql</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(QuickStartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="#编码"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E7%BC%96%E7%A0%81">#</a>编码</h2><p>编写实体类 <code>User.java</code>（此处使用了 <a href="https://www.projectlombok.org/">Lombok (opens new window)</a>简化代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Mapper类 <code>UserMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="#开始使用"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">#</a>开始使用</h2><p>添加测试类，进行功能测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;----- selectAll method test ------&quot;</span>));</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">5</span>, userList.size());</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TIP</p><p>UserMapper 中的 <code>selectList()</code> 方法的参数为 MP 内置的条件封装器 <code>Wrapper</code>，所以不填写就是无任何条件</p></blockquote><p>控制台输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User(id=1, name=Jone, age=18, email=test1@baomidou.com)</span><br><span class="line">User(id=2, name=Jack, age=20, email=test2@baomidou.com)</span><br><span class="line">User(id=3, name=Tom, age=28, email=test3@baomidou.com)</span><br><span class="line">User(id=4, name=Sandy, age=21, email=test4@baomidou.com)</span><br><span class="line">User(id=5, name=Billie, age=24, email=test5@baomidou.com)</span><br></pre></td></tr></table></figure><p>TIP</p><p>完整的代码示例请移步：<a href="https://github.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-quickstart">Spring Boot 快速启动示例 (opens new window)</a>| <a href="https://github.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-quickstart-springmvc">Spring MVC 快速启动示例(opens new window)</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="#小结"></a><a href="https://mp.baomidou.com/guide/quick-start.html#%E5%B0%8F%E7%BB%93">#</a>小结</h2><p>通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！</p><p>从以上步骤中，我们可以看到集成<code>MyBatis-Plus</code>非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。</p>]]></content>
      
      
      <categories>
          
          <category> spring全家桶 </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的中序遍历</title>
      <link href="2021/01/04/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/01/04/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p><strong>思路与算法</strong></p><p>首先我们需要了解什么是二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 nn 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><h2 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h2><p><strong>思路和算法</strong></p><p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 nn 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li><li>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</li></ul><h2 id="方法三：Morris中序遍历"><a href="#方法三：Morris中序遍历" class="headerlink" title="方法三：Morris中序遍历"></a>方法三：Morris中序遍历</h2><p><strong>思路和算法</strong></p><p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。</p><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p><ol><li>如果 x 无左孩子，先将 xx 的值加入答案数组，再访问 x 的右孩子，即 x = x.right。</li><li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。<ul><li>如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x = x.left。</li><li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 xx 的左子树，我们将 predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x = x.right。</li></ul></li><li>重复上述操作，直至访问完整棵树。</li></ol><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode predecessor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = root.left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor.right != <span class="keyword">null</span> &amp;&amp; predecessor.right != root) &#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    predecessor.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(root.val);</span><br><span class="line">                    predecessor.right = <span class="keyword">null</span>;</span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 nn 为二叉搜索树的节点个数。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 O(2n)=O(n)。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringWeb 应用程序构建</title>
      <link href="2020/12/28/spring/SpringWeb-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BA/"/>
      <url>2020/12/28/spring/SpringWeb-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="构建Spring-Web应用程序"><a href="#构建Spring-Web应用程序" class="headerlink" title="构建Spring Web应用程序"></a>构建Spring Web应用程序</h2><ol><li>映射请求到Spring控制器</li><li>透明地绑定表单参数</li><li>校验表单提交</li></ol><p>Spring MVC 基于模型-视图-控制器(Model-View-Controller，MVC)模式实现，帮助构建灵活和松耦合的Web应用程序</p><h3 id="Spring-MVC起步"><a href="#Spring-MVC起步" class="headerlink" title="Spring MVC起步"></a>Spring MVC起步</h3><h4 id="Spring-MVC-请求流程"><a href="#Spring-MVC-请求流程" class="headerlink" title="Spring MVC 请求流程"></a>Spring MVC 请求流程</h4><p>Spring MVC框架将请求在调度Servler、处理器映射（handler mapping）、控制器以及视图解析器（view resolver）之间移动</p><p><img src="https://segmentfault.com/img/bV9skr?w=675&h=395" alt="clipboard.png"></p><p>1：请求访问前端控制器（DispatcherServlet）；<br>2：DispatcherServlet查询一个或多个处理器映射（handler mapping），通过请求路径确定控制器（Controller）；<br>3：DispatcherServlet将请求发送给控制器（Controller）；<br>4：控制器对请求进行处理返回模型和视图名（ModelAndView）；<br>5：DispatcherServlet查询视图解析器（view resolver），通过视图名匹配一个特定的视图实现；<br>6：DispatcherServlet将模型发送给视图；<br>7：视图通过模型数据渲染输出，通过响应对象传递给客户端；</p><h4 id="搭建Spring-MVC"><a href="#搭建Spring-MVC" class="headerlink" title="搭建Spring MVC"></a>搭建Spring MVC</h4><h5 id="配置DisPatcherServlet"><a href="#配置DisPatcherServlet" class="headerlink" title="配置DisPatcherServlet"></a>配置DisPatcherServlet</h5><p>DisPatcherServlet是Spring MVC的核心。负责将请求路由到指定控制器处理。<br>传统方式，DispathcherServlet会配置在web.xml文件中；<br>借助于<strong>Servlet 3规范和Spring3.1功能增强</strong>，可实现Java配置DispatcherServlet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line">import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line">public class DemoWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123; &quot;&#x2F;&quot; &#125;;                 &#x2F;&#x2F;将DispatcherServlet 映射到 &quot;&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class&lt;?&gt;[]&#123; RootConfig.class &#125;;   &#x2F;&#x2F;指定Spring配置类</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class&lt;?&gt;[]&#123; WebConfig.class &#125;;    &#x2F;&#x2F;指定Spring MVC配置类</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：<br>1：在Serlvet 3环境中，Servlet容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，用来配置Servlet容器；<br>2：Spring通过SpringServletContainerInitializer实现了该接口，SpringServletContainerInitializer又会在容器中查找实现WebApplicationInitializer接口的类并将配置任务交给它们来完成；<br>3：Spring3.2引入一个便利的WebApplicationInitializer基础实现，即AbstractAnnotationConfigDispatcherServletIni-tializer，通过继承该类，当部署到Servler3.0容器中时，容器就会自动发现它，并用它来配置Servlet上下文。</p><p>继承AbstractAnnotationConfigDispatcherServletInitializer需重写三个方法：<br><strong>1：getServletMappings()</strong> 设置DispatcherServlet映射、</p><p>在讲另外两个方法之前，先了解一下Dispatcher和一个Servler监听器（ContextLoaderListener）的关系<br><strong>关于两个应用上下文的关系</strong><br>DispatcherServlet启动的时候，会创建Spring应用上下文容器，并加载配置文件或配置类中所声明的bean。<br>Spring Web应用中，通常还有会另外一个应用上下文，由ContextLoaderListener创建。</p><p>我们通常希望DispathcerServlet加载包含Web组件的bean，如控制器、视图解析器以及处理器映射。<br>而ContextLoaderListener加载应用中其他bean，这些bean通常是加载驱动应用后端的中间层和数据层组件。</p><p><strong>2：getServletConfigClasses()</strong> 返回@Configuration注解类并定义DispatcherServlet应用上下文中的bean。<br><strong>3：getRootConfigClasses()</strong> 返回@Configuration注解类并定义ContextLoaderListener应用上下文中的bean。</p><h5 id="启用Spring-MVC"><a href="#启用Spring-MVC" class="headerlink" title="启用Spring MVC"></a>启用Spring MVC</h5><p>完成配置DispatcherServlet后，需启用Spring MVC。</p><p>传统方式：使用XML配置，使用<a href="mvn:annotation-driven">mvn:annotation-driven</a>启用注解驱动的Spring MVC<br>使用Java配置：@EnableWebMvc注解 启用Spring MVC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package demo;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">@ComponentScan(basePackages &#x3D; &quot;demo.web&quot;)    &#x2F;&#x2F; 控制器、视图解析器以及处理器映射。</span><br><span class="line">public void WebConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ViewResolver viewResolver () &#123;    &#x2F;&#x2F;设置视图解析器</span><br><span class="line">        InternalResourceViewResolver resolver &#x3D; new InternalResourceViewResolver();</span><br><span class="line">        resolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;views&#x2F;&quot;);</span><br><span class="line">        resolver.setSuffix(&quot;.jsp&quot;);</span><br><span class="line">        resolver.setExposeContextBeansAsAttributes(true);</span><br><span class="line">        return resolver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override    &#x2F;&#x2F;继承自WebMvcConfigurerAdapter 用于配置静态资源的处理</span><br><span class="line">    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package demo;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages &#x3D; &quot;demo&quot;,    &#x2F;&#x2F; 加载驱动应用后端的中间层和数据层组件</span><br><span class="line">    excludeFilters &#x3D; &#123;</span><br><span class="line">        @Filter(type &#x3D; FilterType.ANNOTATION, value &#x3D; EnableWebMvc.class)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">public class RootConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写基本的控制器（Controller）"><a href="#编写基本的控制器（Controller）" class="headerlink" title="编写基本的控制器（Controller）"></a>编写基本的控制器（Controller）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo.web;</span><br><span class="line"></span><br><span class="line">@Controller    &#x2F;&#x2F;声明为一个控制器，与@Component作用相同，语义不同，更具有可读性</span><br><span class="line">public class HomeController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&quot;, method &#x3D; RequestMethod.GET)     &#x2F;&#x2F; 处理对&quot;&#x2F;&quot;的GET请求</span><br><span class="line">    public String home() &#123;</span><br><span class="line">        return &quot;home&quot;;    &#x2F;&#x2F;视图名为home</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上配置，我们可以使用一个简单的Spring MVC访问页面，<br>为助于读者理解，提供一份开发部署流程，仅供参考：<br>1 配置DispatcherServlet，编写DemoWebAppInitializer（src.main.java.demo包）<br>2 开启Spring MVC，编写WebConfig 和 RootConfig （src.main.java.demo包）<br>3 编写控制器，HomeController（src.main.java.demo.web包）<br>4 编写页面，home.jsp（src.main.webapp.WEB-INF.views）<br>4 打war包（此过程应该会提示缺少web.xml,可在WEB-INF下添加web.xml 或 配置maven-war-plugin插件忽略web.xml）<br>5 部署war包至tomcat即可（注意Tomcat版本。理论上至少需要支持Servlet 3的Tomcat容器）</p><h4 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;关于断言</span><br><span class="line">import static org.junit.Assert.assertEquals;    &#x2F;&#x2F;此处通过静态引入assertEquals静态方法</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import demo.web.HomeController;</span><br><span class="line">public class HomeControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHomePage() throws Exception &#123;</span><br><span class="line">        HelloController controller &#x3D; new HelloController();</span><br><span class="line">        assertEquals(&quot;home&quot;,controller.home());    &#x2F;&#x2F;通过断言判断controller.home()返回的值是否为&quot;home&quot;，不是则报错。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述测试仅调用home()，并断言返回包含”home”值的String,而不是站在Spring MVC控制器的视角进行测试。<br>正确的测试应该是发送”/“的GET请求会调用home()方法，并真正判断”home”是视图的名称。<br>Spring3.2开始支持第控制器视角的测试。通过<strong>mock Spring MVC</strong>并针对控制器执行HTTP请求的测试机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line">import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">import demo.web.HomeController;</span><br><span class="line">public class HomeControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHomePage() throws Exception &#123;</span><br><span class="line">        HelloController controller &#x3D; new HelloController();</span><br><span class="line">       </span><br><span class="line">        MockMvc mockMvc &#x3D; standaloneSetup(controller).build();    &#x2F;&#x2F;构建MockMvc</span><br><span class="line"></span><br><span class="line">        mockMvc.perform(get(&quot;&#x2F;&quot;))                    &#x2F;&#x2F; 执行 &quot;&#x2F;&quot;GET请求</span><br><span class="line">                .andExpect(view().name(&quot;home&quot;));     &#x2F;&#x2F; 预期得到home视图</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="请求映射处理"><a href="#请求映射处理" class="headerlink" title="请求映射处理"></a>请求映射处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;demo&quot;)    \\当控制器在类级别上添加该注解，这个注解会应用到控制器的所有处理器方法上。</span><br><span class="line">public void DemoController &#123;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;demo&quot;)    \\此方法路径为\demo\demo</span><br><span class="line">    public String demo () &#123;</span><br><span class="line">        return &quot;demo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestMapping({“/“,”/demo”}) 支持多个路径映射</p><h4 id="传递模型数据到视图"><a href="#传递模型数据到视图" class="headerlink" title="传递模型数据到视图"></a>传递模型数据到视图</h4><p>有三种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方式1 Model（本质是一个Map，即 key-value 对的集合）</span><br><span class="line">public String demo(Model model) &#123;</span><br><span class="line">    &#x2F;&#x2F;未指定key时，key依据值类型推断得出（List&lt;String&gt;:stringList,String:string等）</span><br><span class="line">    model.addAttribute(createList());</span><br><span class="line">    return &quot;demo&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式2 Map</span><br><span class="line">public String demo(Map model) &#123;</span><br><span class="line">    model.put(&quot;list&quot;,createList());</span><br><span class="line">    return &quot;demo&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式3 此方式即没返回视图名称，也没显式设定模型</span><br><span class="line">public List&lt;String&gt; demo() &#123;</span><br><span class="line">    &#x2F;&#x2F;（视图名称由请求路径决定，返回的对象会添加到模型中，key由其类型推断，类似方式1）</span><br><span class="line">    return createList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; createList() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(&quot;A&quot;);</span><br><span class="line">    list.add(&quot;B&quot;);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h3><p>Spring MVC允许以多种方式传递参数<br>1：查询参数（Query Parameter）<br>2：表单参数（Form Parameter）<br>3：路径变量（Path Variable）</p><h4 id="处理查询参数"><a href="#处理查询参数" class="headerlink" title="处理查询参数"></a>处理查询参数</h4><p>1基本类型 2 包装类型 3 java bean<br>默认以参数名接参<br><strong>@RequestParam</strong><br><strong>value、name</strong> 设置参数名（与请求参数名匹配）<br><strong>required</strong> 设置参数是否必传<br><strong>defaultValue</strong> 设置默认值</p><h4 id="通过路径参数接受输入"><a href="#通过路径参数接受输入" class="headerlink" title="通过路径参数接受输入"></a>通过路径参数接受输入</h4><p>1 设置路径参数占位符<br>@RequestMapping(“/book/{id}”)</p><p>2 接受路径参数<br>public String getBook(@PathVariable Long id) {…}</p><p><strong>@PathVariable</strong><br><strong>value、name</strong> 设置参数名（与路径参数名匹配）<br><strong>required</strong> 设置参数是否必传</p><p>传输少量数据时，查询参数 和 路径参数都很适合<br>传递很多数据时，通常是表单提交的数据</p><h3 id="处理表单"><a href="#处理表单" class="headerlink" title="处理表单"></a>处理表单</h3><h4 id="接受表单数据"><a href="#接受表单数据" class="headerlink" title="接受表单数据"></a>接受表单数据</h4><p>表单的数据往往较多，可使用java Bean接受参数，Spring MVC会将请求参数中与bean属性同名的进行赋值，并返回bean实例。</p><h4 id="检验表单数据"><a href="#检验表单数据" class="headerlink" title="检验表单数据"></a>检验表单数据</h4><p>避免校验逻辑弄乱处理器代码，可使用Spring对Java校验API(Java Validation API,又称JSR-303)的支持。<br>Spring3.0开始，Spring MVC中提供了对Java校验API的支持。只需导入该Java API的实现即可，如<strong>Hibernate Validator</strong></p><p>将注解定义到Java Bean字段属性上，在接受参数处对待检验的参数添加 <strong>@Valid</strong> 即可</p><table><thead><tr><th>@AssertFalse</th><th>所注解的元素必须为Boolean类型，且值为false</th></tr></thead><tbody><tr><td>@AssertTrue</td><td>所注解的元素必须为Boolean类型，且值为true</td></tr><tr><td>@DecimalMax</td><td>所注解的元素必须为数字，且值要小于或等于给定的BigDecimalString的值</td></tr><tr><td>@DecimalMin</td><td>所注解的元素必须为数字，且值要大于或等于给定的BigDecimalString的值</td></tr><tr><td>@Max</td><td>所注解的元素必须为数字，并且它的值要小于或等于给定的值</td></tr><tr><td>@Min</td><td>所注解的元素必须为数字，并且它的值要大于或等于给定的值</td></tr><tr><td>@Digits</td><td>所注解的元素必须为数字，且值必须有指定的位数</td></tr><tr><td>@Future</td><td>所注解的元素必须为一个将来的日期</td></tr><tr><td>@Past</td><td>所注解元素必须为一个已过去的日期</td></tr><tr><td>@NotNull</td><td>所注解元素的值必须不能为null</td></tr><tr><td>@Null</td><td>所注解元素的值必须为null</td></tr><tr><td>@Pattern</td><td>所注解元素必须匹配给定的正则表达式</td></tr><tr><td>@Size</td><td>所注解的元素的值必须是String、集合或数组，并且它的长度要符合给定的范围</td></tr></tbody></table><p>校验出错时，可以通过Errors对象进行访问，此对象已作为processRegistration()方法参数。（需注意，Errors参数要紧跟在带有@Valid注解的参数后面）<br>processRegistration()方法所做的第一件事就是调用Errors.hasErrors()来检查是否有错误。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...表示省略</span></span><br><span class="line"><span class="meta">@RequestMapping(...)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@valid</span> Spitter spitter,</span></span></span><br><span class="line"><span class="function"><span class="params">Errors errors)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;registerForm&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  spitterRepository.save(spitter);</span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forward-和-redirect"><a href="#forward-和-redirect" class="headerlink" title="forward 和 redirect"></a>forward 和 redirect</h3><p>总结一句话：转发是服务器行为，重定向是客户端行为。</p><p>转发过程（forward）：客户浏览器发送http请求–》web服务器接受此请求–》调用内部的一个方法在容器内部完成请求处理和转发动作—-》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</p><p>重定向过程（redirect）：客户浏览器发送http请求–àweb服务器接受后发送302状态码响应及对应新的location给客户浏览器–》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址—-》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。</p>]]></content>
      
      
      <categories>
          
          <category> spring全家桶 </category>
          
          <category> spring in action阅读总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> springweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="2020/12/25/spring/Spring-AOP/"/>
      <url>2020/12/25/spring/Spring-AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="1-AOP基本概念"><a href="#1-AOP基本概念" class="headerlink" title="1.AOP基本概念"></a>1.AOP基本概念</h2><p><strong>切面（Aspect）</strong>：通知（advice）和切入点（pointcut）共同组成了切面（aspect）</p><p><strong>切入点（Pointcut）</strong>：匹配join point的谓词，切面切向哪里，某个类或者某一层包路径</p><p><strong>连接点（Joinpoint）</strong>：aop拦截的类或者方法，例如方法被调用时、异常被抛出时。(在Spring中，所有的方法都可以认为是joinpoint，但是我们不希望所有的方法都添加Advice，而<strong>pointcut的作用就是提供一组规则来匹配joinpoint</strong>，给满足规则的joinpoint添加Advice。)</p><p><strong>通知（Advice）</strong>：切面何时使用，即注有@Around、@Before、@After等注解的方法</p><p><strong>目标对象（Target Object）</strong>：被通知的对象</p><p><strong>AOP代理（AOP Proxy）</strong>: AOP的代理有两种，一种是JDK动态代理，一种是CGLIB代理。默认情况下，TargetObject实现了接口时，则采用JDK动态代理；反之，采用CGLIB代理</p><p><strong>Joinpoint和Pointcut区别：</strong>在Spring AOP中，所有的方法执行都是joinpoint，而pointcut是一个描述信息，它修饰的是joinpoint，通过pointcut可以确定哪些jointpoint可以被Advice。</p><h2 id="2-通知（Advice）类型说明"><a href="#2-通知（Advice）类型说明" class="headerlink" title="2.通知（Advice）类型说明"></a>2.通知（Advice）类型说明</h2><p><strong>@Around</strong>：环绕通知，包围一个连接点的通知，可以在核心方法前后完成自定义的行为。这是<strong>最常用最重要的</strong>。这个注解需要传入参数<strong>ProceedingJoinPoint pjp</strong>，决定是否进入核心方法—-**调用pjp.proceed();**如果不调的话将不进入核心方法！</p><p><strong>@Before</strong>：前通知，核心代码执行前通知</p><p><strong>@After</strong>：后通知，连接点执行退出时通知（不论正常返回还是异常退出）</p><p><strong>@AfterReturning</strong>：返回后通知，正常返回后通知</p><p><strong>@AfterThrowing</strong>：抛出异常后通知，抛出异常时通知</p><p>注意：除了@Around传的参数是<strong>ProceedingJoinPoint pjp外，</strong>其它都是传的<strong>JoinPoint jp</strong>，也就是说能控制是否进入核心代码的只有Around，<strong>因为aop走到核心代码就是通过调用ProceedingJoinPoint的proceed()方法</strong>，而JoinPoint没有这个方法。</p><h2 id="3-使用注解声明切面"><a href="#3-使用注解声明切面" class="headerlink" title="3.使用注解声明切面"></a>3.使用注解声明切面</h2><p>代码中的中文只是为了便于描述和理解，实际情况中不能使用中文！！！！</p><ul><li><p>目标对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>   <span class="comment">//Banana组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 摔跤() &#123;</span><br><span class="line">        <span class="comment">//异常通知</span></span><br><span class="line">        <span class="comment">//int i = 1;</span></span><br><span class="line">        <span class="comment">//i=i/0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;摔跤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String 跳舞() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我还要跳舞&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//表明是一个切面</span></span><br><span class="line"><span class="meta">@Component</span>   <span class="comment">//表明是一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Van</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义公共切点，这样不用以后每一次都写一遍 切入到Banana摔跤方法 </span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.yoyiyi.java.Banana.摔跤())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poincut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前置通知     在Banan摔跤之前说FQ</span></span><br><span class="line">    <span class="meta">@Before(&quot;poincut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 前置sayFQ() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置FQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置通知    在Banana摔跤之后说FQ</span></span><br><span class="line">    <span class="meta">@After(&quot;poincut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 后置sayFQ() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置FQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异常通知   Banana 摔跤发生异常说FQ 比如没体力</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;poincut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 异常sayFQ() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常FQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回后通知 Van想知道Banana跳舞之后在干啥 Van不知道，所以Object</span></span><br><span class="line">     <span class="meta">@AfterReturning(returning = &quot;rvt&quot;,</span></span><br><span class="line"><span class="meta">            pointcut = &quot;execution(* com.yoyiyi.java.Banana.跳舞())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 返回通知sayFQ(Object rvt) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回通知FQ,发现蕉说&quot;</span> + rvt.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知   Van在Banana摔跤之前之后都说FQ</span></span><br><span class="line">    <span class="meta">@Around(&quot;poincut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 环绕sayFQ(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前面FQ&quot;</span>);</span><br><span class="line">            joinPoint.proceed();<span class="comment">//执行方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;后面FQ&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常FQ&quot;</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>            <span class="comment">//相当于一个xml配置文件</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">//表示开启AOP代理自动配置</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.yoyiyi.java&quot;)</span>  <span class="comment">//扫描com.yoyiyi.java 注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuiChuConfig</span> </span>&#123; <span class="comment">//配置</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-在XML文件中声明切面"><a href="#4-在XML文件中声明切面" class="headerlink" title="4.在XML文件中声明切面"></a>4.在XML文件中声明切面</h2><blockquote><pre><code>====================================================================================================aop配置元素                         用途&lt;aop:advisor&gt;                       定义AOP通知器&lt;aop:after&gt;                         定义AOP后置通知(不管被通知的方法是否执行成功)&lt;aop:after-returning&gt;               定义aop返回通知&lt;aop:after-throwing&gt;                定义aop异常通知&lt;aop:around&gt;                        定义aop环绕通知&lt;aop:aspect&gt;                        定义一个切面&lt;aop:aspectj-autoproxy&gt;             启用@Aspect注解驱动的切面&lt;aop:before&gt;                        定义一个AOP前置通知&lt;aop:config&gt;                        顶层的AOP配置元素.大多数的&lt;aop:*&gt;元素必须包含在&lt;aop:config&gt;元素内.&lt;aop:declare-parents&gt;               以透明的方式为被通知的对象引入额外的接口&lt;aop:pointcut&gt;                      定义一个切点=====================================================================================================</code></pre></blockquote><ul><li><p>切面目标对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>   <span class="comment">//Banana组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 摔跤() &#123;</span><br><span class="line">        <span class="comment">//异常通知</span></span><br><span class="line">        <span class="comment">//int i = 1;</span></span><br><span class="line">        <span class="comment">//i=i/0;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;摔跤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String 跳舞() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我还要跳舞&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//表明是一个切面</span></span><br><span class="line"><span class="meta">@Component</span>   <span class="comment">//表明是一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Van</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前置通知     在Banan摔跤之前说FQ</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 前置sayFQ() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置FQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置通知    在Banana摔跤之后说FQ</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 后置sayFQ() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置FQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异常通知   Banana 摔跤发生异常说FQ 比如没体力</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;poincut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 异常sayFQ() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常FQ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回后通知 Van想知道Banana跳舞之后在干啥 Van不知道，所以Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 返回通知sayFQ(Object rvt) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回通知FQ,发现蕉说&quot;</span> + rvt.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知   Van在Banana摔跤之前之后都说FQ</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 环绕sayFQ(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前面FQ&quot;</span>);</span><br><span class="line">            joinPoint.proceed();<span class="comment">//执行方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;后面FQ&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常FQ&quot;</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>XML配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;animalXmlAspect&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;run&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yoyiyi.java.Banana.摔跤())&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;run&quot;</span> <span class="attr">method</span>=<span class="string">&quot;前置sayFQ&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;run&quot;</span> <span class="attr">method</span>=<span class="string">&quot;后置sayFQ&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;run&quot;</span> <span class="attr">method</span>=<span class="string">&quot;返回通知sayFQ&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;run&quot;</span> <span class="attr">method</span>=<span class="string">&quot;异常sayFQ&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;run&quot;</span> <span class="attr">method</span>=<span class="string">&quot;环绕sayFQ&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring全家桶 </category>
          
          <category> spring in action阅读总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bean的生命周期</title>
      <link href="2020/12/16/spring/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2020/12/16/spring/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p><img src="https://cdn.jsdelivr.net/gh/icbtbo/cloudimg//img/20201217095135.png" alt="image-20201217095135223"></p><p>条件化的bean</p><p>ConditionContext的作用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dota2参议院</title>
      <link href="2020/12/11/%E7%AE%97%E6%B3%95/Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
      <url>2020/12/11/%E7%AE%97%E6%B3%95/Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><ul><li><p>禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p></li><li><p>宣布胜利：如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p></li></ul><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路与算法（循环队列）"><a href="#思路与算法（循环队列）" class="headerlink" title="思路与算法（循环队列）"></a>思路与算法（循环队列）</h2><p>我们以天辉方的议员为例。当一名天辉方的议员行使权利时：</p><ul><li><p>如果目前所有的议员都为天辉方，那么该议员可以直接宣布天辉方取得胜利；</p></li><li><p>如果目前仍然有夜魇方的议员，那么这名天辉方的议员只能行使「禁止一名参议员的权利」这一项权利。显然，该议员不会令一名同为天辉方的议员丧失权利，所以他一定会挑选一名夜魇方的议员。那么应该挑选哪一名议员呢？容易想到的是，<strong>应该贪心地挑选按照投票顺序的下一名夜魇方的议员</strong>。这也是很容易形象化地证明的：既然只能挑选一名夜魇方的议员，那么就应该挑最早可以进行投票的那一名议员；如果挑选了其它较晚投票的议员，那么等到最早可以进行投票的那一名议员行使权利时，一名天辉方议员就会丧失权利，这样就得不偿失了。</p></li></ul><p>由于我们总要挑选投票顺序最早的议员，因此我们可以使用两个队列 <em>radiant</em> 和 <em>dire</em> 分别按照投票顺序存储天辉方和夜魇方每一名议员的投票时间。随后我们就可以开始模拟整个投票的过程：</p><ul><li><p>如果此时 <em>radiant</em> 或者 <em>dire</em> 为空，那么就可以宣布另一方获得胜利；</p></li><li><p>如果均不为空，那么比较这两个队列的首元素，就可以确定当前行使权利的是哪一名议员。如果 <em>radiant</em> 的首元素较小，那说明轮到天辉方的议员行使权利，其会挑选 <em>dire</em> 的首元素对应的那一名议员。因此，我们会将 <em>dire</em> 的首元素永久地弹出，并将 <em>radiant</em> 的首元素弹出，增加 <em>n</em> 之后再重新放回队列，这里 <em>n</em> 是给定的字符串 <em>senate</em> 的长度，即表示该议员会参与下一轮的投票。</p></li></ul><blockquote><p> 为什么这里是固定地增加 <em>n</em>，而不是增加与当前剩余议员数量相关的一个数？读者可以思考一下这里的正确性。</p><p>答：保证该轮已行使过权利的议员在下一轮才能再次行使权力</p></blockquote><p>​      同理，如果 <em>dire</em> 的首元素较小，那么会永久弹出 <em>radiant</em> 的首元素，剩余的处理方法也是类似的。</p><p>这样一来，我们就模拟了整个投票的过程，也就可以得到最终的答案了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">predictPartyVictory</span><span class="params">(String senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = senate.length();</span><br><span class="line">        Queue&lt;Integer&gt; radiant = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; dire = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (senate.charAt(i) == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                radiant.offer(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dire.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!radiant.isEmpty() &amp;&amp; !dire.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> radiantIndex = radiant.poll(), direIndex = dire.poll();</span><br><span class="line">            <span class="keyword">if</span> (radiantIndex &lt; direIndex) &#123;</span><br><span class="line">                radiant.offer(radiantIndex + n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dire.offer(direIndex + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !radiant.isEmpty() ? <span class="string">&quot;Radiant&quot;</span> : <span class="string">&quot;Dire&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/dota2-senate/solution/dota2-can-yi-yuan-by-leetcode-solution-jb7l/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：<em>O(n)*，其中 nn 是字符串 *senate</em> 的长度。在模拟整个投票过程的每一步，我们进行的操作的时间复杂度均为 <em>O(1)*，并且会弹出一名天辉方或夜魇方的议员。由于议员的数量为 *n</em>，因此模拟的步数不会超过 <em>n</em>，时间复杂度即为 *O(n)*。</p></li><li><p>空间复杂度：*O(n)*，即为两个队列需要使用的空间。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 循环队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将数组拆分成斐波那契序列</title>
      <link href="2020/12/08/%E7%AE%97%E6%B3%95/%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"/>
      <url>2020/12/08/%E7%AE%97%E6%B3%95/%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="842将数组拆分成斐波那契序列"><a href="#842将数组拆分成斐波那契序列" class="headerlink" title="842将数组拆分成斐波那契序列"></a>842将数组拆分成斐波那契序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><ul><li>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；</li><li>F.length &gt;= 3；</li><li>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。</li></ul><p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>回溯加剪枝</p></blockquote><p>将给定的字符串拆分成斐波那契式序列，可以通过回溯的方法实现。</p><p>使用列表存储拆分出的数，回溯过程中维护该列表的元素，列表初始为空。遍历字符串的所有可能的前缀，作为当前被拆分出的数，然后对剩余部分继续拆分，直到整个字符串拆分完毕。</p><p>根据斐波那契式序列的要求，从第 33 个数开始，每个数都等于前 22 个数的和，因此从第 33 个数开始，需要判断拆分出的数是否等于前 22 个数的和，只有满足要求时才进行拆分，否则不进行拆分。</p><p>回溯过程中，还有三处可以进行剪枝操作。</p><ul><li><p>拆分出的数如果不是 00，则不能以 00 开头，因此如果字符串剩下的部分以 00 开头，就不需要考虑拆分出长度大于 11 的数，因为长度大于 11 的数以 00 开头是不符合要求的，不可能继续拆分得到斐波那契式序列；</p></li><li><p>拆分出的数必须符合 3232 位有符号整数类型，即每个数必须在 [0,2^31−1] 的范围内，如果拆分出的数大于 2^{31}-1，则不符合要求，长度更大的数的数值也一定更大，一定也大于 2^{31}-1,因此不可能继续拆分得到斐波那契式序列；</p></li><li><p>如果列表中至少有 22 个数，并且拆分出的数已经大于最后 22 个数的和，就不需要继续尝试拆分了。</p></li></ul><p>当整个字符串拆分完毕时，如果列表中至少有 33 个数，则得到一个符合要求的斐波那契式序列，返回列表。如果没有找到符合要求的斐波那契式序列，则返回空列表。</p><p>实现方面，回溯需要带返回值，表示是否存在符合要求的斐波那契式序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        backtrack(list, S, S.length(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, String S, <span class="keyword">int</span> length, <span class="keyword">int</span> index, <span class="keyword">int</span> sum, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == length) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.size() &gt;= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> currLong = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; S.charAt(index) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currLong = currLong * <span class="number">10</span> + S.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (currLong &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> curr = (<span class="keyword">int</span>) currLong;</span><br><span class="line">            <span class="keyword">if</span> (list.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; sum) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &gt; sum) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(curr);</span><br><span class="line">            <span class="keyword">if</span> (backtrack(list, S, length, i + <span class="number">1</span>, prev + curr, curr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全与隐私保护</title>
      <link href="2020/12/03/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>2020/12/03/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="差分隐私"><a href="#差分隐私" class="headerlink" title="差分隐私"></a>差分隐私</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>差分隐私，英文名为differential privacy，顾名思义，保护的是数据源中一点微小的改动导致的隐私泄露问题。比如有一群人出去聚餐，那么其中某人是否是单身狗就属于差分隐私。</p><p>为了更形式化地描述差分隐私，我们需要先定义相邻数据集。现给定两个数据集D和D’, 若它们有且仅有一条数据不一样，那我们就称此二者为相邻数据集。以上面数据集为例：假定有 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 个人，他们是否是单身狗，形成一个集合 <img src="https://www.zhihu.com/equation?tex=%5C%7Ba_1,a_2,+%E2%80%A6,+a_n%5C%7D" alt="[公式]"> （其中 <img src="https://www.zhihu.com/equation?tex=a_i+=+0" alt="[公式]">或<img src="https://www.zhihu.com/equation?tex=1" alt="[公式]">），那么另一个集合当中只有一个人改变了单身状态，形成另一个集合 <img src="https://www.zhihu.com/equation?tex=%5C%7Ba_1%E2%80%99,+a_2%E2%80%99,+%E2%80%A6,+a_n%E2%80%99%5C%7D" alt="[公式]"> ，也就是只存在一个 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 使得 <img src="https://www.zhihu.com/equation?tex=a_i+%5Cne+a_i%E2%80%99" alt="[公式]"> ，那么这两个集合便是相邻集合。</p><p>那么对于一个随机化算法 <img src="https://www.zhihu.com/equation?tex=A" alt="[公式]"> （所谓随机化算法，是指对于特定输入，该算法的输出不是固定值，而是服从某一分布），其分别作用于两个相邻数据集得到的两个输出分布难以区分。差分隐私形式化的定义为：</p><p><img src="https://www.zhihu.com/equation?tex=Pr%5C%7BA(D)+=+O%5C%7D+%E2%89%A4e%5E%5Cepsilon+%5Ccdot+Pr%5C%7BA(D%E2%80%99)+=+O%5C%7D+" alt="[公式]"></p><p>也就是说，如果该算法作用于任何相邻数据集，得到一个特定输出 <img src="https://www.zhihu.com/equation?tex=O" alt="[公式]"> 的概率应差不多，那么我们就说这个算法能达到差分隐私的效果。也就是说，观察者通过观察输出结果很难察觉出数据集一点微小的变化，从而达到保护隐私的目的。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>那如何才能得到差分隐私呢？最简单的方法是加噪音，也就是在输入或输出上加入随机化的噪音，以期将真实数据掩盖掉。比较常用的是加拉普拉斯噪音（Laplace noise）。由于拉普拉斯分布的数学性质正好与差分隐私的定义相契合，因此很多研究和应用都采用了此种噪音。还是以前面那个数据集为例，假设我们想要知道到底有多少人是单身狗，我们只需要计算 <img src="https://www.zhihu.com/equation?tex=%5Csum+a_i" alt="[公式]"> ，那么为了掩盖具体数值，实际输出值应为 <img src="https://www.zhihu.com/equation?tex=O=%5Csum+a_i+++r_%7Blap%7D" alt="[公式]"> ，相应地，另一个数据集输出的是 <img src="https://www.zhihu.com/equation?tex=O%E2%80%99=+%5Csum+a_i%E2%80%99+r_%7Blap%7D%E2%80%99" alt="[公式]"> 。这使得观察者分不清最终的输出是由哪个数据集产生的。</p><p>前面描述的是差分隐私的严格定义。还有一种稍微放宽一点的定义为：</p><p><img src="https://www.zhihu.com/equation?tex=Pr%5C%7BA(D)+=+O%5C%7D+%5Cle+e%5E%5Cepsilon+%5Ccdot+Pr%5C%7BA(D%E2%80%99)+=+O%5C%7D+++%5Cdelta+" alt="[公式]"></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cdelta" alt="[公式]"> 是一个比较小的常数。要获取这种差分隐私，我们可以使用高斯噪音（Gaussian noise）。</p><p>当然，对输入或输出加噪音会使得最终的输出结果不准确。而且由于噪音是为了掩盖一条数据，所以很多情况下数据的多少并不影响加的噪音的量。那么在数据量很大的情况下，噪音的影响很小，这时候就可以放心大胆地加噪音了，但数据量很小的情况下，噪音的影响就显得比较大，会使得最终结果偏离准确值较远而变得不可用。也有些算法不需要加噪音就能达到差分隐私的效果，听起来很美好，但这种算法通常要求数据满足一定的分布，这一点在现实中通常很难满足。</p><h2 id="本地化差分隐私和中心化差分隐私的区别"><a href="#本地化差分隐私和中心化差分隐私的区别" class="headerlink" title="本地化差分隐私和中心化差分隐私的区别"></a>本地化差分隐私和中心化差分隐私的区别</h2><p>中心化差分隐私与本地化差分隐私主要的区别在于处理过程的不同。中心化差分隐私对采集后的数据进行扰动，因此需要一个可信的中心服务进行数据的汇总和处理；而本地化差分隐私在数据的源头进行扰动保护，因此允许数据拥有者在本地进行处理，更好地保护了隐私。</p><h1 id="同态加密"><a href="#同态加密" class="headerlink" title="同态加密"></a>同态加密</h1><h2 id="什么是同态加密？"><a href="#什么是同态加密？" class="headerlink" title="什么是同态加密？"></a>什么是同态加密？</h2><p>提出第一个构造出全同态加密（Fully Homomorphic Encryption）[Gen09]的Craig Gentry给出的直观定义最好：</p><blockquote><p>A way to delegate processing of your data, without giving away access to it.</p></blockquote><p>这是什么意思呢？一般的加密方案关注的都是<strong>数据存储安全</strong>。即，我要给其他人发个加密的东西，或者要在计算机或者其他服务器上存一个东西，我要对数据进行加密后在发送或者存储。没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正确解密，得到原始的内容。我们注意到，这个过程中<strong>用户是不能对加密结果做任何操作的</strong>，只能进行存储、传输。对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。</p><p>同态加密方案最有趣的地方在于，其关注的是<strong>数据处理安全</strong>。同态加密提供了一种<strong>对加密数据进行处理的功能</strong>。也就是说，其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。</p><p>有点抽象？我们举个实际生活中的例子。有个叫Alice的用户买到了一大块金子，她想让工人把这块金子打造成一个项链。但是工人在打造的过程中有可能会偷金子啊，毕竟就是一克金子也值很多钱的说… 因此能不能有一种方法，让工人可以对金块进行加工（delegate processing of your data），但是不能得到任何金子（without giving away access to it）？当然有办法啦，Alice可以这么做：</p><ul><li>Alice将金子锁在一个密闭的盒子里面，这个盒子安装了一个手套。</li><li>工人可以带着这个手套，对盒子内部的金子进行处理。但是盒子是锁着的，所以工人不仅拿不到金块，连处理过程中掉下的任何金子都拿不到。</li><li>加工完成后。Alice拿回这个盒子，把锁打开，就得到了金子。</li></ul><p>这里面的对应关系是：</p><ul><li>盒子：加密算法</li><li>盒子上的锁：用户密钥</li><li>将金块放在盒子里面并且用锁锁上：将数据用同态加密方案进行加密</li><li>加工：应用同态特性，在无法取得数据的条件下直接对加密结果进行处理</li><li>开锁：对结果进行解密，直接得到处理后的结果</li></ul><h2 id="同态加密哪里能用？"><a href="#同态加密哪里能用？" class="headerlink" title="同态加密哪里能用？"></a>同态加密哪里能用？</h2><p>这几年不是提了个云计算的概念嘛。同态加密几乎就是为云计算而量身打造的！我们考虑下面的情景：一个用户想要处理一个数据，但是他的计算机计算能力较弱。这个用户可以使用云计算的概念，让云来帮助他进行处理而得到结果。但是如果直接将数据交给云，无法保证安全性啊！于是，他可以使用同态加密，然后让云来对加密数据进行直接处理，并将处理结果返回给他。这样一来：</p><ul><li>用户向云服务商付款，得到了处理的结果；</li><li>云服务商挣到了费用，并在不知道用户数据的前提下正确处理了数据；</li></ul><p>这方法简直完美啊有没有？！但是，这么好的特性肯定会带来一些缺点。同态加密现在最需要解决的问题在于：效率。效率一词包含两个方面，一个是加密数据的处理速度，一个是这个加密方案的数据存储量。我们可以直观地想一想这个问题：</p><ul><li><p>工人戴着手套加工金子，肯定没有直接加工来得快嘛~ 也就是说，隔着手套处理，精准度会变差（现有构造会有误差传递问题），加工的时间也会变得更长（密文的操作花费更长的时间），工人需要隔着操作，因此也需要更专业（会正确调用算法）。</p></li><li><p>金子放在盒子里面，为了操作，总得做一个稍微大一点的盒子吧，要不然手操作不开啊（存储空间问题）。里面也要放各种工具吧，什么电钻啦，锉刀啦，也需要空间吧？</p></li></ul><h1 id="K匿名算法"><a href="#K匿名算法" class="headerlink" title="K匿名算法"></a>K匿名算法</h1><p>在大数据的时代，很多机构需要面向公众或研究者发布其收集的数据，例如医疗数据，地区政务数据等。这些数据中往往包含了个人用户或企业用户的隐私数据，这要求发布机构在发布前对数据进行脱敏处理。K匿名算法是比较通用的一种数据脱敏方法。举例来说，如下图是两张表，一张是用户的会员注册信息表，一张是对外发布的医疗信息表。</p><p><a href="https://imgchr.com/i/D7PRmV"><img src="https://s3.ax1x.com/2020/12/03/D7PRmV.png" alt="D7PRmV.png"></a></p><p><a href="https://imgchr.com/i/D7iq3j"><img src="https://s3.ax1x.com/2020/12/03/D7iq3j.png" alt="D7iq3j.png"></a></p><p>第二张医疗信息表中，虽然已经把用户姓名，身份证号等个人关联信息抹去，但如果直接发布这样简单匿名处理的数据，同样会带来数据泄露的风险。因为通过两张不同数据来源的表进行关联，对出生日期，性别，邮编的值进行匹配，可以定位出张三患有心脏病的隐私数据。这种通过某些属性与外部表链接的攻击称为链接攻击。</p><p>如上图两个表所示，每一行代表用户的一条记录，每一列表示一个属性。每一个记录与一个特定的用户/个体关联，这些属性可以分为三类：</p><ul><li><p>标识符(Explicit Identifier)：可以直接确定一个个体，如：身份证号，姓名等。</p></li><li><p>准标识符集(Quasi-identifier Attribute set): 可以和外部表链接来识别个体的最小属性集，如：邮编，生日，性别等。</p></li><li><p>敏感数据(Sensitive Attributes)：用户不希望被人知道的数据，如：薪水，疾病历史，购买偏好等。</p></li></ul><p>K-匿名(K-Anonymity)是Samarati和Sweeney在1998年提出的技术，该技术可以保证存储在发布数据集中的每条个体记录对于敏感属性不能与其他的K-1个个体相区分，即K-匿名机制要求同一个准标识符至少要有K条记录，因此观察者无法通过准标识符连接记录。</p><p>K-匿名的具体使用如下：隐私数据脱敏的第一步通常是对所有标识符列进行移除或是脱敏处理，使得攻击者无法直接标识用户。但是攻击者还是有可能通过多个准标识列的属性值识别到个人。攻击者可能通过（例如知道某个人的邮编，生日，性别等）包含个人信息的开放数据库获得特定个人的准标识列属性值，并与大数据平台数据进行匹配，从而得到特定个人的敏感信息。为了避免这种情况的发生，通常也需要对准标识列进行脱敏处理，如数据泛化等。数据泛化是将准标识列的数据替换为语义一致但更通用的数据，以上述医疗数据为例，对邮编和年龄泛化后的数据如下图所示。</p><p><a href="https://imgchr.com/i/D7PfTU"><img src="https://s3.ax1x.com/2020/12/03/D7PfTU.png" alt="D7PfTU.png"></a></p><p>经过泛化后，有多条纪录的准标识列属性值相同。所有准标识列属性值相同的行的集合被称为相等集。K-匿名要求对于任意一行纪录，其所属的相等集内纪录数量不小于K，即至少有K-1条纪录的准标识列属性值与该条纪录相同。</p><p><strong>K-匿名技术就是每个相等集(或称为等价组)中的记录个数为K个，那么当针对大数据的攻击者在进行链接攻击时，对于任意一条记录的攻击同时会关联到相等集中的其他K-1条记录。这种特性使得攻击者无法确定与特定用户相关的记录，从而保护了用户的隐私。</strong></p><p>K-匿名技术能保证以下三点：</p><ul><li>攻击者无法知道某特定个人是否在公开的数据中</li><li>给定一个人，攻击者无法确认他是否有某项敏感属性</li><li>攻击者无法确认某条数据对应的是哪个人</li></ul><p>但从另外一个角落来看，K-匿名技术虽然可以阻止身份信息的公开，但无法防止属性信息的公开，导致其无法抵抗同质攻击，背景知识攻击，补充数据攻击等情况：</p><ul><li>同质攻击: 如在上面的K-匿名医疗信息表中，第1-3条记录的敏感数据是一致的，因此这时候K-匿名就失效。观察者只要知道表中某一个用户的邮编是476***，年龄在20多岁，就可以确定他有心脏病。</li><li>背景攻击: 如果观察者通过邮编和年龄确定用户王一在K-匿名医疗信息表的等价集3中，同时观察者知道王一患心脏病的可能很小，那么他就可以确定王一曾经骨折。</li></ul><p>补充数据攻击：当公开的数据有多种类型，如果他们的K-匿名方法不同，那么攻击者可以通过关联多种数据推测用户信息。</p><h1 id="L多样化"><a href="#L多样化" class="headerlink" title="L多样化"></a>L多样化</h1><h2 id="什么是L多样化"><a href="#什么是L多样化" class="headerlink" title="什么是L多样化"></a>什么是L多样化</h2><p>为了解决同质性攻击和背景知识攻击所带来的隐私泄露，Machanavajjhala等人提出了L-多样性(l-diversity)模型。简单来说，就是在公开的数据中，每一个等价类里的敏感属性必须具有多样性，即L-多样性保证每一个等价类里，敏感属性至少有L个不同的取值，通过这样L-多样性使得攻击者最多只能以1/L的概率确认某个体的敏感信息，从而保证用户的隐私信息不能通过背景知识，同质知识等方法推断出来。</p><p><a href="https://imgchr.com/i/D7FjRH"><img src="https://s3.ax1x.com/2020/12/03/D7FjRH.png" alt="D7FjRH.png"></a></p><p>如上图所示，在每一个等价集中，包含至少3个以上不同的属性值，那么这部分公开数据就满足3-diversity的属性。</p><blockquote><p>要实施L-多样性模型，除了上述的不可区分属性方式，通常还可以引入其他的统计方法来实现：</p><ol><li>不可区分L-多样性(Distinction L-Diversity): 在同一个等价类中至少出现L个不同的敏感属性值。</li><li>基于概率的L-多样性(Probabilistic L-Diversity)：在一个类型中出现频率最高的值的概率不大于1/L；</li><li>基于熵的L-多样性(Entropy L-Diversity): 在一个等价类中敏感数据分布的熵至少是log(L)；</li><li>递归(C,L)-多样性(Recursive (C,L)-Diversity): 通过递归的方式，保证等价类中最经常出现的值的出现频率不要太高。</li><li>递归(C1, C2, L)-多样性(Recursive(C1,C2,L)-Diversity): 通过递归的方式，保证等价类中最经常出现的值的出现频率不要太高, 同时还保证了等价类中频率最低的敏感属性出现的频率不能太低。</li></ol></blockquote><h2 id="L-多样性也具有一定局限性"><a href="#L-多样性也具有一定局限性" class="headerlink" title="L-多样性也具有一定局限性"></a>L-多样性也具有一定局限性</h2><ol><li>敏感属性比例的严重不均衡导致L-多样性难以实现，例如某疾病检测报告，敏感属性只有“阳性”和“阴性”，分别占比1%和99%，阴性人群并不在乎被人知道结果，但阳性人群可能很敏感。如果在一个等价类中均为阴性，是没有必要实现可区分的2-Diversity。</li><li>偏斜性攻击(Skewness Attack)：如果在上面那个例子中，我们保证了阳性和阴性出现的概率相同，虽然保证了多样性，但是泄露隐私的可能性会变大，因为L-多样性并没有考虑敏感属性的总体分布。</li></ol><p>L-多样性没有考虑敏感属性的语义，而导致敏感信息的泄露。例如敏感属性是“工资”，某一等价类中的取值全为2K-3K之间，那么观察者只要知道用户在这一等价类就可以知道其工资处于较低水平，具体数值观察者并不关心。</p><h1 id="安全多方计算（MPC）"><a href="#安全多方计算（MPC）" class="headerlink" title="安全多方计算（MPC）"></a>安全多方计算（MPC）</h1><blockquote><p>安全多方计算（Secure Muti-party Computation，简称MPC，亦可简称SMC或SMPC）问题首先由华裔计算机科学家、图领奖获得者姚期智教授于1982年提出，也就是为人熟知的百万富翁问题：两个争强好胜的富翁Alice和Bob在街头相遇，如何在不暴露各自财富的前提下比较出谁更富有？</p></blockquote><p>简单来说，安全多方计算协议作为密码学的一个子领域，其允许多个数据所有者在互不信任的情况下进行协同计算，输出计算结果，并保证任何一方均无法得到除应得的计算结果之外的其他任何信息。换句话说，MPC技术可以获取数据使用价值，却不泄露原始数据内容。</p><h1 id="可验证计算（Verifiable-Computing）"><a href="#可验证计算（Verifiable-Computing）" class="headerlink" title="可验证计算（Verifiable Computing）"></a>可验证计算（Verifiable Computing）</h1><p>可验证计算通常是指Verifiable Computing(简称“VC”)，指可以将计算任务外包给第三方算力提供者；（不受信任的）第三方算力提供者需要在完成计算任务的同时，提交一份关于计算结果的正确性证明。</p>]]></content>
      
      
      <categories>
          
          <category> 课程复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据安全 </tag>
            
            <tag> 隐私保护 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
