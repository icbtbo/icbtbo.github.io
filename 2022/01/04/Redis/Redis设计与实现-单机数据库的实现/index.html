<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis设计与实现:单机数据库的实现 | sjc的搬砖小屋</title><meta name="keywords" content="redis"><meta name="author" content="icbtbo"><meta name="copyright" content="icbtbo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="本文主要对redis单机数据库实现中涉及到的一些技术进行介绍，包括数据库的实现、数据持久化、事件的概念以及客户端和服务端的实现">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis设计与实现:单机数据库的实现">
<meta property="og:url" content="https://icbtbo.github.io/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="sjc的搬砖小屋">
<meta property="og:description" content="本文主要对redis单机数据库实现中涉及到的一些技术进行介绍，包括数据库的实现、数据持久化、事件的概念以及客户端和服务端的实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icbtbo.github.io/img/default_bg.png">
<meta property="article:published_time" content="2022-01-04T06:38:05.000Z">
<meta property="article:modified_time" content="2022-03-23T12:55:59.767Z">
<meta property="article:author" content="icbtbo">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icbtbo.github.io/img/default_bg.png"><link rel="shortcut icon" href="/img/home.png"><link rel="canonical" href="https://icbtbo.github.io/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 20:55:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="sjc的搬砖小屋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/niu.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">86</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_bg.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sjc的搬砖小屋</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Redis设计与实现:单机数据库的实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-04T06:38:05.000Z" title="发表于 2022-01-04 14:38:05">2022-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T12:55:59.767Z" title="更新于 2022-03-23 20:55:59">2022-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《Redis设计与实现》阅读笔记</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>redis3.0 标有注解的源码：<a target="_blank" rel="noopener" href="https://github.com/huangz1990/redis-3.0-annotated">https://github.com/huangz1990/redis-3.0-annotated</a></p>
</blockquote>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>从Redis服务端的实现角度介绍，包括db存储，切换，键的存储及过期相关处理。</p>
<h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis把所有库信息都保存在<code>redis.h/redisServer</code>结构的db数组中，数组类型是<code>redis.h/redisDB</code>，dbnum决定着应该创建多少数据库中的db，clients维护着所有连接Redis的客户端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">//客户端状态链表</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器数据库实例如图所示：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042148700.jpg" alt="img"></p>
<p>当切换库时，其实就是redisClient.db对redisServer.db数组的目标数据库指针的移动。下面展示了从0号库切为1号库的过程。通过<strong>指针的切换</strong>，实现对库的共享：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149516.jpg" alt="img"></p>
<h3 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h3><p>redis将所有key进行统一管理，按照所属的库划分，放在redisDb的字典中（按照上面画的数据结构，redis每一个库都对应一个redisDb）。redisDb结构的dict字典保存了该数据库中的所有键值对，也称为<strong>键空间</strong>。键空间的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键空间的键就是数据库的键，每个键都是一个字符串对象，键空间的值就是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象（上一章主要是对值的存储结构介绍）。</p>
<p>下图展示了键空间的存储：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149396.jpg" alt="img"></p>
<p>当执行一些插入指令时，就是对dict中key的新增；同理，删除键后，dict中的键值对对象都会被删除。</p>
<p><strong>读写键空间时的维护操作(9.3.6详讲)</strong></p>
<p>对键的读写时，服务器会做相应的善后操作，比如更新缓存的命中率，更新LRU（最后一次使用）时间，对已过期的键先进行删除操作，修改时对客户端watch的键进行dirty标记，更新dirty键计数器的值，当开启通知功能后，键修改时需要按配置发送相应通知。</p>
<h3 id="键过期时间相关操作"><a href="#键过期时间相关操作" class="headerlink" title="键过期时间相关操作"></a>键过期时间相关操作</h3><p>通过<code>EXPIRE</code>或<code>PEXPIRE</code>，客户端可以以<strong>秒或毫秒</strong>为精度设置过期时间（Time To Live，TTL）。通过<code>EXPIREAT</code>或<code>PEXPIREAT</code>，客户端可以设置<strong>时间戳</strong>作为过期时间。</p>
<p>使用<code>TTL</code>或<code>PTTL</code>也可查看某个键的剩余生存时间，还有多久过期：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 498</span><br></pre></td></tr></table></figure>

<p>Redis是如何保存过期时间的，又是如何删除过期键的将在下面论述。</p>
<p><strong>设置过期时间</strong></p>
<p>Redis提供了4个命令设置过期时间：</p>
<ul>
<li>EXPIRE<key> <ttl>：将key的生存时间设为ttl秒。</li>
<li>PEXPIRE<key> <ttl>：将key的生存时间设为ttl毫秒。</li>
<li>EXPIREAT<key> <timestamp>：将key的过期时间设置为timestamp秒数时间戳。</li>
<li>PEXPIREAT<key> <timestamp>：将key的过期时间设置为timestamp毫秒数时间戳。</li>
</ul>
<p>其实几个命令底层都是经过换算后，用<strong>PEXPIREAT</strong>实现的。</p>
<p>实现转换关系图：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149255.jpeg" alt="img"></p>
<p><strong>存储过期时间</strong></p>
<p>redisDb中有一个expires的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个<strong>long long</strong>类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的Unix时间戳）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>图中键空间和过期的键其实复用了一个键对象，这里方便展示就拆开来，假设我们给键alphabet和book都设置了过期时间：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042149780.jpg" alt="img"></p>
<p><strong>移除过期时间</strong></p>
<p>PERSIST命令可以<strong>移除一个键的过期时间</strong>，在过期字段中查找给定键，并<strong>解除</strong>键和值在过期字典中的关联。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE key 500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 498</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST message</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure>

<p><strong>计算并返回剩余生存时间</strong></p>
<p>TTL以秒为单位返回剩余时间，PTTL以毫秒返回键的剩余时间。二者的计算都是通过计算键的过期时间与当前时间之差来实现的。</p>
<h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>如果一个键过期了，那么在什么时候被删除？列举几个常见淘汰策略：</p>
<ol>
<li>定时删除：设置键的过期时间时，创建定时器，过期时，以定时器立刻执行键的删除。</li>
<li>惰性删除：不着急删除过期键，每次获取时都会进行过期校验。</li>
<li>定期删除：隔一段时间，程序就对数据库检查，删除过期键。</li>
</ol>
<p><strong>定时删除</strong></p>
<p>定时删除策略<strong>对内存友好</strong>，但<strong>对CPU不友好</strong>。过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。Redis定时器需要创建时间事件，时间事件底层由无序链表实现，查找复杂度为O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p>
<p><strong>惰性删除</strong></p>
<p>惰性删除<strong>对CPU友好</strong>，但<strong>对内存不友好</strong>。不需要把时间浪费在非相关键的删除上。当键非常多时，会导致内存泄漏，因为只有用到时才会判断，删除。</p>
<p><strong>定期删除</strong></p>
<p>定期删除是一种折衷的方式，隔一段时间执行一次，并<strong>限制</strong>删除操作<strong>执行的时长和频率</strong>减少对CPU的占用；定期删除还能<strong>减少庞大的过期键对内存的占用</strong>。如何确定时长和频率是难点，过长或过少，会退变为定时删除和惰性删除。</p>
<p><strong>Redis的过期键删除策略</strong></p>
<p>Redis使用了<strong>惰性删除和定期删除</strong>两种策略配合，服务器可以合理地在使用CPU时间和避免内存浪费之间权衡。</p>
<ul>
<li><p>惰性删除策略的实现</p>
<p>该策略由<code>db.c/expireIfNeeded</code>函数实现，如同指令过滤器，在执行读写键指令时都会调用该函数检查键是否过期，如果过期则删除。</p>
</li>
<li><p>定期删除策略的实现</p>
<p>该策略由<code>redis.c/activeExpireCycle</code>函数实现，当服务器周期性调用<code>redis.c/serverCron</code>函数时，<code>activeExpireCycle</code>函数就会被调用，规定时间内，多次遍历服务器的各个数据库，从expires字典中随机检查一部分键的过期时间，并删除过期键。<code>activeExpireCycle</code>函数的主要工作可以拆分为：</p>
<ol>
<li>每次运行，都从一定数量的数据库中取出一定数量的<strong>随机键</strong>检查并删除过期键。</li>
<li>全局遍历记录检查进度，有<strong>记忆</strong>功能，全局变量存储的是几号库。</li>
<li>当所有数据库都被检查一遍后，<strong>重置</strong>全局变量，进行新一轮检查。</li>
</ol>
</li>
</ul>
<h3 id="RDB、AOF和复制功能对过期键的处理"><a href="#RDB、AOF和复制功能对过期键的处理" class="headerlink" title="RDB、AOF和复制功能对过期键的处理"></a>RDB、AOF和复制功能对过期键的处理</h3><p><strong>载入RDB文件</strong>：</p>
<ul>
<li>若服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键不会对主服务器载入RDB文件产生影响</li>
<li>若以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，主从服务器在进行数据同步时，从服务器的数据库会被清空，所以过期键不会对从服务器载入RDB文件产生影响</li>
</ul>
<p><strong>写入AOF文件</strong>：</p>
<ul>
<li>若某个键已过期但未被删除，那么AOF文件不会因这个过期键产生任何影响</li>
<li>若某个键已过期并被删除后，程序会向AOF文件追加一条DEL命令</li>
</ul>
<p><strong>重写AOF文件</strong>：</p>
<ul>
<li>与生成RDB文件类似，在重写AOF文件过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中</li>
</ul>
<p><strong>复制</strong>：</p>
<ul>
<li>主服务器删除一个过期键后，会向所有从服务器发送一个DEL命令，告知从服务器删除该过期键</li>
<li>从服务器在执行客户端发送的读命令时，即使遇到过期键也不会做什么，而时像处理未过期键一样处理该键，将其值返回。只有在收到主服务器发过来的DEL命令后，从服务器才会删除该过期键。</li>
</ul>
<h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>Redis发布订阅功能可以让客户端获取数据库中键的变化及命令的执行情况。关注某个键执行了什么命令的通知称为键空间通知。关注某个命令被什么键执行的通知称为事件通知。</p>
<p>主要就是围绕通知功能，简单看下发送通知及其实现。</p>
<p><strong>发送通知</strong></p>
<p>该功能由<code>notify.c/notifyKeyspaceEvent</code>函数实现：</p>
<p>通过几个入参：要发送的通知类型，事件名称，产生事件的键，产生事件的数据库号。来构造事件通知内容和接收频道名，Redis许多指令的执行函数都会调用这个函数，传递该命令引发的事件相关信息。</p>
<p><strong>发送通知的实现</strong></p>
<ol>
<li>通过服务器配置的值判断，如果给定通知类型不是服务器允许的就直接返回。</li>
<li>如果是服务器允许发送的，检测是否允许发送键空间通知，允许则构建发送事件并通知。</li>
<li>检测是否允许发送键事件通知，如果允许则构建并发送通知。</li>
</ol>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>由于Redis是内存数据库，数据状态都存储于内存，如果不想办法将存储在内存中的数据库状态保存到磁盘里，那么一旦服务器进程退出，服务器中的数据库状态也会消失。</p>
<p>为解决这个问题，Redis提供了持久化的功能，可将内存中的数据库保存到磁盘，防止意外丢失。RDS持久化（默认持久化策略）就是将某一时间点上的状态保存到一个RDB文件里。RDB文件是经过<strong>压缩的二进制文件</strong>，可通过该文件还原成数据库状态。</p>
<h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个命令可用于生成RDB文件（SAVE和BGSAVE）。他们之间的区别是：SAVE会<strong>阻塞</strong>Redis服务器进程，直到RDB文件创建完毕为止，阻塞期间，服务器不能处理任何命令请求。而BGSAVE会<strong>fork出一个子进程</strong>，由子进程负责创建RDB文件，<strong>父进程继续处理命令请求</strong>。当子进程完成之后，向父进程<strong>发送信号</strong>。</p>
<p>创建就是执行SAVE/BGSAVE底层调用rdbSave函数的过程，载入就是服务启动时读取RDB文件底层调用rdbLoad函数的过程。</p>
<p><strong>适用场景</strong></p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis挂了，就会<strong>丢失最后一次快照后的所有修改</strong>。</li>
<li>fork的时候，当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ul>
<p><strong>BGSAVE执行时的服务器状态</strong></p>
<p>BGSAVE命令执行期间，对SAVE，BGSAVE，BGREWRITEAOF（AOF持久化命令）三个命令的处理方式如下：</p>
<ul>
<li>由于SAVE，BGSAVE底层都是调用rdbSave来持久化文件的，而且父子进程同时执行两个rdbSave调用会<strong>产生竞态条件</strong>，所以这两个指令会被服务器拒绝。</li>
<li>BGREWRITEAOF会被延迟到BGSAVE执行结束后执行。</li>
</ul>
<blockquote>
<p>如果BGREWRITEAOF正在执行，服务器会拒绝BGSAVE命令。由于BGREWRITEAOF和BGSAVE都会产生子进程且有大量的磁盘写入，出于性能考虑不会同时执行。</p>
</blockquote>
<p>简单来说，就是BGSAVE执行期间，<strong>拒绝SAVE，BGSAVE</strong>；<strong>延迟执行BGREWRITEAOF</strong>。BGREWRITEAOF执行期间，<strong>拒绝BGSAVE</strong>。</p>
<p><strong>RDB与AOF共存的载入情况</strong></p>
<p>RDB文件的载入是在服务器启动时执行，Redis并没有专门提供载入RDB文件的命令。由于AOF文件的更新频率更高，因此开启AOF持久化功能后，启动时<strong>优先加载AOF</strong>还原数据，只有在AOF处于关闭状态，才使用RDB文件恢复数据。</p>
<h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>服务器允许用户通过配置文件设置隔一定时间自动执行BGSAVE。可通过save选项设多个保存条件，默认的配置如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>只要满足任意条件，900s内对数据库进行1次修改或300s内…BGSAVE就会被执行。</p>
<p>那么，服务器是如何根据save选项来自动执行BGSAVE的？<br>从实现角度考虑，我们需要<strong>记录配置</strong>、<strong>评判依据</strong>和<strong>依据更新驱动</strong>。记录配置由saveparams实现；评判依据是dirty计数器和lastsave属性；依据更新驱动就是serverCron对评判依据的动态更新。<br>save配置都会在redisServer的saveparam数组中体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>dirty计数器和lastsave属性</strong></p>
<p>这两个属性由redisServer持有：</p>
<ul>
<li>dirty计数器记录距离上次成功执行SAVE或BGSAVE后数据库被修改了几次。</li>
<li>lastsave是一个UNIX时间戳，记录上次成功执行SAVE或BGSAVE的时间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行保存的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>检查条件是否满足</strong></p>
<p>Redis的周期性操作函数serverCron每隔100毫秒会执行一次，其中一项工作就是检查save选项设置的保存条件是否满足要求，满足则执行BGSAVE。</p>
<h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150112.jpeg" alt="img"></p>
<p>REDIS：长度5字节，保存”REDIS”5个字符（为书写方便，其实是5个单独字符），通过这个判断该文件是否为RDB文件。</p>
<p>db_version：长度4字节，是字符串表示的整数记录RDB的版本号。</p>
<p>database：包含0个或多个数据库及各数据库中键值对数据。表示那些数据库是有数据的。</p>
<p>EOF：常量长度1字节，标志RDB文件正文的结束。读取时遇到该值，表示键值对的载入已经结束了。</p>
<p>check_sum：是一个8字节的无符号整数，保存一个同过前几位变量计算出来的校验和。每次加载都会进行计算校验，通过这个来判断文件是否损坏。</p>
<p><strong>database部分</strong></p>
<p>每个非空数据库在RDB文件中都可表示为SELECTDB，db_number，key_value_pairs三部分</p>
<ul>
<li>selectdb：1字节，标志位，标志着下一位存储的是数据库号码。</li>
<li>db_number：是一个数据库号码。</li>
<li>key_value_pairs：保存了数据库中所有键值对数据，如果有过期时间，则过期时间也会保存。</li>
</ul>
<p><strong>key_value_pairs部分</strong></p>
<p>不带过期时间的键值对在RDB文件由TYPE，key，value组成，带过期时间则含有EXPIRETIME_MS，ms：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150519.png" alt="img"></p>
<p>EXPIRETIME_MS：标志位，长度为1字节，告知程序下一个读入的是以毫秒为单位的过期时间。<br>ms：是8字节长的带符号整数，记录UNIX时间戳，即过期时间。<br>type：记录value的类型，长度1字节，这个常量其实就是Redis对象类型和底层编码的组装：</p>
<ul>
<li>REDIS RDBTYPE_STRING</li>
<li>REDIS_ RDB_TYPE_LIST</li>
<li>REDIS_RDB_TYPE_SET</li>
<li>REDIS_RDB_TYPE_ZSET</li>
<li>REDIS_RDB_TYPE_HASH</li>
<li>REDIS_RDB_TYPE_LIST_ ZIPLIST</li>
<li>REDIS_RDB_TYPE_SET_INTSET</li>
<li>REDIS_RDB_TYPE_ZSET_ZIPLIST</li>
<li>REDIS_RDB_TYPE_HASH_ZIPLIST</li>
</ul>
<p>服务器会根据TYPE来决定如何读入和解释value的数据。</p>
<p>key就不用做过多解释~</p>
<p><strong>value的编码</strong></p>
<p>根据TYPE的不同，value的存储结构也大不相同。这里不详细展开，只需要知道，对于字符串对象，如果大于20字节，就会用LZF算法压缩。除字符串对象和整数集合，其他存储方式的开头都是节点数量，告诉程序应读入多少节点/键值对。（详细内容可查阅10.3.3节）</p>
<h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><p>Redis自带RDB文件检查工具redis-check-dump。可以帮助在系统故障后分析快照文件，也就是RDB文件。</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。服务器启动时，可通过载入和执行AOF文件中保存的命令来还原服务器关闭前的数据库状态。</p>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化可分为命令追加，文件写入，文件同步三个步骤。</p>
<p><strong>命令追加</strong></p>
<p>开启AOF持久化后，服务器执行完一个写命令后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的<code>aof_buf</code>缓冲区末尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>AOF文件的写入与同步</strong></p>
<p>Redis服务器进程就是一个<strong>事件循环</strong>，负责接收客户端命令请求及命令回复，时间事件负责执行像<code>serverCron</code>函数这样需要定时运行的函数。服务器每结束一个事件循环前，都会调用<code>flushAppendOnlyFile</code>函数，考虑是否有必要<strong>将aof缓冲区中的内容写入和保存至AOF文件</strong>里。</p>
<p>这个判断的依据就是根据配置文件的appendfsync值决定：</p>
<ul>
<li>always：将aof_buf缓冲区的所有内容<strong>写入并同步</strong>到AOF文件。</li>
<li>everysec：将aof_buf缓冲区中的所有内容写入到AOF文件，如果此时与上次同步AOF文件的时间<strong>超过一秒</strong>，就再次对AOF文件进行同步，并由一个线程专门负责。</li>
<li>no：将aof_buf缓冲区中的所有内容写入到AOF文件，但并<strong>不对AOF文件进行同步</strong>，何时同步<strong>由操作系统决定</strong>。</li>
</ul>
<p>为什么有写入和同步的区分？写入≠同步</p>
<p>为提高写效率，操作系统一般将写入数据<strong>暂时保存在内存缓冲区</strong>，等缓冲区<strong>填满或超过</strong>指定时间后才会真正地将<strong>数据同步到磁盘里</strong>。操作系统提供了fsync和fdatasync两个同步函数，可<strong>强制操作系统同步数据</strong>，保证数据安全性。</p>
<p>也就是说，每一次的事件循环，aof_buf中的指令<strong>都会被写入操作系统的缓冲区</strong>，根据appendfsync配置，当操作系统缓冲区满足一定条件后，才被<strong>真实地写入</strong>磁盘内。</p>
<h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>步骤如下：</p>
<ol>
<li>创建一个没有网络连接的伪客户端。（由于Redis命令只能在客户端上下文中执行，并且AOF文件在本地而不是网络）。</li>
<li>解析AOF文件并取出一条写命令。</li>
<li>使用伪客户端执行被读出的写命令</li>
<li>持续执行2和3，直到所有写命令都已经执行完毕</li>
</ol>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150967.jpg" alt="img"></p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为AOF持久化会将所有的写命令都记录，所以会有冗余情况，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong>瘦身的机制</strong>确保AOF里存的都是必不可少的精华。</p>
<p>Redis提供AOF文件重写功能，让服务器创建一个新的AOF文件，替代现有的AOF文件，减少冗余命令。</p>
<p><strong>AOF文件重写的实现</strong></p>
<p>在新的AOF文件的重写过程中，不会读取旧AOF文件，而是通过<strong>读取数据库状态</strong>来实现的。首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录的多条命令。</p>
<blockquote>
<p>注：在重写时会先检查键所包含的元素数量，因为多元素的键在命令转换时可能会导致客户端输入缓冲区溢出。该限制由配置中对应的一个常量控制，默认超过64个就用多条指令记录。</p>
</blockquote>
<p><strong>AOF后台重写过程</strong></p>
<p>AOF重写的过程中会有大量的写入操作，为了避免Redis服务器长时间的阻塞，重写工作将被放到<strong>子进程中进行</strong>。这样的好处是：</p>
<ul>
<li>父进程仍然可继续处理请求。</li>
<li>子进程有自己的数据副本，而非子线程，可以避免一些线程安全性问题的出现。</li>
</ul>
<p>子进程在执行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致<strong>当前数据库状态与重写后的AOF文件保存的状态不一致</strong>。为解决这个问题，设置了<strong>AOF重写缓冲区</strong>。</p>
<p>当重写子进程创建后，Redis服务器执行完写命令就会将其写入AOF缓冲区和AOF重写缓冲区，子进程执行重写期间，服务器进程要执行3个工作：</p>
<ol>
<li>执行客户端发来的命令。</li>
<li>将执行后的写命令追加到AOF缓冲区。</li>
<li>将执行后的写命令追加到AOF重写缓冲区。</li>
</ol>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150308.jpg" alt="img"></p>
<p>当子进程完成重写后，会向父进程<strong>发送一个信号</strong>，父进程接收并调用信号处理函数，将重写缓冲区的所有内容写到新AOF文件中，原子地覆盖现有的AOF文件。因此整个AOF文件重写的过程中，只有<strong>信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是一个<strong>事件驱动程序</strong>，主要有两种：</p>
<ul>
<li>文件事件：Redis服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端通信会产生相应文件事件，服务器通过监听这些事件来完成一系列网络通信操作。</li>
<li>时间事件：Redis服务器有一些需要在给定时间内执行的操作，而时间事件就是对这类定时操作的抽象。</li>
</ul>
<p>简单来说，文件事件就是<strong>套接字操作相关的事件</strong>；时间事件就是<strong>定时操作相关事件</strong>。</p>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发的网络事件处理器，就是文件事件处理器。大致是使用I/O多路复用程序<strong>同时监听多个套接字</strong>，根据套接字目前执行的任务为套接字<strong>关联不同的事件处理器</strong>；当被监听的套接字准备好<strong>应答，读取，写入，关闭</strong>等操作时。与之对应的文件事件就会产生，文件事件处理器就开始发挥作用了，调用事先关联好的事件处理器来处理事件。</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150098.jpg" alt="img"></p>
<p>利用多路复用，虽然以单线程的方式运行，但文件事件处理器实现了高性能的网络通信模型，又能很好的与Redis服务器中其他模块对接，保持了设计的<strong>简单性</strong>。</p>
<p><strong>文件事件处理器的组成</strong></p>
<p>由套接字，I/O多路复用程序，文件事件分派器，事件处理器组成。</p>
<p>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O多路复用程序总是将所有产生事件的<strong>套接字放入到一个队列</strong>中，以有序，同步，<strong>一次一个套接字</strong>向文件事件分派器传送的姿态来运行。只有当上一个套接字产生事件被事件处理器执行完了，才会继续传送下一个套接字。</p>
<p>下图展示了多路复用程序使用队列传输套接字：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150230.png" alt="img"></p>
<p><strong>I/O多路复用的实现</strong></p>
<p>Redis为所有多路复用的函数库进行包装，每个多路复用函数库在其中都对应一个单独文件：<code>ae_select.c</code>,<code>ae_epoll.c</code>,<code>ae_kqueue.c</code>。为每个多路复用函数都实现了相同的API，所以多路复用程序的底层实现是可以互换的。Redis在多路复用程序源码中用宏定义了相应规则，使得程序在编译时自动选择系统中性能最高的I/O多路复用函数库。</p>
<p>有关多路复用的知识可以参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127170201">https://zhuanlan.zhihu.com/p/127170201</a></p>
<p><strong>事件的类型</strong></p>
<p>多路复用程序可监听的套接字事件可分为<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件。</p>
<ul>
<li>当套接字变得<strong>可读</strong>时（客户端对套接字执行write，close，accept后），套接字产生AE_READABLE事件。</li>
<li>当套接字变得<strong>可写</strong>时（客户端对套接字执行read操作后），套接字产生AE_WRITABLE事件。</li>
</ul>
<p>I/O多路复用程序允许服务器同时监听者两个事件，如果某个套接字同时产生了两种事件，文件事件分派其会优先处理AE_READABLE，再处理AE_WRITABLE</p>
<p><strong>文件事件的处理器</strong></p>
<p>根据客户端的需要，事件处理器分为连接应答处理器，命令请求处理器，命令回复处理器，复制处理器。这里只介绍前三者。</p>
<ol>
<li><p>连接应答处理器</p>
<p><code>networking.c/acceptTcpHandler</code>函数是Redis的连接应答处理器，用于连接服务器监听套接字的客户端进行应答。</p>
<p>Redis服务器初始化时，程序就将连接应答处理器和服务器监听套接字的<strong>AE_READABLE事件关联</strong>，当客户端调用<code>sys/socket.h/connect</code>函数时连接服务器监听套接字时，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p>
<p>简单来说就是客户端<strong>连接被监听的套接字</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>连接应答处理器就会执行</strong>。</p>
</li>
<li><p>命令请求处理器</p>
<p><code>networking.c/readQueryFromClient</code>函数是Redis命令请求处理器，主要负责从套接字中读入客户端发送的命令请求内容。</p>
<p>当客户端成功连接到服务器后，服务器会将<strong>AE_READABLE事件</strong>和命令请求处理器关联。当客户端向服务器发送命令请求时，套接字产生AE_READABLE事件，引发命令请求处理器执行，执行相应套接字的读入操作。</p>
<p>简单来说就是客户端<strong>发送命令请求</strong>时，套接字<strong>产生并触发读事件</strong>，<strong>命令请求处理器就会执行</strong>。</p>
</li>
<li><p>命令回复处理器</p>
<p><code>networking.c/sendReplyToClient</code>函数是Redis的命令回复处理器，负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p>
<p>当需要回复命令结果时，服务器会将客户端套接字的<strong>AE_WRITEBLE事件</strong>和命令回复处理器关联，当客户端准备好接收回复时就会产生AE_WRITABLE事件，引发命令回复处理器执行。执行结束，服务器会解除命令回复处理器与客户端的套接字AE_WRITABLE事件之间的关联。</p>
<p>简单来说就是服务器<strong>发送命令回复</strong>时，套接字<strong>产生并触发写事件</strong>，<strong>命令回复处理器就会执行</strong>。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p>一次完整的基于文件事件的服务器与客户端交互，相关处理器的处理过程：</p>
<ol>
<li>客户端发起连接，产生读事件，触发连接应答处理器执行。创建套接字，客户端状态并将该套接字的读事件与命令请求处理器关联。</li>
<li>客户端发送命令，产生读事件，触发命令请求处理器。读取执行命令，得到回复并将该套接字的写事件与命令回复处理器关联。</li>
<li>客户端读取命令回复，产生写事件，触发命令回复处理器。将回复写入套接字，解除写事件与命令回复处理器的关联。</li>
</ol>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件可分为<strong>定时事件</strong>和<strong>周期性事件</strong>：</p>
<ul>
<li>定时事件:只在指定时间到达时执行一次。如xx时间后执行一次。</li>
<li>周期性事件:每隔一段时间执行一次。如每隔xx秒执行一次。</li>
</ul>
<blockquote>
<p>注：Redis一般只用周期性事件。</p>
</blockquote>
<p><strong>时间事件的组成</strong></p>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>id：服务器为时间事件创建的全局唯一ID (标识号)。 ID号按<strong>从小到大</strong>的顺序递增，新事件的ID号比旧事件大。</li>
<li>when：毫秒精度的UNIX时间戳，时间事件的到达(arrive)时间。</li>
<li>timeProc：时间事件处理器函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li>
</ul>
<p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:</p>
<ul>
<li>事件处理器返回<code>ae.h/AE_NOMORE</code>, 为定时事件：该事件在达到一次之后被删除，之后不再到达。</li>
<li>事件处理器返回非<code>AE_NOMORE</code>的整数值，为周期性时间。当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，遍历整个链表，找到已到达的时间事件，调用相应的事件处理器。新的事件总是插入到链表的表头。</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150489.jpg" alt="img"></p>
<p>因为事件ID只能增大，所以新插入的id总是最大的。</p>
<h4 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h4><p>很多情况下，Redis需要定期进行资源检查，状态同步等操作，就需要定期操作，而定期操作都是由serverCron函数负责的，也是时间事件的应用实例。默认每隔100ms执行，具体工作包括：</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。以及清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<p>下面简单从几个方面出发，介绍serverCron的本职工作。</p>
<p><strong>更新服务器时间缓存</strong></p>
<p>Redis不少功能依赖于系统当前时间，每次获取系统时间都会进行系统调用，为减少系统调用次数，服务器使用了unixtime和mstime作为当前时间的缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">//保存了毫秒级的系统当前UNIC时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于serverCron默认100毫秒更新一次unixtime和mstime，导致其精度不高，只使用于精度要求不高的场景：</p>
<ul>
<li>服务器打印日志，更新服务器的LRU时钟，决定执行持久化，计算上限时间等。</li>
<li>设置过期时间，添加慢查询日志需要高高进度，服务器还是会进行系统调用。</li>
</ul>
<p><strong>更新LRU时钟</strong></p>
<p>每个Redis对象也会有lru属性，记录上一次被命令访问的时间。如果要计算一个键的空转时长，就要通过lrulock记录的时间减去对象的lru属性记录时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认每10秒更新一次的时钟缓存，</span></span><br><span class="line">    <span class="comment">//用于计算键的空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lrulock:<span class="number">22</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//对象最后一个被命令访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>更新服务器每秒执行命令数</strong></p>
<p>抽样计算函数以100毫秒一次，估算最近一秒钟的处理请求数。每次都会根据4个变量（上次抽样时间、当前时间、上次抽样已执行命令数、当前已执行命令数）来计算调用之间平均每毫秒处理几个命令，乘以1000就是1秒内处理命令的估计值。这个估计值会被放入redisServer的ops_sec_samples数组中。当我们需要知道秒内的指令数时，就会计算这个数组的平均数，因此结果是一个估算值。</p>
<p><strong>更新服务器内存峰值记录</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stat_peak_memory记录内存峰值，每次serverCron函数执行就会判断是否需要刷新内存峰值，如果当前使用的多就刷新。</p>
<p><strong>管理客户端资源</strong></p>
<p>serverCron每次执行都会调用clientsCron函数对客户端进行检查：如果已经超时则关闭；如果输入缓冲区大小超过一定长度则重新创建默认大小的输入缓冲区。</p>
<p><strong>管理数据库资源</strong></p>
<p>serverCron每次执行都会调用databaseCron函数，会对服务器的一部分数据库检查，删除过期键；对字典收缩。</p>
<p><strong>执行被延迟的BGREWRITEAOF</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//AOF延迟标志位，如果为1，则有AOF操作被延迟</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_shceduled;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由<code>aof_rewrite_shceduled</code>标志位决定，如果处于BGSAVE命令执行期间，BGREWRITEAOF会被延迟到BGSAVE执行后执行。</p>
<p><strong>检查持久化操作的运行状态</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行BGSAVE命令的子进程，没有为-1</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;</span><br><span class="line">    <span class="comment">//执行BGREWRITEAOF命令的子进程，没有为-1</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rdb_child_pid</code>和<code>aof_child_pid</code>只要<strong>一个不为-1</strong>，则检查子进程是否有信号发来。如果有信号到达则进行后续操作，比如新<strong>RDB文件的替换，重写的AOF文件替换</strong>等。</p>
<p>如果<code>rdb_child_pid</code>和<code>aof_child_pid</code><strong>都为-1</strong>，则进行检查：</p>
<ul>
<li>是否有BGREWRITEAOF被延迟，有的话就进行BGREWRITEAOF操作。</li>
<li>自动保存条件是否满足，满足且未执行其他持久化操作则执行BGSAVE。</li>
<li>AOF重写条件是否满足，满足且未执行其他持久化操作则开始一次新的BGREWRITEAOF操作。</li>
</ul>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150971.jpg" alt="img"></p>
<h4 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h4><p>当服务器同时存在时间事件和文件事件，调度时该如何选择，花费多久？</p>
<p>事件的调度由<code>ae.c/aeProcessEvents</code>函数负责。对于每一次事件循环，主要过程是：</p>
<ol>
<li>拿到最近的时间事件并计算还有多少毫秒。</li>
<li>创建时间任务结构；阻塞等待文件事件产生，最大阻塞时间<strong>由最近时间事件到达毫秒数决定</strong>。</li>
<li>先处理已产生的<strong>文件事件</strong>再处理到达的<strong>时间事件</strong>。</li>
</ol>
<p>执行原则/设计利弊：</p>
<ol>
<li>aeApiPoll函数（redis封装的多路复用函数）的最大阻塞时间由到达时间<strong>最接近当前时间的时间事件</strong>决定，这个方法既可以避免服务器对时间事件进行频繁的轮询(忙等待)，也可以确保aeApiPoll函数<strong>不会阻塞过长时间</strong>。</li>
<li>因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。</li>
<li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器,还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>本文第一章提到过Redis服务器的状态结构clients属性是<strong>链表</strong>，记录了所有与服务器相连的客户端结构，对客户端执行批量操作或查找操作，都可以通过clients链表完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clents</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端的属性主要分为通用和特定的，这里主要介绍通用的。简单来说有套接字描述符，标志，输入缓冲区，命令与参数，输出缓冲区，时间等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//标志</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="comment">//单个命令拆分的数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//argv数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    <span class="comment">//固定大小输出缓冲区，默认16K</span></span><br><span class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    <span class="comment">//buf已使用字节数</span></span><br><span class="line">    <span class="keyword">int</span> bufpos;</span><br><span class="line">    <span class="comment">//大小可变输出缓冲区</span></span><br><span class="line">    <span class="built_in">list</span> *reply</span><br><span class="line">    <span class="comment">//创建客户端的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;</span><br><span class="line">    <span class="comment">//与服务器互动的最后时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction;</span><br><span class="line">    <span class="comment">//软性限制时间</span></span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    ...</span><br><span class="line">&#125;redis client;</span><br></pre></td></tr></table></figure>

<p><strong>套接字描述符fd</strong></p>
<p>根据客户端类型不同：</p>
<ul>
<li>fd为-1表示伪客户端。</li>
<li>fd为大于-1的整数时表示普通客户端。</li>
</ul>
<p>伪客户端就是用于处理的命令请求来源于AOF或Lua脚本，不需要套接字连接，也就不需要套接字记录符。普通客户端就是所有来源于网络需要套接字连接的客户端。</p>
<p><strong>标志flags</strong></p>
<p>标志flags记录了客户端的角色。有主从标志，Lua伪客户端标志，执行MONITOR标志…标志可以以二进制来拼接：flags:<flag1>|<flag2>|<flag3>…</p>
<p><strong>输入缓冲区querybuf</strong></p>
<p>输入缓冲区存储客户端输入的指令，大小根据输入内容动态缩小扩大，最大不可超过1G，否则导致服务器关闭该客户端。</p>
<p><strong>命令与参数(argv，argc）</strong></p>
<p>在将客户端输入的命令保存到querybuf后，服务器将对命令进行解析，并将得到的命令参数以及命令参数的个数存放到数组argv和整数argc中，其数据结构是这样的：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150757.jpg" alt="img"></p>
<blockquote>
<p>当客户端输入命令后，服务器根据argv[0]的值在命令表中查找（命令不区分大小写）对应命令的函数并给cmd赋值，cmd就是对应的命令函数相关的操作信息。</p>
<p>命令表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令的redisCommand结构，这个结构保存了命令的实现函数、命令的标志、命令需要的参数个数以及总执行次数和总消耗时长等统计信息。</p>
</blockquote>
<p><strong>输出缓冲区（buf，bufpos，reply）</strong></p>
<p>输出缓冲区有两个，一个大小固定，一个大小可变。大小固定的存储长度小的回复，比如OK，错误返回等。大小可变缓冲区保存长度较大的回复，比如长列表，大集合。</p>
<p>大小可变缓冲区由reply链表实现，利用链表结构存储若干和字符串对象，使得长度不会受到限制。</p>
<p>其数据结构如下：</p>
<img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150003.png" alt="image-20220104200809219" style="zoom:30%;" />

<p><strong>时间（ctime，lastinteraction，obuf_soft_limit_reached_time）</strong></p>
<ul>
<li>ctime属性记录了创建客户端的事件</li>
<li>lastinteraction属性记录了客户端与服务器最后一次进行互动的事件</li>
<li>obuf_soft_limit_reached_time记录了输出缓冲区第一次到达软性限制的时间</li>
</ul>
<blockquote>
<p>服务器使用两种模式来限制客户端输出缓冲区的大小:</p>
<ul>
<li>硬性限制( hard limit):如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。</li>
<li>软性限制(softlimit):软性限制比硬性限制小，服务器会根据输出缓冲区大小介于软硬性限制之间的时间决定是否关闭客户端 。</li>
</ul>
</blockquote>
<h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><p>由于客户端有不同类型，所以创建和关闭的方式也不相同。</p>
<p><strong>创建普通客户端</strong></p>
<p>客户端连接时调用connect函数，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将该新的客户端状态添加到client链表末尾。</p>
<p><strong>关闭普通客户端</strong></p>
<p>普通客户端可因其中一个原因关闭：</p>
<ul>
<li>客户端进程退出或者被杀死</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求</li>
<li>客户端成为了CLIENT KILL命令的目标</li>
<li>用户为服务器设置了timeout配置选项且当客户端的空转时间超过timeout时。不过timeout选项有一些例外情况：若客户端是主服务器，从服务器，正在被BLPOP等命令阻塞，或正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li>
<li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小(默认为1GB)</li>
<li>输出缓冲区的大小超过了硬性限制所设置的大小</li>
<li>输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制的时间超过指定时间。</li>
</ul>
<p><strong>Lua脚本的伪客户端</strong></p>
<p>服务器初始化时创建，随服务器结束关闭。</p>
<p><strong>AOF文件的伪客户端</strong></p>
<p>载入AOF文件时创建，载入结束关闭。</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>简而言之，这章就是在解释客户端<strong>输入Redis指令到返回结果的执行过程</strong>。</p>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>首先是Redis服务器初始化操作，服务器从启动到能够处理客户端的命令请求需要执行以下步骤：</p>
<ol>
<li>初始化服务器状态。</li>
<li>载入服务器配置。</li>
<li>初始化服务器数据结构。</li>
<li>还原数据库状态。</li>
<li>执行事件循环。</li>
</ol>
<p><strong>初始化服务器状态结构</strong></p>
<p>主要是对redisServer结构体的初始化，包括设置服务器运行ID，运行频率，设置配置文件路径，设置持久化条件，命令表创建等。</p>
<p><strong>载入配置选项</strong></p>
<p>根据用户设定的配置，对redisServer相关变量的值进行修改，比如端口号，数据库数量，RDB的压缩是否开启等等。其他属性还是沿用默认值。</p>
<p><strong>初始化服务器数据结构</strong></p>
<p>对除了命令表外的数据结构（包括客户端链表，db数组，订阅信息，Lua脚本执行环境，慢查询日志相关属性等等）进行初始化。</p>
<blockquote>
<p>服务器必须先载入用户配置，才能对其他数据结构进行准确初始化。否则，若是先初始化再根据用户配置设定相关值，那么若是用户配置的值和默认值不同，且该配置和数据结构有关，那么服务器就要重新调整和修改已创建的数据结构。这样就会比较麻烦。</p>
</blockquote>
<p><strong>还原数据库状态</strong></p>
<p>载入RDB或AOF文件的数据恢复过程。</p>
<p><strong>执行事件循环</strong></p>
<p>至此，服务器可接收客户端请求并发送信息。</p>
<h3 id="命令执行过程"><a href="#命令执行过程" class="headerlink" title="命令执行过程"></a>命令执行过程</h3><p>以<code>SET key value</code>为例，命令的执行过程是：</p>
<ol>
<li>客户端发送命令。</li>
<li>服务器接收并处理请求，对数据库操作，回复OK。</li>
<li>服务器将命令回复OK返回给给客户端。</li>
<li>客户端接收命令并打印结果。</li>
</ol>
<p>下面将按照步骤拆解为发送，读取查找，执行预备操作，调用实现函数，执行后续工作，回复，打印操作讲解。</p>
<p><strong>发送</strong></p>
<p>客户端接收命令请求时，会将命令根据协议转为固定格式再发送给服务器。</p>
<p><strong>读取</strong></p>
<p>当套接字因客户端的写入变得可读时，服务器会先读取协议格式内容并保存到输入缓冲区。命令分析，提取参数及个数，存入argv和argc属性。最后调用命令执行器。</p>
<p><strong>命令执行器-查找命令的实现</strong></p>
<p>命令表是一个<strong>字典</strong>，键是命令名字，值是redisCommand结构。几个重要属性如下：</p>
<ul>
<li>name：命令名称。</li>
<li>proc：指向命令实现函数。</li>
<li>arity：命令参数个数，包括命令名称。</li>
<li>sflags：命令属性。</li>
</ul>
<p>查找命令表的过程就是找到redisCommand，把指针指向它：</p>
<p><img src="https://blogimg-picgo.oss-cn-beijing.aliyuncs.com/img/202201042150982.jpg" alt="img"></p>
<p><strong>命令执行器-执行预备操作</strong></p>
<p>在命令真正执行前需要有预备操作保证命令可以被正确，顺利地执行。这个环节相当于一层过滤，比如检查命令是否正确，参数是否正确，身份验证是否通过，内存是否够用等等。保证配置生效，准确执行。</p>
<p><strong>命令执行器-调用命令的实现函数</strong></p>
<p>执行过程就是调用之前找到并指向的执行函数。通过client-&gt;cmd-&gt;proc(client);调用。然后将回复保存在客户端状态的输出缓冲区中，关联该套接字的命令回复处理器。</p>
<p><strong>命令执行器-执行后续工作</strong></p>
<p>有一些善后工作还将继续，比如慢查询日志记录，执行时长记录，AOF持久化，主服务器将命令传给从服务器。当这些都处理完后，服务器就继续从文件事件处理器中取出并执行下一个命令请求。</p>
<p><strong>将命令回复发送给客户端</strong></p>
<p>当客户端套接字变为可写状态，服务器执行命令回复处理器，将输出缓冲区的回复发送给客户端。</p>
<p><strong>客户端接收并打印命令回复</strong></p>
<p>将回复转为人类可读的格式，打印给用户看。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库章节主要介绍键值对的宏观存储是怎么实现的和过期策略。通过RedisServer进行组织，用<strong>字典存键值对</strong>，具体数据结构<strong>按照对象的编码存储</strong>。客户端与服务器主要通过<strong>共享指针</strong>的方式来共享库对象。键的过期时间是按照单独的键过期字典存储的，设置过期时间的命令<strong>都会转换为PEXPIREAT</strong>来实现。Redis使用<strong>惰性删除</strong>和<strong>定期删除</strong>作为移除策略。每次对键的读取都会判断是否过期，定期抽查并删除过期键。</p>
<p>RDB持久化章节主要介绍持久化机制和发生时机，BGSAVE指令对其他指令的<strong>排斥性</strong>，RDB文件结构。RDB文件载入时，主服务器会<strong>检查键是否过期</strong>。RDB的实现分为SAVE和BGSAVE，<strong>SAVE会阻塞</strong>，BGSAVE是通过fork子进程来写RDB文件的方式，来记录Redis的数据库快照。BGSAVE随着serverCron函数的执行，每次都会判断是否有必要执行。</p>
<p>AOF持久化章节主要介绍持久化机制，时机，重写过程。AOF文件<strong>载入时不会判断键是否过期</strong>，只是执行文件中的命令。AOF开启后，执行一个写命令就会被<strong>追加到aof_buf</strong>中。AOF持久化过程是根据其同步策略配置，一次事件循环，一定会将aof_buf中的命令写到操作系统缓冲区，在根据配置考虑是否需要<strong>强制写入磁盘</strong>。AOF重写是对文件的瘦身计划，为了解决子进程执行AOF文件重写前后数据库状态不一致的问题，AOF重写缓冲区会<strong>记录在这期间对数据库的变更</strong>，子进程结束后<strong>发信号</strong>，主进程接收后会<strong>进入阻塞阶段</strong>，同步重写缓冲区至新的AOF文件。</p>
<p>事件章节主要介绍文件事件和时间事件。文件时间是<strong>对套接字操作</strong>的事件，时间事件是<strong>对定时操作</strong>相关的事件。文件事件利用I/O多路复用程序<strong>监听多个套接字</strong>，根据相应的<strong>可读/可写事件</strong>来触发并移交给文件事件分派器，分派器会给具体的<strong>事件处理器处理</strong>。然后介绍了时间事件的组成，serverCron的职能，主要负责对资源的检查，更新，判断操作。对于两种事件同时出现情况的处理机制，利用<strong>等待时间事件的空隙</strong>作为文件事件的最大阻塞时间，然后先处理随机的文件事件，再处理时间事件。不浪费CPU资源，提高效率。</p>
<p>客户端章节主要介绍<strong>redisClient的属性</strong>，包括套接字描述符，输入缓冲区，时间等。然后介绍普通客户端的创建和关闭原因，是通过对应的事件处理器进行的。其他的伪客户端主要是AOF伪客户端按卸磨杀驴的套路，在载入时创建，载入结束后关闭。</p>
<p>服务器章节主要描述了Redi<strong>s一条指令的执行过</strong>程，从初始化到具体的过程细化，发送命令，读取命令，查找命令字典，执行预备操作，调用实现函数，善后工作，发送回复，客户端打印。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">icbtbo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://icbtbo.github.io/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://icbtbo.github.io/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://icbtbo.github.io" target="_blank">sjc的搬砖小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="/img/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis设计与实现:多机数据库的实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/18/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"><img class="next-cover" src="/img/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis设计与实现:数据结构与对象</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/05/Redis/Redis设计与实现-独立功能的实现/" title="Redis设计与实现:独立功能的实现"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Redis设计与实现:独立功能的实现</div></div></a></div><div><a href="/2022/01/05/Redis/Redis设计与实现-多机数据库的实现/" title="Redis设计与实现:多机数据库的实现"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Redis设计与实现:多机数据库的实现</div></div></a></div><div><a href="/2021/12/18/Redis/Redis设计与实现-数据结构与对象/" title="Redis设计与实现:数据结构与对象"><img class="cover" src="/img/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-18</div><div class="title">Redis设计与实现:数据结构与对象</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/niu.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">icbtbo</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">86</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/icbtbo"><i class="fab fa-github"></i><span>Github</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">服务器中的数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%AE%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.</span> <span class="toc-text">数据库的键空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">键过期时间相关操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.</span> <span class="toc-text">过期键删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E3%80%81AOF%E5%92%8C%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">RDB、AOF和复制功能对过期键的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%9F%A5"><span class="toc-number">1.6.</span> <span class="toc-text">数据库通知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BD%BD%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">RDB文件的创建与载入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%97%B4%E9%9A%94%E6%80%A7%E4%BF%9D%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">自动间隔性保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">RDB文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90RDB%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">分析RDB文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">AOF持久化的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%BD%E5%85%A5%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%98%E5%8E%9F"><span class="toc-number">3.2.</span> <span class="toc-text">AOF文件的载入与数据还原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99"><span class="toc-number">3.3.</span> <span class="toc-text">AOF重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">文件事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">时间事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serverCron%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">serverCron函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">4.2.3.</span> <span class="toc-text">事件的调度与执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">客户端属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">5.2.</span> <span class="toc-text">客户端的创建与关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">初始化服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">命令执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/15/Netty/Netty%E7%9A%84FastThreadLocal/" title="Netty的FastThreadLocal"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty的FastThreadLocal"/></a><div class="content"><a class="title" href="/2022/06/15/Netty/Netty%E7%9A%84FastThreadLocal/" title="Netty的FastThreadLocal">Netty的FastThreadLocal</a><time datetime="2022-06-15T07:04:51.000Z" title="发表于 2022-06-15 15:04:51">2022-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/" title="Netty的对象池技术：Recycler"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty的对象池技术：Recycler"/></a><div class="content"><a class="title" href="/2022/06/13/Netty/Netty%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9ARecycler/" title="Netty的对象池技术：Recycler">Netty的对象池技术：Recycler</a><time datetime="2022-06-13T13:08:25.000Z" title="发表于 2022-06-13 21:08:25">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:独立功能的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:独立功能的实现">Redis设计与实现:独立功能的实现</a><time datetime="2022-01-05T12:59:07.000Z" title="发表于 2022-01-05 20:59:07">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:多机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:多机数据库的实现">Redis设计与实现:多机数据库的实现</a><time datetime="2022-01-05T01:35:35.000Z" title="发表于 2022-01-05 09:35:35">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现"><img src="/img/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis设计与实现:单机数据库的实现"/></a><div class="content"><a class="title" href="/2022/01/04/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="Redis设计与实现:单机数据库的实现">Redis设计与实现:单机数据库的实现</a><time datetime="2022-01-04T06:38:05.000Z" title="发表于 2022-01-04 14:38:05">2022-01-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By icbtbo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'pLWJLVgdxc6WLcEaFgEr2tQ2-gzGzoHsz',
      appKey: 'OAmeyAUV6TdXoX5n1hSX4ELm',
      placeholder: '请留下你的小脚印～',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      master: 'f94877d77182a6f9068fc12b5545e1f5',
      tagMeta: ["博主","小伙伴","访客"],
      friends: ["52dc4d80afb3aeab1d0deab1aa45a7b5","fd99ca470e7b5e8e2b4f76d6ed26d6cf"]
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>